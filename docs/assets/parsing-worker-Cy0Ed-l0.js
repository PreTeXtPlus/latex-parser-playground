var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField = (obj, key2, value2) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
(function() {
  "use strict";
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */
  var _a2;
  const proxyMarker = Symbol("Comlink.proxy");
  const createEndpoint = Symbol("Comlink.endpoint");
  const releaseProxy = Symbol("Comlink.releaseProxy");
  const finalizer = Symbol("Comlink.finalizer");
  const throwMarker = Symbol("Comlink.thrown");
  const isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
  const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap$2(port);
    }
  };
  const throwTransferHandler = {
    canHandle: (value2) => isObject(value2) && throwMarker in value2,
    serialize({ value: value2 }) {
      let serialized;
      if (value2 instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value2.message,
            name: value2.name,
            stack: value2.stack
          }
        };
      } else {
        serialized = { isError: false, value: value2 };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  const transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
      if (origin === allowedOrigin || allowedOrigin === "*") {
        return true;
      }
      if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
        return true;
      }
    }
    return false;
  }
  function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
        console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
        return;
      }
      const { id: id2, type, path: path2 } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path2.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path2.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value2 = new rawValue(...argumentList);
              returnValue = proxy(value2);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value2) {
        returnValue = { value: value2, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value2) => {
        return { value: value2, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((error) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        });
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap$2(ep, target) {
    return createProxy(ep, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function releaseEndpoint(ep) {
    return requestResponseMessage(ep, {
      type: "RELEASE"
    }).then(() => {
      closeEndPoint(ep);
    });
  }
  const proxyCounter = /* @__PURE__ */ new WeakMap();
  const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
  function registerProxy(proxy2, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, ep, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(ep, path2 = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            unregisterProxy(proxy2);
            releaseEndpoint(ep);
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path2.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, {
            type: "GET",
            path: path2.map((p2) => p2.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, [...path2, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value2, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, {
          type: "SET",
          path: [...path2, prop].map((p2) => p2.toString()),
          value: value2
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path2[path2.length - 1];
        if (last === createEndpoint) {
          return requestResponseMessage(ep, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last === "bind") {
          return createProxy(ep, path2.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, {
          type: "APPLY",
          path: path2.map((p2) => p2.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, {
          type: "CONSTRUCT",
          path: path2.map((p2) => p2.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    registerProxy(proxy2, ep);
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  const transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function toWireValue(value2) {
    for (const [name2, handler] of transferHandlers) {
      if (handler.canHandle(value2)) {
        const [serializedValue, transferables] = handler.serialize(value2);
        return [
          {
            type: "HANDLER",
            name: name2,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value: value2
      },
      transferCache.get(value2) || []
    ];
  }
  function fromWireValue(value2) {
    switch (value2.type) {
      case "HANDLER":
        return transferHandlers.get(value2.name).deserialize(value2.value);
      case "RAW":
        return value2.value;
    }
  }
  function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve2) => {
      const id2 = generateUUID();
      ep.addEventListener("message", function l(ev) {
        if (!ev.data || !ev.data.id || ev.data.id !== id2) {
          return;
        }
        ep.removeEventListener("message", l);
        resolve2(ev.data);
      });
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }
  var Te = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
  var pt = Te((Vg, ou) => {
    var ur = function(e) {
      return e && e.Math == Math && e;
    };
    ou.exports = ur(typeof globalThis == "object" && globalThis) || ur(typeof window == "object" && window) || ur(typeof self == "object" && self) || ur(typeof global == "object" && global) || /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  });
  var Dt = Te((Wg, lu) => {
    lu.exports = function(e) {
      try {
        return !!e();
      } catch {
        return true;
      }
    };
  });
  var yt = Te((Hg, cu) => {
    var wo = Dt();
    cu.exports = !wo(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  });
  var sr = Te((Gg, pu) => {
    var _o = Dt();
    pu.exports = !_o(function() {
      var e = (function() {
      }).bind();
      return typeof e != "function" || e.hasOwnProperty("prototype");
    });
  });
  var At = Te((Ug, fu) => {
    var Po = sr(), ir = Function.prototype.call;
    fu.exports = Po ? ir.bind(ir) : function() {
      return ir.apply(ir, arguments);
    };
  });
  var gu = Te((du) => {
    var Du = {}.propertyIsEnumerable, mu = Object.getOwnPropertyDescriptor, Io = mu && !Du.call({ 1: 2 }, 1);
    du.f = Io ? function(r) {
      var t = mu(this, r);
      return !!t && t.enumerable;
    } : Du;
  });
  var ar = Te((zg, yu) => {
    yu.exports = function(e, r) {
      return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
    };
  });
  var mt = Te((Xg, Cu) => {
    var hu = sr(), vu = Function.prototype, $r = vu.call, ko = hu && vu.bind.bind($r, $r);
    Cu.exports = hu ? ko : function(e) {
      return function() {
        return $r.apply(e, arguments);
      };
    };
  });
  var Rt = Te((Kg, Fu) => {
    var Eu = mt(), Lo = Eu({}.toString), Oo = Eu("".slice);
    Fu.exports = function(e) {
      return Oo(Lo(e), 8, -1);
    };
  });
  var Su = Te((Yg, Au) => {
    var jo = mt(), qo = Dt(), Mo = Rt(), Vr = Object, Ro = jo("".split);
    Au.exports = qo(function() {
      return !Vr("z").propertyIsEnumerable(0);
    }) ? function(e) {
      return Mo(e) == "String" ? Ro(e, "") : Vr(e);
    } : Vr;
  });
  var or = Te((Qg, xu) => {
    xu.exports = function(e) {
      return e == null;
    };
  });
  var Wr = Te((Zg, bu) => {
    var $o = or(), Vo = TypeError;
    bu.exports = function(e) {
      if ($o(e))
        throw Vo("Can't call method on " + e);
      return e;
    };
  });
  var lr = Te((e0, Tu) => {
    var Wo = Su(), Ho = Wr();
    Tu.exports = function(e) {
      return Wo(Ho(e));
    };
  });
  var Gr = Te((t0, Bu) => {
    var Hr = typeof document == "object" && document.all, Go = typeof Hr > "u" && Hr !== void 0;
    Bu.exports = { all: Hr, IS_HTMLDDA: Go };
  });
  var ot = Te((r0, wu) => {
    var Nu = Gr(), Uo = Nu.all;
    wu.exports = Nu.IS_HTMLDDA ? function(e) {
      return typeof e == "function" || e === Uo;
    } : function(e) {
      return typeof e == "function";
    };
  });
  var St = Te((n0, Iu) => {
    var _u = ot(), Pu = Gr(), Jo = Pu.all;
    Iu.exports = Pu.IS_HTMLDDA ? function(e) {
      return typeof e == "object" ? e !== null : _u(e) || e === Jo;
    } : function(e) {
      return typeof e == "object" ? e !== null : _u(e);
    };
  });
  var $t = Te((u0, ku) => {
    var Ur = pt(), zo = ot(), Xo = function(e) {
      return zo(e) ? e : void 0;
    };
    ku.exports = function(e, r) {
      return arguments.length < 2 ? Xo(Ur[e]) : Ur[e] && Ur[e][r];
    };
  });
  var Jr = Te((s0, Lu) => {
    var Ko = mt();
    Lu.exports = Ko({}.isPrototypeOf);
  });
  var ju = Te((i0, Ou) => {
    var Yo = $t();
    Ou.exports = Yo("navigator", "userAgent") || "";
  });
  var Hu = Te((a0, Wu) => {
    var Vu = pt(), zr = ju(), qu = Vu.process, Mu = Vu.Deno, Ru = qu && qu.versions || Mu && Mu.version, $u = Ru && Ru.v8, dt2, cr;
    $u && (dt2 = $u.split("."), cr = dt2[0] > 0 && dt2[0] < 4 ? 1 : +(dt2[0] + dt2[1]));
    !cr && zr && (dt2 = zr.match(/Edge\/(\d+)/), (!dt2 || dt2[1] >= 74) && (dt2 = zr.match(/Chrome\/(\d+)/), dt2 && (cr = +dt2[1])));
    Wu.exports = cr;
  });
  var Xr = Te((o0, Uu) => {
    var Gu = Hu(), Qo = Dt();
    Uu.exports = !!Object.getOwnPropertySymbols && !Qo(function() {
      var e = Symbol();
      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Gu && Gu < 41;
    });
  });
  var Kr = Te((l0, Ju) => {
    var Zo = Xr();
    Ju.exports = Zo && !Symbol.sham && typeof Symbol.iterator == "symbol";
  });
  var Yr = Te((c0, zu) => {
    var el = $t(), tl = ot(), rl = Jr(), nl = Kr(), ul = Object;
    zu.exports = nl ? function(e) {
      return typeof e == "symbol";
    } : function(e) {
      var r = el("Symbol");
      return tl(r) && rl(r.prototype, ul(e));
    };
  });
  var pr = Te((p0, Xu) => {
    var sl = String;
    Xu.exports = function(e) {
      try {
        return sl(e);
      } catch {
        return "Object";
      }
    };
  });
  var Vt = Te((f0, Ku) => {
    var il = ot(), al = pr(), ol = TypeError;
    Ku.exports = function(e) {
      if (il(e))
        return e;
      throw ol(al(e) + " is not a function");
    };
  });
  var fr = Te((D0, Yu) => {
    var ll = Vt(), cl = or();
    Yu.exports = function(e, r) {
      var t = e[r];
      return cl(t) ? void 0 : ll(t);
    };
  });
  var Zu = Te((m0, Qu) => {
    var Qr = At(), Zr = ot(), en = St(), pl = TypeError;
    Qu.exports = function(e, r) {
      var t, s2;
      if (r === "string" && Zr(t = e.toString) && !en(s2 = Qr(t, e)) || Zr(t = e.valueOf) && !en(s2 = Qr(t, e)) || r !== "string" && Zr(t = e.toString) && !en(s2 = Qr(t, e)))
        return s2;
      throw pl("Can't convert object to primitive value");
    };
  });
  var ts = Te((d0, es) => {
    es.exports = false;
  });
  var Dr = Te((g0, ns) => {
    var rs = pt(), fl = Object.defineProperty;
    ns.exports = function(e, r) {
      try {
        fl(rs, e, { value: r, configurable: true, writable: true });
      } catch {
        rs[e] = r;
      }
      return r;
    };
  });
  var mr = Te((y0, ss) => {
    var Dl = pt(), ml = Dr(), us = "__core-js_shared__", dl2 = Dl[us] || ml(us, {});
    ss.exports = dl2;
  });
  var tn = Te((h0, as) => {
    var gl = ts(), is = mr();
    (as.exports = function(e, r) {
      return is[e] || (is[e] = r !== void 0 ? r : {});
    })("versions", []).push({ version: "3.26.1", mode: gl ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
  });
  var dr = Te((v0, os) => {
    var yl = Wr(), hl = Object;
    os.exports = function(e) {
      return hl(yl(e));
    };
  });
  var Ct = Te((C0, ls) => {
    var vl = mt(), Cl = dr(), El = vl({}.hasOwnProperty);
    ls.exports = Object.hasOwn || function(r, t) {
      return El(Cl(r), t);
    };
  });
  var rn = Te((E0, cs2) => {
    var Fl = mt(), Al = 0, Sl = Math.random(), xl = Fl(1 .toString);
    cs2.exports = function(e) {
      return "Symbol(" + (e === void 0 ? "" : e) + ")_" + xl(++Al + Sl, 36);
    };
  });
  var bt = Te((F0, ds) => {
    var bl = pt(), Tl = tn(), ps = Ct(), Bl = rn(), fs = Xr(), ms = Kr(), Pt = Tl("wks"), xt = bl.Symbol, Ds = xt && xt.for, Nl = ms ? xt : xt && xt.withoutSetter || Bl;
    ds.exports = function(e) {
      if (!ps(Pt, e) || !(fs || typeof Pt[e] == "string")) {
        var r = "Symbol." + e;
        fs && ps(xt, e) ? Pt[e] = xt[e] : ms && Ds ? Pt[e] = Ds(r) : Pt[e] = Nl(r);
      }
      return Pt[e];
    };
  });
  var vs = Te((A0, hs) => {
    var wl = At(), gs = St(), ys = Yr(), _l = fr(), Pl = Zu(), Il = bt(), kl = TypeError, Ll = Il("toPrimitive");
    hs.exports = function(e, r) {
      if (!gs(e) || ys(e))
        return e;
      var t = _l(e, Ll), s2;
      if (t) {
        if (r === void 0 && (r = "default"), s2 = wl(t, e, r), !gs(s2) || ys(s2))
          return s2;
        throw kl("Can't convert object to primitive value");
      }
      return r === void 0 && (r = "number"), Pl(e, r);
    };
  });
  var gr = Te((S0, Cs) => {
    var Ol = vs(), jl = Yr();
    Cs.exports = function(e) {
      var r = Ol(e, "string");
      return jl(r) ? r : r + "";
    };
  });
  var As = Te((x0, Fs) => {
    var ql = pt(), Es = St(), nn = ql.document, Ml = Es(nn) && Es(nn.createElement);
    Fs.exports = function(e) {
      return Ml ? nn.createElement(e) : {};
    };
  });
  var un = Te((b0, Ss) => {
    var Rl = yt(), $l = Dt(), Vl = As();
    Ss.exports = !Rl && !$l(function() {
      return Object.defineProperty(Vl("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  });
  var sn = Te((bs) => {
    var Wl = yt(), Hl = At(), Gl = gu(), Ul = ar(), Jl = lr(), zl = gr(), Xl = Ct(), Kl = un(), xs = Object.getOwnPropertyDescriptor;
    bs.f = Wl ? xs : function(r, t) {
      if (r = Jl(r), t = zl(t), Kl)
        try {
          return xs(r, t);
        } catch {
        }
      if (Xl(r, t))
        return Ul(!Hl(Gl.f, r, t), r[t]);
    };
  });
  var Bs = Te((B0, Ts) => {
    var Yl = yt(), Ql = Dt();
    Ts.exports = Yl && Ql(function() {
      return Object.defineProperty(function() {
      }, "prototype", { value: 42, writable: false }).prototype != 42;
    });
  });
  var Tt = Te((N0, Ns) => {
    var Zl = St(), ec = String, tc = TypeError;
    Ns.exports = function(e) {
      if (Zl(e))
        return e;
      throw tc(ec(e) + " is not an object");
    };
  });
  var It = Te((_s) => {
    var rc = yt(), nc = un(), uc = Bs(), yr = Tt(), ws = gr(), sc = TypeError, an = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, on = "enumerable", ln = "configurable", cn = "writable";
    _s.f = rc ? uc ? function(r, t, s2) {
      if (yr(r), t = ws(t), yr(s2), typeof r == "function" && t === "prototype" && "value" in s2 && cn in s2 && !s2[cn]) {
        var a2 = ic(r, t);
        a2 && a2[cn] && (r[t] = s2.value, s2 = { configurable: ln in s2 ? s2[ln] : a2[ln], enumerable: on in s2 ? s2[on] : a2[on], writable: false });
      }
      return an(r, t, s2);
    } : an : function(r, t, s2) {
      if (yr(r), t = ws(t), yr(s2), nc)
        try {
          return an(r, t, s2);
        } catch {
        }
      if ("get" in s2 || "set" in s2)
        throw sc("Accessors not supported");
      return "value" in s2 && (r[t] = s2.value), r;
    };
  });
  var pn = Te((_0, Ps) => {
    var ac = yt(), oc = It(), lc = ar();
    Ps.exports = ac ? function(e, r, t) {
      return oc.f(e, r, lc(1, t));
    } : function(e, r, t) {
      return e[r] = t, e;
    };
  });
  var Ls = Te((P0, ks) => {
    var fn = yt(), cc = Ct(), Is = Function.prototype, pc = fn && Object.getOwnPropertyDescriptor, Dn = cc(Is, "name"), fc = Dn && (function() {
    }).name === "something", Dc = Dn && (!fn || fn && pc(Is, "name").configurable);
    ks.exports = { EXISTS: Dn, PROPER: fc, CONFIGURABLE: Dc };
  });
  var dn = Te((I0, Os) => {
    var mc = mt(), dc = ot(), mn = mr(), gc = mc(Function.toString);
    dc(mn.inspectSource) || (mn.inspectSource = function(e) {
      return gc(e);
    });
    Os.exports = mn.inspectSource;
  });
  var Ms = Te((k0, qs) => {
    var yc = pt(), hc = ot(), js2 = yc.WeakMap;
    qs.exports = hc(js2) && /native code/.test(String(js2));
  });
  var Vs = Te((L0, $s) => {
    var vc = tn(), Cc = rn(), Rs = vc("keys");
    $s.exports = function(e) {
      return Rs[e] || (Rs[e] = Cc(e));
    };
  });
  var gn = Te((O0, Ws) => {
    Ws.exports = {};
  });
  var Js = Te((j0, Us) => {
    var Ec = Ms(), Gs = pt(), Fc = St(), Ac = pn(), yn = Ct(), hn = mr(), Sc = Vs(), xc = gn(), Hs = "Object already initialized", vn = Gs.TypeError, bc2 = Gs.WeakMap, hr2, Wt, vr, Tc = function(e) {
      return vr(e) ? Wt(e) : hr2(e, {});
    }, Bc = function(e) {
      return function(r) {
        var t;
        if (!Fc(r) || (t = Wt(r)).type !== e)
          throw vn("Incompatible receiver, " + e + " required");
        return t;
      };
    };
    Ec || hn.state ? (gt = hn.state || (hn.state = new bc2()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, hr2 = function(e, r) {
      if (gt.has(e))
        throw vn(Hs);
      return r.facade = e, gt.set(e, r), r;
    }, Wt = function(e) {
      return gt.get(e) || {};
    }, vr = function(e) {
      return gt.has(e);
    }) : (Bt = Sc("state"), xc[Bt] = true, hr2 = function(e, r) {
      if (yn(e, Bt))
        throw vn(Hs);
      return r.facade = e, Ac(e, Bt, r), r;
    }, Wt = function(e) {
      return yn(e, Bt) ? e[Bt] : {};
    }, vr = function(e) {
      return yn(e, Bt);
    });
    var gt, Bt;
    Us.exports = { set: hr2, get: Wt, has: vr, enforce: Tc, getterFor: Bc };
  });
  var En = Te((q0, Xs) => {
    var Nc = Dt(), wc = ot(), Cr = Ct(), Cn = yt(), _c = Ls().CONFIGURABLE, Pc = dn(), zs = Js(), Ic = zs.enforce, kc = zs.get, Er = Object.defineProperty, Lc = Cn && !Nc(function() {
      return Er(function() {
      }, "length", { value: 8 }).length !== 8;
    }), Oc = String(String).split("String"), jc = Xs.exports = function(e, r, t) {
      String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Cr(e, "name") || _c && e.name !== r) && (Cn ? Er(e, "name", { value: r, configurable: true }) : e.name = r), Lc && t && Cr(t, "arity") && e.length !== t.arity && Er(e, "length", { value: t.arity });
      try {
        t && Cr(t, "constructor") && t.constructor ? Cn && Er(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
      } catch {
      }
      var s2 = Ic(e);
      return Cr(s2, "source") || (s2.source = Oc.join(typeof r == "string" ? r : "")), e;
    };
    Function.prototype.toString = jc(function() {
      return wc(this) && kc(this).source || Pc(this);
    }, "toString");
  });
  var Ys = Te((M0, Ks) => {
    var qc = ot(), Mc = It(), Rc = En(), $c = Dr();
    Ks.exports = function(e, r, t, s2) {
      s2 || (s2 = {});
      var a2 = s2.enumerable, n = s2.name !== void 0 ? s2.name : r;
      if (qc(t) && Rc(t, n, s2), s2.global)
        a2 ? e[r] = t : $c(r, t);
      else {
        try {
          s2.unsafe ? e[r] && (a2 = true) : delete e[r];
        } catch {
        }
        a2 ? e[r] = t : Mc.f(e, r, { value: t, enumerable: false, configurable: !s2.nonConfigurable, writable: !s2.nonWritable });
      }
      return e;
    };
  });
  var Zs = Te((R0, Qs) => {
    var Vc = Math.ceil, Wc = Math.floor;
    Qs.exports = Math.trunc || function(r) {
      var t = +r;
      return (t > 0 ? Wc : Vc)(t);
    };
  });
  var Fr = Te(($0, ei) => {
    var Hc = Zs();
    ei.exports = function(e) {
      var r = +e;
      return r !== r || r === 0 ? 0 : Hc(r);
    };
  });
  var ri = Te((V0, ti) => {
    var Gc = Fr(), Uc = Math.max, Jc = Math.min;
    ti.exports = function(e, r) {
      var t = Gc(e);
      return t < 0 ? Uc(t + r, 0) : Jc(t, r);
    };
  });
  var ui = Te((W0, ni) => {
    var zc = Fr(), Xc = Math.min;
    ni.exports = function(e) {
      return e > 0 ? Xc(zc(e), 9007199254740991) : 0;
    };
  });
  var kt = Te((H0, si) => {
    var Kc = ui();
    si.exports = function(e) {
      return Kc(e.length);
    };
  });
  var oi = Te((G0, ai) => {
    var Yc = lr(), Qc = ri(), Zc = kt(), ii = function(e) {
      return function(r, t, s2) {
        var a2 = Yc(r), n = Zc(a2), u = Qc(s2, n), i;
        if (e && t != t) {
          for (; n > u; )
            if (i = a2[u++], i != i)
              return true;
        } else
          for (; n > u; u++)
            if ((e || u in a2) && a2[u] === t)
              return e || u || 0;
        return !e && -1;
      };
    };
    ai.exports = { includes: ii(true), indexOf: ii(false) };
  });
  var pi = Te((U0, ci) => {
    var ep = mt(), Fn = Ct(), tp = lr(), rp = oi().indexOf, np = gn(), li2 = ep([].push);
    ci.exports = function(e, r) {
      var t = tp(e), s2 = 0, a2 = [], n;
      for (n in t)
        !Fn(np, n) && Fn(t, n) && li2(a2, n);
      for (; r.length > s2; )
        Fn(t, n = r[s2++]) && (~rp(a2, n) || li2(a2, n));
      return a2;
    };
  });
  var Di = Te((J0, fi) => {
    fi.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
  });
  var di = Te((mi) => {
    var up = pi(), sp = Di(), ip2 = sp.concat("length", "prototype");
    mi.f = Object.getOwnPropertyNames || function(r) {
      return up(r, ip2);
    };
  });
  var yi = Te((gi) => {
    gi.f = Object.getOwnPropertySymbols;
  });
  var vi = Te((K0, hi) => {
    var ap = $t(), op2 = mt(), lp = di(), cp = yi(), pp = Tt(), fp = op2([].concat);
    hi.exports = ap("Reflect", "ownKeys") || function(r) {
      var t = lp.f(pp(r)), s2 = cp.f;
      return s2 ? fp(t, s2(r)) : t;
    };
  });
  var Fi = Te((Y0, Ei) => {
    var Ci = Ct(), Dp = vi(), mp = sn(), dp = It();
    Ei.exports = function(e, r, t) {
      for (var s2 = Dp(r), a2 = dp.f, n = mp.f, u = 0; u < s2.length; u++) {
        var i = s2[u];
        !Ci(e, i) && !(t && Ci(t, i)) && a2(e, i, n(r, i));
      }
    };
  });
  var Si = Te((Q0, Ai) => {
    var gp = Dt(), yp = ot(), hp = /#|\.prototype\./, Ht = function(e, r) {
      var t = Cp[vp(e)];
      return t == Fp ? true : t == Ep ? false : yp(r) ? gp(r) : !!r;
    }, vp = Ht.normalize = function(e) {
      return String(e).replace(hp, ".").toLowerCase();
    }, Cp = Ht.data = {}, Ep = Ht.NATIVE = "N", Fp = Ht.POLYFILL = "P";
    Ai.exports = Ht;
  });
  var Gt = Te((Z0, xi) => {
    var An = pt(), Ap = sn().f, Sp = pn(), xp = Ys(), bp = Dr(), Tp = Fi(), Bp = Si();
    xi.exports = function(e, r) {
      var t = e.target, s2 = e.global, a2 = e.stat, n, u, i, l, p2, d;
      if (s2 ? u = An : a2 ? u = An[t] || bp(t, {}) : u = (An[t] || {}).prototype, u)
        for (i in r) {
          if (p2 = r[i], e.dontCallGetSet ? (d = Ap(u, i), l = d && d.value) : l = u[i], n = Bp(s2 ? i : t + (a2 ? "." : "#") + i, e.forced), !n && l !== void 0) {
            if (typeof p2 == typeof l)
              continue;
            Tp(p2, l);
          }
          (e.sham || l && l.sham) && Sp(p2, "sham", true), xp(u, i, p2, e);
        }
    };
  });
  var Sn = Te((ey, bi) => {
    var Np = Rt();
    bi.exports = Array.isArray || function(r) {
      return Np(r) == "Array";
    };
  });
  var Bi = Te((ty, Ti) => {
    var wp = TypeError, _p = 9007199254740991;
    Ti.exports = function(e) {
      if (e > _p)
        throw wp("Maximum allowed index exceeded");
      return e;
    };
  });
  var wi = Te((ry, Ni) => {
    var Pp = Rt(), Ip = mt();
    Ni.exports = function(e) {
      if (Pp(e) === "Function")
        return Ip(e);
    };
  });
  var xn = Te((ny, Pi) => {
    var _i = wi(), kp = Vt(), Lp = sr(), Op = _i(_i.bind);
    Pi.exports = function(e, r) {
      return kp(e), r === void 0 ? e : Lp ? Op(e, r) : function() {
        return e.apply(r, arguments);
      };
    };
  });
  var bn = Te((uy, ki) => {
    var jp = Sn(), qp = kt(), Mp = Bi(), Rp = xn(), Ii = function(e, r, t, s2, a2, n, u, i) {
      for (var l = a2, p2 = 0, d = u ? Rp(u, i) : false, y, g; p2 < s2; )
        p2 in t && (y = d ? d(t[p2], p2, r) : t[p2], n > 0 && jp(y) ? (g = qp(y), l = Ii(e, r, y, g, l, n - 1) - 1) : (Mp(l + 1), e[l] = y), l++), p2++;
      return l;
    };
    ki.exports = Ii;
  });
  var ji = Te((sy, Oi) => {
    var $p = bt(), Vp = $p("toStringTag"), Li = {};
    Li[Vp] = "z";
    Oi.exports = String(Li) === "[object z]";
  });
  var Tn = Te((iy, qi) => {
    var Wp = ji(), Hp = ot(), Ar = Rt(), Gp = bt(), Up = Gp("toStringTag"), Jp = Object, zp = Ar(/* @__PURE__ */ function() {
      return arguments;
    }()) == "Arguments", Xp = function(e, r) {
      try {
        return e[r];
      } catch {
      }
    };
    qi.exports = Wp ? Ar : function(e) {
      var r, t, s2;
      return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Xp(r = Jp(e), Up)) == "string" ? t : zp ? Ar(r) : (s2 = Ar(r)) == "Object" && Hp(r.callee) ? "Arguments" : s2;
    };
  });
  var Hi = Te((ay, Wi) => {
    var Kp = mt(), Yp = Dt(), Mi = ot(), Qp = Tn(), Zp = $t(), ef = dn(), Ri = function() {
    }, tf = [], $i = Zp("Reflect", "construct"), Bn = /^\s*(?:class|function)\b/, rf = Kp(Bn.exec), nf = !Bn.exec(Ri), Ut = function(r) {
      if (!Mi(r))
        return false;
      try {
        return $i(Ri, tf, r), true;
      } catch {
        return false;
      }
    }, Vi = function(r) {
      if (!Mi(r))
        return false;
      switch (Qp(r)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return nf || !!rf(Bn, ef(r));
      } catch {
        return true;
      }
    };
    Vi.sham = true;
    Wi.exports = !$i || Yp(function() {
      var e;
      return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
        e = true;
      }) || e;
    }) ? Vi : Ut;
  });
  var zi = Te((oy, Ji) => {
    var Gi = Sn(), uf = Hi(), sf = St(), af = bt(), of = af("species"), Ui = Array;
    Ji.exports = function(e) {
      var r;
      return Gi(e) && (r = e.constructor, uf(r) && (r === Ui || Gi(r.prototype)) ? r = void 0 : sf(r) && (r = r[of], r === null && (r = void 0))), r === void 0 ? Ui : r;
    };
  });
  var Nn = Te((ly, Xi) => {
    var lf = zi();
    Xi.exports = function(e, r) {
      return new (lf(e))(r === 0 ? 0 : r);
    };
  });
  var wn = Te((cy, Ki) => {
    Ki.exports = {};
  });
  var Qi = Te((py, Yi) => {
    var gf = bt(), yf = wn(), hf = gf("iterator"), vf = Array.prototype;
    Yi.exports = function(e) {
      return e !== void 0 && (yf.Array === e || vf[hf] === e);
    };
  });
  var _n = Te((fy, ea) => {
    var Cf = Tn(), Zi = fr(), Ef = or(), Ff = wn(), Af = bt(), Sf = Af("iterator");
    ea.exports = function(e) {
      if (!Ef(e))
        return Zi(e, Sf) || Zi(e, "@@iterator") || Ff[Cf(e)];
    };
  });
  var ra = Te((Dy, ta) => {
    var xf = At(), bf = Vt(), Tf = Tt(), Bf = pr(), Nf = _n(), wf = TypeError;
    ta.exports = function(e, r) {
      var t = arguments.length < 2 ? Nf(e) : r;
      if (bf(t))
        return Tf(xf(t, e));
      throw wf(Bf(e) + " is not iterable");
    };
  });
  var sa = Te((my, ua) => {
    var _f = At(), na = Tt(), Pf = fr();
    ua.exports = function(e, r, t) {
      var s2, a2;
      na(e);
      try {
        if (s2 = Pf(e, "return"), !s2) {
          if (r === "throw")
            throw t;
          return t;
        }
        s2 = _f(s2, e);
      } catch (n) {
        a2 = true, s2 = n;
      }
      if (r === "throw")
        throw t;
      if (a2)
        throw s2;
      return na(s2), t;
    };
  });
  var ca = Te((dy, la) => {
    var If = xn(), kf = At(), Lf = Tt(), Of = pr(), jf = Qi(), qf = kt(), ia = Jr(), Mf = ra(), Rf = _n(), aa = sa(), $f = TypeError, Sr = function(e, r) {
      this.stopped = e, this.result = r;
    }, oa = Sr.prototype;
    la.exports = function(e, r, t) {
      var s2 = t && t.that, a2 = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = If(r, s2), p2, d, y, g, c2, f, E, _ = function(F) {
        return p2 && aa(p2, "normal", F), new Sr(true, F);
      }, w = function(F) {
        return a2 ? (Lf(F), i ? l(F[0], F[1], _) : l(F[0], F[1])) : i ? l(F, _) : l(F);
      };
      if (n)
        p2 = e.iterator;
      else if (u)
        p2 = e;
      else {
        if (d = Rf(e), !d)
          throw $f(Of(e) + " is not iterable");
        if (jf(d)) {
          for (y = 0, g = qf(e); g > y; y++)
            if (c2 = w(e[y]), c2 && ia(oa, c2))
              return c2;
          return new Sr(false);
        }
        p2 = Mf(e, d);
      }
      for (f = n ? e.next : p2.next; !(E = kf(f, p2)).done; ) {
        try {
          c2 = w(E.value);
        } catch (F) {
          aa(p2, "throw", F);
        }
        if (typeof c2 == "object" && c2 && ia(oa, c2))
          return c2;
      }
      return new Sr(false);
    };
  });
  var fa = Te((gy, pa) => {
    var Vf = gr(), Wf = It(), Hf = ar();
    pa.exports = function(e, r, t) {
      var s2 = Vf(r);
      s2 in e ? Wf.f(e, s2, Hf(0, t)) : e[s2] = t;
    };
  });
  var da = Te((yy, ma) => {
    var Da = En(), zf = It();
    ma.exports = function(e, r, t) {
      return t.get && Da(t.get, r, { getter: true }), t.set && Da(t.set, r, { setter: true }), zf.f(e, r, t);
    };
  });
  var ya = Te((hy, ga) => {
    var Xf = Tt();
    ga.exports = function() {
      var e = Xf(this), r = "";
      return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
    };
  });
  var Ca = Te(() => {
    var rD = Gt(), Pn = pt();
    rD({ global: true, forced: Pn.globalThis !== Pn }, { globalThis: Pn });
  });
  var cf = Gt(), pf = bn(), ff = Vt(), Df = dr(), mf = kt(), df = Nn();
  cf({ target: "Array", proto: true }, { flatMap: function(r) {
    var t = Df(this), s2 = mf(t), a2;
    return ff(r), a2 = df(t, 0), a2.length = pf(a2, t, t, s2, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a2;
  } });
  var Gf = Gt(), Uf = ca(), Jf = fa();
  Gf({ target: "Object", stat: true }, { fromEntries: function(r) {
    var t = {};
    return Uf(r, function(s2, a2) {
      Jf(t, s2, a2);
    }, { AS_ENTRIES: true }), t;
  } });
  var Kf = pt(), Yf = yt(), Qf = da(), Zf = ya(), eD = Dt(), ha = Kf.RegExp, va = ha.prototype, tD = Yf && eD(function() {
    var e = true;
    try {
      ha(".", "d");
    } catch {
      e = false;
    }
    var r = {}, t = "", s2 = e ? "dgimsy" : "gimsy", a2 = function(l, p2) {
      Object.defineProperty(r, l, { get: function() {
        return t += p2, true;
      } });
    }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
    e && (n.hasIndices = "d");
    for (var u in n)
      a2(u, n[u]);
    var i = Object.getOwnPropertyDescriptor(va, "flags").get.call(r);
    return i !== s2 || t !== s2;
  });
  tD && Qf(va, "flags", { configurable: true, get: Zf });
  Ca();
  var nD = Gt(), uD = bn(), sD = dr(), iD = kt(), aD = Fr(), oD = Nn();
  nD({ target: "Array", proto: true }, { flat: function() {
    var r = arguments.length ? arguments[0] : void 0, t = sD(this), s2 = iD(t), a2 = oD(t, 0);
    return a2.length = uD(a2, t, t, s2, 0, r === void 0 ? 1 : aD(r)), a2;
  } });
  var lD = ["cliName", "cliCategory", "cliDescription"], cD = ["_"], pD = ["languageId"];
  function $n(e, r) {
    if (e == null)
      return {};
    var t = fD(e, r), s2, a2;
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (a2 = 0; a2 < n.length; a2++)
        s2 = n[a2], !(r.indexOf(s2) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s2) && (t[s2] = e[s2]);
    }
    return t;
  }
  function fD(e, r) {
    if (e == null)
      return {};
    var t = {}, s2 = Object.keys(e), a2, n;
    for (n = 0; n < s2.length; n++)
      a2 = s2[n], !(r.indexOf(a2) >= 0) && (t[a2] = e[a2]);
    return t;
  }
  var DD = Object.create, Nr = Object.defineProperty, mD = Object.getOwnPropertyDescriptor, Vn = Object.getOwnPropertyNames, dD = Object.getPrototypeOf, gD = Object.prototype.hasOwnProperty, ht = (e, r) => function() {
    return e && (r = (0, e[Vn(e)[0]])(e = 0)), r;
  }, te = (e, r) => function() {
    return r || (0, e[Vn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
  }, zt = (e, r) => {
    for (var t in r)
      Nr(e, t, { get: r[t], enumerable: true });
  }, Sa = (e, r, t, s2) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let a2 of Vn(r))
        !gD.call(e, a2) && a2 !== t && Nr(e, a2, { get: () => r[a2], enumerable: !(s2 = mD(r, a2)) || s2.enumerable });
    return e;
  }, yD = (e, r, t) => (t = e != null ? DD(dD(e)) : {}, Sa(r || !e || !e.__esModule ? Nr(t, "default", { value: e, enumerable: true }) : t, e)), ft = (e) => Sa(Nr({}, "__esModule", { value: true }), e), Nt, ne = ht({ "<define:process>"() {
    Nt = { env: {}, argv: [] };
  } }), xa = te({ "package.json"(e, r) {
    r.exports = { version: "2.8.8" };
  } }), hD = te({ "node_modules/diff/lib/diff/base.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
    function r() {
    }
    r.prototype = { diff: function(n, u) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
      typeof i == "function" && (l = i, i = {}), this.options = i;
      var p2 = this;
      function d(N) {
        return l ? (setTimeout(function() {
          l(void 0, N);
        }, 0), true) : N;
      }
      n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
      var y = u.length, g = n.length, c2 = 1, f = y + g, E = [{ newPos: -1, components: [] }], _ = this.extractCommon(E[0], u, n, 0);
      if (E[0].newPos + 1 >= y && _ + 1 >= g)
        return d([{ value: this.join(u), count: u.length }]);
      function w() {
        for (var N = -1 * c2; N <= c2; N += 2) {
          var x2 = void 0, I = E[N - 1], P = E[N + 1], $2 = (P ? P.newPos : 0) - N;
          I && (E[N - 1] = void 0);
          var D = I && I.newPos + 1 < y, T = P && 0 <= $2 && $2 < g;
          if (!D && !T) {
            E[N] = void 0;
            continue;
          }
          if (!D || T && I.newPos < P.newPos ? (x2 = s2(P), p2.pushComponent(x2.components, void 0, true)) : (x2 = I, x2.newPos++, p2.pushComponent(x2.components, true, void 0)), $2 = p2.extractCommon(x2, u, n, N), x2.newPos + 1 >= y && $2 + 1 >= g)
            return d(t(p2, x2.components, u, n, p2.useLongestToken));
          E[N] = x2;
        }
        c2++;
      }
      if (l)
        (function N() {
          setTimeout(function() {
            if (c2 > f)
              return l();
            w() || N();
          }, 0);
        })();
      else
        for (; c2 <= f; ) {
          var F = w();
          if (F)
            return F;
        }
    }, pushComponent: function(n, u, i) {
      var l = n[n.length - 1];
      l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
    }, extractCommon: function(n, u, i, l) {
      for (var p2 = u.length, d = i.length, y = n.newPos, g = y - l, c2 = 0; y + 1 < p2 && g + 1 < d && this.equals(u[y + 1], i[g + 1]); )
        y++, g++, c2++;
      return c2 && n.components.push({ count: c2 }), n.newPos = y, g;
    }, equals: function(n, u) {
      return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
    }, removeEmpty: function(n) {
      for (var u = [], i = 0; i < n.length; i++)
        n[i] && u.push(n[i]);
      return u;
    }, castInput: function(n) {
      return n;
    }, tokenize: function(n) {
      return n.split("");
    }, join: function(n) {
      return n.join("");
    } };
    function t(a2, n, u, i, l) {
      for (var p2 = 0, d = n.length, y = 0, g = 0; p2 < d; p2++) {
        var c2 = n[p2];
        if (c2.removed) {
          if (c2.value = a2.join(i.slice(g, g + c2.count)), g += c2.count, p2 && n[p2 - 1].added) {
            var E = n[p2 - 1];
            n[p2 - 1] = n[p2], n[p2] = E;
          }
        } else {
          if (!c2.added && l) {
            var f = u.slice(y, y + c2.count);
            f = f.map(function(w, F) {
              var N = i[g + F];
              return N.length > w.length ? N : w;
            }), c2.value = a2.join(f);
          } else
            c2.value = a2.join(u.slice(y, y + c2.count));
          y += c2.count, c2.added || (g += c2.count);
        }
      }
      var _ = n[d - 1];
      return d > 1 && typeof _.value == "string" && (_.added || _.removed) && a2.equals("", _.value) && (n[d - 2].value += _.value, n.pop()), n;
    }
    function s2(a2) {
      return { newPos: a2.newPos, components: a2.components.slice(0) };
    }
  } }), vD = te({ "node_modules/diff/lib/diff/array.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a2, e.arrayDiff = void 0;
    var r = t(hD());
    function t(n) {
      return n && n.__esModule ? n : { default: n };
    }
    var s2 = new r.default();
    e.arrayDiff = s2, s2.tokenize = function(n) {
      return n.slice();
    }, s2.join = s2.removeEmpty = function(n) {
      return n;
    };
    function a2(n, u, i) {
      return s2.diff(n, u, i);
    }
  } }), Wn = te({ "src/document/doc-builders.js"(e, r) {
    ne();
    function t(C) {
      return { type: "concat", parts: C };
    }
    function s2(C) {
      return { type: "indent", contents: C };
    }
    function a2(C, o) {
      return { type: "align", contents: o, n: C };
    }
    function n(C) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
    }
    function u(C) {
      return a2(Number.NEGATIVE_INFINITY, C);
    }
    function i(C) {
      return a2({ type: "root" }, C);
    }
    function l(C) {
      return a2(-1, C);
    }
    function p2(C, o) {
      return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
    }
    function d(C) {
      return { type: "fill", parts: C };
    }
    function y(C, o) {
      let h2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return { type: "if-break", breakContents: C, flatContents: o, groupId: h2.groupId };
    }
    function g(C, o) {
      return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
    }
    function c2(C) {
      return { type: "line-suffix", contents: C };
    }
    var f = { type: "line-suffix-boundary" }, E = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, N = { type: "line" }, x2 = { type: "line", soft: true }, I = t([w, E]), P = t([F, E]), $2 = { type: "cursor", placeholder: Symbol("cursor") };
    function D(C, o) {
      let h2 = [];
      for (let v = 0; v < o.length; v++)
        v !== 0 && h2.push(C), h2.push(o[v]);
      return t(h2);
    }
    function T(C, o, h2) {
      let v = C;
      if (o > 0) {
        for (let S = 0; S < Math.floor(o / h2); ++S)
          v = s2(v);
        v = a2(o % h2, v), v = a2(Number.NEGATIVE_INFINITY, v);
      }
      return v;
    }
    function m2(C, o) {
      return { type: "label", label: C, contents: o };
    }
    r.exports = { concat: t, join: D, line: N, softline: x2, hardline: I, literalline: P, group: n, conditionalGroup: p2, fill: d, lineSuffix: c2, lineSuffixBoundary: f, cursor: $2, breakParent: E, ifBreak: y, trim: _, indent: s2, indentIfBreak: g, align: a2, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: F, label: m2 };
  } }), Hn = te({ "src/common/end-of-line.js"(e, r) {
    ne();
    function t(u) {
      let i = u.indexOf("\r");
      return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
    }
    function s2(u) {
      switch (u) {
        case "cr":
          return "\r";
        case "crlf":
          return `\r
`;
        default:
          return `
`;
      }
    }
    function a2(u, i) {
      let l;
      switch (i) {
        case `
`:
          l = /\n/g;
          break;
        case "\r":
          l = /\r/g;
          break;
        case `\r
`:
          l = /\r\n/g;
          break;
        default:
          throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
      }
      let p2 = u.match(l);
      return p2 ? p2.length : 0;
    }
    function n(u) {
      return u.replace(/\r\n?/g, `
`);
    }
    r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s2, countEndOfLineChars: a2, normalizeEndOfLine: n };
  } }), lt = te({ "src/utils/get-last.js"(e, r) {
    ne();
    var t = (s2) => s2[s2.length - 1];
    r.exports = t;
  } });
  function CD() {
    let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
    return new RegExp(r, e ? void 0 : "g");
  }
  var ED = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
    ne();
  } });
  function FD(e) {
    if (typeof e != "string")
      throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
    return e.replace(CD(), "");
  }
  var AD = ht({ "node_modules/strip-ansi/index.js"() {
    ne(), ED();
  } });
  function SD(e) {
    return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
  }
  var xD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
    ne();
  } }), bD = te({ "node_modules/emoji-regex/index.js"(e, r) {
    ne(), r.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  } }), ba = {};
  zt(ba, { default: () => TD });
  function TD(e) {
    if (typeof e != "string" || e.length === 0 || (e = FD(e), e.length === 0))
      return 0;
    e = e.replace((0, Ta.default)(), "  ");
    let r = 0;
    for (let t = 0; t < e.length; t++) {
      let s2 = e.codePointAt(t);
      s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t++, r += SD(s2) ? 2 : 1);
    }
    return r;
  }
  var Ta, BD = ht({ "node_modules/string-width/index.js"() {
    ne(), AD(), xD(), Ta = yD(bD());
  } }), Ba = te({ "src/utils/get-string-width.js"(e, r) {
    ne();
    var t = (BD(), ft(ba)).default, s2 = /[^\x20-\x7F]/;
    function a2(n) {
      return n ? s2.test(n) ? t(n) : n.length : 0;
    }
    r.exports = a2;
  } }), Xt = te({ "src/document/doc-utils.js"(e, r) {
    ne();
    var t = lt(), { literalline: s2, join: a2 } = Wn(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
      if (Array.isArray(o))
        return o;
      if (o.type !== "concat" && o.type !== "fill")
        throw new Error("Expect doc type to be `concat` or `fill`.");
      return o.parts;
    }, i = {};
    function l(o, h2, v, S) {
      let b = [o];
      for (; b.length > 0; ) {
        let B = b.pop();
        if (B === i) {
          v(b.pop());
          continue;
        }
        if (v && b.push(B, i), !h2 || h2(B) !== false)
          if (n(B) || B.type === "fill") {
            let k = u(B);
            for (let M = k.length, R = M - 1; R >= 0; --R)
              b.push(k[R]);
          } else if (B.type === "if-break")
            B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
          else if (B.type === "group" && B.expandedStates)
            if (S)
              for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                b.push(B.expandedStates[M]);
            else
              b.push(B.contents);
          else
            B.contents && b.push(B.contents);
      }
    }
    function p2(o, h2) {
      let v = /* @__PURE__ */ new Map();
      return S(o);
      function S(B) {
        if (v.has(B))
          return v.get(B);
        let k = b(B);
        return v.set(B, k), k;
      }
      function b(B) {
        if (Array.isArray(B))
          return h2(B.map(S));
        if (B.type === "concat" || B.type === "fill") {
          let k = B.parts.map(S);
          return h2(Object.assign(Object.assign({}, B), {}, { parts: k }));
        }
        if (B.type === "if-break") {
          let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
          return h2(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
        }
        if (B.type === "group" && B.expandedStates) {
          let k = B.expandedStates.map(S), M = k[0];
          return h2(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
        }
        if (B.contents) {
          let k = S(B.contents);
          return h2(Object.assign(Object.assign({}, B), {}, { contents: k }));
        }
        return h2(B);
      }
    }
    function d(o, h2, v) {
      let S = v, b = false;
      function B(k) {
        let M = h2(k);
        if (M !== void 0 && (b = true, S = M), b)
          return false;
      }
      return l(o, B), S;
    }
    function y(o) {
      if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
        return true;
    }
    function g(o) {
      return d(o, y, false);
    }
    function c2(o) {
      if (o.length > 0) {
        let h2 = t(o);
        !h2.expandedStates && !h2.break && (h2.break = "propagated");
      }
      return null;
    }
    function f(o) {
      let h2 = /* @__PURE__ */ new Set(), v = [];
      function S(B) {
        if (B.type === "break-parent" && c2(v), B.type === "group") {
          if (v.push(B), h2.has(B))
            return false;
          h2.add(B);
        }
      }
      function b(B) {
        B.type === "group" && v.pop().break && c2(v);
      }
      l(o, S, b, true);
    }
    function E(o) {
      return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
    }
    function _(o) {
      return p2(o, E);
    }
    var w = (o, h2) => o && o.type === "line" && o.hard && h2 && h2.type === "break-parent";
    function F(o) {
      if (!o)
        return o;
      if (n(o) || o.type === "fill") {
        let h2 = u(o);
        for (; h2.length > 1 && w(...h2.slice(-2)); )
          h2.length -= 2;
        if (h2.length > 0) {
          let v = F(t(h2));
          h2[h2.length - 1] = v;
        }
        return Array.isArray(o) ? h2 : Object.assign(Object.assign({}, o), {}, { parts: h2 });
      }
      switch (o.type) {
        case "align":
        case "indent":
        case "indent-if-break":
        case "group":
        case "line-suffix":
        case "label": {
          let h2 = F(o.contents);
          return Object.assign(Object.assign({}, o), {}, { contents: h2 });
        }
        case "if-break": {
          let h2 = F(o.breakContents), v = F(o.flatContents);
          return Object.assign(Object.assign({}, o), {}, { breakContents: h2, flatContents: v });
        }
      }
      return o;
    }
    function N(o) {
      return F(I(o));
    }
    function x2(o) {
      switch (o.type) {
        case "fill":
          if (o.parts.every((v) => v === ""))
            return "";
          break;
        case "group":
          if (!o.contents && !o.id && !o.break && !o.expandedStates)
            return "";
          if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
            return o.contents;
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!o.contents)
            return "";
          break;
        case "if-break":
          if (!o.flatContents && !o.breakContents)
            return "";
          break;
      }
      if (!n(o))
        return o;
      let h2 = [];
      for (let v of u(o)) {
        if (!v)
          continue;
        let [S, ...b] = n(v) ? u(v) : [v];
        typeof S == "string" && typeof t(h2) == "string" ? h2[h2.length - 1] += S : h2.push(S), h2.push(...b);
      }
      return h2.length === 0 ? "" : h2.length === 1 ? h2[0] : Array.isArray(o) ? h2 : Object.assign(Object.assign({}, o), {}, { parts: h2 });
    }
    function I(o) {
      return p2(o, (h2) => x2(h2));
    }
    function P(o) {
      let h2 = [], v = o.filter(Boolean);
      for (; v.length > 0; ) {
        let S = v.shift();
        if (S) {
          if (n(S)) {
            v.unshift(...u(S));
            continue;
          }
          if (h2.length > 0 && typeof t(h2) == "string" && typeof S == "string") {
            h2[h2.length - 1] += S;
            continue;
          }
          h2.push(S);
        }
      }
      return h2;
    }
    function $2(o) {
      return p2(o, (h2) => Array.isArray(h2) ? P(h2) : h2.parts ? Object.assign(Object.assign({}, h2), {}, { parts: P(h2.parts) }) : h2);
    }
    function D(o) {
      return p2(o, (h2) => typeof h2 == "string" && h2.includes(`
`) ? T(h2) : h2);
    }
    function T(o) {
      let h2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2;
      return a2(h2, o.split(`
`)).parts;
    }
    function m2(o) {
      if (o.type === "line")
        return true;
    }
    function C(o) {
      return d(o, m2, false);
    }
    r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: d, mapDoc: p2, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $2, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
  } }), ND = te({ "src/document/doc-printer.js"(e, r) {
    ne();
    var { convertEndOfLineToChars: t } = Hn(), s2 = lt(), a2 = Ba(), { fill: n, cursor: u, indent: i } = Wn(), { isConcat: l, getDocParts: p2 } = Xt(), d, y = 1, g = 2;
    function c2() {
      return { value: "", length: 0, queue: [] };
    }
    function f(x2, I) {
      return _(x2, { type: "indent" }, I);
    }
    function E(x2, I, P) {
      return I === Number.NEGATIVE_INFINITY ? x2.root || c2() : I < 0 ? _(x2, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x2), {}, { root: x2 }) : _(x2, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x2;
    }
    function _(x2, I, P) {
      let $2 = I.type === "dedent" ? x2.queue.slice(0, -1) : [...x2.queue, I], D = "", T = 0, m2 = 0, C = 0;
      for (let k of $2)
        switch (k.type) {
          case "indent":
            v(), P.useTabs ? o(1) : h2(P.tabWidth);
            break;
          case "stringAlign":
            v(), D += k.n, T += k.n.length;
            break;
          case "numberAlign":
            m2 += 1, C += k.n;
            break;
          default:
            throw new Error(`Unexpected type '${k.type}'`);
        }
      return b(), Object.assign(Object.assign({}, x2), {}, { value: D, length: T, queue: $2 });
      function o(k) {
        D += "	".repeat(k), T += P.tabWidth * k;
      }
      function h2(k) {
        D += " ".repeat(k), T += k;
      }
      function v() {
        P.useTabs ? S() : b();
      }
      function S() {
        m2 > 0 && o(m2), B();
      }
      function b() {
        C > 0 && h2(C), B();
      }
      function B() {
        m2 = 0, C = 0;
      }
    }
    function w(x2) {
      if (x2.length === 0)
        return 0;
      let I = 0;
      for (; x2.length > 0 && typeof s2(x2) == "string" && /^[\t ]*$/.test(s2(x2)); )
        I += x2.pop().length;
      if (x2.length > 0 && typeof s2(x2) == "string") {
        let P = s2(x2).replace(/[\t ]*$/, "");
        I += s2(x2).length - P.length, x2[x2.length - 1] = P;
      }
      return I;
    }
    function F(x2, I, P, $2, D) {
      let T = I.length, m2 = [x2], C = [];
      for (; P >= 0; ) {
        if (m2.length === 0) {
          if (T === 0)
            return true;
          m2.push(I[--T]);
          continue;
        }
        let { mode: o, doc: h2 } = m2.pop();
        if (typeof h2 == "string")
          C.push(h2), P -= a2(h2);
        else if (l(h2) || h2.type === "fill") {
          let v = p2(h2);
          for (let S = v.length - 1; S >= 0; S--)
            m2.push({ mode: o, doc: v[S] });
        } else
          switch (h2.type) {
            case "indent":
            case "align":
            case "indent-if-break":
            case "label":
              m2.push({ mode: o, doc: h2.contents });
              break;
            case "trim":
              P += w(C);
              break;
            case "group": {
              if (D && h2.break)
                return false;
              let v = h2.break ? y : o, S = h2.expandedStates && v === y ? s2(h2.expandedStates) : h2.contents;
              m2.push({ mode: v, doc: S });
              break;
            }
            case "if-break": {
              let S = (h2.groupId ? d[h2.groupId] || g : o) === y ? h2.breakContents : h2.flatContents;
              S && m2.push({ mode: o, doc: S });
              break;
            }
            case "line":
              if (o === y || h2.hard)
                return true;
              h2.soft || (C.push(" "), P--);
              break;
            case "line-suffix":
              $2 = true;
              break;
            case "line-suffix-boundary":
              if ($2)
                return false;
              break;
          }
      }
      return false;
    }
    function N(x2, I) {
      d = {};
      let P = I.printWidth, $2 = t(I.endOfLine), D = 0, T = [{ ind: c2(), mode: y, doc: x2 }], m2 = [], C = false, o = [];
      for (; T.length > 0; ) {
        let { ind: v, mode: S, doc: b } = T.pop();
        if (typeof b == "string") {
          let B = $2 !== `
` ? b.replace(/\n/g, $2) : b;
          m2.push(B), D += a2(B);
        } else if (l(b)) {
          let B = p2(b);
          for (let k = B.length - 1; k >= 0; k--)
            T.push({ ind: v, mode: S, doc: B[k] });
        } else
          switch (b.type) {
            case "cursor":
              m2.push(u.placeholder);
              break;
            case "indent":
              T.push({ ind: f(v, I), mode: S, doc: b.contents });
              break;
            case "align":
              T.push({ ind: E(v, b.n, I), mode: S, doc: b.contents });
              break;
            case "trim":
              D -= w(m2);
              break;
            case "group":
              switch (S) {
                case g:
                  if (!C) {
                    T.push({ ind: v, mode: b.break ? y : g, doc: b.contents });
                    break;
                  }
                case y: {
                  C = false;
                  let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                  if (!b.break && F(B, T, k, M))
                    T.push(B);
                  else if (b.expandedStates) {
                    let R = s2(b.expandedStates);
                    if (b.break) {
                      T.push({ ind: v, mode: y, doc: R });
                      break;
                    } else
                      for (let q2 = 1; q2 < b.expandedStates.length + 1; q2++)
                        if (q2 >= b.expandedStates.length) {
                          T.push({ ind: v, mode: y, doc: R });
                          break;
                        } else {
                          let J = b.expandedStates[q2], L = { ind: v, mode: g, doc: J };
                          if (F(L, T, k, M)) {
                            T.push(L);
                            break;
                          }
                        }
                  } else
                    T.push({ ind: v, mode: y, doc: b.contents });
                  break;
                }
              }
              b.id && (d[b.id] = s2(T).mode);
              break;
            case "fill": {
              let B = P - D, { parts: k } = b;
              if (k.length === 0)
                break;
              let [M, R] = k, q2 = { ind: v, mode: g, doc: M }, J = { ind: v, mode: y, doc: M }, L = F(q2, [], B, o.length > 0, true);
              if (k.length === 1) {
                L ? T.push(q2) : T.push(J);
                break;
              }
              let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: y, doc: R };
              if (k.length === 2) {
                L ? T.push(Q, q2) : T.push(V, J);
                break;
              }
              k.splice(0, 2);
              let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
              F({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q2) : L ? T.push(j, V, q2) : T.push(j, V, J);
              break;
            }
            case "if-break":
            case "indent-if-break": {
              let B = b.groupId ? d[b.groupId] : S;
              if (B === y) {
                let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                k && T.push({ ind: v, mode: S, doc: k });
              }
              if (B === g) {
                let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                k && T.push({ ind: v, mode: S, doc: k });
              }
              break;
            }
            case "line-suffix":
              o.push({ ind: v, mode: S, doc: b.contents });
              break;
            case "line-suffix-boundary":
              o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
              break;
            case "line":
              switch (S) {
                case g:
                  if (b.hard)
                    C = true;
                  else {
                    b.soft || (m2.push(" "), D += 1);
                    break;
                  }
                case y:
                  if (o.length > 0) {
                    T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                    break;
                  }
                  b.literal ? v.root ? (m2.push($2, v.root.value), D = v.root.length) : (m2.push($2), D = 0) : (D -= w(m2), m2.push($2 + v.value), D = v.length);
                  break;
              }
              break;
            case "label":
              T.push({ ind: v, mode: S, doc: b.contents });
              break;
          }
        T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
      }
      let h2 = m2.indexOf(u.placeholder);
      if (h2 !== -1) {
        let v = m2.indexOf(u.placeholder, h2 + 1), S = m2.slice(0, h2).join(""), b = m2.slice(h2 + 1, v).join(""), B = m2.slice(v + 1).join("");
        return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
      }
      return { formatted: m2.join("") };
    }
    r.exports = { printDocToString: N };
  } }), wD = te({ "src/document/doc-debug.js"(e, r) {
    ne();
    var { isConcat: t, getDocParts: s2 } = Xt();
    function a2(u) {
      if (!u)
        return "";
      if (t(u)) {
        let i = [];
        for (let l of s2(u))
          if (t(l))
            i.push(...a2(l).parts);
          else {
            let p2 = a2(l);
            p2 !== "" && i.push(p2);
          }
        return { type: "concat", parts: i };
      }
      return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a2(u.breakContents), flatContents: a2(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a2) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a2) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents) }) : u;
    }
    function n(u) {
      let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
      return p2(a2(u));
      function p2(y, g, c2) {
        if (typeof y == "string")
          return JSON.stringify(y);
        if (t(y)) {
          let f = s2(y).map(p2).filter(Boolean);
          return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
        }
        if (y.type === "line") {
          let f = Array.isArray(c2) && c2[g + 1] && c2[g + 1].type === "break-parent";
          return y.literal ? f ? "literalline" : "literallineWithoutBreakParent" : y.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : y.soft ? "softline" : "line";
        }
        if (y.type === "break-parent")
          return Array.isArray(c2) && c2[g - 1] && c2[g - 1].type === "line" && c2[g - 1].hard ? void 0 : "breakParent";
        if (y.type === "trim")
          return "trim";
        if (y.type === "indent")
          return "indent(" + p2(y.contents) + ")";
        if (y.type === "align")
          return y.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p2(y.contents) + ")" : y.n < 0 ? "dedent(" + p2(y.contents) + ")" : y.n.type === "root" ? "markAsRoot(" + p2(y.contents) + ")" : "align(" + JSON.stringify(y.n) + ", " + p2(y.contents) + ")";
        if (y.type === "if-break")
          return "ifBreak(" + p2(y.breakContents) + (y.flatContents ? ", " + p2(y.flatContents) : "") + (y.groupId ? (y.flatContents ? "" : ', ""') + `, { groupId: ${d(y.groupId)} }` : "") + ")";
        if (y.type === "indent-if-break") {
          let f = [];
          y.negate && f.push("negate: true"), y.groupId && f.push(`groupId: ${d(y.groupId)}`);
          let E = f.length > 0 ? `, { ${f.join(", ")} }` : "";
          return `indentIfBreak(${p2(y.contents)}${E})`;
        }
        if (y.type === "group") {
          let f = [];
          y.break && y.break !== "propagated" && f.push("shouldBreak: true"), y.id && f.push(`id: ${d(y.id)}`);
          let E = f.length > 0 ? `, { ${f.join(", ")} }` : "";
          return y.expandedStates ? `conditionalGroup([${y.expandedStates.map((_) => p2(_)).join(",")}]${E})` : `group(${p2(y.contents)}${E})`;
        }
        if (y.type === "fill")
          return `fill([${y.parts.map((f) => p2(f)).join(", ")}])`;
        if (y.type === "line-suffix")
          return "lineSuffix(" + p2(y.contents) + ")";
        if (y.type === "line-suffix-boundary")
          return "lineSuffixBoundary";
        if (y.type === "label")
          return `label(${JSON.stringify(y.label)}, ${p2(y.contents)})`;
        throw new Error("Unknown doc type " + y.type);
      }
      function d(y) {
        if (typeof y != "symbol")
          return JSON.stringify(String(y));
        if (y in i)
          return i[y];
        let g = String(y).slice(7, -1) || "symbol";
        for (let c2 = 0; ; c2++) {
          let f = g + (c2 > 0 ? ` #${c2}` : "");
          if (!l.has(f))
            return l.add(f), i[y] = `Symbol.for(${JSON.stringify(f)})`;
        }
      }
    }
    r.exports = { printDocToDebug: n };
  } }), qe = te({ "src/document/index.js"(e, r) {
    ne(), r.exports = { builders: Wn(), printer: ND(), utils: Xt(), debug: wD() };
  } }), Na = {};
  zt(Na, { default: () => _D });
  function _D(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  var PD = ht({ "node_modules/escape-string-regexp/index.js"() {
    ne();
  } }), wa = te({ "node_modules/semver/internal/debug.js"(e, r) {
    ne();
    var t = typeof Nt == "object" && Nt.env && Nt.env.NODE_DEBUG && /\bsemver\b/i.test(Nt.env.NODE_DEBUG) ? function() {
      for (var s2 = arguments.length, a2 = new Array(s2), n = 0; n < s2; n++)
        a2[n] = arguments[n];
      return console.error("SEMVER", ...a2);
    } : () => {
    };
    r.exports = t;
  } }), _a = te({ "node_modules/semver/internal/constants.js"(e, r) {
    ne();
    var t = "2.0.0", s2 = 256, a2 = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
    r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2, MAX_SAFE_COMPONENT_LENGTH: n };
  } }), ID = te({ "node_modules/semver/internal/re.js"(e, r) {
    ne();
    var { MAX_SAFE_COMPONENT_LENGTH: t } = _a(), s2 = wa();
    e = r.exports = {};
    var a2 = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p2, d, y) => {
      let g = i++;
      s2(p2, g, d), u[p2] = g, n[g] = d, a2[g] = new RegExp(d, y ? "g" : void 0);
    };
    l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  } }), kD = te({ "node_modules/semver/internal/parse-options.js"(e, r) {
    ne();
    var t = ["includePrerelease", "loose", "rtl"], s2 = (a2) => a2 ? typeof a2 != "object" ? { loose: true } : t.filter((n) => a2[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
    r.exports = s2;
  } }), LD = te({ "node_modules/semver/internal/identifiers.js"(e, r) {
    ne();
    var t = /^[0-9]+$/, s2 = (n, u) => {
      let i = t.test(n), l = t.test(u);
      return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
    }, a2 = (n, u) => s2(u, n);
    r.exports = { compareIdentifiers: s2, rcompareIdentifiers: a2 };
  } }), OD = te({ "node_modules/semver/classes/semver.js"(e, r) {
    ne();
    var t = wa(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2 } = _a(), { re: n, t: u } = ID(), i = kD(), { compareIdentifiers: l } = LD(), p2 = class {
      constructor(d, y) {
        if (y = i(y), d instanceof p2) {
          if (d.loose === !!y.loose && d.includePrerelease === !!y.includePrerelease)
            return d;
          d = d.version;
        } else if (typeof d != "string")
          throw new TypeError(`Invalid Version: ${d}`);
        if (d.length > s2)
          throw new TypeError(`version is longer than ${s2} characters`);
        t("SemVer", d, y), this.options = y, this.loose = !!y.loose, this.includePrerelease = !!y.includePrerelease;
        let g = d.trim().match(y.loose ? n[u.LOOSE] : n[u.FULL]);
        if (!g)
          throw new TypeError(`Invalid Version: ${d}`);
        if (this.raw = d, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a2 || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > a2 || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > a2 || this.patch < 0)
          throw new TypeError("Invalid patch version");
        g[4] ? this.prerelease = g[4].split(".").map((c2) => {
          if (/^[0-9]+$/.test(c2)) {
            let f = +c2;
            if (f >= 0 && f < a2)
              return f;
          }
          return c2;
        }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(d) {
        if (t("SemVer.compare", this.version, this.options, d), !(d instanceof p2)) {
          if (typeof d == "string" && d === this.version)
            return 0;
          d = new p2(d, this.options);
        }
        return d.version === this.version ? 0 : this.compareMain(d) || this.comparePre(d);
      }
      compareMain(d) {
        return d instanceof p2 || (d = new p2(d, this.options)), l(this.major, d.major) || l(this.minor, d.minor) || l(this.patch, d.patch);
      }
      comparePre(d) {
        if (d instanceof p2 || (d = new p2(d, this.options)), this.prerelease.length && !d.prerelease.length)
          return -1;
        if (!this.prerelease.length && d.prerelease.length)
          return 1;
        if (!this.prerelease.length && !d.prerelease.length)
          return 0;
        let y = 0;
        do {
          let g = this.prerelease[y], c2 = d.prerelease[y];
          if (t("prerelease compare", y, g, c2), g === void 0 && c2 === void 0)
            return 0;
          if (c2 === void 0)
            return 1;
          if (g === void 0)
            return -1;
          if (g === c2)
            continue;
          return l(g, c2);
        } while (++y);
      }
      compareBuild(d) {
        d instanceof p2 || (d = new p2(d, this.options));
        let y = 0;
        do {
          let g = this.build[y], c2 = d.build[y];
          if (t("prerelease compare", y, g, c2), g === void 0 && c2 === void 0)
            return 0;
          if (c2 === void 0)
            return 1;
          if (g === void 0)
            return -1;
          if (g === c2)
            continue;
          return l(g, c2);
        } while (++y);
      }
      inc(d, y) {
        switch (d) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", y);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", y);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", y), this.inc("pre", y);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", y), this.inc("pre", y);
            break;
          case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0)
              this.prerelease = [0];
            else {
              let g = this.prerelease.length;
              for (; --g >= 0; )
                typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
              g === -1 && this.prerelease.push(0);
            }
            y && (l(this.prerelease[0], y) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [y, 0]) : this.prerelease = [y, 0]);
            break;
          default:
            throw new Error(`invalid increment argument: ${d}`);
        }
        return this.format(), this.raw = this.version, this;
      }
    };
    r.exports = p2;
  } }), Gn = te({ "node_modules/semver/functions/compare.js"(e, r) {
    ne();
    var t = OD(), s2 = (a2, n, u) => new t(a2, u).compare(new t(n, u));
    r.exports = s2;
  } }), jD = te({ "node_modules/semver/functions/lt.js"(e, r) {
    ne();
    var t = Gn(), s2 = (a2, n, u) => t(a2, n, u) < 0;
    r.exports = s2;
  } }), qD = te({ "node_modules/semver/functions/gte.js"(e, r) {
    ne();
    var t = Gn(), s2 = (a2, n, u) => t(a2, n, u) >= 0;
    r.exports = s2;
  } }), MD = te({ "src/utils/arrayify.js"(e, r) {
    ne(), r.exports = (t, s2) => Object.entries(t).map((a2) => {
      let [n, u] = a2;
      return Object.assign({ [s2]: n }, u);
    });
  } }), RD = te({ "node_modules/outdent/lib/index.js"(e, r) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
    function t() {
      for (var F = [], N = 0; N < arguments.length; N++)
        F[N] = arguments[N];
    }
    function s2() {
      return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a2();
    }
    function a2() {
      return { add: t, delete: t, get: t, set: t, has: function(F) {
        return false;
      } };
    }
    var n = Object.prototype.hasOwnProperty, u = function(F, N) {
      return n.call(F, N);
    };
    function i(F, N) {
      for (var x2 in N)
        u(N, x2) && (F[x2] = N[x2]);
      return F;
    }
    var l = /^[ \t]*(?:\r\n|\r|\n)/, p2 = /(?:\r\n|\r|\n)[ \t]*$/, d = /^(?:[\r\n]|$)/, y = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function c2(F, N, x2) {
      var I = 0, P = F[0].match(y);
      P && (I = P[1].length);
      var $2 = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($2, "g");
      N && (F = F.slice(1));
      var T = x2.newline, m2 = x2.trimLeadingNewline, C = x2.trimTrailingNewline, o = typeof T == "string", h2 = F.length, v = F.map(function(S, b) {
        return S = S.replace(D, "$1"), b === 0 && m2 && (S = S.replace(l, "")), b === h2 - 1 && C && (S = S.replace(p2, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
          return T;
        })), S;
      });
      return v;
    }
    function f(F, N) {
      for (var x2 = "", I = 0, P = F.length; I < P; I++)
        x2 += F[I], I < P - 1 && (x2 += N[I]);
      return x2;
    }
    function E(F) {
      return u(F, "raw") && u(F, "length");
    }
    function _(F) {
      var N = s2(), x2 = s2();
      function I($2) {
        for (var D = [], T = 1; T < arguments.length; T++)
          D[T - 1] = arguments[T];
        if (E($2)) {
          var m2 = $2, C = (D[0] === I || D[0] === w) && g.test(m2[0]) && d.test(m2[1]), o = C ? x2 : N, h2 = o.get(m2);
          if (h2 || (h2 = c2(m2, C, F), o.set(m2, h2)), D.length === 0)
            return h2[0];
          var v = f(h2, C ? D.slice(1) : D);
          return v;
        } else
          return _(i(i({}, F), $2 || {}));
      }
      var P = i(I, { string: function($2) {
        return c2([$2], false, F)[0];
      } });
      return P;
    }
    var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
    if (e.outdent = w, e.default = w, typeof r < "u")
      try {
        r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
      } catch {
      }
  } }), $D = te({ "src/main/core-options.js"(e, r) {
    ne();
    var { outdent: t } = RD(), s2 = "Config", a2 = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p2 = "Special", d = { cursorOffset: { since: "1.4.0", category: p2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a2 }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (y) => typeof y == "string" || typeof y == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (y) => typeof y == "string" || typeof y == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (y) => typeof y == "string" || typeof y == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, rangeStart: { since: "1.4.0", category: p2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, requirePragma: { since: "1.7.0", category: p2, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
    r.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: a2, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p2, options: d };
  } }), Un = te({ "src/main/support.js"(e, r) {
    ne();
    var t = { compare: Gn(), lt: jD(), gte: qD() }, s2 = MD(), a2 = xa().version, n = $D().options;
    function u() {
      let { plugins: l = [], showUnreleased: p2 = false, showDeprecated: d = false, showInternal: y = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a2.split("-", 1)[0], c2 = l.flatMap((F) => F.languages || []).filter(E), f = s2(Object.assign({}, ...l.map((F) => {
        let { options: N } = F;
        return N;
      }), n), "name").filter((F) => E(F) && _(F)).sort((F, N) => F.name === N.name ? 0 : F.name < N.name ? -1 : 1).map(w).map((F) => {
        F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(E).sort((x2, I) => t.compare(I.since, x2.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((x2) => E(x2) && _(x2)), F.name === "parser" && i(F, c2, l));
        let N = Object.fromEntries(l.filter((x2) => x2.defaultOptions && x2.defaultOptions[F.name] !== void 0).map((x2) => [x2.name, x2.defaultOptions[F.name]]));
        return Object.assign(Object.assign({}, F), {}, { pluginDefaults: N });
      });
      return { languages: c2, options: f };
      function E(F) {
        return p2 || !("since" in F) || F.since && t.gte(g, F.since);
      }
      function _(F) {
        return d || !("deprecated" in F) || F.deprecated && t.lt(g, F.deprecated);
      }
      function w(F) {
        if (y)
          return F;
        return $n(F, lD);
      }
    }
    function i(l, p2, d) {
      let y = new Set(l.choices.map((g) => g.value));
      for (let g of p2)
        if (g.parsers) {
          for (let c2 of g.parsers)
            if (!y.has(c2)) {
              y.add(c2);
              let f = d.find((_) => _.parsers && _.parsers[c2]), E = g.name;
              f && f.name && (E += ` (plugin: ${f.name})`), l.choices.push({ value: c2, description: E });
            }
        }
    }
    r.exports = { getSupportInfo: u };
  } }), Jn = te({ "src/utils/is-non-empty-array.js"(e, r) {
    ne();
    function t(s2) {
      return Array.isArray(s2) && s2.length > 0;
    }
    r.exports = t;
  } }), wr = te({ "src/utils/text/skip.js"(e, r) {
    ne();
    function t(i) {
      return (l, p2, d) => {
        let y = d && d.backwards;
        if (p2 === false)
          return false;
        let { length: g } = l, c2 = p2;
        for (; c2 >= 0 && c2 < g; ) {
          let f = l.charAt(c2);
          if (i instanceof RegExp) {
            if (!i.test(f))
              return c2;
          } else if (!i.includes(f))
            return c2;
          y ? c2-- : c2++;
        }
        return c2 === -1 || c2 === g ? c2 : false;
      };
    }
    var s2 = t(/\s/), a2 = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
    r.exports = { skipWhitespace: s2, skipSpaces: a2, skipToLineEnd: n, skipEverythingButNewLine: u };
  } }), Pa = te({ "src/utils/text/skip-inline-comment.js"(e, r) {
    ne();
    function t(s2, a2) {
      if (a2 === false)
        return false;
      if (s2.charAt(a2) === "/" && s2.charAt(a2 + 1) === "*") {
        for (let n = a2 + 2; n < s2.length; ++n)
          if (s2.charAt(n) === "*" && s2.charAt(n + 1) === "/")
            return n + 2;
      }
      return a2;
    }
    r.exports = t;
  } }), Ia = te({ "src/utils/text/skip-trailing-comment.js"(e, r) {
    ne();
    var { skipEverythingButNewLine: t } = wr();
    function s2(a2, n) {
      return n === false ? false : a2.charAt(n) === "/" && a2.charAt(n + 1) === "/" ? t(a2, n) : n;
    }
    r.exports = s2;
  } }), ka = te({ "src/utils/text/skip-newline.js"(e, r) {
    ne();
    function t(s2, a2, n) {
      let u = n && n.backwards;
      if (a2 === false)
        return false;
      let i = s2.charAt(a2);
      if (u) {
        if (s2.charAt(a2 - 1) === "\r" && i === `
`)
          return a2 - 2;
        if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
          return a2 - 1;
      } else {
        if (i === "\r" && s2.charAt(a2 + 1) === `
`)
          return a2 + 2;
        if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
          return a2 + 1;
      }
      return a2;
    }
    r.exports = t;
  } }), VD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
    ne();
    var t = Pa(), s2 = ka(), a2 = Ia(), { skipSpaces: n } = wr();
    function u(i, l) {
      let p2 = null, d = l;
      for (; d !== p2; )
        p2 = d, d = n(i, d), d = t(i, d), d = a2(i, d), d = s2(i, d);
      return d;
    }
    r.exports = u;
  } }), Ue = te({ "src/common/util.js"(e, r) {
    ne();
    var { default: t } = (PD(), ft(Na)), s2 = lt(), { getSupportInfo: a2 } = Un(), n = Jn(), u = Ba(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p2, skipEverythingButNewLine: d } = wr(), y = Pa(), g = Ia(), c2 = ka(), f = VD(), E = (V) => V[V.length - 2];
    function _(V) {
      return (j, Y, ie) => {
        let ee = ie && ie.backwards;
        if (Y === false)
          return false;
        let { length: ce } = j, W = Y;
        for (; W >= 0 && W < ce; ) {
          let K = j.charAt(W);
          if (V instanceof RegExp) {
            if (!V.test(K))
              return W;
          } else if (!V.includes(K))
            return W;
          ee ? W-- : W++;
        }
        return W === -1 || W === ce ? W : false;
      };
    }
    function w(V, j) {
      let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c2(V, ie, Y);
      return ie !== ee;
    }
    function F(V, j, Y) {
      for (let ie = j; ie < Y; ++ie)
        if (V.charAt(ie) === `
`)
          return true;
      return false;
    }
    function N(V, j, Y) {
      let ie = Y(j) - 1;
      ie = l(V, ie, { backwards: true }), ie = c2(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
      let ee = c2(V, ie, { backwards: true });
      return ie !== ee;
    }
    function x2(V, j) {
      let Y = null, ie = j;
      for (; ie !== Y; )
        Y = ie, ie = p2(V, ie), ie = y(V, ie), ie = l(V, ie);
      return ie = g(V, ie), ie = c2(V, ie), ie !== false && w(V, ie);
    }
    function I(V, j, Y) {
      return x2(V, Y(j));
    }
    function P(V, j, Y) {
      return f(V, Y(j));
    }
    function $2(V, j, Y) {
      return V.charAt(P(V, j, Y));
    }
    function D(V, j) {
      let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return l(V, Y.backwards ? j - 1 : j, Y) !== j;
    }
    function T(V, j) {
      let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
      for (let ee = Y; ee < V.length; ++ee)
        V[ee] === "	" ? ie = ie + j - ie % j : ie++;
      return ie;
    }
    function m2(V, j) {
      let Y = V.lastIndexOf(`
`);
      return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
    }
    function C(V, j) {
      let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
      if (V.includes(ee.quote) || V.includes(ce.quote)) {
        let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
        W = K > de ? ce : ee;
      }
      return W;
    }
    function o(V, j) {
      let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
      return h2(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
    }
    function h2(V, j, Y) {
      let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
      return j + ce + j;
    }
    function v(V) {
      return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    }
    function S(V, j) {
      let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
      return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
    }
    function b(V, j) {
      let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
      if (Y === null)
        return 0;
      let ie = /* @__PURE__ */ new Map(), ee = 0;
      for (let ce of Y) {
        let W = ce.length / j.length;
        ie.set(W, true), W > ee && (ee = W);
      }
      for (let ce = 1; ce < ee; ce++)
        if (!ie.get(ce))
          return ce;
      return ee + 1;
    }
    function B(V, j) {
      (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
    }
    function k(V, j) {
      j.leading = true, j.trailing = false, B(V, j);
    }
    function M(V, j, Y) {
      j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
    }
    function R(V, j) {
      j.leading = false, j.trailing = true, B(V, j);
    }
    function q2(V, j) {
      let { languages: Y } = a2({ plugins: j.plugins }), ie = Y.find((ee) => {
        let { name: ce } = ee;
        return ce.toLowerCase() === V;
      }) || Y.find((ee) => {
        let { aliases: ce } = ee;
        return Array.isArray(ce) && ce.includes(V);
      }) || Y.find((ee) => {
        let { extensions: ce } = ee;
        return Array.isArray(ce) && ce.includes(`.${V}`);
      });
      return ie && ie.parsers[0];
    }
    function J(V) {
      return V && V.type === "front-matter";
    }
    function L(V) {
      let j = /* @__PURE__ */ new WeakMap();
      return function(Y) {
        return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
      };
    }
    function Q(V) {
      let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
      return Y.length > 20 && (Y = Y.slice(0, 19) + "â¦"), j + (Y ? " " + Y : "");
    }
    r.exports = { inferParserByLanguage: q2, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: E, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $2, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p2, skipEverythingButNewLine: d, skipInlineComment: y, skipTrailingComment: g, skipNewline: c2, isNextLineEmptyAfterIndex: x2, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: F, hasSpaces: D, getAlignmentSize: T, getIndentSize: m2, getPreferredQuote: C, printString: o, printNumber: v, makeString: h2, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
  } }), La = {};
  zt(La, { basename: () => Ra, default: () => Va, delimiter: () => On, dirname: () => Ma, extname: () => $a, isAbsolute: () => Xn, join: () => ja, normalize: () => zn, relative: () => qa, resolve: () => Br, sep: () => Ln });
  function Oa(e, r) {
    for (var t = 0, s2 = e.length - 1; s2 >= 0; s2--) {
      var a2 = e[s2];
      a2 === "." ? e.splice(s2, 1) : a2 === ".." ? (e.splice(s2, 1), t++) : t && (e.splice(s2, 1), t--);
    }
    if (r)
      for (; t--; t)
        e.unshift("..");
    return e;
  }
  function Br() {
    for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
      var s2 = t >= 0 ? arguments[t] : "/";
      if (typeof s2 != "string")
        throw new TypeError("Arguments to path.resolve must be strings");
      if (!s2)
        continue;
      e = s2 + "/" + e, r = s2.charAt(0) === "/";
    }
    return e = Oa(Kn(e.split("/"), function(a2) {
      return !!a2;
    }), !r).join("/"), (r ? "/" : "") + e || ".";
  }
  function zn(e) {
    var r = Xn(e), t = Wa(e, -1) === "/";
    return e = Oa(Kn(e.split("/"), function(s2) {
      return !!s2;
    }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
  }
  function Xn(e) {
    return e.charAt(0) === "/";
  }
  function ja() {
    var e = Array.prototype.slice.call(arguments, 0);
    return zn(Kn(e, function(r, t) {
      if (typeof r != "string")
        throw new TypeError("Arguments to path.join must be strings");
      return r;
    }).join("/"));
  }
  function qa(e, r) {
    e = Br(e).substr(1), r = Br(r).substr(1);
    function t(p2) {
      for (var d = 0; d < p2.length && p2[d] === ""; d++)
        ;
      for (var y = p2.length - 1; y >= 0 && p2[y] === ""; y--)
        ;
      return d > y ? [] : p2.slice(d, y - d + 1);
    }
    for (var s2 = t(e.split("/")), a2 = t(r.split("/")), n = Math.min(s2.length, a2.length), u = n, i = 0; i < n; i++)
      if (s2[i] !== a2[i]) {
        u = i;
        break;
      }
    for (var l = [], i = u; i < s2.length; i++)
      l.push("..");
    return l = l.concat(a2.slice(u)), l.join("/");
  }
  function Ma(e) {
    var r = _r(e), t = r[0], s2 = r[1];
    return !t && !s2 ? "." : (s2 && (s2 = s2.substr(0, s2.length - 1)), t + s2);
  }
  function Ra(e, r) {
    var t = _r(e)[2];
    return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
  }
  function $a(e) {
    return _r(e)[3];
  }
  function Kn(e, r) {
    if (e.filter)
      return e.filter(r);
    for (var t = [], s2 = 0; s2 < e.length; s2++)
      r(e[s2], s2, e) && t.push(e[s2]);
    return t;
  }
  var Ea, _r, Ln, On, Va, Wa, WD = ht({ "node-modules-polyfills:path"() {
    ne(), Ea = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, _r = function(e) {
      return Ea.exec(e).slice(1);
    }, Ln = "/", On = ":", Va = { extname: $a, basename: Ra, dirname: Ma, sep: Ln, delimiter: On, relative: qa, join: ja, isAbsolute: Xn, normalize: zn, resolve: Br }, Wa = "ab".substr(-1) === "b" ? function(e, r, t) {
      return e.substr(r, t);
    } : function(e, r, t) {
      return r < 0 && (r = e.length + r), e.substr(r, t);
    };
  } }), HD = te({ "node-modules-polyfills-commonjs:path"(e, r) {
    ne();
    var t = (WD(), ft(La));
    if (t && t.default) {
      r.exports = t.default;
      for (let s2 in t)
        r.exports[s2] = t[s2];
    } else
      t && (r.exports = t);
  } }), Kt = te({ "src/common/errors.js"(e, r) {
    ne();
    var t = class extends Error {
    }, s2 = class extends Error {
    }, a2 = class extends Error {
    }, n = class extends Error {
    };
    r.exports = { ConfigError: t, DebugError: s2, UndefinedParserError: a2, ArgExpansionBailout: n };
  } }), vt = {};
  zt(vt, { __assign: () => Tr, __asyncDelegator: () => nm, __asyncGenerator: () => rm, __asyncValues: () => um, __await: () => Jt, __awaiter: () => KD, __classPrivateFieldGet: () => om, __classPrivateFieldSet: () => lm, __createBinding: () => QD, __decorate: () => JD, __exportStar: () => ZD, __extends: () => GD, __generator: () => YD, __importDefault: () => am, __importStar: () => im, __makeTemplateObject: () => sm, __metadata: () => XD, __param: () => zD, __read: () => Ha, __rest: () => UD, __spread: () => em$1, __spreadArrays: () => tm, __values: () => jn });
  function GD(e, r) {
    br$2(e, r);
    function t() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
  }
  function UD(e, r) {
    var t = {};
    for (var s2 in e)
      Object.prototype.hasOwnProperty.call(e, s2) && r.indexOf(s2) < 0 && (t[s2] = e[s2]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var a2 = 0, s2 = Object.getOwnPropertySymbols(e); a2 < s2.length; a2++)
        r.indexOf(s2[a2]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s2[a2]) && (t[s2[a2]] = e[s2[a2]]);
    return t;
  }
  function JD(e, r, t, s2) {
    var a2 = arguments.length, n = a2 < 3 ? r : s2 === null ? s2 = Object.getOwnPropertyDescriptor(r, t) : s2, u;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      n = Reflect.decorate(e, r, t, s2);
    else
      for (var i = e.length - 1; i >= 0; i--)
        (u = e[i]) && (n = (a2 < 3 ? u(n) : a2 > 3 ? u(r, t, n) : u(r, t)) || n);
    return a2 > 3 && n && Object.defineProperty(r, t, n), n;
  }
  function zD(e, r) {
    return function(t, s2) {
      r(t, s2, e);
    };
  }
  function XD(e, r) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(e, r);
  }
  function KD(e, r, t, s2) {
    function a2(n) {
      return n instanceof t ? n : new t(function(u) {
        u(n);
      });
    }
    return new (t || (t = Promise))(function(n, u) {
      function i(d) {
        try {
          p2(s2.next(d));
        } catch (y) {
          u(y);
        }
      }
      function l(d) {
        try {
          p2(s2.throw(d));
        } catch (y) {
          u(y);
        }
      }
      function p2(d) {
        d.done ? n(d.value) : a2(d.value).then(i, l);
      }
      p2((s2 = s2.apply(e, r || [])).next());
    });
  }
  function YD(e, r) {
    var t = { label: 0, sent: function() {
      if (n[0] & 1)
        throw n[1];
      return n[1];
    }, trys: [], ops: [] }, s2, a2, n, u;
    return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
      return this;
    }), u;
    function i(p2) {
      return function(d) {
        return l([p2, d]);
      };
    }
    function l(p2) {
      if (s2)
        throw new TypeError("Generator is already executing.");
      for (; t; )
        try {
          if (s2 = 1, a2 && (n = p2[0] & 2 ? a2.return : p2[0] ? a2.throw || ((n = a2.return) && n.call(a2), 0) : a2.next) && !(n = n.call(a2, p2[1])).done)
            return n;
          switch (a2 = 0, n && (p2 = [p2[0] & 2, n.value]), p2[0]) {
            case 0:
            case 1:
              n = p2;
              break;
            case 4:
              return t.label++, { value: p2[1], done: false };
            case 5:
              t.label++, a2 = p2[1], p2 = [0];
              continue;
            case 7:
              p2 = t.ops.pop(), t.trys.pop();
              continue;
            default:
              if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p2[0] === 6 || p2[0] === 2)) {
                t = 0;
                continue;
              }
              if (p2[0] === 3 && (!n || p2[1] > n[0] && p2[1] < n[3])) {
                t.label = p2[1];
                break;
              }
              if (p2[0] === 6 && t.label < n[1]) {
                t.label = n[1], n = p2;
                break;
              }
              if (n && t.label < n[2]) {
                t.label = n[2], t.ops.push(p2);
                break;
              }
              n[2] && t.ops.pop(), t.trys.pop();
              continue;
          }
          p2 = r.call(e, t);
        } catch (d) {
          p2 = [6, d], a2 = 0;
        } finally {
          s2 = n = 0;
        }
      if (p2[0] & 5)
        throw p2[1];
      return { value: p2[0] ? p2[1] : void 0, done: true };
    }
  }
  function QD(e, r, t, s2) {
    s2 === void 0 && (s2 = t), e[s2] = r[t];
  }
  function ZD(e, r) {
    for (var t in e)
      t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
  }
  function jn(e) {
    var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s2 = 0;
    if (t)
      return t.call(e);
    if (e && typeof e.length == "number")
      return { next: function() {
        return e && s2 >= e.length && (e = void 0), { value: e && e[s2++], done: !e };
      } };
    throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function Ha(e, r) {
    var t = typeof Symbol == "function" && e[Symbol.iterator];
    if (!t)
      return e;
    var s2 = t.call(e), a2, n = [], u;
    try {
      for (; (r === void 0 || r-- > 0) && !(a2 = s2.next()).done; )
        n.push(a2.value);
    } catch (i) {
      u = { error: i };
    } finally {
      try {
        a2 && !a2.done && (t = s2.return) && t.call(s2);
      } finally {
        if (u)
          throw u.error;
      }
    }
    return n;
  }
  function em$1() {
    for (var e = [], r = 0; r < arguments.length; r++)
      e = e.concat(Ha(arguments[r]));
    return e;
  }
  function tm() {
    for (var e = 0, r = 0, t = arguments.length; r < t; r++)
      e += arguments[r].length;
    for (var s2 = Array(e), a2 = 0, r = 0; r < t; r++)
      for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a2++)
        s2[a2] = n[u];
    return s2;
  }
  function Jt(e) {
    return this instanceof Jt ? (this.v = e, this) : new Jt(e);
  }
  function rm(e, r, t) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var s2 = t.apply(e, r || []), a2, n = [];
    return a2 = {}, u("next"), u("throw"), u("return"), a2[Symbol.asyncIterator] = function() {
      return this;
    }, a2;
    function u(g) {
      s2[g] && (a2[g] = function(c2) {
        return new Promise(function(f, E) {
          n.push([g, c2, f, E]) > 1 || i(g, c2);
        });
      });
    }
    function i(g, c2) {
      try {
        l(s2[g](c2));
      } catch (f) {
        y(n[0][3], f);
      }
    }
    function l(g) {
      g.value instanceof Jt ? Promise.resolve(g.value.v).then(p2, d) : y(n[0][2], g);
    }
    function p2(g) {
      i("next", g);
    }
    function d(g) {
      i("throw", g);
    }
    function y(g, c2) {
      g(c2), n.shift(), n.length && i(n[0][0], n[0][1]);
    }
  }
  function nm(e) {
    var r, t;
    return r = {}, s2("next"), s2("throw", function(a2) {
      throw a2;
    }), s2("return"), r[Symbol.iterator] = function() {
      return this;
    }, r;
    function s2(a2, n) {
      r[a2] = e[a2] ? function(u) {
        return (t = !t) ? { value: Jt(e[a2](u)), done: a2 === "return" } : n ? n(u) : u;
      } : n;
    }
  }
  function um(e) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = e[Symbol.asyncIterator], t;
    return r ? r.call(e) : (e = typeof jn == "function" ? jn(e) : e[Symbol.iterator](), t = {}, s2("next"), s2("throw"), s2("return"), t[Symbol.asyncIterator] = function() {
      return this;
    }, t);
    function s2(n) {
      t[n] = e[n] && function(u) {
        return new Promise(function(i, l) {
          u = e[n](u), a2(i, l, u.done, u.value);
        });
      };
    }
    function a2(n, u, i, l) {
      Promise.resolve(l).then(function(p2) {
        n({ value: p2, done: i });
      }, u);
    }
  }
  function sm(e, r) {
    return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
  }
  function im(e) {
    if (e && e.__esModule)
      return e;
    var r = {};
    if (e != null)
      for (var t in e)
        Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
    return r.default = e, r;
  }
  function am(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function om(e, r) {
    if (!r.has(e))
      throw new TypeError("attempted to get private field on non-instance");
    return r.get(e);
  }
  function lm(e, r, t) {
    if (!r.has(e))
      throw new TypeError("attempted to set private field on non-instance");
    return r.set(e, t), t;
  }
  var br$2, Tr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
    ne(), br$2 = function(e, r) {
      return br$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s2) {
        t.__proto__ = s2;
      } || function(t, s2) {
        for (var a2 in s2)
          s2.hasOwnProperty(a2) && (t[a2] = s2[a2]);
      }, br$2(e, r);
    }, Tr = function() {
      return Tr = Object.assign || function(r) {
        for (var t, s2 = 1, a2 = arguments.length; s2 < a2; s2++) {
          t = arguments[s2];
          for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
        }
        return r;
      }, Tr.apply(this, arguments);
    };
  } }), Ga = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
      if (r === null || typeof r != "object")
        return JSON.stringify(r);
      if (Array.isArray(r))
        return `[${r.map((s2) => e.apiDescriptor.value(s2)).join(", ")}]`;
      let t = Object.keys(r);
      return t.length === 0 ? "{}" : `{ ${t.map((s2) => `${e.apiDescriptor.key(s2)}: ${e.apiDescriptor.value(r[s2])}`).join(", ")} }`;
    }, pair: (r) => {
      let { key: t, value: s2 } = r;
      return e.apiDescriptor.value({ [t]: s2 });
    } };
  } }), cm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(Ga(), e);
  } }), Pr = te({ "scripts/build/shims/chalk.cjs"(e, r) {
    ne();
    var t = (s2) => s2;
    t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
  } }), Ua = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Pr();
    e.commonDeprecatedHandler = (t, s2, a2) => {
      let { descriptor: n } = a2, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
      return s2 && u.push(`we now treat it as ${r.default.blue(typeof s2 == "string" ? n.key(s2) : n.pair(s2))}`), u.join("; ") + ".";
    };
  } }), pm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(Ua(), e);
  } }), fm = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Pr();
    e.commonInvalidHandler = (t, s2, a2) => [`Invalid ${r.default.red(a2.descriptor.key(t))} value.`, `Expected ${r.default.blue(a2.schemas[t].expected(a2))},`, `but received ${r.default.red(a2.descriptor.value(s2))}.`].join(" ");
  } }), Ja = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(fm(), e);
  } }), Dm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
    ne();
    var t = [], s2 = [];
    r.exports = function(a2, n) {
      if (a2 === n)
        return 0;
      var u = a2;
      a2.length > n.length && (a2 = n, n = u);
      var i = a2.length, l = n.length;
      if (i === 0)
        return l;
      if (l === 0)
        return i;
      for (; i > 0 && a2.charCodeAt(~-i) === n.charCodeAt(~-l); )
        i--, l--;
      if (i === 0)
        return l;
      for (var p2 = 0; p2 < i && a2.charCodeAt(p2) === n.charCodeAt(p2); )
        p2++;
      if (i -= p2, l -= p2, i === 0)
        return l;
      for (var d, y, g, c2, f = 0, E = 0; f < i; )
        s2[p2 + f] = a2.charCodeAt(p2 + f), t[f] = ++f;
      for (; E < l; )
        for (d = n.charCodeAt(p2 + E), g = E++, y = E, f = 0; f < i; f++)
          c2 = d === s2[p2 + f] ? g : g + 1, g = t[f], y = t[f] = g > y ? c2 > y ? y + 1 : c2 : c2 > g ? g + 1 : c2;
      return y;
    };
  } }), za = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Pr(), t = Dm();
    e.levenUnknownHandler = (s2, a2, n) => {
      let { descriptor: u, logger: i, schemas: l } = n, p2 = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s2, value: a2 }))}.`], d = Object.keys(l).sort().find((y) => t(s2, y) < 3);
      d && p2.push(`Did you mean ${r.default.blue(u.key(d))}?`), i.warn(p2.join(" "));
    };
  } }), mm = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(za(), e);
  } }), dm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(pm(), e), r.__exportStar(Ja(), e), r.__exportStar(mm(), e);
  } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
    function t(n, u) {
      let i = new n(u), l = Object.create(i);
      for (let p2 of r)
        p2 in u && (l[p2] = a2(u[p2], i, s2.prototype[p2].length));
      return l;
    }
    e.createSchema = t;
    var s2 = class {
      constructor(n) {
        this.name = n.name;
      }
      static create(n) {
        return t(this, n);
      }
      default(n) {
      }
      expected(n) {
        return "nothing";
      }
      validate(n, u) {
        return false;
      }
      deprecated(n, u) {
        return false;
      }
      forward(n, u) {
      }
      redirect(n, u) {
      }
      overlap(n, u, i) {
        return n;
      }
      preprocess(n, u) {
        return n;
      }
      postprocess(n, u) {
        return n;
      }
    };
    e.Schema = s2;
    function a2(n, u, i) {
      return typeof n == "function" ? function() {
        for (var l = arguments.length, p2 = new Array(l), d = 0; d < l; d++)
          p2[d] = arguments[d];
        return n(...p2.slice(0, i - 1), u, ...p2.slice(i - 1));
      } : () => n;
    }
  } }), gm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = class extends r.Schema {
      constructor(s2) {
        super(s2), this._sourceName = s2.sourceName;
      }
      expected(s2) {
        return s2.schemas[this._sourceName].expected(s2);
      }
      validate(s2, a2) {
        return a2.schemas[this._sourceName].validate(s2, a2);
      }
      redirect(s2, a2) {
        return this._sourceName;
      }
    };
    e.AliasSchema = t;
  } }), ym = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = class extends r.Schema {
      expected() {
        return "anything";
      }
      validate() {
        return true;
      }
    };
    e.AnySchema = t;
  } }), hm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt)), t = Ft(), s2 = class extends t.Schema {
      constructor(n) {
        var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
        super(Object.assign({}, l, { name: i })), this._valueSchema = u;
      }
      expected(n) {
        return `an array of ${this._valueSchema.expected(n)}`;
      }
      validate(n, u) {
        if (!Array.isArray(n))
          return false;
        let i = [];
        for (let l of n) {
          let p2 = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
          p2 !== true && i.push(p2.value);
        }
        return i.length === 0 ? true : { value: i };
      }
      deprecated(n, u) {
        let i = [];
        for (let l of n) {
          let p2 = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
          p2 !== false && i.push(...p2.map((d) => {
            let { value: y } = d;
            return { value: [y] };
          }));
        }
        return i;
      }
      forward(n, u) {
        let i = [];
        for (let l of n) {
          let p2 = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
          i.push(...p2.map(a2));
        }
        return i;
      }
      redirect(n, u) {
        let i = [], l = [];
        for (let p2 of n) {
          let d = u.normalizeRedirectResult(this._valueSchema.redirect(p2, u), p2);
          "remain" in d && i.push(d.remain), l.push(...d.redirect.map(a2));
        }
        return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
      }
      overlap(n, u) {
        return n.concat(u);
      }
    };
    e.ArraySchema = s2;
    function a2(n) {
      let { from: u, to: i } = n;
      return { from: [u], to: i };
    }
  } }), vm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = class extends r.Schema {
      expected() {
        return "true or false";
      }
      validate(s2) {
        return typeof s2 == "boolean";
      }
    };
    e.BooleanSchema = t;
  } }), Yn = te({ "node_modules/vnopts/lib/utils.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    function r(c2, f) {
      let E = /* @__PURE__ */ Object.create(null);
      for (let _ of c2) {
        let w = _[f];
        if (E[w])
          throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
        E[w] = _;
      }
      return E;
    }
    e.recordFromArray = r;
    function t(c2, f) {
      let E = /* @__PURE__ */ new Map();
      for (let _ of c2) {
        let w = _[f];
        if (E.has(w))
          throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
        E.set(w, _);
      }
      return E;
    }
    e.mapFromArray = t;
    function s2() {
      let c2 = /* @__PURE__ */ Object.create(null);
      return (f) => {
        let E = JSON.stringify(f);
        return c2[E] ? true : (c2[E] = true, false);
      };
    }
    e.createAutoChecklist = s2;
    function a2(c2, f) {
      let E = [], _ = [];
      for (let w of c2)
        f(w) ? E.push(w) : _.push(w);
      return [E, _];
    }
    e.partition = a2;
    function n(c2) {
      return c2 === Math.floor(c2);
    }
    e.isInt = n;
    function u(c2, f) {
      if (c2 === f)
        return 0;
      let E = typeof c2, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
      return E !== _ ? w.indexOf(E) - w.indexOf(_) : E !== "string" ? Number(c2) - Number(f) : c2.localeCompare(f);
    }
    e.comparePrimitive = u;
    function i(c2) {
      return c2 === void 0 ? {} : c2;
    }
    e.normalizeDefaultResult = i;
    function l(c2, f) {
      return c2 === true ? true : c2 === false ? { value: f } : c2;
    }
    e.normalizeValidateResult = l;
    function p2(c2, f) {
      let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return c2 === false ? false : c2 === true ? E ? true : [{ value: f }] : "value" in c2 ? [c2] : c2.length === 0 ? false : c2;
    }
    e.normalizeDeprecatedResult = p2;
    function d(c2, f) {
      return typeof c2 == "string" || "key" in c2 ? { from: f, to: c2 } : "from" in c2 ? { from: c2.from, to: c2.to } : { from: f, to: c2.to };
    }
    e.normalizeTransferResult = d;
    function y(c2, f) {
      return c2 === void 0 ? [] : Array.isArray(c2) ? c2.map((E) => d(E, f)) : [d(c2, f)];
    }
    e.normalizeForwardResult = y;
    function g(c2, f) {
      let E = y(typeof c2 == "object" && "redirect" in c2 ? c2.redirect : c2, f);
      return E.length === 0 ? { remain: f, redirect: E } : typeof c2 == "object" && "remain" in c2 ? { remain: c2.remain, redirect: E } : { redirect: E };
    }
    e.normalizeRedirectResult = g;
  } }), Cm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = Yn(), s2 = class extends r.Schema {
      constructor(a2) {
        super(a2), this._choices = t.mapFromArray(a2.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
      }
      expected(a2) {
        let { descriptor: n } = a2, u = Array.from(this._choices.keys()).map((p2) => this._choices.get(p2)).filter((p2) => !p2.deprecated).map((p2) => p2.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
        return i.concat(l.join(" or ")).join(", ");
      }
      validate(a2) {
        return this._choices.has(a2);
      }
      deprecated(a2) {
        let n = this._choices.get(a2);
        return n && n.deprecated ? { value: a2 } : false;
      }
      forward(a2) {
        let n = this._choices.get(a2);
        return n ? n.forward : void 0;
      }
      redirect(a2) {
        let n = this._choices.get(a2);
        return n ? n.redirect : void 0;
      }
    };
    e.ChoiceSchema = s2;
  } }), Xa = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = class extends r.Schema {
      expected() {
        return "a number";
      }
      validate(s2, a2) {
        return typeof s2 == "number";
      }
    };
    e.NumberSchema = t;
  } }), Em = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Yn(), t = Xa(), s2 = class extends t.NumberSchema {
      expected() {
        return "an integer";
      }
      validate(a2, n) {
        return n.normalizeValidateResult(super.validate(a2, n), a2) === true && r.isInt(a2);
      }
    };
    e.IntegerSchema = s2;
  } }), Fm = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ft(), t = class extends r.Schema {
      expected() {
        return "a string";
      }
      validate(s2) {
        return typeof s2 == "string";
      }
    };
    e.StringSchema = t;
  } }), Am = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(gm(), e), r.__exportStar(ym(), e), r.__exportStar(hm(), e), r.__exportStar(vm(), e), r.__exportStar(Cm(), e), r.__exportStar(Em(), e), r.__exportStar(Xa(), e), r.__exportStar(Fm(), e);
  } }), Sm = te({ "node_modules/vnopts/lib/defaults.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Ga(), t = Ua(), s2 = Ja(), a2 = za();
    e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a2.levenUnknownHandler, e.defaultInvalidHandler = s2.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
  } }), xm = te({ "node_modules/vnopts/lib/normalize.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = Sm(), t = Yn();
    e.normalize = (a2, n, u) => new s2(n, u).normalize(a2);
    var s2 = class {
      constructor(a2, n) {
        let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p2 = r.defaultInvalidHandler, deprecated: d = r.defaultDeprecatedHandler } = n || {};
        this._utils = { descriptor: i, logger: u || { warn: () => {
        } }, schemas: t.recordFromArray(a2, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p2, this._deprecatedHandler = d, this.cleanHistory();
      }
      cleanHistory() {
        this._hasDeprecationWarned = t.createAutoChecklist();
      }
      normalize(a2) {
        let n = {}, u = [a2], i = () => {
          for (; u.length !== 0; ) {
            let l = u.shift(), p2 = this._applyNormalization(l, n);
            u.push(...p2);
          }
        };
        i();
        for (let l of Object.keys(this._utils.schemas)) {
          let p2 = this._utils.schemas[l];
          if (!(l in n)) {
            let d = t.normalizeDefaultResult(p2.default(this._utils));
            "value" in d && u.push({ [l]: d.value });
          }
        }
        i();
        for (let l of Object.keys(this._utils.schemas)) {
          let p2 = this._utils.schemas[l];
          l in n && (n[l] = p2.postprocess(n[l], this._utils));
        }
        return n;
      }
      _applyNormalization(a2, n) {
        let u = [], [i, l] = t.partition(Object.keys(a2), (p2) => p2 in this._utils.schemas);
        for (let p2 of i) {
          let d = this._utils.schemas[p2], y = d.preprocess(a2[p2], this._utils), g = t.normalizeValidateResult(d.validate(y, this._utils), y);
          if (g !== true) {
            let { value: w } = g, F = this._invalidHandler(p2, w, this._utils);
            throw typeof F == "string" ? new Error(F) : F;
          }
          let c2 = (w) => {
            let { from: F, to: N } = w;
            u.push(typeof N == "string" ? { [N]: F } : { [N.key]: N.value });
          }, f = (w) => {
            let { value: F, redirectTo: N } = w, x2 = t.normalizeDeprecatedResult(d.deprecated(F, this._utils), y, true);
            if (x2 !== false)
              if (x2 === true)
                this._hasDeprecationWarned(p2) || this._utils.logger.warn(this._deprecatedHandler(p2, N, this._utils));
              else
                for (let { value: I } of x2) {
                  let P = { key: p2, value: I };
                  if (!this._hasDeprecationWarned(P)) {
                    let $2 = typeof N == "string" ? { key: N, value: I } : N;
                    this._utils.logger.warn(this._deprecatedHandler(P, $2, this._utils));
                  }
                }
          };
          t.normalizeForwardResult(d.forward(y, this._utils), y).forEach(c2);
          let _ = t.normalizeRedirectResult(d.redirect(y, this._utils), y);
          if (_.redirect.forEach(c2), "remain" in _) {
            let w = _.remain;
            n[p2] = p2 in n ? d.overlap(n[p2], w, this._utils) : w, f({ value: w });
          }
          for (let { from: w, to: F } of _.redirect)
            f({ value: w, redirectTo: F });
        }
        for (let p2 of l) {
          let d = a2[p2], y = this._unknownHandler(p2, d, this._utils);
          if (y)
            for (let g of Object.keys(y)) {
              let c2 = { [g]: y[g] };
              g in this._utils.schemas ? u.push(c2) : Object.assign(n, c2);
            }
        }
        return u;
      }
    };
    e.Normalizer = s2;
  } }), bm = te({ "node_modules/vnopts/lib/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = (Et(), ft(vt));
    r.__exportStar(cm(), e), r.__exportStar(dm(), e), r.__exportStar(Am(), e), r.__exportStar(xm(), e), r.__exportStar(Ft(), e);
  } }), Tm = te({ "src/main/options-normalizer.js"(e, r) {
    ne();
    var t = bm(), s2 = lt(), a2 = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
      let { key: c2, value: f } = g;
      return f === false ? `--no-${c2}` : f === true ? a2.key(c2) : f === "" ? `${a2.key(c2)} without an argument` : `${a2.key(c2)}=${f}`;
    } }, n = (g) => {
      let { colorsModule: c2, levenshteinDistance: f } = g;
      return class extends t.ChoiceSchema {
        constructor(_) {
          let { name: w, flags: F } = _;
          super({ name: w, choices: F }), this._flags = [...F].sort();
        }
        preprocess(_, w) {
          if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
            let F = this._flags.find((N) => f(N, _) < 3);
            if (F)
              return w.logger.warn([`Unknown flag ${c2.yellow(w.descriptor.value(_))},`, `did you mean ${c2.blue(w.descriptor.value(F))}?`].join(" ")), F;
          }
          return _;
        }
        expected() {
          return "a flag";
        }
      };
    }, u;
    function i(g, c2) {
      let { logger: f = false, isCLI: E = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m2) => _.includes(T) ? { [T]: m2 } : void 0 : (T, m2) => ({ [T]: m2 }) : (T, m2, C) => {
        let o = C.schemas, v = $n(o, cD);
        return t.levenUnknownHandler(T, m2, Object.assign(Object.assign({}, C), {}, { schemas: v }));
      }, x2 = E ? a2 : t.apiDescriptor, I = l(c2, { isCLI: E, colorsModule: w, levenshteinDistance: F }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x2 }), $2 = f !== false;
      $2 && u && (P._hasDeprecationWarned = u);
      let D = P.normalize(g);
      return $2 && (u = P._hasDeprecationWarned), E && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
    }
    function l(g, c2) {
      let { isCLI: f, colorsModule: E, levenshteinDistance: _ } = c2, w = [];
      f && w.push(t.AnySchema.create({ name: "_" }));
      for (let F of g)
        w.push(p2(F, { isCLI: f, optionInfos: g, colorsModule: E, levenshteinDistance: _ })), F.alias && f && w.push(t.AliasSchema.create({ name: F.alias, sourceName: F.name }));
      return w;
    }
    function p2(g, c2) {
      let { isCLI: f, optionInfos: E, colorsModule: _, levenshteinDistance: w } = c2, { name: F } = g;
      if (F === "plugin-search-dir" || F === "pluginSearchDirs")
        return t.AnySchema.create({ name: F, preprocess(P) {
          return P === false || (P = Array.isArray(P) ? P : [P]), P;
        }, validate(P) {
          return P === false ? true : P.every(($2) => typeof $2 == "string");
        }, expected() {
          return "false or paths to plugin search dir";
        } });
      let N = { name: F }, x2, I = {};
      switch (g.type) {
        case "int":
          x2 = t.IntegerSchema, f && (N.preprocess = Number);
          break;
        case "string":
          x2 = t.StringSchema;
          break;
        case "choice":
          x2 = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
          break;
        case "boolean":
          x2 = t.BooleanSchema;
          break;
        case "flag":
          x2 = n({ colorsModule: _, levenshteinDistance: w }), N.flags = E.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
          break;
        case "path":
          x2 = t.StringSchema;
          break;
        default:
          throw new Error(`Unexpected type ${g.type}`);
      }
      if (g.exception ? N.validate = (P, $2, D) => g.exception(P) || $2.validate(P, D) : N.validate = (P, $2, D) => P === void 0 || $2.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
        let P = N.preprocess || (($2) => $2);
        N.preprocess = ($2, D, T) => D.preprocess(P(Array.isArray($2) ? s2($2) : $2), T);
      }
      return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x2.create(N) })) : x2.create(Object.assign(Object.assign({}, N), I));
    }
    function d(g, c2, f) {
      return i(g, c2, f);
    }
    function y(g, c2, f) {
      return i(g, c2, Object.assign({ isCLI: true }, f));
    }
    r.exports = { normalizeApiOptions: d, normalizeCliOptions: y };
  } }), ut = te({ "src/language-js/loc.js"(e, r) {
    ne();
    var t = Jn();
    function s2(l) {
      var p2, d;
      let y = l.range ? l.range[0] : l.start, g = (p2 = (d = l.declaration) === null || d === void 0 ? void 0 : d.decorators) !== null && p2 !== void 0 ? p2 : l.decorators;
      return t(g) ? Math.min(s2(g[0]), y) : y;
    }
    function a2(l) {
      return l.range ? l.range[1] : l.end;
    }
    function n(l, p2) {
      let d = s2(l);
      return Number.isInteger(d) && d === s2(p2);
    }
    function u(l, p2) {
      let d = a2(l);
      return Number.isInteger(d) && d === a2(p2);
    }
    function i(l, p2) {
      return n(l, p2) && u(l, p2);
    }
    r.exports = { locStart: s2, locEnd: a2, hasSameLocStart: n, hasSameLoc: i };
  } }), Bm = te({ "src/main/load-parser.js"(e, r) {
    ne(), r.exports = () => {
    };
  } }), Nm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
    ne();
    var t = Pr(), s2 = { shouldHighlight: () => false, getChalk: () => t };
    r.exports = s2;
  } }), wm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
    var r = Nm(), t = false;
    function s2(l) {
      return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
    }
    var a2 = /\r\n|[\n\r\u2028\u2029]/;
    function n(l, p2, d) {
      let y = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, y, l.end), { linesAbove: c2 = 2, linesBelow: f = 3 } = d || {}, E = y.line, _ = y.column, w = g.line, F = g.column, N = Math.max(E - (c2 + 1), 0), x2 = Math.min(p2.length, w + f);
      E === -1 && (N = 0), w === -1 && (x2 = p2.length);
      let I = w - E, P = {};
      if (I)
        for (let $2 = 0; $2 <= I; $2++) {
          let D = $2 + E;
          if (!_)
            P[D] = true;
          else if ($2 === 0) {
            let T = p2[D - 1].length;
            P[D] = [_, T - _ + 1];
          } else if ($2 === I)
            P[D] = [0, F];
          else {
            let T = p2[D - $2].length;
            P[D] = [0, T];
          }
        }
      else
        _ === F ? _ ? P[E] = [_, 0] : P[E] = true : P[E] = [_, F - _];
      return { start: N, end: x2, markerLines: P };
    }
    function u(l, p2) {
      let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, y = (d.highlightCode || d.forceColor) && (0, r.shouldHighlight)(d), g = (0, r.getChalk)(d), c2 = s2(g), f = ($2, D) => y ? $2(D) : D, E = l.split(a2), { start: _, end: w, markerLines: F } = n(p2, E, d), N = p2.start && typeof p2.start.column == "number", x2 = String(w).length, P = (y ? (0, r.default)(l, d) : l).split(a2, w).slice(_, w).map(($2, D) => {
        let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x2)} |`, o = F[T], h2 = !F[T + 1];
        if (o) {
          let v = "";
          if (Array.isArray(o)) {
            let S = $2.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
            v = [`
 `, f(c2.gutter, C.replace(/\d/g, " ")), " ", S, f(c2.marker, "^").repeat(b)].join(""), h2 && d.message && (v += " " + f(c2.message, d.message));
          }
          return [f(c2.marker, ">"), f(c2.gutter, C), $2.length > 0 ? ` ${$2}` : "", v].join("");
        } else
          return ` ${f(c2.gutter, C)}${$2.length > 0 ? ` ${$2}` : ""}`;
      }).join(`
`);
      return d.message && !N && (P = `${" ".repeat(x2 + 1)}${d.message}
${P}`), y ? g.reset(P) : P;
    }
    function i(l, p2, d) {
      let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (!t) {
        t = true;
        let c2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (Nt.emitWarning)
          Nt.emitWarning(c2, "DeprecationWarning");
        else {
          let f = new Error(c2);
          f.name = "DeprecationWarning", console.warn(new Error(c2));
        }
      }
      return d = Math.max(d, 0), u(l, { start: { column: d, line: p2 } }, y);
    }
  } }), Qn = te({ "src/main/parser.js"(e, r) {
    ne();
    var { ConfigError: t } = Kt(), s2 = ut();
    Bm();
    var { locStart: n, locEnd: u } = s2, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
    function p2(g) {
      let c2 = {};
      for (let f of g.plugins)
        if (f.parsers)
          for (let E of i(f.parsers))
            Object.defineProperty(c2, E, l(f.parsers, E));
      return c2;
    }
    function d(g) {
      let c2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p2(g);
      if (typeof g.parser == "function")
        return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
      if (typeof g.parser == "string") {
        if (Object.prototype.hasOwnProperty.call(c2, g.parser))
          return c2[g.parser];
        throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
      }
    }
    function y(g, c2) {
      let f = p2(c2), E = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
        return f[w].parse;
      } }]))), _ = d(c2, f);
      try {
        return _.preprocess && (g = _.preprocess(g, c2)), { text: g, ast: _.parse(g, E, c2) };
      } catch (w) {
        let { loc: F } = w;
        if (F) {
          let { codeFrameColumns: N } = wm();
          throw w.codeFrame = N(g, F, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
        }
        throw w;
      }
    }
    r.exports = { parse: y, resolveParser: d };
  } }), Ka = te({ "src/main/options.js"(e, r) {
    ne();
    var t = HD(), { UndefinedParserError: s2 } = Kt(), { getSupportInfo: a2 } = Un(), n = Tm(), { resolveParser: u } = Qn(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
    function l(y) {
      let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c2 = Object.assign({}, y), f = a2({ plugins: y.plugins, showUnreleased: true, showDeprecated: true }).options, E = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x2) => x2.default !== void 0).map((x2) => [x2.name, x2.default])));
      if (!c2.parser) {
        if (!c2.filepath)
          (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c2.parser = "babel";
        else if (c2.parser = d(c2.filepath, c2.plugins), !c2.parser)
          throw new s2(`No parser could be inferred for file: ${c2.filepath}`);
      }
      let _ = u(n.normalizeApiOptions(c2, [f.find((x2) => x2.name === "parser")], { passThrough: true, logger: false }));
      c2.astFormat = _.astFormat, c2.locEnd = _.locEnd, c2.locStart = _.locStart;
      let w = p2(c2);
      c2.printer = w.printers[c2.astFormat];
      let F = Object.fromEntries(f.filter((x2) => x2.pluginDefaults && x2.pluginDefaults[w.name] !== void 0).map((x2) => [x2.name, x2.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, E), F);
      for (let [x2, I] of Object.entries(N))
        (c2[x2] === null || c2[x2] === void 0) && (c2[x2] = I);
      return c2.parser === "json" && (c2.trailingComma = "none"), n.normalizeApiOptions(c2, f, Object.assign({ passThrough: Object.keys(i) }, g));
    }
    function p2(y) {
      let { astFormat: g } = y;
      if (!g)
        throw new Error("getPlugin() requires astFormat to be set");
      let c2 = y.plugins.find((f) => f.printers && f.printers[g]);
      if (!c2)
        throw new Error(`Couldn't find plugin for AST format "${g}"`);
      return c2;
    }
    function d(y, g) {
      let c2 = t.basename(y).toLowerCase(), E = a2({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c2.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c2));
      return E && E.parsers[0];
    }
    r.exports = { normalize: l, hiddenDefaults: i, inferParser: d };
  } }), _m = te({ "src/main/massage-ast.js"(e, r) {
    ne();
    function t(s2, a2, n) {
      if (Array.isArray(s2))
        return s2.map((p2) => t(p2, a2, n)).filter(Boolean);
      if (!s2 || typeof s2 != "object")
        return s2;
      let u = a2.printer.massageAstNode, i;
      u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
      let l = {};
      for (let [p2, d] of Object.entries(s2))
        !i.has(p2) && typeof d != "function" && (l[p2] = t(d, a2, s2));
      if (u) {
        let p2 = u(s2, l, n);
        if (p2 === null)
          return;
        if (p2)
          return p2;
      }
      return l;
    }
    r.exports = t;
  } }), Yt = te({ "scripts/build/shims/assert.cjs"(e, r) {
    ne();
    var t = () => {
    };
    t.ok = t, t.strictEqual = t, r.exports = t;
  } }), et = te({ "src/main/comments.js"(e, r) {
    ne();
    var t = Yt(), { builders: { line: s2, hardline: a2, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p2 } } = qe(), { hasNewline: d, skipNewline: y, skipSpaces: g, isPreviousLineEmpty: c2, addLeadingComment: f, addDanglingComment: E, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
    function F(k, M, R) {
      if (!k)
        return;
      let { printer: q2, locStart: J, locEnd: L } = M;
      if (R) {
        if (q2.canAttachComment && q2.canAttachComment(k)) {
          let V;
          for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V)
            ;
          R.splice(V + 1, 0, k);
          return;
        }
      } else if (w.has(k))
        return w.get(k);
      let Q = q2.getCommentChildNodes && q2.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
        let [j] = V;
        return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
      }).map((V) => {
        let [, j] = V;
        return j;
      });
      if (Q) {
        R || (R = [], w.set(k, R));
        for (let V of Q)
          F(V, M, R);
        return R;
      }
    }
    function N(k, M, R, q2) {
      let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = F(k, R), Y, ie, ee = 0, ce = j.length;
      for (; ee < ce; ) {
        let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
        if (de <= Q && V <= ue)
          return N(K, M, R, K);
        if (ue <= Q) {
          Y = K, ee = W + 1;
          continue;
        }
        if (V <= de) {
          ie = K, ce = W;
          continue;
        }
        throw new Error("Comment location overlaps with node location");
      }
      if (q2 && q2.type === "TemplateLiteral") {
        let { quasis: W } = q2, K = C(W, M, R);
        Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
      }
      return { enclosingNode: q2, precedingNode: Y, followingNode: ie };
    }
    var x2 = () => false;
    function I(k, M, R, q2) {
      if (!Array.isArray(k))
        return;
      let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q2, { avoidAstMutation: j, ownLine: Y = x2, endOfLine: ie = x2, remaining: ee = x2 } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q2)), {}, { comment: W, text: R, options: q2, ast: M, isLastComment: k.length - 1 === K }));
      for (let [W, K] of ce.entries()) {
        let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
        if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
          if (L(de) - L(se) <= 0) {
            f(se, de);
            continue;
          }
          if (Q(de) - Q(se) >= 0) {
            _(se, de);
            continue;
          }
        }
        let ge;
        if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $2(U, Z, ce, W))
          de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : E(Fe || se, de));
        else if (D(U, Z, ce, W))
          de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : E(Fe || se, de));
        else if (de.placement = "remaining", !ee(...ge))
          if (ue && z) {
            let he = J.length;
            he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
          } else
            ue ? _(ue, de) : z ? f(z, de) : E(Fe || se, de);
      }
      if (T(J, R, q2), !j)
        for (let W of k)
          delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
    }
    var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
    function $2(k, M, R, q2) {
      let { comment: J, precedingNode: L } = R[q2], { locStart: Q, locEnd: V } = M, j = Q(J);
      if (L)
        for (let Y = q2 - 1; Y >= 0; Y--) {
          let { comment: ie, precedingNode: ee } = R[Y];
          if (ee !== L || !P(k.slice(V(ie), j)))
            break;
          j = Q(ie);
        }
      return d(k, j, { backwards: true });
    }
    function D(k, M, R, q2) {
      let { comment: J, followingNode: L } = R[q2], { locStart: Q, locEnd: V } = M, j = V(J);
      if (L)
        for (let Y = q2 + 1; Y < R.length; Y++) {
          let { comment: ie, followingNode: ee } = R[Y];
          if (ee !== L || !P(k.slice(j, Q(ie))))
            break;
          j = V(ie);
        }
      return d(k, j);
    }
    function T(k, M, R) {
      let q2 = k.length;
      if (q2 === 0)
        return;
      let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
      for (Y = q2; Y > 0; --Y) {
        let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
        t.strictEqual(ee, J), t.strictEqual(ce, L);
        let W = M.slice(R.locEnd(ie), j);
        if (V.test(W))
          j = R.locStart(ie);
        else
          break;
      }
      for (let [ie, { comment: ee }] of k.entries())
        ie < Y ? _(J, ee) : f(L, ee);
      for (let ie of [J, L])
        ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
      k.length = 0;
    }
    function m2(k, M) {
      let R = k.getValue();
      return R.printed = true, M.printer.printComment(k, M);
    }
    function C(k, M, R) {
      let q2 = R.locStart(M) - 1;
      for (let J = 1; J < k.length; ++J)
        if (q2 < R.locStart(k[J]))
          return J - 1;
      return 0;
    }
    function o(k, M) {
      let R = k.getValue(), q2 = [m2(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
      if (J.isBlockComment && J.isBlockComment(R)) {
        let ie = d(L, V(R)) ? d(L, Q(R), { backwards: true }) ? a2 : s2 : " ";
        q2.push(ie);
      } else
        q2.push(a2);
      let Y = y(L, g(L, V(R)));
      return Y !== false && d(L, Y) && q2.push(a2), q2;
    }
    function h2(k, M) {
      let R = k.getValue(), q2 = m2(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
      if (d(L, Q(R), { backwards: true })) {
        let Y = c2(L, R, Q);
        return i([a2, Y ? a2 : "", q2]);
      }
      let j = [" ", q2];
      return V || (j = [i(j), n]), j;
    }
    function v(k, M, R, q2) {
      let J = [], L = k.getValue();
      return !L || !L.comments || (k.each(() => {
        let Q = k.getValue();
        !Q.leading && !Q.trailing && (!q2 || q2(Q)) && J.push(m2(k, M));
      }, "comments"), J.length === 0) ? "" : R ? l(a2, J) : u([a2, l(a2, J)]);
    }
    function S(k, M, R) {
      let q2 = k.getValue();
      if (!q2)
        return {};
      let J = q2.comments || [];
      R && (J = J.filter((j) => !R.has(j)));
      let L = q2 === M.cursorNode;
      if (J.length === 0) {
        let j = L ? p2 : "";
        return { leading: j, trailing: j };
      }
      let Q = [], V = [];
      return k.each(() => {
        let j = k.getValue();
        if (R && R.has(j))
          return;
        let { leading: Y, trailing: ie } = j;
        Y ? Q.push(o(k, M)) : ie && V.push(h2(k, M));
      }, "comments"), L && (Q.unshift(p2), V.push(p2)), { leading: Q, trailing: V };
    }
    function b(k, M, R, q2) {
      let { leading: J, trailing: L } = S(k, R, q2);
      return !J && !L ? M : [J, M, L];
    }
    function B(k) {
      if (k)
        for (let M of k) {
          if (!M.printed)
            throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
          delete M.printed;
        }
    }
    r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: F, ensureAllCommentsPrinted: B };
  } }), Pm = te({ "src/common/ast-path.js"(e, r) {
    ne();
    var t = lt();
    function s2(u, i) {
      let l = a2(u.stack, i);
      return l === -1 ? null : u.stack[l];
    }
    function a2(u, i) {
      for (let l = u.length - 1; l >= 0; l -= 2) {
        let p2 = u[l];
        if (p2 && !Array.isArray(p2) && --i < 0)
          return l;
      }
      return -1;
    }
    var n = class {
      constructor(u) {
        this.stack = [u];
      }
      getName() {
        let { stack: u } = this, { length: i } = u;
        return i > 1 ? u[i - 2] : null;
      }
      getValue() {
        return t(this.stack);
      }
      getNode() {
        let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return s2(this, u);
      }
      getParentNode() {
        let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return s2(this, u + 1);
      }
      call(u) {
        let { stack: i } = this, { length: l } = i, p2 = t(i);
        for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), g = 1; g < d; g++)
          y[g - 1] = arguments[g];
        for (let f of y)
          p2 = p2[f], i.push(f, p2);
        let c2 = u(this);
        return i.length = l, c2;
      }
      callParent(u) {
        let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a2(this.stack, i + 1), p2 = this.stack.splice(l + 1), d = u(this);
        return this.stack.push(...p2), d;
      }
      each(u) {
        let { stack: i } = this, { length: l } = i, p2 = t(i);
        for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), g = 1; g < d; g++)
          y[g - 1] = arguments[g];
        for (let c2 of y)
          p2 = p2[c2], i.push(c2, p2);
        for (let c2 = 0; c2 < p2.length; ++c2)
          i.push(c2, p2[c2]), u(this, c2, p2), i.length -= 2;
        i.length = l;
      }
      map(u) {
        let i = [];
        for (var l = arguments.length, p2 = new Array(l > 1 ? l - 1 : 0), d = 1; d < l; d++)
          p2[d - 1] = arguments[d];
        return this.each((y, g, c2) => {
          i[g] = u(y, g, c2);
        }, ...p2), i;
      }
      try(u) {
        let { stack: i } = this, l = [...i];
        try {
          return u();
        } finally {
          i.length = 0, i.push(...l);
        }
      }
      match() {
        let u = this.stack.length - 1, i = null, l = this.stack[u--];
        for (var p2 = arguments.length, d = new Array(p2), y = 0; y < p2; y++)
          d[y] = arguments[y];
        for (let g of d) {
          if (l === void 0)
            return false;
          let c2 = null;
          if (typeof i == "number" && (c2 = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c2))
            return false;
          i = this.stack[u--], l = this.stack[u--];
        }
        return true;
      }
      findAncestor(u) {
        let i = this.stack.length - 1, l = null, p2 = this.stack[i--];
        for (; p2; ) {
          let d = null;
          if (typeof l == "number" && (d = l, l = this.stack[i--], p2 = this.stack[i--]), l !== null && u(p2, l, d))
            return p2;
          l = this.stack[i--], p2 = this.stack[i--];
        }
      }
    };
    r.exports = n;
  } }), Im = te({ "src/main/multiparser.js"(e, r) {
    ne();
    var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s2 } = Ka(), a2 = et();
    function n(i, l, p2, d) {
      if (p2.printer.embed && p2.embeddedLanguageFormatting === "auto")
        return p2.printer.embed(i, l, (y, g, c2) => u(y, g, p2, d, c2), p2);
    }
    function u(i, l, p2, d) {
      let { stripTrailingHardline: y = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s2(Object.assign(Object.assign(Object.assign({}, p2), l), {}, { parentParser: p2.parser, originalText: i }), { passThrough: true }), c2 = Qn().parse(i, g), { ast: f } = c2;
      i = c2.text;
      let E = f.comments;
      delete f.comments, a2.attach(E, f, i, g), g[Symbol.for("comments")] = E || [], g[Symbol.for("tokens")] = f.tokens || [];
      let _ = d(f, g);
      return a2.ensureAllCommentsPrinted(E), y ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
    }
    r.exports = { printSubtree: n };
  } }), km = te({ "src/main/ast-to-doc.js"(e, r) {
    ne();
    var t = Pm(), { builders: { hardline: s2, addAlignmentToDoc: a2 }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Im();
    function l(y, g) {
      let c2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
      f.preprocess && (y = f.preprocess(y, g));
      let E = /* @__PURE__ */ new Map(), _ = new t(y), w = F();
      return c2 > 0 && (w = a2([s2, w], c2, g.tabWidth)), n(w), w;
      function F(x2, I) {
        return x2 === void 0 || x2 === _ ? N(I) : Array.isArray(x2) ? _.call(() => N(I), ...x2) : _.call(() => N(I), x2);
      }
      function N(x2) {
        let I = _.getValue(), P = I && typeof I == "object" && x2 === void 0;
        if (P && E.has(I))
          return E.get(I);
        let $2 = d(_, g, F, x2);
        return P && E.set(I, $2), $2;
      }
    }
    function p2(y, g) {
      let { originalText: c2, [Symbol.for("comments")]: f, locStart: E, locEnd: _ } = g, w = E(y), F = _(y), N = /* @__PURE__ */ new Set();
      for (let x2 of f)
        E(x2) >= w && _(x2) <= F && (x2.printed = true, N.add(x2));
      return { doc: c2.slice(w, F), printedComments: N };
    }
    function d(y, g, c2, f) {
      let E = y.getValue(), { printer: _ } = g, w, F;
      if (_.hasPrettierIgnore && _.hasPrettierIgnore(y))
        ({ doc: w, printedComments: F } = p2(E, g));
      else {
        if (E)
          try {
            w = i.printSubtree(y, c2, g, l);
          } catch (N) {
            if (globalThis.PRETTIER_DEBUG)
              throw N;
          }
        w || (w = _.print(y, g, c2, f));
      }
      return (!_.willPrintOwnComments || !_.willPrintOwnComments(y, g)) && (w = u(y, w, g, F)), w;
    }
    r.exports = l;
  } }), Lm = te({ "src/main/range-util.js"(e, r) {
    ne();
    var t = Yt(), s2 = et(), a2 = (f) => {
      let { parser: E } = f;
      return E === "json" || E === "json5" || E === "json-stringify";
    };
    function n(f, E) {
      let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([E.node, ...E.parentNodes]);
      return _.find((F) => d.has(F.type) && w.has(F));
    }
    function u(f) {
      let E = f.length - 1;
      for (; ; ) {
        let _ = f[E];
        if (_ && (_.type === "Program" || _.type === "File"))
          E--;
        else
          break;
      }
      return f.slice(0, E + 1);
    }
    function i(f, E, _) {
      let { locStart: w, locEnd: F } = _, N = f.node, x2 = E.node;
      if (N === x2)
        return { startNode: N, endNode: x2 };
      let I = w(f.node);
      for (let $2 of u(E.parentNodes))
        if (w($2) >= I)
          x2 = $2;
        else
          break;
      let P = F(E.node);
      for (let $2 of u(f.parentNodes)) {
        if (F($2) <= P)
          N = $2;
        else
          break;
        if (N === x2)
          break;
      }
      return { startNode: N, endNode: x2 };
    }
    function l(f, E, _, w) {
      let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x2, locEnd: I } = _, P = x2(f), $2 = I(f);
      if (!(E > $2 || E < P || N === "rangeEnd" && E === P || N === "rangeStart" && E === $2)) {
        for (let D of s2.getSortedChildNodes(f, _)) {
          let T = l(D, E, _, w, [f, ...F], N);
          if (T)
            return T;
        }
        if (!w || w(f, F[0]))
          return { node: f, parentNodes: F };
      }
    }
    function p2(f, E) {
      return E !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
    }
    var d = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), y = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
    function g(f, E, _) {
      if (!E)
        return false;
      switch (f.parser) {
        case "flow":
        case "babel":
        case "babel-flow":
        case "babel-ts":
        case "typescript":
        case "acorn":
        case "espree":
        case "meriyah":
        case "__babel_estree":
          return p2(E.type, _ && _.type);
        case "json":
        case "json5":
        case "json-stringify":
          return d.has(E.type);
        case "graphql":
          return y.has(E.kind);
        case "vue":
          return E.tag !== "root";
      }
      return false;
    }
    function c2(f, E, _) {
      let { rangeStart: w, rangeEnd: F, locStart: N, locEnd: x2 } = E;
      t.ok(F > w);
      let I = f.slice(w, F).search(/\S/), P = I === -1;
      if (!P)
        for (w += I; F > w && !/\S/.test(f[F - 1]); --F)
          ;
      let $2 = l(_, w, E, (C, o) => g(E, C, o), [], "rangeStart"), D = P ? $2 : l(_, F, E, (C) => g(E, C), [], "rangeEnd");
      if (!$2 || !D)
        return { rangeStart: 0, rangeEnd: 0 };
      let T, m2;
      if (a2(E)) {
        let C = n($2, D);
        T = C, m2 = C;
      } else
        ({ startNode: T, endNode: m2 } = i($2, D, E));
      return { rangeStart: Math.min(N(T), N(m2)), rangeEnd: Math.max(x2(T), x2(m2)) };
    }
    r.exports = { calculateRange: c2, findNodeAtOffset: l };
  } }), Om = te({ "src/main/core.js"(e, r) {
    ne();
    var { diffArrays: t } = vD(), { printer: { printDocToString: s2 }, debug: { printDocToDebug: a2 } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p2 } = Hn(), d = Ka().normalize, y = _m(), g = et(), c2 = Qn(), f = km(), E = Lm(), _ = "\uFEFF", w = Symbol("cursor");
    function F(m2, C, o) {
      let h2 = C.comments;
      return h2 && (delete C.comments, g.attach(h2, C, m2, o)), o[Symbol.for("comments")] = h2 || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m2, h2;
    }
    function N(m2, C) {
      let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (!m2 || m2.trim().length === 0)
        return { formatted: "", cursorOffset: -1, comments: [] };
      let { ast: h2, text: v } = c2.parse(m2, C);
      if (C.cursorOffset >= 0) {
        let k = E.findNodeAtOffset(h2, C.cursorOffset, C);
        k && k.node && (C.cursorNode = k.node);
      }
      let S = F(v, h2, C), b = f(h2, C, o), B = s2(b, C);
      if (g.ensureAllCommentsPrinted(S), o > 0) {
        let k = B.formatted.trim();
        B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
      }
      if (C.cursorOffset >= 0) {
        let k, M, R, q2, J;
        if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q2 = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q2 = 0, J = B.formatted), M === J)
          return { formatted: B.formatted, cursorOffset: q2 + R, comments: S };
        let L = [...M];
        L.splice(R, 0, w);
        let Q = [...J], V = t(L, Q), j = q2;
        for (let Y of V)
          if (Y.removed) {
            if (Y.value.includes(w))
              break;
          } else
            j += Y.count;
        return { formatted: B.formatted, cursorOffset: j, comments: S };
      }
      return { formatted: B.formatted, cursorOffset: -1, comments: S };
    }
    function x2(m2, C) {
      let { ast: o, text: h2 } = c2.parse(m2, C), { rangeStart: v, rangeEnd: S } = E.calculateRange(h2, C, o), b = h2.slice(v, S), B = Math.min(v, h2.lastIndexOf(`
`, v) + 1), k = h2.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q2 = R.formatted.trimEnd(), { cursorOffset: J } = C;
      J > S ? J += q2.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
      let L = h2.slice(0, v) + q2 + h2.slice(S);
      if (C.endOfLine !== "lf") {
        let Q = i(C.endOfLine);
        J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
      }
      return { formatted: L, cursorOffset: J, comments: R.comments };
    }
    function I(m2, C, o) {
      return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m2.length ? o : C;
    }
    function P(m2, C) {
      let { cursorOffset: o, rangeStart: h2, rangeEnd: v } = C;
      return o = I(m2, o, -1), h2 = I(m2, h2, 0), v = I(m2, v, m2.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h2, rangeEnd: v });
    }
    function $2(m2, C) {
      let { cursorOffset: o, rangeStart: h2, rangeEnd: v, endOfLine: S } = P(m2, C), b = m2.charAt(0) === _;
      if (b && (m2 = m2.slice(1), o--, h2--, v--), S === "auto" && (S = u(m2)), m2.includes("\r")) {
        let B = (k) => l(m2.slice(0, Math.max(k, 0)), `\r
`);
        o -= B(o), h2 -= B(h2), v -= B(v), m2 = p2(m2);
      }
      return { hasBOM: b, text: m2, options: P(m2, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h2, rangeEnd: v, endOfLine: S })) };
    }
    function D(m2, C) {
      let o = c2.resolveParser(C);
      return !o.hasPragma || o.hasPragma(m2);
    }
    function T(m2, C) {
      let { hasBOM: o, text: h2, options: v } = $2(m2, d(C));
      if (v.rangeStart >= v.rangeEnd && h2 !== "" || v.requirePragma && !D(h2, v))
        return { formatted: m2, cursorOffset: C.cursorOffset, comments: [] };
      let S;
      return v.rangeStart > 0 || v.rangeEnd < h2.length ? S = x2(h2, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(h2, v) && (h2 = v.printer.insertPragma(h2)), S = N(h2, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
    }
    r.exports = { formatWithCursor: T, parse(m2, C, o) {
      let { text: h2, options: v } = $2(m2, d(C)), S = c2.parse(h2, v);
      return o && (S.ast = y(S.ast, v)), S;
    }, formatAST(m2, C) {
      C = d(C);
      let o = f(m2, C);
      return s2(o, C);
    }, formatDoc(m2, C) {
      return T(a2(m2), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
    }, printToDoc(m2, C) {
      C = d(C);
      let { ast: o, text: h2 } = c2.parse(m2, C);
      return F(h2, o, C), f(o, C);
    }, printDocToString(m2, C) {
      return s2(m2, d(C));
    } };
  } }), jm = te({ "src/common/util-shared.js"(e, r) {
    ne();
    var { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p2, skipToLineEnd: d, skipEverythingButNewLine: y, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: E, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D } = Ue();
    r.exports = { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p2, skipToLineEnd: d, skipEverythingButNewLine: y, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: E, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D };
  } }), wt = te({ "src/utils/create-language.js"(e, r) {
    ne(), r.exports = function(t, s2) {
      let { languageId: a2 } = t, n = $n(t, pD);
      return Object.assign(Object.assign({ linguistLanguageId: a2 }, n), s2(t));
    };
  } }), qm = te({ "node_modules/esutils/lib/ast.js"(e, r) {
    ne(), function() {
      function t(l) {
        if (l == null)
          return false;
        switch (l.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function s2(l) {
        if (l == null)
          return false;
        switch (l.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function a2(l) {
        if (l == null)
          return false;
        switch (l.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function n(l) {
        return a2(l) || l != null && l.type === "FunctionDeclaration";
      }
      function u(l) {
        switch (l.type) {
          case "IfStatement":
            return l.alternate != null ? l.alternate : l.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return l.body;
        }
        return null;
      }
      function i(l) {
        var p2;
        if (l.type !== "IfStatement" || l.alternate == null)
          return false;
        p2 = l.consequent;
        do {
          if (p2.type === "IfStatement" && p2.alternate == null)
            return true;
          p2 = u(p2);
        } while (p2);
        return false;
      }
      r.exports = { isExpression: t, isStatement: a2, isIterationStatement: s2, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
    }();
  } }), Ya = te({ "node_modules/esutils/lib/code.js"(e, r) {
    ne(), function() {
      var t, s2, a2, n, u, i;
      s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
      function l(F) {
        return 48 <= F && F <= 57;
      }
      function p2(F) {
        return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
      }
      function d(F) {
        return F >= 48 && F <= 55;
      }
      a2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
      function y(F) {
        return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a2.indexOf(F) >= 0;
      }
      function g(F) {
        return F === 10 || F === 13 || F === 8232 || F === 8233;
      }
      function c2(F) {
        if (F <= 65535)
          return String.fromCharCode(F);
        var N = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), x2 = String.fromCharCode((F - 65536) % 1024 + 56320);
        return N + x2;
      }
      for (n = new Array(128), i = 0; i < 128; ++i)
        n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
      for (u = new Array(128), i = 0; i < 128; ++i)
        u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
      function f(F) {
        return F < 128 ? n[F] : s2.NonAsciiIdentifierStart.test(c2(F));
      }
      function E(F) {
        return F < 128 ? u[F] : s2.NonAsciiIdentifierPart.test(c2(F));
      }
      function _(F) {
        return F < 128 ? n[F] : t.NonAsciiIdentifierStart.test(c2(F));
      }
      function w(F) {
        return F < 128 ? u[F] : t.NonAsciiIdentifierPart.test(c2(F));
      }
      r.exports = { isDecimalDigit: l, isHexDigit: p2, isOctalDigit: d, isWhiteSpace: y, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: E, isIdentifierStartES6: _, isIdentifierPartES6: w };
    }();
  } }), Mm = te({ "node_modules/esutils/lib/keyword.js"(e, r) {
    ne(), function() {
      var t = Ya();
      function s2(f) {
        switch (f) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function a2(f, E) {
        return !E && f === "yield" ? false : n(f, E);
      }
      function n(f, E) {
        if (E && s2(f))
          return true;
        switch (f.length) {
          case 2:
            return f === "if" || f === "in" || f === "do";
          case 3:
            return f === "var" || f === "for" || f === "new" || f === "try";
          case 4:
            return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
          case 5:
            return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
          case 6:
            return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
          case 7:
            return f === "default" || f === "finally" || f === "extends";
          case 8:
            return f === "function" || f === "continue" || f === "debugger";
          case 10:
            return f === "instanceof";
          default:
            return false;
        }
      }
      function u(f, E) {
        return f === "null" || f === "true" || f === "false" || a2(f, E);
      }
      function i(f, E) {
        return f === "null" || f === "true" || f === "false" || n(f, E);
      }
      function l(f) {
        return f === "eval" || f === "arguments";
      }
      function p2(f) {
        var E, _, w;
        if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w)))
          return false;
        for (E = 1, _ = f.length; E < _; ++E)
          if (w = f.charCodeAt(E), !t.isIdentifierPartES5(w))
            return false;
        return true;
      }
      function d(f, E) {
        return (f - 55296) * 1024 + (E - 56320) + 65536;
      }
      function y(f) {
        var E, _, w, F, N;
        if (f.length === 0)
          return false;
        for (N = t.isIdentifierStartES6, E = 0, _ = f.length; E < _; ++E) {
          if (w = f.charCodeAt(E), 55296 <= w && w <= 56319) {
            if (++E, E >= _ || (F = f.charCodeAt(E), !(56320 <= F && F <= 57343)))
              return false;
            w = d(w, F);
          }
          if (!N(w))
            return false;
          N = t.isIdentifierPartES6;
        }
        return true;
      }
      function g(f, E) {
        return p2(f) && !u(f, E);
      }
      function c2(f, E) {
        return y(f) && !i(f, E);
      }
      r.exports = { isKeywordES5: a2, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p2, isIdentifierNameES6: y, isIdentifierES5: g, isIdentifierES6: c2 };
    }();
  } }), Rm = te({ "node_modules/esutils/lib/utils.js"(e) {
    ne(), function() {
      e.ast = qm(), e.code = Ya(), e.keyword = Mm();
    }();
  } }), _t = te({ "src/language-js/utils/is-block-comment.js"(e, r) {
    ne();
    var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s2 = (a2) => t.has(a2 == null ? void 0 : a2.type);
    r.exports = s2;
  } }), $m = te({ "src/language-js/utils/is-node-matches.js"(e, r) {
    ne();
    function t(a2, n) {
      let u = n.split(".");
      for (let i = u.length - 1; i >= 0; i--) {
        let l = u[i];
        if (i === 0)
          return a2.type === "Identifier" && a2.name === l;
        if (a2.type !== "MemberExpression" || a2.optional || a2.computed || a2.property.type !== "Identifier" || a2.property.name !== l)
          return false;
        a2 = a2.object;
      }
    }
    function s2(a2, n) {
      return n.some((u) => t(a2, u));
    }
    r.exports = s2;
  } }), Ke = te({ "src/language-js/utils/index.js"(e, r) {
    ne();
    var t = Rm().keyword.isIdentifierNameES5, { getLast: s2, hasNewline: a2, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p2, locEnd: d, hasSameLocStart: y } = ut(), g = _t(), c2 = $m(), f = "(?:(?=.)\\s)", E = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
    function w(O) {
      var me, _e;
      return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && E.test(O.trailingComments[0].value);
    }
    function F(O) {
      let me = O == null ? void 0 : O[0];
      return g(me) && _.test(me.value);
    }
    function N(O, me) {
      if (!O || typeof O != "object")
        return false;
      if (Array.isArray(O))
        return O.some((He) => N(He, me));
      let _e = me(O);
      return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
    }
    function x2(O) {
      return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
    }
    function I(O) {
      var me, _e, He, Ge, it, Qe;
      return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
    }
    function P(O, me) {
      if (me.expressions)
        return ["expressions", 0];
      if (me.left)
        return ["left"];
      if (me.test)
        return ["test"];
      if (me.object)
        return ["object"];
      if (me.callee)
        return ["callee"];
      if (me.tag)
        return ["tag"];
      if (me.argument)
        return ["argument"];
      if (me.expression)
        return ["expression"];
      throw new Error("Unexpected node has no left side.");
    }
    function $2(O) {
      return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
    }
    var D = $2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
    function m2(O) {
      let me = O.getParentNode();
      return O.getName() === "declaration" && T(me) ? me : null;
    }
    var C = $2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
    function o(O) {
      return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
    }
    function h2(O) {
      return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
    }
    function v(O) {
      return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
    }
    var S = $2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $2(["FunctionExpression", "ArrowFunctionExpression"]);
    function B(O) {
      return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
    }
    function k(O) {
      return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
    }
    var M = $2(["JSXElement", "JSXFragment"]);
    function R(O, me) {
      if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
        return false;
      let _e = me.getNode();
      if (!_e.expression || !M(_e.expression))
        return false;
      let He = me.getParentNode();
      return He.type === "Program" && He.body.length === 1;
    }
    function q2(O) {
      return O.kind === "get" || O.kind === "set";
    }
    function J(O) {
      return q2(O) || y(O, O.value);
    }
    function L(O) {
      return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
    }
    function Q(O) {
      return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !y(O, O.typeAnnotation);
    }
    var V = $2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
    function j(O) {
      return ue(O) || O.type === "BindExpression" && Boolean(O.object);
    }
    var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
    function ie(O) {
      return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
    }
    function ee(O) {
      let me = /^(?:before|after)(?:Each|All)$/;
      return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
    }
    var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
    function W(O) {
      return c2(O, ce);
    }
    function K(O, me) {
      if (O.type !== "CallExpression")
        return false;
      if (O.arguments.length === 1) {
        if (k(O) && me && K(me))
          return b(O.arguments[0]);
        if (ee(O))
          return k(O.arguments[0]);
      } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee))
        return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
      return false;
    }
    var de = $2(["CallExpression", "OptionalCallExpression"]), ue = $2(["MemberExpression", "OptionalMemberExpression"]);
    function Fe(O) {
      let me = "expressions";
      O.type === "TSTemplateLiteralType" && (me = "types");
      let _e = O[me];
      return _e.length === 0 ? false : _e.every((He) => {
        if (Me(He))
          return false;
        if (He.type === "Identifier" || He.type === "ThisExpression")
          return true;
        if (ue(He)) {
          let Ge = He;
          for (; ue(Ge); )
            if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge)))
              return false;
          return Ge.type === "Identifier" || Ge.type === "ThisExpression";
        }
        return false;
      });
    }
    function z(O, me) {
      return O === "+" || O === "-" ? O + me : me;
    }
    function U(O, me) {
      let _e = p2(me), He = n(O, d(me));
      return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
    }
    function Z(O, me) {
      return M(me) ? Oe(me) : Me(me, be.Leading, (_e) => a2(O, d(_e)));
    }
    function se(O, me) {
      return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
    }
    function fe(O) {
      return /^(?:\d+|\d+\.\d+)$/.test(O);
    }
    function ge(O, me) {
      let _e = /^[fx]?(?:describe|it|test)$/;
      return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
    }
    function he(O) {
      return O.quasis.some((me) => me.value.raw.includes(`
`));
    }
    function we(O, me) {
      return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a2(me, p2(O), { backwards: true });
    }
    function ke(O) {
      if (!Me(O))
        return false;
      let me = s2(ae(O, be.Dangling));
      return me && !g(me);
    }
    function Re(O) {
      if (O.length <= 1)
        return false;
      let me = 0;
      for (let _e of O)
        if (b(_e)) {
          if (me += 1, me > 1)
            return true;
        } else if (de(_e)) {
          for (let He of _e.arguments)
            if (b(He))
              return true;
        }
      return false;
    }
    function Ne(O) {
      let me = O.getValue(), _e = O.getParentNode();
      return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
    }
    function Pe(O, me) {
      if (me >= 2)
        return false;
      let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
      if (He && l(He) > 5)
        return false;
      if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
        return true;
      if (O.type === "TemplateLiteral")
        return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
      if (O.type === "ObjectExpression")
        return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
      if (O.type === "ArrayExpression")
        return O.elements.every((Qe) => Qe === null || _e(Qe));
      if (tt(O))
        return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
      if (ue(O))
        return Pe(O.object, me) && Pe(O.property, me);
      let Ge = { "!": true, "-": true, "+": true, "~": true };
      if (O.type === "UnaryExpression" && Ge[O.operator])
        return Pe(O.argument, me);
      let it = { "++": true, "--": true };
      return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
    }
    function oe(O) {
      var me, _e;
      return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
    }
    function H(O) {
      return O;
    }
    function pe(O) {
      return O.filepath && /\.tsx$/i.test(O.filepath);
    }
    function X(O) {
      let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
      return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
    }
    function le(O, me) {
      switch (O.type) {
        case "BinaryExpression":
        case "LogicalExpression":
        case "AssignmentExpression":
        case "NGPipeExpression":
          return le(O.left, me);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return le(O.object, me);
        case "TaggedTemplateExpression":
          return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
        case "CallExpression":
        case "OptionalCallExpression":
          return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
        case "ConditionalExpression":
          return le(O.test, me);
        case "UpdateExpression":
          return !O.prefix && le(O.argument, me);
        case "BindExpression":
          return O.object && le(O.object, me);
        case "SequenceExpression":
          return le(O.expressions[0], me);
        case "TSSatisfiesExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
          return le(O.expression, me);
        default:
          return me(O);
      }
    }
    var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
    function A(O, me) {
      return !(re2(me) !== re2(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
    }
    var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
    function re2(O) {
      return G.get(O);
    }
    function ye(O) {
      return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
    }
    function Ce(O) {
      var me;
      if (O.rest)
        return true;
      let _e = ve(O);
      return ((me = s2(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
    }
    var Be = /* @__PURE__ */ new WeakMap();
    function ve(O) {
      if (Be.has(O))
        return Be.get(O);
      let me = [];
      return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
    }
    function ze(O, me) {
      let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
      _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
    }
    var xe = /* @__PURE__ */ new WeakMap();
    function Ye(O) {
      if (xe.has(O))
        return xe.get(O);
      let me = O.arguments;
      return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), xe.set(O, me), me;
    }
    function Se(O, me) {
      let _e = O.getValue();
      _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
    }
    function Ie(O) {
      return O.value.trim() === "prettier-ignore" && !O.unignore;
    }
    function Oe(O) {
      return O && (O.prettierIgnore || Me(O, be.PrettierIgnore));
    }
    function Je(O) {
      let me = O.getValue();
      return Oe(me);
    }
    var be = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
      if (typeof O == "function" && (me = O, O = 0), O || me)
        return (_e, He, Ge) => !(O & be.Leading && !_e.leading || O & be.Trailing && !_e.trailing || O & be.Dangling && (_e.leading || _e.trailing) || O & be.Block && !g(_e) || O & be.Line && !D(_e) || O & be.First && He !== 0 || O & be.Last && He !== Ge.length - 1 || O & be.PrettierIgnore && !Ie(_e) || me && !me(_e));
    };
    function Me(O, me, _e) {
      if (!u(O == null ? void 0 : O.comments))
        return false;
      let He = je(me, _e);
      return He ? O.comments.some(He) : true;
    }
    function ae(O, me, _e) {
      if (!Array.isArray(O == null ? void 0 : O.comments))
        return [];
      let He = je(me, _e);
      return He ? O.comments.filter(He) : O.comments;
    }
    var nt = (O, me) => {
      let { originalText: _e } = me;
      return i(_e, d(O));
    };
    function tt(O) {
      return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
    }
    function Ve(O) {
      return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
    }
    function We(O) {
      return Boolean(O.__isUsingHackPipeline);
    }
    var Xe = Symbol("ifWithoutBlockAndSameLineComment");
    function st(O) {
      return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
    }
    r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m2, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x2, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q2, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: h2, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re2, hasComment: Me, getComments: ae, CommentCheckFlags: be, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
  } }), Lt = te({ "src/language-js/print/template-literal.js"(e, r) {
    ne();
    var t = lt(), { getStringWidth: s2, getIndentSize: a2 } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p2, align: d, lineSuffixBoundary: y, addAlignmentToDoc: g }, printer: { printDocToString: c2 }, utils: { mapDoc: f } } = qe(), { isBinaryish: E, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: F, isMemberExpression: N, isTSTypeExpression: x2 } = Ke();
    function I(C, o, h2) {
      let v = C.getValue();
      if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
        let R = P(C, h2, o);
        if (R)
          return R;
      }
      let b = "expressions";
      v.type === "TSTemplateLiteralType" && (b = "types");
      let B = [], k = C.map(o, b), M = w(v);
      return M && (k = k.map((R) => c2(R, Object.assign(Object.assign({}, h2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(y, "`"), C.each((R) => {
        let q2 = R.getName();
        if (B.push(o()), q2 < k.length) {
          let { tabWidth: J } = h2, L = R.getValue(), Q = a2(L.value.raw, J), V = k[q2];
          if (!M) {
            let Y = v[b][q2];
            (F(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x2(Y) || E(Y)) && (V = [p2([i, V]), i]);
          }
          let j = Q === 0 && L.value.raw.endsWith(`
`) ? d(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
          B.push(l(["${", j, y, "}"]));
        }
      }, "quasis"), B.push("`"), B;
    }
    function P(C, o, h2) {
      let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
      if (S.length > 1 || S.some((b) => b.length > 0)) {
        o.__inJestEach = true;
        let b = C.map(h2, "expressions");
        o.__inJestEach = false;
        let B = [], k = b.map((L) => "${" + c2(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
        for (let L = 1; L < v.quasis.length; L++) {
          let Q = t(M), V = k[L - 1];
          Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
        }
        let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q2 = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
        for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
          for (let [Q, V] of L.entries())
            q2[Q] = Math.max(q2[Q], s2(V));
        return B.push(y, "`", p2([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q2[V] - s2(Q))))))]), u, "`"), B;
      }
    }
    function $2(C, o) {
      let h2 = C.getValue(), v = o();
      return F(h2) && (v = l([p2([i, v]), i])), ["${", v, y, "}"];
    }
    function D(C, o) {
      return C.map((h2) => $2(h2, o), "expressions");
    }
    function T(C, o) {
      return f(C, (h2) => typeof h2 == "string" ? o ? h2.replace(/(\\*)`/g, "$1$1\\`") : m2(h2) : h2);
    }
    function m2(C) {
      return C.replace(/([\\`]|\${)/g, "\\$1");
    }
    r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m2 };
  } }), Vm = te({ "src/language-js/embed/markdown.js"(e, r) {
    ne();
    var { builders: { indent: t, softline: s2, literalline: a2, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = Lt();
    function i(p2, d, y) {
      let c2 = p2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, F) => "\\".repeat(F.length / 2) + "`"), f = l(c2), E = f !== "";
      E && (c2 = c2.replace(new RegExp(`^${f}`, "gm"), ""));
      let _ = u(y(c2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
      return ["`", E ? t([s2, _]) : [a2, n(_)], s2, "`"];
    }
    function l(p2) {
      let d = p2.match(/^([^\S\n]*)\S/m);
      return d === null ? "" : d[1];
    }
    r.exports = i;
  } }), Wm = te({ "src/language-js/embed/css.js"(e, r) {
    ne();
    var { isNonEmptyArray: t } = Ue(), { builders: { indent: s2, hardline: a2, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p2 } = Lt();
    function d(c2, f, E) {
      let _ = c2.getValue(), w = _.quasis.map((P) => P.value.raw), F = 0, N = w.reduce((P, $2, D) => D === 0 ? $2 : P + "@prettier-placeholder-" + F++ + "-id" + $2, ""), x2 = E(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p2(c2, f);
      return y(x2, _, I);
    }
    function y(c2, f, E) {
      if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
        return "``";
      let w = g(c2, E);
      if (!w)
        throw new Error("Couldn't insert all the expressions");
      return ["`", s2([a2, w]), n, "`"];
    }
    function g(c2, f) {
      if (!t(f))
        return c2;
      let E = 0, _ = u(l(c2), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((F, N) => N % 2 === 0 ? i(F) : (E++, f[F])));
      return f.length === E ? _ : null;
    }
    r.exports = d;
  } }), Hm = te({ "src/language-js/embed/graphql.js"(e, r) {
    ne();
    var { builders: { indent: t, join: s2, hardline: a2 } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = Lt();
    function i(p2, d, y) {
      let g = p2.getValue(), c2 = g.quasis.length;
      if (c2 === 1 && g.quasis[0].value.raw.trim() === "")
        return "``";
      let f = u(p2, d), E = [];
      for (let _ = 0; _ < c2; _++) {
        let w = g.quasis[_], F = _ === 0, N = _ === c2 - 1, x2 = w.value.cooked, I = x2.split(`
`), P = I.length, $2 = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m2 = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
        if (!N && /#[^\n\r]*$/.test(I[P - 1]))
          return null;
        let C = null;
        m2 ? C = l(I) : C = y(x2, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !F && D && E.push(""), E.push(C), !N && T && E.push("")) : !F && !N && D && E.push(""), $2 && E.push($2);
      }
      return ["`", t([a2, s2(a2, E)]), a2, "`"];
    }
    function l(p2) {
      let d = [], y = false, g = p2.map((c2) => c2.trim());
      for (let [c2, f] of g.entries())
        f !== "" && (g[c2 - 1] === "" && y ? d.push([a2, f]) : d.push(f), y = true);
      return d.length === 0 ? null : s2(a2, d);
    }
    r.exports = i;
  } }), Gm = te({ "src/language-js/embed/html.js"(e, r) {
    ne();
    var { builders: { indent: t, line: s2, hardline: a2, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = Lt(), p2 = 0;
    function d(y, g, c2, f, E) {
      let { parser: _ } = E, w = y.getValue(), F = p2;
      p2 = p2 + 1 >>> 0;
      let N = (h2) => `PRETTIER_HTML_PLACEHOLDER_${h2}_${F}_IN_JS`, x2 = w.quasis.map((h2, v, S) => v === S.length - 1 ? h2.value.cooked : h2.value.cooked + N(v)).join(""), I = i(y, g);
      if (I.length === 0 && x2.trim().length === 0)
        return "``";
      let P = new RegExp(N("(\\d+)"), "g"), $2 = 0, D = c2(x2, { parser: _, __onHtmlRoot(h2) {
        $2 = h2.children.length;
      } }, { stripTrailingHardline: true }), T = u(D, (h2) => {
        if (typeof h2 != "string")
          return h2;
        let v = [], S = h2.split(P);
        for (let b = 0; b < S.length; b++) {
          let B = S[b];
          if (b % 2 === 0) {
            B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
            continue;
          }
          let k = Number(B);
          v.push(I[k]);
        }
        return v;
      }), m2 = /^\s/.test(x2) ? " " : "", C = /\s$/.test(x2) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a2 : m2 && C ? s2 : null;
      return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m2, $2 > 1 ? t(n(T)) : n(T), C, "`"]);
    }
    r.exports = d;
  } }), Um = te({ "src/language-js/embed.js"(e, r) {
    ne();
    var { hasComment: t, CommentCheckFlags: s2, isObjectProperty: a2 } = Ke(), n = Vm(), u = Wm(), i = Hm(), l = Gm();
    function p2(D) {
      if (g(D) || _(D) || w(D) || c2(D))
        return "css";
      if (x2(D))
        return "graphql";
      if (P(D))
        return "html";
      if (f(D))
        return "angular";
      if (y(D))
        return "markdown";
    }
    function d(D, T, m2, C) {
      let o = D.getValue();
      if (o.type !== "TemplateLiteral" || $2(o))
        return;
      let h2 = p2(D);
      if (h2) {
        if (h2 === "markdown")
          return n(D, T, m2);
        if (h2 === "css")
          return u(D, T, m2);
        if (h2 === "graphql")
          return i(D, T, m2);
        if (h2 === "html" || h2 === "angular")
          return l(D, T, m2, C, { parser: h2 });
      }
    }
    function y(D) {
      let T = D.getValue(), m2 = D.getParentNode();
      return m2 && m2.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m2.tag.type === "Identifier" && (m2.tag.name === "md" || m2.tag.name === "markdown");
    }
    function g(D) {
      let T = D.getValue(), m2 = D.getParentNode(), C = D.getParentNode(1);
      return C && T.quasis && m2.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "Identifier" && m2.tag.name === "css" || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "MemberExpression" && m2.tag.object.name === "css" && (m2.tag.property.name === "global" || m2.tag.property.name === "resolve");
    }
    function c2(D) {
      return D.match((T) => T.type === "TemplateLiteral", (T, m2) => T.type === "ArrayExpression" && m2 === "elements", (T, m2) => a2(T) && T.key.type === "Identifier" && T.key.name === "styles" && m2 === "value", ...E);
    }
    function f(D) {
      return D.match((T) => T.type === "TemplateLiteral", (T, m2) => a2(T) && T.key.type === "Identifier" && T.key.name === "template" && m2 === "value", ...E);
    }
    var E = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
    function _(D) {
      let T = D.getParentNode();
      if (!T || T.type !== "TaggedTemplateExpression")
        return false;
      let m2 = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
      switch (m2.type) {
        case "MemberExpression":
          return F(m2.object) || N(m2);
        case "CallExpression":
          return F(m2.callee) || m2.callee.type === "MemberExpression" && (m2.callee.object.type === "MemberExpression" && (F(m2.callee.object.object) || N(m2.callee.object)) || m2.callee.object.type === "CallExpression" && F(m2.callee.object.callee));
        case "Identifier":
          return m2.name === "css";
        default:
          return false;
      }
    }
    function w(D) {
      let T = D.getParentNode(), m2 = D.getParentNode(1);
      return m2 && T.type === "JSXExpressionContainer" && m2.type === "JSXAttribute" && m2.name.type === "JSXIdentifier" && m2.name.name === "css";
    }
    function F(D) {
      return D.type === "Identifier" && D.name === "styled";
    }
    function N(D) {
      return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
    }
    function x2(D) {
      let T = D.getValue(), m2 = D.getParentNode();
      return I(T, "GraphQL") || m2 && (m2.type === "TaggedTemplateExpression" && (m2.tag.type === "MemberExpression" && m2.tag.object.name === "graphql" && m2.tag.property.name === "experimental" || m2.tag.type === "Identifier" && (m2.tag.name === "gql" || m2.tag.name === "graphql")) || m2.type === "CallExpression" && m2.callee.type === "Identifier" && m2.callee.name === "graphql");
    }
    function I(D, T) {
      return t(D, s2.Block | s2.Leading, (m2) => {
        let { value: C } = m2;
        return C === ` ${T} `;
      });
    }
    function P(D) {
      return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m2) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m2 === "quasi");
    }
    function $2(D) {
      let { quasis: T } = D;
      return T.some((m2) => {
        let { value: { cooked: C } } = m2;
        return C === null;
      });
    }
    r.exports = d;
  } }), Jm = te({ "src/language-js/clean.js"(e, r) {
    ne();
    var t = _t(), s2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a2 = (u) => {
      for (let i of u.quasis)
        delete i.value;
    };
    function n(u, i, l) {
      if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
        return null;
      if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((y) => y.name.name === "jsx"))
        for (let { type: y, expression: g } of i.children)
          y === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a2(g);
      u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a2(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
      let p2 = u.expression || u.callee;
      if (u.type === "Decorator" && p2.type === "CallExpression" && p2.callee.name === "Component" && p2.arguments.length === 1) {
        let y = u.expression.arguments[0].properties;
        for (let [g, c2] of i.expression.arguments[0].properties.entries())
          switch (y[g].key.name) {
            case "styles":
              c2.value.type === "ArrayExpression" && a2(c2.value.elements[0]);
              break;
            case "template":
              c2.value.type === "TemplateLiteral" && a2(c2.value);
              break;
          }
      }
      if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a2(i.quasi), u.type === "TemplateLiteral") {
        var d;
        (((d = u.leadingComments) === null || d === void 0 ? void 0 : d.some((g) => t(g) && ["GraphQL", "HTML"].some((c2) => g.value === ` ${c2} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a2(i);
      }
      if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
        return i.types[0];
    }
    n.ignoredProperties = s2, r.exports = n;
  } }), Qa = {};
  zt(Qa, { EOL: () => Rn, arch: () => zm, cpus: () => so, default: () => co, endianness: () => Za, freemem: () => no, getNetworkInterfaces: () => lo, hostname: () => eo, loadavg: () => to, networkInterfaces: () => oo, platform: () => Xm, release: () => ao, tmpDir: () => qn, tmpdir: () => Mn, totalmem: () => uo, type: () => io, uptime: () => ro });
  function Za() {
    if (typeof xr > "u") {
      var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
      if (r[0] = 1, r[1] = 2, t[0] === 258)
        xr = "BE";
      else if (t[0] === 513)
        xr = "LE";
      else
        throw new Error("unable to figure out endianess");
    }
    return xr;
  }
  function eo() {
    return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
  }
  function to() {
    return [];
  }
  function ro() {
    return 0;
  }
  function no() {
    return Number.MAX_VALUE;
  }
  function uo() {
    return Number.MAX_VALUE;
  }
  function so() {
    return [];
  }
  function io() {
    return "Browser";
  }
  function ao() {
    return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
  }
  function oo() {
  }
  function lo() {
  }
  function zm() {
    return "javascript";
  }
  function Xm() {
    return "browser";
  }
  function qn() {
    return "/tmp";
  }
  var xr, Mn, Rn, co, Km = ht({ "node-modules-polyfills:os"() {
    ne(), Mn = qn, Rn = `
`, co = { EOL: Rn, tmpdir: Mn, tmpDir: qn, networkInterfaces: oo, getNetworkInterfaces: lo, release: ao, type: io, cpus: so, totalmem: uo, freemem: no, uptime: ro, loadavg: to, hostname: eo, endianness: Za };
  } }), Ym = te({ "node-modules-polyfills-commonjs:os"(e, r) {
    ne();
    var t = (Km(), ft(Qa));
    if (t && t.default) {
      r.exports = t.default;
      for (let s2 in t)
        r.exports[s2] = t[s2];
    } else
      t && (r.exports = t);
  } }), Qm = te({ "node_modules/detect-newline/index.js"(e, r) {
    ne();
    var t = (s2) => {
      if (typeof s2 != "string")
        throw new TypeError("Expected a string");
      let a2 = s2.match(/(?:\r?\n)/g) || [];
      if (a2.length === 0)
        return;
      let n = a2.filter((i) => i === `\r
`).length, u = a2.length - n;
      return n > u ? `\r
` : `
`;
    };
    r.exports = t, r.exports.graceful = (s2) => typeof s2 == "string" && t(s2) || `
`;
  } }), Zm = te({ "node_modules/jest-docblock/build/index.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c2, e.parse = E, e.parseWithComments = _, e.print = w, e.strip = f;
    function r() {
      let N = Ym();
      return r = function() {
        return N;
      }, N;
    }
    function t() {
      let N = s2(Qm());
      return t = function() {
        return N;
      }, N;
    }
    function s2(N) {
      return N && N.__esModule ? N : { default: N };
    }
    var a2 = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, d = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, y = /(\r?\n|^) *\* ?/g, g = [];
    function c2(N) {
      let x2 = N.match(u);
      return x2 ? x2[0].trimLeft() : "";
    }
    function f(N) {
      let x2 = N.match(u);
      return x2 && x2[0] ? N.substring(x2[0].length) : N;
    }
    function E(N) {
      return _(N).pragmas;
    }
    function _(N) {
      let x2 = (0, t().default)(N) || r().EOL;
      N = N.replace(n, "").replace(a2, "").replace(y, "$1");
      let I = "";
      for (; I !== N; )
        I = N, N = N.replace(p2, `${x2}$1 $2${x2}`);
      N = N.replace(l, "").trimRight();
      let P = /* @__PURE__ */ Object.create(null), $2 = N.replace(d, "").replace(l, "").trimRight(), D;
      for (; D = d.exec(N); ) {
        let T = D[2].replace(i, "");
        typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
      }
      return { comments: $2, pragmas: P };
    }
    function w(N) {
      let { comments: x2 = "", pragmas: I = {} } = N, P = (0, t().default)(x2) || r().EOL, $2 = "/**", D = " *", T = " */", m2 = Object.keys(I), C = m2.map((h2) => F(h2, I[h2])).reduce((h2, v) => h2.concat(v), []).map((h2) => `${D} ${h2}${P}`).join("");
      if (!x2) {
        if (m2.length === 0)
          return "";
        if (m2.length === 1 && !Array.isArray(I[m2[0]])) {
          let h2 = I[m2[0]];
          return `${$2} ${F(m2[0], h2)[0]}${T}`;
        }
      }
      let o = x2.split(P).map((h2) => `${D} ${h2}`).join(P) + P;
      return $2 + P + (x2 ? o : "") + (x2 && m2.length ? D + P : "") + C + T;
    }
    function F(N, x2) {
      return g.concat(x2).map((I) => `@${N} ${I}`.trim());
    }
  } }), ed = te({ "src/language-js/utils/get-shebang.js"(e, r) {
    ne();
    function t(s2) {
      if (!s2.startsWith("#!"))
        return "";
      let a2 = s2.indexOf(`
`);
      return a2 === -1 ? s2 : s2.slice(0, a2);
    }
    r.exports = t;
  } }), po = te({ "src/language-js/pragma.js"(e, r) {
    ne();
    var { parseWithComments: t, strip: s2, extract: a2, print: n } = Zm(), { normalizeEndOfLine: u } = Hn(), i = ed();
    function l(y) {
      let g = i(y);
      g && (y = y.slice(g.length + 1));
      let c2 = a2(y), { pragmas: f, comments: E } = t(c2);
      return { shebang: g, text: y, pragmas: f, comments: E };
    }
    function p2(y) {
      let g = Object.keys(l(y).pragmas);
      return g.includes("prettier") || g.includes("format");
    }
    function d(y) {
      let { shebang: g, text: c2, pragmas: f, comments: E } = l(y), _ = s2(c2), w = n({ pragmas: Object.assign({ format: "" }, f), comments: E.trimStart() });
      return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
    }
    r.exports = { hasPragma: p2, insertPragma: d };
  } }), td = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
    ne();
    var t = _t();
    function s2(a2) {
      return t(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/.test(a2.value);
    }
    r.exports = s2;
  } }), fo = te({ "src/language-js/comments.js"(e, r) {
    ne();
    var { getLast: t, hasNewline: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a2, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p2, getNextNonSpaceNonCommentCharacterIndex: d, isNonEmptyArray: y } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c2, isJsxNode: f, hasFlowShorthandAnnotationComment: E, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: F, getCallArguments: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isLineComment: $2, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m2 } = Ke(), { locStart: C, locEnd: o } = ut(), h2 = _t(), v = td();
    function S(De) {
      return [H, Fe, Q, q2, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
    }
    function b(De) {
      return [R, Fe, V, we, q2, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A) => A(De));
    }
    function B(De) {
      return [H, q2, J, j, ue, ce, ge, de, K, pe, U, oe].some((A) => A(De));
    }
    function k(De, A) {
      let G = (De.body || De.properties).find((re2) => {
        let { type: ye } = re2;
        return ye !== "EmptyStatement";
      });
      G ? i(G, A) : p2(De, A);
    }
    function M(De, A) {
      De.type === "BlockStatement" ? k(De, A) : i(De, A);
    }
    function R(De) {
      let { comment: A, followingNode: G } = De;
      return G && v(A) ? (i(G, A), true) : false;
    }
    function q2(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
      if ((re2 == null ? void 0 : re2.type) !== "IfStatement" || !ye)
        return false;
      if (n(Ce, A, o) === ")")
        return l(G, A), true;
      if (G === re2.consequent && ye === re2.alternate) {
        if (G.type === "BlockStatement")
          l(G, A);
        else {
          let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
          ve && ze ? p2(G, A, m2) : p2(re2, A);
        }
        return true;
      }
      return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re2.consequent === ye ? (i(ye, A), true) : false;
    }
    function J(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
      return (re2 == null ? void 0 : re2.type) !== "WhileStatement" || !ye ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re2.body === ye ? (i(ye, A), true) : false;
    }
    function L(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
      return (re2 == null ? void 0 : re2.type) !== "TryStatement" && (re2 == null ? void 0 : re2.type) !== "CatchClause" || !ye ? false : re2.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
    }
    function Q(De) {
      let { comment: A, enclosingNode: G, followingNode: re2 } = De;
      return I(G) && (re2 == null ? void 0 : re2.type) === "Identifier" ? (i(G, A), true) : false;
    }
    function V(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
      return (!G || !Be) && ((re2 == null ? void 0 : re2.type) === "ConditionalExpression" || (re2 == null ? void 0 : re2.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
    }
    function j(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2 } = De;
      return P(re2) && re2.shorthand && re2.key === G && re2.value.type === "AssignmentPattern" ? (l(re2.value.left, A), true) : false;
    }
    var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
    function ie(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
      if (Y.has(re2 == null ? void 0 : re2.type)) {
        if (y(re2.decorators) && !(ye && ye.type === "Decorator"))
          return l(t(re2.decorators), A), true;
        if (re2.body && ye === re2.body)
          return k(re2.body, A), true;
        if (ye) {
          if (re2.superClass && ye === re2.superClass && G && (G === re2.id || G === re2.typeParameters))
            return l(G, A), true;
          for (let Ce of ["implements", "extends", "mixins"])
            if (re2[Ce] && ye === re2[Ce][0])
              return G && (G === re2.id || G === re2.typeParameters || G === re2.superClass) ? l(G, A) : p2(re2, A, Ce), true;
        }
      }
      return false;
    }
    var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
    function ce(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
      return re2 && G && n(ye, A, o) === "(" && (re2.type === "Property" || re2.type === "TSDeclareMethod" || re2.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re2.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re2 == null ? void 0 : re2.type) ? (l(G, A), true) : false;
    }
    var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
    function K(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
      return n(ye, A, o) !== "(" ? false : G && W.has(re2 == null ? void 0 : re2.type) ? (l(G, A), true) : false;
    }
    function de(De) {
      let { comment: A, enclosingNode: G, text: re2 } = De;
      if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
        return false;
      let ye = d(re2, A, o);
      return ye !== false && re2.slice(ye, ye + 2) === "=>" ? (p2(G, A), true) : false;
    }
    function ue(De) {
      let { comment: A, enclosingNode: G, text: re2 } = De;
      return n(re2, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || F(G) && N(G).length === 0) ? (p2(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p2(G.value, A), true) : false;
    }
    function Fe(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
      if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re2 == null ? void 0 : re2.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re2 && le(re2) && n(Ce, A, o) === ")")
        return l(G, A), true;
      if ((re2 == null ? void 0 : re2.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
        let Be = (() => {
          let ve = g(re2);
          if (ve.length > 0)
            return a2(Ce, o(t(ve)));
          let ze = a2(Ce, o(re2.id));
          return ze !== false && a2(Ce, ze + 1);
        })();
        if (C(A) > Be)
          return k(ye, A), true;
      }
      return false;
    }
    function z(De) {
      let { comment: A, enclosingNode: G } = De;
      return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
    }
    function U(De) {
      let { comment: A, enclosingNode: G } = De;
      return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
    }
    function Z(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2 } = De;
      return x2(re2) && G && re2.callee === G && re2.arguments.length > 0 ? (i(re2.arguments[0], A), true) : false;
    }
    function se(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
      return (re2 == null ? void 0 : re2.type) === "UnionTypeAnnotation" || (re2 == null ? void 0 : re2.type) === "TSUnionType" ? (c2(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c2(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
    }
    function fe(De) {
      let { comment: A, enclosingNode: G } = De;
      return P(G) ? (i(G, A), true) : false;
    }
    function ge(De) {
      let { comment: A, enclosingNode: G, followingNode: re2, ast: ye, isLastComment: Ce } = De;
      return ye && ye.body && ye.body.length === 0 ? (Ce ? p2(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !y(G.directives) ? (Ce ? p2(G, A) : i(G, A), true) : (re2 == null ? void 0 : re2.type) === "Program" && (re2 == null ? void 0 : re2.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p2(re2, A), true) : false;
    }
    function he(De) {
      let { comment: A, enclosingNode: G } = De;
      return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
    }
    function we(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
      if ((re2 == null ? void 0 : re2.type) === "ImportSpecifier" || (re2 == null ? void 0 : re2.type) === "ExportSpecifier")
        return i(re2, A), true;
      let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re2 == null ? void 0 : re2.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re2 == null ? void 0 : re2.type) === "ExportNamedDeclaration";
      return (Ce || Be) && s2(ye, o(A)) ? (l(G, A), true) : false;
    }
    function ke(De) {
      let { comment: A, enclosingNode: G } = De;
      return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
    }
    var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
    function Pe(De) {
      let { comment: A, enclosingNode: G, followingNode: re2 } = De;
      return Re.has(G == null ? void 0 : G.type) && re2 && (Ne.has(re2.type) || h2(A)) ? (i(re2, A), true) : false;
    }
    function oe(De) {
      let { comment: A, enclosingNode: G, followingNode: re2, text: ye } = De;
      return !re2 && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A, o) === ";" ? (l(G, A), true) : false;
    }
    function H(De) {
      let { comment: A, enclosingNode: G, followingNode: re2 } = De;
      if (c2(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re2 == null ? void 0 : re2.type) === "TSTypeParameter" && re2.constraint)
        return G.prettierIgnore = true, A.unignore = true, true;
    }
    function pe(De) {
      let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
      return (re2 == null ? void 0 : re2.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
    }
    function X(De) {
      let { comment: A, enclosingNode: G, followingNode: re2 } = De;
      return !G || G.type !== "SwitchCase" || G.test || !re2 || re2 !== G.consequent[0] ? false : (re2.type === "BlockStatement" && $2(A) ? k(re2, A) : p2(G, A), true);
    }
    function le(De) {
      return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
    }
    function Ae(De, A) {
      if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !y(De.value.typeParameters) && De.value.body)
        return [...De.decorators || [], De.key, De.value.body];
    }
    function Ee(De) {
      let A = De.getValue(), G = De.getParentNode(), re2 = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
      return (A && (f(A) || E(A) || x2(G) && re2(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
    }
    r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
  } }), Ot = te({ "src/language-js/needs-parens.js"(e, r) {
    ne();
    var t = lt(), s2 = Jn(), { getFunctionParameters: a2, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p2, startsWithNoLookaheadToken: d, shouldFlatten: y, getPrecedence: g, isCallExpression: c2, isMemberExpression: f, isObjectProperty: E, isTSTypeExpression: _ } = Ke();
    function w(D, T) {
      let m2 = D.getParentNode();
      if (!m2)
        return false;
      let C = D.getName(), o = D.getNode();
      if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
        return true;
      if (F(o))
        return false;
      if (T.parser !== "flow" && u(D.getValue()))
        return true;
      if (o.type === "Identifier") {
        if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m2.await || o.name === "let") && m2.type === "ForOfStatement")
          return true;
        if (o.name === "let") {
          var h2;
          let S = (h2 = D.findAncestor((b) => b.type === "ForOfStatement")) === null || h2 === void 0 ? void 0 : h2.left;
          if (S && d(S, (b) => b === o))
            return true;
        }
        if (C === "object" && o.name === "let" && m2.type === "MemberExpression" && m2.computed && !m2.optional) {
          let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
          if (b && d(b, (B) => B === o))
            return true;
        }
        return false;
      }
      if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
        var v;
        let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
        if (S && d(S, (b) => b === o))
          return true;
      }
      switch (m2.type) {
        case "ParenthesizedExpression":
          return false;
        case "ClassDeclaration":
        case "ClassExpression": {
          if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
            return true;
          break;
        }
        case "ExportDefaultDeclaration":
          return $2(D, T) || o.type === "SequenceExpression";
        case "Decorator": {
          if (C === "expression") {
            if (f(o) && o.computed)
              return true;
            let S = false, b = false, B = o;
            for (; B; )
              switch (B.type) {
                case "MemberExpression":
                  b = true, B = B.object;
                  break;
                case "CallExpression":
                  if (b || S)
                    return T.parser !== "typescript";
                  S = true, B = B.callee;
                  break;
                case "Identifier":
                  return false;
                case "TaggedTemplateExpression":
                  return T.parser !== "typescript";
                default:
                  return true;
              }
            return true;
          }
          break;
        }
        case "ArrowFunctionExpression": {
          if (C === "body" && o.type !== "SequenceExpression" && d(o, (S) => S.type === "ObjectExpression"))
            return true;
          break;
        }
      }
      switch (o.type) {
        case "UpdateExpression":
          if (m2.type === "UnaryExpression")
            return o.prefix && (o.operator === "++" && m2.operator === "+" || o.operator === "--" && m2.operator === "-");
        case "UnaryExpression":
          switch (m2.type) {
            case "UnaryExpression":
              return o.operator === m2.operator && (o.operator === "+" || o.operator === "-");
            case "BindExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return C === "object";
            case "TaggedTemplateExpression":
              return true;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "BinaryExpression":
              return C === "left" && m2.operator === "**";
            case "TSNonNullExpression":
              return true;
            default:
              return false;
          }
        case "BinaryExpression": {
          if (m2.type === "UpdateExpression" || o.operator === "in" && N(D))
            return true;
          if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
            let S = D.getParentNode(1);
            if (S.type === "BinaryExpression" && S.operator === "|>")
              return true;
          }
        }
        case "TSTypeAssertion":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "LogicalExpression":
          switch (m2.type) {
            case "TSSatisfiesExpression":
            case "TSAsExpression":
              return !_(o);
            case "ConditionalExpression":
              return _(o);
            case "CallExpression":
            case "NewExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "ClassExpression":
            case "ClassDeclaration":
              return C === "superClass";
            case "TSTypeAssertion":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "JSXSpreadAttribute":
            case "SpreadElement":
            case "SpreadProperty":
            case "BindExpression":
            case "AwaitExpression":
            case "TSNonNullExpression":
            case "UpdateExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return C === "object";
            case "AssignmentExpression":
            case "AssignmentPattern":
              return C === "left" && (o.type === "TSTypeAssertion" || _(o));
            case "LogicalExpression":
              if (o.type === "LogicalExpression")
                return m2.operator !== o.operator;
            case "BinaryExpression": {
              let { operator: S, type: b } = o;
              if (!S && b !== "TSTypeAssertion")
                return true;
              let B = g(S), k = m2.operator, M = g(k);
              return M > B || C === "right" && M === B || M === B && !y(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p2(k);
            }
            default:
              return false;
          }
        case "SequenceExpression":
          switch (m2.type) {
            case "ReturnStatement":
              return false;
            case "ForStatement":
              return false;
            case "ExpressionStatement":
              return C !== "expression";
            case "ArrowFunctionExpression":
              return C !== "body";
            default:
              return true;
          }
        case "YieldExpression":
          if (m2.type === "UnaryExpression" || m2.type === "AwaitExpression" || _(m2) || m2.type === "TSNonNullExpression")
            return true;
        case "AwaitExpression":
          switch (m2.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "BindExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return C === "object";
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "ConditionalExpression":
              return C === "test";
            case "BinaryExpression":
              return !(!o.argument && m2.operator === "|>");
            default:
              return false;
          }
        case "TSConditionalType":
        case "TSFunctionType":
        case "TSConstructorType":
          if (C === "extendsType" && m2.type === "TSConditionalType") {
            if (o.type === "TSConditionalType")
              return true;
            let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
            if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
              return true;
          }
          if (C === "checkType" && m2.type === "TSConditionalType")
            return true;
        case "TSUnionType":
        case "TSIntersectionType":
          if ((m2.type === "TSUnionType" || m2.type === "TSIntersectionType") && m2.types.length > 1 && (!o.types || o.types.length > 1))
            return true;
        case "TSInferType":
          if (o.type === "TSInferType" && m2.type === "TSRestType")
            return false;
        case "TSTypeOperator":
          return m2.type === "TSArrayType" || m2.type === "TSOptionalType" || m2.type === "TSRestType" || C === "objectType" && m2.type === "TSIndexedAccessType" || m2.type === "TSTypeOperator" || m2.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
        case "TSTypeQuery":
          return C === "objectType" && m2.type === "TSIndexedAccessType" || C === "elementType" && m2.type === "TSArrayType";
        case "TypeofTypeAnnotation":
          return C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType") || C === "elementType" && m2.type === "ArrayTypeAnnotation";
        case "ArrayTypeAnnotation":
          return m2.type === "NullableTypeAnnotation";
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
          return m2.type === "ArrayTypeAnnotation" || m2.type === "NullableTypeAnnotation" || m2.type === "IntersectionTypeAnnotation" || m2.type === "UnionTypeAnnotation" || C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
        case "NullableTypeAnnotation":
          return m2.type === "ArrayTypeAnnotation" || C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
        case "FunctionTypeAnnotation": {
          let S = m2.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m2;
          return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m2.type === "FunctionTypeParam" && m2.name === null && a2(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
        }
        case "OptionalIndexedAccessType":
          return C === "objectType" && m2.type === "IndexedAccessType";
        case "StringLiteral":
        case "NumericLiteral":
        case "Literal":
          if (typeof o.value == "string" && m2.type === "ExpressionStatement" && !m2.directive) {
            let S = D.getParentNode(1);
            return S.type === "Program" || S.type === "BlockStatement";
          }
          return C === "object" && m2.type === "MemberExpression" && typeof o.value == "number";
        case "AssignmentExpression": {
          let S = D.getParentNode(1);
          return C === "body" && m2.type === "ArrowFunctionExpression" ? true : C === "key" && (m2.type === "ClassProperty" || m2.type === "PropertyDefinition") && m2.computed || (C === "init" || C === "update") && m2.type === "ForStatement" ? false : m2.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m2.type === "TSPropertySignature" || m2.type === "AssignmentExpression" || m2.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m2 || S.update === m2) || C === "value" && m2.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m2) || m2.type === "NGChainedExpression");
        }
        case "ConditionalExpression":
          switch (m2.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "BinaryExpression":
            case "LogicalExpression":
            case "NGPipeExpression":
            case "ExportDefaultDeclaration":
            case "AwaitExpression":
            case "JSXSpreadAttribute":
            case "TSTypeAssertion":
            case "TypeCastExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
              return true;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "ConditionalExpression":
              return C === "test";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return C === "object";
            default:
              return false;
          }
        case "FunctionExpression":
          switch (m2.type) {
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "TaggedTemplateExpression":
              return true;
            default:
              return false;
          }
        case "ArrowFunctionExpression":
          switch (m2.type) {
            case "BinaryExpression":
              return m2.operator !== "|>" || o.extra && o.extra.parenthesized;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return C === "callee";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return C === "object";
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "BindExpression":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "AwaitExpression":
            case "TSTypeAssertion":
              return true;
            case "ConditionalExpression":
              return C === "test";
            default:
              return false;
          }
        case "ClassExpression":
          if (s2(o.decorators))
            return true;
          switch (m2.type) {
            case "NewExpression":
              return C === "callee";
            default:
              return false;
          }
        case "OptionalMemberExpression":
        case "OptionalCallExpression": {
          let S = D.getParentNode(1);
          if (C === "object" && m2.type === "MemberExpression" || C === "callee" && (m2.type === "CallExpression" || m2.type === "NewExpression") || m2.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m2)
            return true;
        }
        case "CallExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "TSNonNullExpression":
          if (C === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression")) {
            let S = o;
            for (; S; )
              switch (S.type) {
                case "CallExpression":
                case "OptionalCallExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                case "BindExpression":
                  S = S.object;
                  break;
                case "TaggedTemplateExpression":
                  S = S.tag;
                  break;
                case "TSNonNullExpression":
                  S = S.expression;
                  break;
                default:
                  return false;
              }
          }
          return false;
        case "BindExpression":
          return C === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression") || C === "object" && f(m2);
        case "NGPipeExpression":
          return !(m2.type === "NGRoot" || m2.type === "NGMicrosyntaxExpression" || m2.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m2.type === "ArrayExpression" || c2(m2) && m2.arguments[C] === o || C === "right" && m2.type === "NGPipeExpression" || C === "property" && m2.type === "MemberExpression" || m2.type === "AssignmentExpression");
        case "JSXFragment":
        case "JSXElement":
          return C === "callee" || C === "left" && m2.type === "BinaryExpression" && m2.operator === "<" || m2.type !== "ArrayExpression" && m2.type !== "ArrowFunctionExpression" && m2.type !== "AssignmentExpression" && m2.type !== "AssignmentPattern" && m2.type !== "BinaryExpression" && m2.type !== "NewExpression" && m2.type !== "ConditionalExpression" && m2.type !== "ExpressionStatement" && m2.type !== "JsExpressionRoot" && m2.type !== "JSXAttribute" && m2.type !== "JSXElement" && m2.type !== "JSXExpressionContainer" && m2.type !== "JSXFragment" && m2.type !== "LogicalExpression" && !c2(m2) && !E(m2) && m2.type !== "ReturnStatement" && m2.type !== "ThrowStatement" && m2.type !== "TypeCastExpression" && m2.type !== "VariableDeclarator" && m2.type !== "YieldExpression";
        case "TypeAnnotation":
          return C === "returnType" && m2.type === "ArrowFunctionExpression" && x2(o);
      }
      return false;
    }
    function F(D) {
      return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
    }
    function N(D) {
      let T = 0, m2 = D.getValue();
      for (; m2; ) {
        let C = D.getParentNode(T++);
        if (C && C.type === "ForStatement" && C.init === m2)
          return true;
        m2 = C;
      }
      return false;
    }
    function x2(D) {
      return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m2) => m2.type === "FunctionTypeAnnotation" || void 0) || void 0);
    }
    function I(D) {
      switch (D.type) {
        case "ObjectExpression":
          return true;
        default:
          return false;
      }
    }
    function P(D) {
      let T = D.getValue(), m2 = D.getParentNode(), C = D.getName();
      switch (m2.type) {
        case "NGPipeExpression":
          if (typeof C == "number" && m2.arguments[C] === T && m2.arguments.length - 1 === C)
            return D.callParent(P);
          break;
        case "ObjectProperty":
          if (C === "value") {
            let o = D.getParentNode(1);
            return t(o.properties) === m2;
          }
          break;
        case "BinaryExpression":
        case "LogicalExpression":
          if (C === "right")
            return D.callParent(P);
          break;
        case "ConditionalExpression":
          if (C === "alternate")
            return D.callParent(P);
          break;
        case "UnaryExpression":
          if (m2.prefix)
            return D.callParent(P);
          break;
      }
      return false;
    }
    function $2(D, T) {
      let m2 = D.getValue(), C = D.getParentNode();
      return m2.type === "FunctionExpression" || m2.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m2) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $2(o, T), ...n(D, m2));
    }
    r.exports = w;
  } }), Do = te({ "src/language-js/print-preprocess.js"(e, r) {
    ne();
    function t(s2, a2) {
      switch (a2.parser) {
        case "json":
        case "json5":
        case "json-stringify":
        case "__js_expression":
        case "__vue_expression":
        case "__vue_ts_expression":
          return Object.assign(Object.assign({}, s2), {}, { type: a2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s2, comments: [], rootMarker: a2.rootMarker });
        default:
          return s2;
      }
    }
    r.exports = t;
  } }), rd = te({ "src/language-js/print/html-binding.js"(e, r) {
    ne();
    var { builders: { join: t, line: s2, group: a2, softline: n, indent: u } } = qe();
    function i(p2, d, y) {
      let g = p2.getValue();
      if (d.__onHtmlBindingRoot && p2.getName() === null && d.__onHtmlBindingRoot(g, d), g.type === "File") {
        if (d.__isVueForBindingLeft)
          return p2.call((c2) => {
            let f = t([",", s2], c2.map(y, "params")), { params: E } = c2.getValue();
            return E.length === 1 ? f : ["(", u([n, a2(f)]), n, ")"];
          }, "program", "body", 0);
        if (d.__isVueBindings)
          return p2.call((c2) => t([",", s2], c2.map(y, "params")), "program", "body", 0);
      }
    }
    function l(p2) {
      switch (p2.type) {
        case "MemberExpression":
          switch (p2.property.type) {
            case "Identifier":
            case "NumericLiteral":
            case "StringLiteral":
              return l(p2.object);
          }
          return false;
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
  } }), Zn = te({ "src/language-js/print/binaryish.js"(e, r) {
    ne();
    var { printComments: t } = et(), { getLast: s2 } = Ue(), { builders: { join: a2, line: n, softline: u, group: i, indent: l, align: p2, indentIfBreak: d }, utils: { cleanDoc: y, getDocParts: g, isConcat: c2 } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: E, isJsxNode: _, shouldFlatten: w, hasComment: F, CommentCheckFlags: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $2 } = Ke(), D = 0;
    function T(o, h2, v) {
      let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $2(h2) && S.operator === "|>", R = m2(o, v, h2, false, k);
      if (k)
        return R;
      if (M)
        return i(R);
      if (x2(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
        return i([l([u, ...R]), u]);
      let q2 = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && h2.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x2(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = E(S.left) && w(S.operator, S.left.operator);
      if (q2 || C(S) && !L || !C(S) && J)
        return i(R);
      if (R.length === 0)
        return "";
      let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
      if (!Q)
        return ee;
      let ce = s2(R);
      return i([ee, d(ce, { groupId: ie })]);
    }
    function m2(o, h2, v, S, b) {
      let B = o.getValue();
      if (!E(B))
        return [i(h2())];
      let k = [];
      w(B.operator, B.left.operator) ? k = o.call((Y) => m2(Y, h2, v, true, b), "left") : k.push(i(h2("left")));
      let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q2 = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a2([n, ": "], o.map(h2, "arguments").map((Y) => p2(2, i(Y))))])) : "", L;
      if (M)
        L = [q2, " ", h2("right"), J];
      else {
        let ie = $2(v) && q2 === "|>" ? o.call((ee) => m2(ee, h2, v, true, b), "right") : h2("right");
        L = [R ? n : "", q2, R ? " " : n, ie, J];
      }
      let Q = o.getParentNode(), V = F(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
      if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && F(B)) {
        let Y = y(t(o, k, v));
        return c2(Y) || Y.type === "fill" ? g(Y) : [Y];
      }
      return k;
    }
    function C(o) {
      return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
    }
    r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
  } }), nd = te({ "src/language-js/print/angular.js"(e, r) {
    ne();
    var { builders: { join: t, line: s2, group: a2 } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = Zn();
    function p2(g, c2, f) {
      let E = g.getValue();
      if (E.type.startsWith("NG"))
        switch (E.type) {
          case "NGRoot":
            return [f("node"), u(E.node) ? " //" + i(E.node)[0].value.trimEnd() : ""];
          case "NGPipeExpression":
            return l(g, c2, f);
          case "NGChainedExpression":
            return a2(t([";", s2], g.map((_) => y(_) ? f() : ["(", f(), ")"], "expressions")));
          case "NGEmptyExpression":
            return "";
          case "NGQuotedExpression":
            return [E.prefix, ": ", E.value.trim()];
          case "NGMicrosyntax":
            return g.map((_, w) => [w === 0 ? "" : d(_.getValue(), w, E) ? " " : [";", s2], f()], "body");
          case "NGMicrosyntaxKey":
            return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(E.name) ? E.name : JSON.stringify(E.name);
          case "NGMicrosyntaxExpression":
            return [f("expression"), E.alias === null ? "" : [" as ", f("alias")]];
          case "NGMicrosyntaxKeyedExpression": {
            let _ = g.getName(), w = g.getParentNode(), F = d(E, _, w) || (_ === 1 && (E.key.name === "then" || E.key.name === "else") || _ === 2 && E.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
            return [f("key"), F ? " " : ": ", f("expression")];
          }
          case "NGMicrosyntaxLet":
            return ["let ", f("key"), E.value === null ? "" : [" = ", f("value")]];
          case "NGMicrosyntaxAs":
            return [f("key"), " as ", f("alias")];
          default:
            throw new Error(`Unknown Angular node type: ${JSON.stringify(E.type)}.`);
        }
    }
    function d(g, c2, f) {
      return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c2 === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
    }
    function y(g) {
      return n(g.getValue(), (c2) => {
        switch (c2.type) {
          case void 0:
            return false;
          case "CallExpression":
          case "OptionalCallExpression":
          case "AssignmentExpression":
            return true;
        }
      });
    }
    r.exports = { printAngular: p2 };
  } }), ud = te({ "src/language-js/print/jsx.js"(e, r) {
    ne();
    var { printComments: t, printDanglingComments: s2, printCommentsSeparately: a2 } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p2, conditionalGroup: d, fill: y, ifBreak: g, lineSuffixBoundary: c2, join: f }, utils: { willBreak: E } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: F, rawText: N, isCallExpression: x2, isStringLiteral: I, isBinaryish: P, hasComment: $2, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m2 = Ot(), { willPrintOwnComments: C } = fo(), o = (U) => U === "" || U === n || U === u || U === i;
    function h2(U, Z, se) {
      let fe = U.getValue();
      if (fe.type === "JSXElement" && de(fe))
        return [se("openingElement"), se("closingElement")];
      let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
      if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
        return [ge, ...U.map(se, "children"), he];
      fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
      let we = fe.children.some(F), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = E(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A) => ue(A));
      for (let A = X.length - 2; A >= 0; A--) {
        let G = X[A] === "" && X[A + 1] === "", re2 = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
        re2 && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
      }
      for (; X.length > 0 && o(_(X)); )
        X.pop();
      for (; X.length > 1 && o(X[0]) && o(X[1]); )
        X.shift(), X.shift();
      let Ae = [];
      for (let [A, G] of X.entries()) {
        if (G === H) {
          if (A === 1 && X[A - 1] === "") {
            if (X.length === 2) {
              Ae.push(oe);
              continue;
            }
            Ae.push([oe, u]);
            continue;
          } else if (A === X.length - 1) {
            Ae.push(oe);
            continue;
          } else if (X[A - 1] === "" && X[A - 2] === u) {
            Ae.push(oe);
            continue;
          }
        }
        Ae.push(G), E(G) && (Ne = true);
      }
      let Ee = le ? y(Ae) : l(Ae, { shouldBreak: true });
      if (Pe)
        return Ee;
      let De = l([ge, p2([u, Ee]), u, he]);
      return Ne ? De : d([l([ge, ...X, he]), De]);
    }
    function v(U, Z, se, fe, ge) {
      let he = [];
      return U.each((we, ke, Re) => {
        let Ne = we.getValue();
        if (Ne.type === "JSXText") {
          let Pe = N(Ne);
          if (ue(Ne)) {
            let oe = Pe.split(ce);
            if (oe[0] === "") {
              if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                let pe = Re[ke + 1];
                he.push(b(ge, oe[1], Ne, pe));
              } else
                he.push(fe);
              oe.shift();
            }
            let H;
            if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
              return;
            for (let [pe, X] of oe.entries())
              pe % 2 === 1 ? he.push(n) : he.push(X);
            if (H !== void 0)
              if (/\n/.test(H)) {
                let pe = Re[ke + 1];
                he.push(b(ge, _(he), Ne, pe));
              } else
                he.push(fe);
            else {
              let pe = Re[ke + 1];
              he.push(S(ge, _(he), Ne, pe));
            }
          } else
            /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
        } else {
          let Pe = se();
          he.push(Pe);
          let oe = Re[ke + 1];
          if (oe && ue(oe)) {
            let pe = K(N(oe)).split(ce)[0];
            he.push(S(ge, pe, Ne, oe));
          } else
            he.push(u);
        }
      }, "children"), he;
    }
    function S(U, Z, se, fe) {
      return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
    }
    function b(U, Z, se, fe) {
      return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
    }
    function B(U, Z, se) {
      let fe = U.getParentNode();
      if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
        return Z;
      let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x2, (ke) => ke.type === "JSXExpressionContainer"), we = m2(U, se);
      return l([we ? "" : g("("), p2([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
    }
    function k(U, Z, se) {
      let fe = U.getValue(), ge = [];
      if (ge.push(se("name")), fe.value) {
        let he;
        if (I(fe.value)) {
          let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
          ke = ke.replace(Pe, Re);
          let { leading: oe, trailing: H } = U.call(() => a2(U, Z), "value");
          he = [oe, Ne, ke, Ne, H];
        } else
          he = se("value");
        ge.push("=", he);
      }
      return ge;
    }
    function M(U, Z, se) {
      let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$2(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x2(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || F(we) && (he.type === "ConditionalExpression" || P(he)));
      return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c2, "}"]) : l(["{", p2([i, se("expression")]), i, c2, "}"]);
    }
    function R(U, Z, se) {
      let fe = U.getValue(), ge = fe.name && $2(fe.name) || fe.typeParameters && $2(fe.typeParameters);
      if (fe.selfClosing && fe.attributes.length === 0 && !ge)
        return ["<", se("name"), se("typeParameters"), " />"];
      if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$2(fe.attributes[0]))
        return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
      let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
      return l(["<", se("name"), se("typeParameters"), p2(U.map(() => [we, se()], "attributes")), ...q2(fe, Z, ge)], { shouldBreak: he });
    }
    function q2(U, Z, se) {
      return U.selfClosing ? [n, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
    }
    function J(U, Z, se) {
      let fe = U.attributes.length > 0 && $2(_(U.attributes), D.Trailing);
      return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
    }
    function L(U, Z, se) {
      let fe = U.getValue(), ge = [];
      ge.push("</");
      let he = se("name");
      return $2(fe.name, D.Leading | D.Line) ? ge.push(p2([u, he]), u) : $2(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
    }
    function Q(U, Z) {
      let se = U.getValue(), fe = $2(se), ge = $2(se, D.Line), he = se.type === "JSXOpeningFragment";
      return [he ? "<" : "</", p2([ge ? u : fe && !he ? " " : "", s2(U, Z, true)]), ge ? u : "", ">"];
    }
    function V(U, Z, se) {
      let fe = t(U, h2(U, Z, se), Z);
      return B(U, fe, Z);
    }
    function j(U, Z) {
      let se = U.getValue(), fe = $2(se, D.Line);
      return [s2(U, Z, !fe), fe ? u : ""];
    }
    function Y(U, Z, se) {
      let fe = U.getValue();
      return ["{", U.call((ge) => {
        let he = ["...", se()], we = ge.getValue();
        return !$2(we) || !C(ge) ? he : [p2([i, t(ge, he, Z)]), i];
      }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
    }
    function ie(U, Z, se) {
      let fe = U.getValue();
      if (fe.type.startsWith("JSX"))
        switch (fe.type) {
          case "JSXAttribute":
            return k(U, Z, se);
          case "JSXIdentifier":
            return String(fe.name);
          case "JSXNamespacedName":
            return f(":", [se("namespace"), se("name")]);
          case "JSXMemberExpression":
            return f(".", [se("object"), se("property")]);
          case "JSXSpreadAttribute":
            return Y(U, Z, se);
          case "JSXSpreadChild":
            return Y(U, Z, se);
          case "JSXExpressionContainer":
            return M(U, Z, se);
          case "JSXFragment":
          case "JSXElement":
            return V(U, Z, se);
          case "JSXOpeningElement":
            return R(U, Z, se);
          case "JSXClosingElement":
            return L(U, Z, se);
          case "JSXOpeningFragment":
          case "JSXClosingFragment":
            return Q(U, Z);
          case "JSXEmptyExpression":
            return j(U, Z);
          case "JSXText":
            throw new Error("JSXText should be handled by JSXElement");
          default:
            throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
        }
    }
    var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
    function de(U) {
      if (U.children.length === 0)
        return true;
      if (U.children.length > 1)
        return false;
      let Z = U.children[0];
      return Z.type === "JSXText" && !ue(Z);
    }
    function ue(U) {
      return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
    }
    function Fe(U) {
      return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$2(U.expression);
    }
    function z(U) {
      let Z = U.getValue(), se = U.getParentNode();
      if (!se || !Z || !F(Z) || !F(se))
        return false;
      let fe = se.children.indexOf(Z), ge = null;
      for (let he = fe; he > 0; he--) {
        let we = se.children[he - 1];
        if (!(we.type === "JSXText" && !ue(we))) {
          ge = we;
          break;
        }
      }
      return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
    }
    r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
  } }), ct = te({ "src/language-js/print/misc.js"(e, r) {
    ne();
    var { isNonEmptyArray: t } = Ue(), { builders: { indent: s2, join: a2, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
    function i(_) {
      let w = _.getValue();
      return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
    }
    function l(_) {
      return _.getValue().definite || _.match(void 0, (w, F) => F === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
    }
    function p2(_, w, F) {
      let N = _.getValue();
      return N.typeArguments ? F("typeArguments") : N.typeParameters ? F("typeParameters") : "";
    }
    function d(_, w, F) {
      let N = _.getValue();
      if (!N.typeAnnotation)
        return "";
      let x2 = _.getParentNode(), I = x2.type === "DeclareFunction" && x2.id === N;
      return u(w.originalText, N.typeAnnotation) ? [" /*: ", F("typeAnnotation"), " */"] : [I ? "" : ": ", F("typeAnnotation")];
    }
    function y(_, w, F) {
      return ["::", F("callee")];
    }
    function g(_, w, F) {
      let N = _.getValue();
      return t(N.modifiers) ? [a2(" ", _.map(F, "modifiers")), " "] : "";
    }
    function c2(_, w, F) {
      return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || F ? [" ", w] : s2([n, w]);
    }
    function f(_, w, F) {
      return ["...", F("argument"), d(_, w, F)];
    }
    function E(_, w) {
      let F = _.slice(1, -1);
      if (F.includes('"') || F.includes("'"))
        return _;
      let N = w.singleQuote ? "'" : '"';
      return N + F + N;
    }
    r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p2, printBindExpressionCallee: y, printTypeScriptModifiers: g, printTypeAnnotation: d, printRestSpread: f, adjustClause: c2, printDirective: E };
  } }), Qt = te({ "src/language-js/print/array.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { builders: { line: s2, softline: a2, hardline: n, group: u, indent: i, ifBreak: l, fill: p2 } } = qe(), { getLast: d, hasNewline: y } = Ue(), { shouldPrintComma: g, hasComment: c2, CommentCheckFlags: f, isNextLineEmpty: E, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: F } = ut(), { printOptionalToken: N, printTypeAnnotation: x2 } = ct();
    function I(T, m2, C) {
      let o = T.getValue(), h2 = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
      if (o.elements.length === 0)
        c2(o, f.Dangling) ? h2.push(u([v, t(T, m2), a2, S])) : h2.push(v, S);
      else {
        let b = d(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m2.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
          let j = L && L.type;
          if (j !== "ArrayExpression" && j !== "ObjectExpression")
            return false;
          let Y = V[Q + 1];
          if (Y && j !== Y.type)
            return false;
          let ie = j === "ArrayExpression" ? "elements" : "properties";
          return L[ie] && L[ie].length > 1;
        }), q2 = P(o, m2), J = B ? k ? "," : g(m2) ? q2 ? l(",", "", { groupId: M }) : l(",") : "" : "";
        h2.push(u([v, i([a2, q2 ? D(T, m2, C, J) : [$2(T, m2, "elements", C), J], t(T, m2, true)]), a2, S], { shouldBreak: R, id: M }));
      }
      return h2.push(N(T), x2(T, m2, C)), h2;
    }
    function P(T, m2) {
      return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c2(C.argument)) && !c2(C, f.Trailing | f.Line, (o) => !y(m2.originalText, F(o), { backwards: true })));
    }
    function $2(T, m2, C, o) {
      let h2 = [], v = [];
      return T.each((S) => {
        h2.push(v, u(o())), v = [",", s2], S.getValue() && E(S.getValue(), m2) && v.push(a2);
      }, C), h2;
    }
    function D(T, m2, C, o) {
      let h2 = [];
      return T.each((v, S, b) => {
        let B = S === b.length - 1;
        h2.push([C(), B ? o : ","]), B || h2.push(E(v.getValue(), m2) ? [n, n] : c2(b[S + 1], f.Leading | f.Line) ? n : s2);
      }, "elements"), p2(h2);
    }
    r.exports = { printArray: I, printArrayItems: $2, isConciselyPrintedArray: P };
  } }), mo = te({ "src/language-js/print/call-arguments.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { getLast: s2, getPenultimate: a2 } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p2, isLongCurriedCallExpression: d, shouldPrintComma: y, getCallArguments: g, iterateCallArgumentsPath: c2, isNextLineEmpty: f, isCallExpression: E, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: F } = Ke(), { builders: { line: N, hardline: x2, softline: I, group: P, indent: $2, conditionalGroup: D, ifBreak: T, breakParent: m2 }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Kt(), { isConciselyPrintedArray: h2 } = Qt();
    function v(q2, J, L) {
      let Q = q2.getValue(), V = Q.type === "ImportExpression", j = g(Q);
      if (j.length === 0)
        return ["(", t(q2, J, true), ")"];
      if (k(j))
        return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
      let Y = false, ie = false, ee = j.length - 1, ce = [];
      c2(q2, (z, U) => {
        let Z = z.getNode(), se = [L()];
        U === ee || (f(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x2, x2)) : se.push(",", N)), ce.push(se);
      });
      let W = !(V || Q.callee && Q.callee.type === "Import") && y(J, "all") ? "," : "";
      function K() {
        return P(["(", $2([N, ...ce]), W, N, ")"], { shouldBreak: true });
      }
      if (Y || q2.getParentNode().type !== "Decorator" && l(j))
        return K();
      let de = B(j), ue = b(j, J);
      if (de || ue) {
        if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C))
          return K();
        let z = [];
        try {
          q2.try(() => {
            c2(q2, (U, Z) => {
              de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x2 : N, ie ? x2 : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
            });
          });
        } catch (U) {
          if (U instanceof o)
            return K();
          throw U;
        }
        return [ce.some(C) ? m2 : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s2(z), { shouldBreak: true }), ")"], K()])];
      }
      let Fe = ["(", $2([I, ...ce]), T(W), I, ")"];
      return d(q2) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
    }
    function S(q2) {
      let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return q2.type === "ObjectExpression" && (q2.properties.length > 0 || u(q2)) || q2.type === "ArrayExpression" && (q2.elements.length > 0 || u(q2)) || q2.type === "TSTypeAssertion" && S(q2.expression) || F(q2) && S(q2.expression) || q2.type === "FunctionExpression" || q2.type === "ArrowFunctionExpression" && (!q2.returnType || !q2.returnType.typeAnnotation || q2.returnType.typeAnnotation.type !== "TSTypeReference" || M(q2.body)) && (q2.body.type === "BlockStatement" || q2.body.type === "ArrowFunctionExpression" && S(q2.body, true) || q2.body.type === "ObjectExpression" || q2.body.type === "ArrayExpression" || !J && (E(q2.body) || q2.body.type === "ConditionalExpression") || p2(q2.body)) || q2.type === "DoExpression" || q2.type === "ModuleExpression";
    }
    function b(q2, J) {
      let L = s2(q2), Q = a2(q2);
      return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q2.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q2.length > 1 && L.type === "ArrayExpression" && h2(L, J));
    }
    function B(q2) {
      if (q2.length !== 2)
        return false;
      let [J, L] = q2;
      return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
    }
    function k(q2) {
      return q2.length === 2 && q2[0].type === "ArrowFunctionExpression" && n(q2[0]).length === 0 && q2[0].body.type === "BlockStatement" && q2[1].type === "ArrayExpression" && !q2.some((J) => u(J));
    }
    function M(q2) {
      return q2.type === "BlockStatement" && (q2.body.some((J) => J.type !== "EmptyStatement") || u(q2, i.Dangling));
    }
    function R(q2) {
      return q2.type === "ObjectExpression" && q2.properties.length === 1 && w(q2.properties[0]) && q2.properties[0].key.type === "Identifier" && q2.properties[0].key.name === "type" && _(q2.properties[0].value) && q2.properties[0].value.value === "module";
    }
    r.exports = v;
  } }), go = te({ "src/language-js/print/member.js"(e, r) {
    ne();
    var { builders: { softline: t, group: s2, indent: a2, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p2 } = ct();
    function d(g, c2, f) {
      let E = g.getValue(), _ = g.getParentNode(), w, F = 0;
      do
        w = g.getParentNode(F), F++;
      while (w && (i(w) || w.type === "TSNonNullExpression"));
      let N = f("object"), x2 = y(g, c2, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || E.computed || E.object.type === "Identifier" && E.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(E.object) && E.object.arguments.length > 0 || E.object.type === "TSNonNullExpression" && l(E.object.expression) && E.object.expression.arguments.length > 0 || N.label === "member-chain");
      return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x2 : s2(a2([t, x2]))]);
    }
    function y(g, c2, f) {
      let E = f("property"), _ = g.getValue(), w = p2(g);
      return _.computed ? !_.property || u(_.property) ? [w, "[", E, "]"] : s2([w, "[", a2([t, E]), t, "]"]) : [w, ".", E];
    }
    r.exports = { printMemberExpression: d, printMemberLookup: y };
  } }), sd = te({ "src/language-js/print/member-chain.js"(e, r) {
    ne();
    var { printComments: t } = et(), { getLast: s2, isNextLineEmptyAfterIndex: a2, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = Ot(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p2, isLongCurriedCallExpression: d, isMemberish: y, isNumericLiteral: g, isSimpleCallArgument: c2, hasComment: f, CommentCheckFlags: E, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: F, hardline: N, group: x2, indent: I, conditionalGroup: P, breakParent: $2, label: D }, utils: { willBreak: T } } = qe(), m2 = mo(), { printMemberLookup: C } = go(), { printOptionalToken: o, printFunctionTypeParameters: h2, printBindExpressionCallee: v } = ct();
    function S(b, B, k) {
      let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q2 = [];
      function J(Ne) {
        let { originalText: Pe } = B, oe = n(Pe, Ne, w);
        return Pe.charAt(oe) === ")" ? oe !== false && a2(Pe, oe + 1) : _(Ne, B);
      }
      function L(Ne) {
        let Pe = Ne.getValue();
        i(Pe) && (y(Pe.callee) || i(Pe.callee)) ? (q2.unshift({ node: Pe, printed: [t(Ne, [o(Ne), h2(Ne, B, k), m2(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : y(Pe) ? (q2.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q2.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q2.unshift({ node: Pe, printed: k() });
      }
      let Q = b.getValue();
      q2.unshift({ node: Q, printed: [o(b), h2(b, B, k), m2(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
      let V = [], j = [q2[0]], Y = 1;
      for (; Y < q2.length && (q2[Y].node.type === "TSNonNullExpression" || i(q2[Y].node) || l(q2[Y].node) && q2[Y].node.computed && g(q2[Y].node.property)); ++Y)
        j.push(q2[Y]);
      if (!i(q2[0].node))
        for (; Y + 1 < q2.length && (y(q2[Y].node) && y(q2[Y + 1].node)); ++Y)
          j.push(q2[Y]);
      V.push(j), j = [];
      let ie = false;
      for (; Y < q2.length; ++Y) {
        if (ie && y(q2[Y].node)) {
          if (q2[Y].node.computed && g(q2[Y].node.property)) {
            j.push(q2[Y]);
            continue;
          }
          V.push(j), j = [], ie = false;
        }
        (i(q2[Y].node) || q2[Y].node.type === "ImportExpression") && (ie = true), j.push(q2[Y]), f(q2[Y].node, E.Trailing) && (V.push(j), j = [], ie = false);
      }
      j.length > 0 && V.push(j);
      function ee(Ne) {
        return /^[A-Z]|^[$_]+$/.test(Ne);
      }
      function ce(Ne) {
        return Ne.length <= B.tabWidth;
      }
      function W(Ne) {
        let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
        if (Ne[0].length === 1) {
          let H = Ne[0][0].node;
          return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
        }
        let oe = s2(Ne[0]).node;
        return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
      }
      let K = V.length >= 2 && !f(V[1][0].node) && W(V);
      function de(Ne) {
        let Pe = Ne.map((oe) => oe.printed);
        return Ne.length > 0 && s2(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
      }
      function ue(Ne) {
        return Ne.length === 0 ? "" : I(x2([N, F(N, Ne.map(de))]));
      }
      let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, E.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, E.Trailing)) || V[U] && f(V[U][0].node, E.Leading);
      if (V.length <= U && !se)
        return d(b) ? z : x2(z);
      let fe = s2(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q2.map((Ne) => {
        let { node: Pe } = Ne;
        return Pe;
      }).filter(i);
      function ke() {
        let Ne = s2(s2(V)).node, Pe = s2(Fe);
        return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p2));
      }
      let Re;
      return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c2(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x2(he) : Re = [T(z) || ge ? $2 : "", P([z, he])], D("member-chain", Re);
    }
    r.exports = S;
  } }), yo = te({ "src/language-js/print/call-expression.js"(e, r) {
    ne();
    var { builders: { join: t, group: s2 } } = qe(), a2 = Ot(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p2, isTemplateOnItsOwnLine: d, isTestCall: y, iterateCallArgumentsPath: g } = Ke(), c2 = sd(), f = mo(), { printOptionalToken: E, printFunctionTypeParameters: _ } = ct();
    function w(N, x2, I) {
      let P = N.getValue(), $2 = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m2 = E(N), C = n(P);
      if (C.length > 0 && (!T && !D && F(P, $2) || C.length === 1 && d(C[0], x2.originalText) || !D && y(P, $2))) {
        let v = [];
        return g(N, () => {
          v.push(I());
        }), [D ? "new " : "", I("callee"), m2, _(N, x2, I), "(", t(", ", v), ")"];
      }
      let o = (x2.parser === "babel" || x2.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
      if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a2(v, x2), "callee"))
        return c2(N, x2, I);
      let h2 = [D ? "new " : "", T ? "import" : I("callee"), m2, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x2, I), f(N, x2, I)];
      return T || i(P.callee) ? s2(h2) : h2;
    }
    function F(N, x2) {
      if (N.callee.type !== "Identifier")
        return false;
      if (N.callee.name === "require")
        return true;
      if (N.callee.name === "define") {
        let I = n(N);
        return x2.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p2(I[0]) && I[1].type === "ArrayExpression");
      }
      return false;
    }
    r.exports = { printCallExpression: w };
  } }), Zt = te({ "src/language-js/print/assignment.js"(e, r) {
    ne();
    var { isNonEmptyArray: t, getStringWidth: s2 } = Ue(), { builders: { line: a2, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p2, willBreak: d, canBreak: y } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c2, isStringLiteral: f, isLiteral: E, isNumericLiteral: _, isCallExpression: w, isMemberExpression: F, getCallArguments: N, rawText: x2, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $2 } = Ke(), { shouldInlineLogicalExpression: D } = Zn(), { printCallExpression: T } = yo();
    function m2(W, K, de, ue, Fe, z) {
      let U = h2(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
      switch (U) {
        case "break-after-operator":
          return n([n(ue), Fe, n(u([a2, Z]))]);
        case "never-break-after-operator":
          return n([n(ue), Fe, " ", Z]);
        case "fluid": {
          let se = Symbol("assignment");
          return n([n(ue), Fe, n(u(a2), { id: se }), l, i(Z, { groupId: se })]);
        }
        case "break-lhs":
          return n([ue, Fe, " ", n(Z)]);
        case "chain":
          return [n(ue), Fe, a2, Z];
        case "chain-tail":
          return [n(ue), Fe, u([a2, Z])];
        case "chain-tail-arrow-chain":
          return [n(ue), Fe, Z];
        case "only-left":
          return ue;
      }
    }
    function C(W, K, de) {
      let ue = W.getValue();
      return m2(W, K, de, de("left"), [" ", ue.operator], "right");
    }
    function o(W, K, de) {
      return m2(W, K, de, de("id"), " =", "init");
    }
    function h2(W, K, de, ue, Fe) {
      let z = W.getValue(), U = z[Fe];
      if (!U)
        return "only-left";
      let Z = !b(U);
      if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
        return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
      if (!Z && b(U.right) || g(K.originalText, U))
        return "break-after-operator";
      if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json")
        return "never-break-after-operator";
      if (S(z) || k(z) || q2(z) || J(z) && y(ue))
        return "break-lhs";
      let ge = ie(z, ue, K);
      return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
    }
    function v(W, K, de, ue) {
      let Fe = W.getValue();
      if (c2(Fe) && !D(Fe))
        return true;
      switch (Fe.type) {
        case "StringLiteralTypeAnnotation":
        case "SequenceExpression":
          return true;
        case "ConditionalExpression": {
          let { test: Z } = Fe;
          return c2(Z) && !D(Z);
        }
        case "ClassExpression":
          return t(Fe.decorators);
      }
      if (ue)
        return false;
      let z = Fe, U = [];
      for (; ; )
        if (z.type === "UnaryExpression")
          z = z.argument, U.push("argument");
        else if (z.type === "TSNonNullExpression")
          z = z.expression, U.push("expression");
        else
          break;
      return !!(f(z) || W.call(() => V(W, K, de), ...U));
    }
    function S(W) {
      if (B(W)) {
        let K = W.left || W.id;
        return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $2(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
      }
      return false;
    }
    function b(W) {
      return W.type === "AssignmentExpression";
    }
    function B(W) {
      return b(W) || W.type === "VariableDeclarator";
    }
    function k(W) {
      let K = M(W);
      if (t(K)) {
        let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
        if (K.length > 1 && K.some((ue) => ue[de] || ue.default))
          return true;
      }
      return false;
    }
    function M(W) {
      return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
    }
    function R(W) {
      return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
    }
    function q2(W) {
      if (W.type !== "VariableDeclarator")
        return false;
      let { typeAnnotation: K } = W.id;
      if (!K || !K.typeAnnotation)
        return false;
      let de = L(K.typeAnnotation);
      return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
    }
    function J(W) {
      return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
    }
    function L(W) {
      return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
    }
    function Q(W) {
      return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
    }
    function V(W, K, de) {
      let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
      if (Fe.type === "TSNonNullExpression")
        return W.call(z, "expression");
      if (w(Fe)) {
        if (T(W, K, de).label === "member-chain")
          return false;
        let Z = N(Fe);
        return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
      }
      return F(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
    }
    var j = 0.25;
    function Y(W, K) {
      let { printWidth: de } = K;
      if (I(W))
        return false;
      let ue = de * j;
      if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument))
        return true;
      let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
      return Fe ? Fe.length <= ue : f(W) ? x2(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : E(W);
    }
    function ie(W, K, de) {
      if (!$2(W))
        return false;
      K = p2(K);
      let ue = 3;
      return typeof K == "string" && s2(K) < de.tabWidth + ue;
    }
    function ee(W, K) {
      let de = ce(W);
      if (t(de)) {
        if (de.length > 1)
          return true;
        if (de.length === 1) {
          let Fe = de[0];
          if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation")
            return true;
        }
        let ue = W.typeParameters ? "typeParameters" : "typeArguments";
        if (d(K(ue)))
          return true;
      }
      return false;
    }
    function ce(W) {
      return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
    }
    r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m2, isArrowFunctionVariableDeclarator: J };
  } }), Ir = te({ "src/language-js/print/function-parameters.js"(e, r) {
    ne();
    var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s2 } = et(), { builders: { line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p2 }, utils: { removeLines: d, willBreak: y } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c2, isSimpleType: f, isTestCall: E, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: F, hasRestParameter: N, shouldPrintComma: x2, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $2 } = ut(), { ArgExpansionBailout: D } = Kt(), { printFunctionTypeParameters: T } = ct();
    function m2(v, S, b, B, k) {
      let M = v.getValue(), R = g(M), q2 = k ? T(v, b, S) : "";
      if (R.length === 0)
        return [q2, "(", s2(v, b, true, (ie) => t(b.originalText, ie, $2) === ")"), ")"];
      let J = v.getParentNode(), L = E(J), Q = C(M), V = [];
      if (c2(v, (ie, ee) => {
        let ce = ee === R.length - 1;
        ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a2));
      }), B) {
        if (y(q2) || y(V))
          throw new D();
        return i([d(q2), "(", d(V), ")"]);
      }
      let j = R.every((ie) => !ie.decorators);
      return Q && j ? [q2, "(", ...V, ")"] : L ? [q2, "(", ...V, ")"] : (F(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q2, "(", l([u, ...V]), p2(!N(M) && x2(b, "all") ? "," : ""), u, ")"];
    }
    function C(v) {
      if (!v)
        return false;
      let S = g(v);
      if (S.length !== 1)
        return false;
      let [b] = S;
      return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
    }
    function o(v) {
      let S;
      return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
    }
    function h2(v, S) {
      let b = o(v);
      if (!b)
        return false;
      let B = v.typeParameters && v.typeParameters.params;
      if (B) {
        if (B.length > 1)
          return false;
        if (B.length === 1) {
          let k = B[0];
          if (k.constraint || k.default)
            return false;
        }
      }
      return g(v).length === 1 && (w(b) || y(S));
    }
    r.exports = { printFunctionParameters: m2, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: h2 };
  } }), kr = te({ "src/language-js/print/type-annotation.js"(e, r) {
    ne();
    var { printComments: t, printDanglingComments: s2 } = et(), { isNonEmptyArray: a2 } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p2, align: d, ifBreak: y } } = qe(), g = Ot(), { locStart: c2 } = ut(), { isSimpleType: f, isObjectType: E, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: F } = Ke(), { printAssignment: N } = Zt(), { printFunctionParameters: x2, shouldGroupFunctionParameters: I } = Ir(), { printArrayItems: P } = Qt();
    function $2(b) {
      if (f(b) || E(b))
        return true;
      if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
        let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
        if (b.types.length - 1 === B && k)
          return true;
      }
      return false;
    }
    function D(b, B, k) {
      let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
      return q2.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q2.push(": ", k("supertype")), R.impltype && q2.push(" = ", k("impltype")), q2.push(M), q2;
    }
    function T(b, B, k) {
      let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
      R.declare && q2.push("declare "), q2.push("type ", k("id"), k("typeParameters"));
      let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
      return [N(b, B, k, q2, " =", J), M];
    }
    function m2(b, B, k) {
      let M = b.getValue(), R = b.map(k, "types"), q2 = [], J = false;
      for (let L = 0; L < R.length; ++L)
        L === 0 ? q2.push(R[L]) : E(M.types[L - 1]) && E(M.types[L]) ? q2.push([" & ", J ? p2(R[L]) : R[L]]) : !E(M.types[L - 1]) && !E(M.types[L]) ? q2.push(p2([" &", i, R[L]])) : (L > 1 && (J = true), q2.push(" & ", L > 1 ? p2(R[L]) : R[L]));
      return n(q2);
    }
    function C(b, B, k) {
      let M = b.getValue(), R = b.getParentNode(), q2 = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $2(M), L = b.map((j) => {
        let Y = k();
        return J || (Y = d(2, Y)), t(j, Y, B);
      }, "types");
      if (J)
        return u(" | ", L);
      let Q = q2 && !_(B.originalText, M), V = [y([Q ? i : "", "| "]), u([i, "| "], L)];
      return g(b, B) ? n([p2(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p2([y(["(", l]), V]), l, y(")")]) : n(q2 ? p2(V) : V);
    }
    function o(b, B, k) {
      let M = b.getValue(), R = [], q2 = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q2.type === "ObjectTypeProperty" || q2.type === "ObjectTypeInternalSlot") && !q2.variance && !q2.optional && c2(q2) === c2(M) || q2.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation"), j = V && Q && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
      w(q2) && (Q = true, V = true), j && R.push("(");
      let Y = x2(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
      return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
    }
    function h2(b, B, k) {
      let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q2 = M[R], J = a2(q2), L = J ? l : "";
      return n(["[", p2([L, P(b, B, R, k)]), y(J && F(B, "all") ? "," : ""), s2(b, B, true), L, "]"]);
    }
    function v(b, B, k) {
      let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
      return [k("objectType"), R, k("indexType"), "]"];
    }
    function S(b, B, k) {
      let M = b.getValue();
      return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
    }
    r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m2, printUnionType: C, printFunctionType: o, printTupleType: h2, printIndexedAccessType: v, shouldHugType: $2, printJSDocType: S };
  } }), Lr = te({ "src/language-js/print/type-parameters.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { builders: { join: s2, line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p2 } } = qe(), { isTestCall: d, hasComment: y, CommentCheckFlags: g, isTSXFile: c2, shouldPrintComma: f, getFunctionParameters: E, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: F } = Ue(), { shouldHugType: N } = kr(), { isArrowFunctionVariableDeclarator: x2 } = Zt(), I = F("typeParameters");
    function P(T, m2, C, o) {
      let h2 = T.getValue();
      if (!h2[o])
        return "";
      if (!Array.isArray(h2[o]))
        return C(o);
      let v = T.getNode(2), S = v && d(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x2);
      if (h2[o].length === 0 || !b && (S || h2[o].length === 1 && (h2[o][0].type === "NullableTypeAnnotation" || N(h2[o][0]))))
        return ["<", s2(", ", T.map(C, o)), $2(T, m2), ">"];
      let k = h2.type === "TSTypeParameterInstantiation" ? "" : E(h2).length === 1 && c2(m2) && !h2[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m2, "all") ? p2(",") : "";
      return i(["<", l([u, s2([",", a2], T.map(C, o))]), k, u, ">"], { id: I(h2) });
    }
    function $2(T, m2) {
      let C = T.getValue();
      if (!y(C, g.Dangling))
        return "";
      let o = !y(C, g.Line), h2 = t(T, m2, o);
      return o ? h2 : [h2, n];
    }
    function D(T, m2, C) {
      let o = T.getValue(), h2 = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
      return v.type === "TSMappedType" ? (v.readonly && h2.push(w(v.readonly, "readonly"), " "), h2.push("[", C("name")), o.constraint && h2.push(" in ", C("constraint")), v.nameType && h2.push(" as ", T.callParent(() => C("nameType"))), h2.push("]"), h2) : (o.variance && h2.push(C("variance")), o.in && h2.push("in "), o.out && h2.push("out "), h2.push(C("name")), o.bound && h2.push(": ", C("bound")), o.constraint && h2.push(" extends ", C("constraint")), o.default && h2.push(" = ", C("default")), h2);
    }
    r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
  } }), er = te({ "src/language-js/print/property.js"(e, r) {
    ne();
    var { printComments: t } = et(), { printString: s2, printNumber: a2 } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p2 } = Ke(), { printAssignment: d } = Zt(), y = /* @__PURE__ */ new WeakMap();
    function g(f, E, _) {
      let w = f.getNode();
      if (w.computed)
        return ["[", _("key"), "]"];
      let F = f.getParentNode(), { key: N } = w;
      if (E.quoteProps === "consistent" && !y.has(F)) {
        let x2 = (F.properties || F.body || F.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, E));
        y.set(F, x2);
      }
      if ((N.type === "Identifier" || n(N) && u(a2(p2(N))) && String(N.value) === a2(p2(N)) && !(E.parser === "typescript" || E.parser === "babel-ts")) && (E.parser === "json" || E.quoteProps === "consistent" && y.get(F))) {
        let x2 = s2(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), E);
        return f.call((I) => t(I, x2, E), "key");
      }
      return l(w, E) && (E.quoteProps === "as-needed" || E.quoteProps === "consistent" && !y.get(F)) ? f.call((x2) => t(x2, /^\d/.test(N.value) ? a2(N.value) : N.value, E), "key") : _("key");
    }
    function c2(f, E, _) {
      return f.getValue().shorthand ? _("value") : d(f, E, _, g(f, E, _), ":", "value");
    }
    r.exports = { printProperty: c2, printPropertyKey: g };
  } }), Or = te({ "src/language-js/print/function.js"(e, r) {
    ne();
    var t = Yt(), { printDanglingComments: s2, printCommentsSeparately: a2 } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p2, indent: d, ifBreak: y, hardline: g, join: c2, indentIfBreak: f }, utils: { removeLines: E, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Kt(), { getFunctionParameters: F, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x2, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $2, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m2, hasComment: C, getComments: o, CommentCheckFlags: h2, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q2 } = Ir(), { printPropertyKey: J } = er(), { printFunctionTypeParameters: L } = ct();
    function Q(U, Z, se, fe) {
      let ge = U.getValue(), he = false;
      if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
        let Pe = U.getParentNode();
        S(Pe) && b(Pe).length > 1 && (he = true);
      }
      let we = [];
      ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
      let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q2(ge, Re);
      return we.push(L(U, se, Z), p2([Ne ? p2(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
    }
    function V(U, Z, se) {
      let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
      return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
    }
    function j(U, Z, se) {
      let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q2(fe, he), ke = [L(U, Z, se), p2([we ? p2(ge) : ge, he])];
      return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
    }
    function Y(U, Z, se, fe) {
      let ge = U.getValue(), he = [];
      if (ge.async && he.push("async "), W(U, Z))
        he.push(se(["params", 0]));
      else {
        let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
        if (ke) {
          if (_(Re))
            throw new w();
          Re = p2(E(Re));
        }
        he.push(p2([R(U, se, Z, ke, true), Re]));
      }
      let we = s2(U, Z, true, (ke) => {
        let Re = u(Z.originalText, ke, M);
        return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
      });
      return we && he.push(" ", we), he;
    }
    function ie(U, Z, se, fe, ge, he) {
      let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
      return he.body.type === "SequenceExpression" && (ge = p2(["(", d([l, ge]), l, ")"])), p2([p2(d([Re || Ne ? l : "", p2(c2([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? d([i, ge]) : [" ", ge], { groupId: H }), Re ? y(l, "", { groupId: H }) : ""]);
    }
    function ee(U, Z, se, fe) {
      let ge = U.getValue(), he = [], we = [], ke = false;
      if (function H() {
        let pe = Y(U, Z, se, fe);
        if (he.length === 0)
          he.push(pe);
        else {
          let { leading: X, trailing: le } = a2(U, Z);
          he.push([X, pe]), we.unshift(le);
        }
        ke = ke || ge.returnType && F(ge).length > 0 || ge.typeParameters || F(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
      }(), he.length > 1)
        return ie(U, fe, he, ke, we, ge);
      let Re = he;
      if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
        return p2([...Re, " ", we]);
      if (ge.body.type === "SequenceExpression")
        return p2([...Re, p2([" (", d([l, we]), l, ")"])]);
      let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $2(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
      return p2([...Re, p2([d([i, oe ? y("", "(") : "", we, oe ? y("", ")") : ""]), Ne ? [y(Pe ? "," : ""), l] : ""])]);
    }
    function ce(U) {
      let Z = F(U);
      return Z.length === 1 && !U.typeParameters && !C(U, h2.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
    }
    function W(U, Z) {
      if (Z.arrowParens === "always")
        return false;
      if (Z.arrowParens === "avoid") {
        let se = U.getValue();
        return ce(se);
      }
      return false;
    }
    function K(U, Z, se) {
      let fe = U.getValue(), ge = Z("returnType");
      if (fe.returnType && x2(se.originalText, fe.returnType))
        return [" /*: ", ge, " */"];
      let he = [ge];
      return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
    }
    function de(U, Z, se) {
      let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
      fe.argument && (z(Z, fe.argument) ? he.push([" (", d([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p2([y(" (", " "), d([l, se("argument")]), l, y(")")])) : he.push(" ", se("argument")));
      let we = o(fe), ke = n(we), Re = ke && m2(ke);
      return Re && he.push(ge), C(fe, h2.Dangling) && he.push(" ", s2(U, Z, true)), Re || he.push(ge), he;
    }
    function ue(U, Z, se) {
      return ["return", de(U, Z, se)];
    }
    function Fe(U, Z, se) {
      return ["throw", de(U, Z, se)];
    }
    function z(U, Z) {
      if (N(U.originalText, Z))
        return true;
      if (B(Z)) {
        let se = Z, fe;
        for (; fe = k(se); )
          if (se = fe, N(U.originalText, se))
            return true;
      }
      return false;
    }
    r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
  } }), eu = te({ "src/language-js/print/decorators.js"(e, r) {
    ne();
    var { isNonEmptyArray: t, hasNewline: s2 } = Ue(), { builders: { line: a2, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p2, locEnd: d } = ut(), { getParentExportDeclaration: y } = Ke();
    function g(w, F, N) {
      let x2 = w.getValue();
      return l([u(a2, w.map(N, "decorators")), E(x2, F) ? n : a2]);
    }
    function c2(w, F, N) {
      return [u(n, w.map(N, "declaration", "decorators")), n];
    }
    function f(w, F, N) {
      let x2 = w.getValue(), { decorators: I } = x2;
      if (!t(I) || _(w.getParentNode()))
        return;
      let P = x2.type === "ClassExpression" || x2.type === "ClassDeclaration" || E(x2, F);
      return [y(w) ? n : P ? i : "", u(a2, w.map(N, "decorators")), a2];
    }
    function E(w, F) {
      return w.decorators.some((N) => s2(F.originalText, d(N)));
    }
    function _(w) {
      if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
        return false;
      let F = w.declaration && w.declaration.decorators;
      return t(F) && p2(w) === p2(F[0]);
    }
    r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c2, hasDecoratorsBeforeExport: _ };
  } }), tr$1 = te({ "src/language-js/print/class.js"(e, r) {
    ne();
    var { isNonEmptyArray: t, createGroupIdMapper: s2 } = Ue(), { printComments: a2, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p2, group: d, indent: y, ifBreak: g } } = qe(), { hasComment: c2, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: E } = Lr(), { printMethod: _ } = Or(), { printOptionalToken: w, printTypeAnnotation: F, printDefiniteToken: N } = ct(), { printPropertyKey: x2 } = er(), { printAssignment: I } = Zt(), { printClassMemberDecorators: P } = eu();
    function $2(b, B, k) {
      let M = b.getValue(), R = [];
      M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
      let q2 = M.id && c2(M.id, f.Trailing) || M.typeParameters && c2(M.typeParameters, f.Trailing) || M.superClass && c2(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
      if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
        let Q = [h2(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a2(j, Q, B)], "superClass");
        q2 ? L.push(i, d(V)) : L.push(" ", V);
      } else
        L.push(o(b, B, k, "extends"));
      if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q2) {
        let Q;
        C(M) ? Q = [...J, y(L)] : Q = y([...J, L]), R.push(d(Q, { id: D(M) }));
      } else
        R.push(...J, ...L);
      return R.push(" ", k("body")), R;
    }
    var D = s2("heritageGroup");
    function T(b) {
      return g(l, "", { groupId: D(b) });
    }
    function m2(b) {
      return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
    }
    function C(b) {
      return b.typeParameters && !c2(b.typeParameters, f.Trailing | f.Line) && !m2(b);
    }
    function o(b, B, k, M) {
      let R = b.getValue();
      if (!t(R[M]))
        return "";
      let q2 = n(b, B, true, (J) => {
        let { marker: L } = J;
        return L === M;
      });
      return [C(R) ? g(" ", i, { groupId: E(R.typeParameters) }) : i, q2, q2 && l, M, d(y([i, u([",", i], b.map(k, M))]))];
    }
    function h2(b, B, k) {
      let M = k("superClass");
      return b.getParentNode().type === "AssignmentExpression" ? d(g(["(", y([p2, M]), p2, ")"], M)) : M;
    }
    function v(b, B, k) {
      let M = b.getValue(), R = [];
      return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
    }
    function S(b, B, k) {
      let M = b.getValue(), R = [], q2 = B.semi ? ";" : "";
      return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x2(b, B, k), w(b), N(b), F(b, B, k)), [I(b, B, k, R, " =", "value"), q2];
    }
    r.exports = { printClass: $2, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
  } }), ho = te({ "src/language-js/print/interface.js"(e, r) {
    ne();
    var { isNonEmptyArray: t } = Ue(), { builders: { join: s2, line: a2, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p2, CommentCheckFlags: d } = Ke(), { getTypeParametersGroupId: y } = Lr(), { printTypeScriptModifiers: g } = ct();
    function c2(f, E, _) {
      let w = f.getValue(), F = [];
      w.declare && F.push("declare "), w.type === "TSInterfaceDeclaration" && F.push(w.abstract ? "abstract " : "", g(f, E, _)), F.push("interface");
      let N = [], x2 = [];
      w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
      let I = w.typeParameters && !l(w.typeParameters, d.Trailing | d.Line);
      return t(w.extends) && x2.push(I ? i(" ", a2, { groupId: y(w.typeParameters) }) : a2, "extends ", (w.extends.length === 1 ? p2 : u)(s2([",", a2], f.map(_, "extends")))), w.id && l(w.id, d.Trailing) || t(w.extends) ? I ? F.push(n([...N, u(x2)])) : F.push(n(u([...N, ...x2]))) : F.push(...N, ...x2), F.push(" ", _("body")), n(F);
    }
    r.exports = { printInterface: c2 };
  } }), vo = te({ "src/language-js/print/module.js"(e, r) {
    ne();
    var { isNonEmptyArray: t } = Ue(), { builders: { softline: s2, group: a2, indent: n, join: u, line: i, ifBreak: l, hardline: p2 } } = qe(), { printDanglingComments: d } = et(), { hasComment: y, CommentCheckFlags: g, shouldPrintComma: c2, needsHardlineAfterDanglingComment: f, isStringLiteral: E, rawText: _ } = Ke(), { locStart: w, hasSameLoc: F } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x2 } = eu();
    function I(S, b, B) {
      let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q2 } = k;
      return R.push("import"), q2 && q2 !== "value" && R.push(" ", q2), R.push(m2(S, b, B), T(S, b, B), o(S, b, B), M), R;
    }
    function P(S, b, B) {
      let k = S.getValue(), M = [];
      N(k) && M.push(x2(S, b, B));
      let { type: R, exportKind: q2, declaration: J } = k;
      return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), y(k, g.Dangling) && (M.push(" ", d(S, b, true)), f(k) && M.push(p2)), J ? M.push(" ", B("declaration")) : M.push(q2 === "type" ? " type" : "", m2(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
    }
    function $2(S, b, B) {
      let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q2, exported: J } = k;
      return R.push("export"), q2 === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
    }
    function D(S, b) {
      if (!b.semi)
        return false;
      let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
      if (!k)
        return true;
      let { type: R } = k;
      return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
    }
    function T(S, b, B) {
      let k = S.getValue();
      if (!k.source)
        return "";
      let M = [];
      return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
    }
    function m2(S, b, B) {
      let k = S.getValue();
      if (C(k, b))
        return "";
      let M = [" "];
      if (t(k.specifiers)) {
        let R = [], q2 = [];
        S.each(() => {
          let J = S.getValue().type;
          if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
            R.push(B());
          else if (J === "ExportSpecifier" || J === "ImportSpecifier")
            q2.push(B());
          else
            throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
        }, "specifiers"), M.push(u(", ", R)), q2.length > 0 && (R.length > 0 && M.push(", "), q2.length > 1 || R.length > 0 || k.specifiers.some((L) => y(L)) ? M.push(a2(["{", n([b.bracketSpacing ? i : s2, u([",", i], q2)]), l(c2(b) ? "," : ""), b.bracketSpacing ? i : s2, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q2, b.bracketSpacing ? " " : "", "}"]));
      } else
        M.push("{}");
      return M;
    }
    function C(S, b) {
      let { type: B, importKind: k, source: M, specifiers: R } = S;
      return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
    }
    function o(S, b, B) {
      let k = S.getNode();
      return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
    }
    function h2(S, b, B) {
      let k = S.getNode(), { type: M } = k, R = [], q2 = M === "ImportSpecifier" ? k.importKind : k.exportKind;
      q2 && q2 !== "value" && R.push(q2, " ");
      let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
      return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
    }
    function v(S) {
      if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
        return false;
      let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
      if (b.type !== B.type || !F(b, B))
        return false;
      if (E(b))
        return b.value === B.value && _(b) === _(B);
      switch (b.type) {
        case "Identifier":
          return b.name === B.name;
        default:
          return false;
      }
    }
    r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $2, printModuleSpecifier: h2 };
  } }), tu = te({ "src/language-js/print/object.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { builders: { line: s2, softline: a2, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p2, hasNewlineInRange: d, hasNewline: y, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c2, hasComment: f, getComments: E, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: F, locEnd: N } = ut(), { printOptionalToken: x2, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Ir(), { shouldHugType: $2 } = kr(), { printHardlineAfterHeritage: D } = tr$1();
    function T(m2, C, o) {
      let h2 = C.semi ? ";" : "", v = m2.getValue(), S;
      v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
      let b = v.type === "ObjectTypeAnnotation", B = [S];
      b && B.push("indexers", "callProperties", "internalSlots");
      let k = B.map((W) => v[W][0]).sort((W, K) => F(W) - F(K))[0], M = m2.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m2.getName() === "body", q2 = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && d(C.originalText, F(v), F(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(h2, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
      for (let W of B)
        m2.each((K) => {
          let de = K.getValue();
          V.push({ node: de, printed: o(), loc: F(de) });
        }, W);
      B.length > 1 && V.sort((W, K) => W.loc - K.loc);
      let j = [], Y = V.map((W) => {
        let K = [...j, n(W.printed)];
        return j = [J, s2], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
      });
      if (v.inexact) {
        let W;
        if (f(v, _.Dangling)) {
          let K = f(v, _.Line);
          W = [t(m2, C, true), K || y(C.originalText, N(p2(E(v)))) ? l : s2, "..."];
        } else
          W = ["..."];
        Y.push([...j, ...W]);
      }
      let ie = p2(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
      if (Y.length === 0) {
        if (!f(v, _.Dangling))
          return [L, Q, I(m2, C, o)];
        ce = n([L, t(m2, C), a2, Q, x2(m2), I(m2, C, o)]);
      } else
        ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s2 : a2, ...Y]), i(ee && (J !== "," || c2(C)) ? J : ""), C.bracketSpacing ? s2 : a2, Q, x2(m2), I(m2, C, o)];
      return m2.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m2.match($2, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q2 && m2.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q2 });
    }
    r.exports = { printObject: T };
  } }), id = te({ "src/language-js/print/flow.js"(e, r) {
    ne();
    var t = Yt(), { printDanglingComments: s2 } = et(), { printString: a2, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p2 } } = qe(), { getParentExportDeclaration: d, isFunctionNotation: y, isGetterOrSetter: g, rawText: c2, shouldPrintComma: f } = Ke(), { locStart: E, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Xt(), { printClass: F } = tr$1(), { printOpaqueType: N, printTypeAlias: x2, printIntersectionType: I, printUnionType: P, printFunctionType: $2, printTupleType: D, printIndexedAccessType: T } = kr(), { printInterface: m2 } = ho(), { printTypeParameter: C, printTypeParameters: o } = Lr(), { printExportDeclaration: h2, printExportAllDeclaration: v } = vo(), { printArrayItems: S } = Qt(), { printObject: b } = tu(), { printPropertyKey: B } = er(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
    function q2(L, Q, V) {
      let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
      switch (j.type) {
        case "DeclareClass":
          return J(L, F(L, Q, V));
        case "DeclareFunction":
          return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
        case "DeclareModule":
          return J(L, ["module ", V("id"), " ", V("body")]);
        case "DeclareModuleExports":
          return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
        case "DeclareVariable":
          return J(L, ["var ", V("id"), Y]);
        case "DeclareOpaqueType":
          return J(L, N(L, Q, V));
        case "DeclareInterface":
          return J(L, m2(L, Q, V));
        case "DeclareTypeAlias":
          return J(L, x2(L, Q, V));
        case "DeclareExportDeclaration":
          return J(L, h2(L, Q, V));
        case "DeclareExportAllDeclaration":
          return J(L, v(L, Q, V));
        case "OpaqueType":
          return N(L, Q, V);
        case "TypeAlias":
          return x2(L, Q, V);
        case "IntersectionTypeAnnotation":
          return I(L, Q, V);
        case "UnionTypeAnnotation":
          return P(L, Q, V);
        case "FunctionTypeAnnotation":
          return $2(L, Q, V);
        case "TupleTypeAnnotation":
          return D(L, Q, V);
        case "GenericTypeAnnotation":
          return [V("id"), o(L, Q, V, "typeParameters")];
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          return T(L, Q, V);
        case "TypeAnnotation":
          return V("typeAnnotation");
        case "TypeParameter":
          return C(L, Q, V);
        case "TypeofTypeAnnotation":
          return ["typeof ", V("argument")];
        case "ExistsTypeAnnotation":
          return "*";
        case "EmptyTypeAnnotation":
          return "empty";
        case "MixedTypeAnnotation":
          return "mixed";
        case "ArrayTypeAnnotation":
          return [V("elementType"), "[]"];
        case "BooleanLiteralTypeAnnotation":
          return String(j.value);
        case "EnumDeclaration":
          return ["enum ", V("id"), " ", V("body")];
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody": {
          if (j.type === "EnumSymbolBody" || j.explicitType) {
            let ee = null;
            switch (j.type) {
              case "EnumBooleanBody":
                ee = "boolean";
                break;
              case "EnumNumberBody":
                ee = "number";
                break;
              case "EnumStringBody":
                ee = "string";
                break;
              case "EnumSymbolBody":
                ee = "symbol";
                break;
            }
            ie.push("of ", ee, " ");
          }
          if (j.members.length === 0 && !j.hasUnknownMembers)
            ie.push(l(["{", s2(L, Q), i, "}"]));
          else {
            let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
            ie.push(l(["{", p2([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s2(L, Q, true), u, "}"]));
          }
          return ie;
        }
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
          return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
        case "EnumDefaultedMember":
          return V("id");
        case "FunctionTypeParam": {
          let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
          return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
        }
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
          return m2(L, Q, V);
        case "ClassImplements":
        case "InterfaceExtends":
          return [V("id"), V("typeParameters")];
        case "NullableTypeAnnotation":
          return ["?", V("typeAnnotation")];
        case "Variance": {
          let { kind: ee } = j;
          return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
        }
        case "ObjectTypeCallProperty":
          return j.static && ie.push("static "), ie.push(V("value")), ie;
        case "ObjectTypeIndexer":
          return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
        case "ObjectTypeProperty": {
          let ee = "";
          return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), y(j) ? "" : ": ", V("value")];
        }
        case "ObjectTypeAnnotation":
          return b(L, Q, V);
        case "ObjectTypeInternalSlot":
          return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
        case "ObjectTypeSpreadProperty":
          return R(L, Q, V);
        case "QualifiedTypeofIdentifier":
        case "QualifiedTypeIdentifier":
          return [V("qualification"), ".", V("id")];
        case "StringLiteralTypeAnnotation":
          return w(a2(c2(j), Q));
        case "NumberLiteralTypeAnnotation":
          t.strictEqual(typeof j.value, "number");
        case "BigIntLiteralTypeAnnotation":
          return j.extra ? n(j.extra.raw) : n(j.raw);
        case "TypeCastExpression":
          return ["(", V("expression"), M(L, Q, V), ")"];
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation": {
          let ee = o(L, Q, V, "params");
          if (Q.parser === "flow") {
            let ce = E(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
            if (K !== -1 && de !== -1) {
              let ue = Q.originalText.slice(K + 2, de).trim();
              if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                return ["/*:: ", ee, " */"];
            }
          }
          return ee;
        }
        case "InferredPredicate":
          return "%checks";
        case "DeclaredPredicate":
          return ["%checks(", V("value"), ")"];
        case "AnyTypeAnnotation":
          return "any";
        case "BooleanTypeAnnotation":
          return "boolean";
        case "BigIntTypeAnnotation":
          return "bigint";
        case "NullLiteralTypeAnnotation":
          return "null";
        case "NumberTypeAnnotation":
          return "number";
        case "SymbolTypeAnnotation":
          return "symbol";
        case "StringTypeAnnotation":
          return "string";
        case "VoidTypeAnnotation":
          return "void";
        case "ThisTypeAnnotation":
          return "this";
        case "Node":
        case "Printable":
        case "SourceLocation":
        case "Position":
        case "Statement":
        case "Function":
        case "Pattern":
        case "Expression":
        case "Declaration":
        case "Specifier":
        case "NamedSpecifier":
        case "Comment":
        case "MemberTypeAnnotation":
        case "Type":
          throw new Error("unprintable type: " + JSON.stringify(j.type));
      }
    }
    function J(L, Q) {
      let V = d(L);
      return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
    }
    r.exports = { printFlow: q2 };
  } }), ad = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
    ne();
    function t(s2) {
      let { type: a2 } = s2;
      return a2.startsWith("TS") && a2.endsWith("Keyword");
    }
    r.exports = t;
  } }), Co = te({ "src/language-js/print/ternary.js"(e, r) {
    ne();
    var { hasNewlineInRange: t } = Ue(), { isJsxNode: s2, getComments: a2, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p2 } = ut(), d = _t(), { builders: { line: y, softline: g, group: c2, indent: f, align: E, ifBreak: _, dedent: w, breakParent: F } } = qe();
    function N(D) {
      let T = [D];
      for (let m2 = 0; m2 < T.length; m2++) {
        let C = T[m2];
        for (let o of ["test", "consequent", "alternate"]) {
          let h2 = C[o];
          if (s2(h2))
            return true;
          h2.type === "ConditionalExpression" && T.push(h2);
        }
      }
      return false;
    }
    function x2(D, T, m2) {
      let C = D.getValue(), o = C.type === "ConditionalExpression", h2 = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m2("test") : [m2("checkType"), " ", "extends", " ", m2("extendsType")];
      return v.type === C.type && v[h2] === C ? E(2, S) : S;
    }
    var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
    function P(D) {
      let T = D.getValue();
      if (T.type !== "ConditionalExpression")
        return false;
      let m2, C = T;
      for (let o = 0; !m2; o++) {
        let h2 = D.getParentNode(o);
        if (n(h2) && h2.callee === C || u(h2) && h2.object === C || h2.type === "TSNonNullExpression" && h2.expression === C) {
          C = h2;
          continue;
        }
        h2.type === "NewExpression" && h2.callee === C || i(h2) && h2.expression === C ? (m2 = D.getParentNode(o + 1), C = h2) : m2 = h2;
      }
      return C === T ? false : m2[I.get(m2.type)] === C;
    }
    function $2(D, T, m2) {
      let C = D.getValue(), o = C.type === "ConditionalExpression", h2 = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[h2], B = C[v], k = [], M = false, R = D.getParentNode(), q2 = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q2, L, Q, V = 0;
      do
        Q = L || C, L = D.getParentNode(V), V++;
      while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
      let j = L || R, Y = Q;
      if (o && (s2(C[S[0]]) || s2(b) || s2(B) || N(Y))) {
        M = true, J = true;
        let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
        k.push(" ? ", Fe(b) ? m2(h2) : ue(m2(h2)), " : ", B.type === C.type || Fe(B) ? m2(v) : ue(m2(v)));
      } else {
        let ue = [y, "? ", b.type === C.type ? _("", "(") : "", E(2, m2(h2)), b.type === C.type ? _("", ")") : "", y, ": ", B.type === C.type ? m2(v) : E(2, m2(v))];
        k.push(R.type !== C.type || R[v] === C || q2 ? ue : T.useTabs ? w(f(ue)) : E(Math.max(0, T.tabWidth - 2), ue));
      }
      let ee = [...S.map((ue) => a2(C[ue])), a2(b), a2(B)].flat().some((ue) => d(ue) && t(T.originalText, l(ue), p2(ue))), ce = (ue) => R === j ? c2(ue, { shouldBreak: ee }) : ee ? [ue, F] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x2(D, T, m2), J ? k : f(k), o && W && !K ? g : ""]);
      return q2 || K ? c2([f([g, de]), g]) : de;
    }
    r.exports = { printTernary: $2 };
  } }), Eo = te({ "src/language-js/print/statement.js"(e, r) {
    ne();
    var { builders: { hardline: t } } = qe(), s2 = Ot(), { getLeftSidePathName: a2, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p2, isNextLineEmpty: d } = Ke(), { shouldPrintParamsWithoutParens: y } = Or();
    function g(x2, I, P, $2) {
      let D = x2.getValue(), T = [], m2 = D.type === "ClassBody", C = c2(D[$2]);
      return x2.each((o, h2, v) => {
        let S = o.getValue();
        if (S.type === "EmptyStatement")
          return;
        let b = P();
        !I.semi && !m2 && !i(I, o) && f(o, I) ? l(S, p2.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m2 && F(S) && N(S, v[h2 + 1]) && T.push(";"), S !== C && (T.push(t), d(S, I) && T.push(t));
      }, $2), T;
    }
    function c2(x2) {
      for (let I = x2.length - 1; I >= 0; I--) {
        let P = x2[I];
        if (P.type !== "EmptyStatement")
          return P;
      }
    }
    function f(x2, I) {
      return x2.getNode().type !== "ExpressionStatement" ? false : x2.call(($2) => E($2, I), "expression");
    }
    function E(x2, I) {
      let P = x2.getValue();
      switch (P.type) {
        case "ParenthesizedExpression":
        case "TypeCastExpression":
        case "ArrayExpression":
        case "ArrayPattern":
        case "TemplateLiteral":
        case "TemplateElement":
        case "RegExpLiteral":
          return true;
        case "ArrowFunctionExpression": {
          if (!y(x2, I))
            return true;
          break;
        }
        case "UnaryExpression": {
          let { prefix: $2, operator: D } = P;
          if ($2 && (D === "+" || D === "-"))
            return true;
          break;
        }
        case "BindExpression": {
          if (!P.object)
            return true;
          break;
        }
        case "Literal": {
          if (P.regex)
            return true;
          break;
        }
        default:
          if (u(P))
            return true;
      }
      return s2(x2, I) ? true : n(P) ? x2.call(($2) => E($2, I), ...a2(x2, P)) : false;
    }
    function _(x2, I, P) {
      return g(x2, I, P, "body");
    }
    function w(x2, I, P) {
      return g(x2, I, P, "consequent");
    }
    var F = (x2) => {
      let { type: I } = x2;
      return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
    };
    function N(x2, I) {
      let { type: P, name: $2 } = x2.key;
      if (!x2.computed && P === "Identifier" && ($2 === "static" || $2 === "get" || $2 === "set" || $2 === "accessor") && !x2.value && !x2.typeAnnotation)
        return true;
      if (!I || I.static || I.accessibility)
        return false;
      if (!I.computed) {
        let D = I.key && I.key.name;
        if (D === "in" || D === "instanceof")
          return true;
      }
      if (F(I) && I.variance && !I.static && !I.declare)
        return true;
      switch (I.type) {
        case "ClassProperty":
        case "PropertyDefinition":
        case "TSAbstractPropertyDefinition":
          return I.computed;
        case "MethodDefinition":
        case "TSAbstractMethodDefinition":
        case "ClassMethod":
        case "ClassPrivateMethod": {
          if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
            return false;
          let T = I.value ? I.value.generator : I.generator;
          return !!(I.computed || T);
        }
        case "TSIndexSignature":
          return true;
      }
      return false;
    }
    r.exports = { printBody: _, printSwitchCaseConsequent: w };
  } }), Fo = te({ "src/language-js/print/block.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { isNonEmptyArray: s2 } = Ue(), { builders: { hardline: a2, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p2 } = tr$1(), { printBody: d } = Eo();
    function y(c2, f, E) {
      let _ = c2.getValue(), w = [];
      if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s2(_.body)) {
        let N = c2.getParentNode();
        w.push(p2(N));
      }
      w.push("{");
      let F = g(c2, f, E);
      if (F)
        w.push(n([a2, F]), a2);
      else {
        let N = c2.getParentNode(), x2 = c2.getParentNode(1);
        N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x2.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a2);
      }
      return w.push("}"), w;
    }
    function g(c2, f, E) {
      let _ = c2.getValue(), w = s2(_.directives), F = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
      if (!w && !F && !N)
        return "";
      let x2 = [];
      if (w && c2.each((I, P, $2) => {
        x2.push(E()), (P < $2.length - 1 || F || N) && (x2.push(a2), l(I.getValue(), f) && x2.push(a2));
      }, "directives"), F && x2.push(d(c2, f, E)), N && x2.push(t(c2, f, true)), _.type === "Program") {
        let I = c2.getParentNode();
        (!I || I.type !== "ModuleExpression") && x2.push(a2);
      }
      return x2;
    }
    r.exports = { printBlock: y, printBlockBody: g };
  } }), od = te({ "src/language-js/print/typescript.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { hasNewlineInRange: s2 } = Ue(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p2, conditionalGroup: d, ifBreak: y } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c2, shouldPrintComma: f, isCallExpression: E, isMemberExpression: _ } = Ke(), w = ad(), { locStart: F, locEnd: N } = ut(), { printOptionalToken: x2, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Co(), { printFunctionParameters: $2, shouldGroupFunctionParameters: D } = Ir(), { printTemplateLiteral: T } = Lt(), { printArrayItems: m2 } = Qt(), { printObject: C } = tu(), { printClassProperty: o, printClassMethod: h2 } = tr$1(), { printTypeParameter: v, printTypeParameters: S } = Lr(), { printPropertyKey: b } = er(), { printFunction: B, printMethodInternal: k } = Or(), { printInterface: M } = ho(), { printBlock: R } = Fo(), { printTypeAlias: q2, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = kr();
    function ie(ee, ce, W) {
      let K = ee.getValue();
      if (!K.type.startsWith("TS"))
        return;
      if (w(K))
        return K.type.slice(2, -7).toLowerCase();
      let de = ce.semi ? ";" : "", ue = [];
      switch (K.type) {
        case "TSThisType":
          return "this";
        case "TSTypeAssertion": {
          let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p2([i, W("typeAnnotation")]), i, ">"]), U = [y("("), p2([i, W("expression")]), i, y(")")];
          return Fe ? d([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
        }
        case "TSDeclareFunction":
          return B(ee, W, ce);
        case "TSExportAssignment":
          return ["export = ", W("expression"), de];
        case "TSModuleBlock":
          return R(ee, ce, W);
        case "TSInterfaceBody":
        case "TSTypeLiteral":
          return C(ee, ce, W);
        case "TSTypeAliasDeclaration":
          return q2(ee, ce, W);
        case "TSQualifiedName":
          return a2(".", [W("left"), W("right")]);
        case "TSAbstractMethodDefinition":
        case "TSDeclareMethod":
          return h2(ee, ce, W);
        case "TSAbstractAccessorProperty":
        case "TSAbstractPropertyDefinition":
          return o(ee, ce, W);
        case "TSInterfaceHeritage":
        case "TSExpressionWithTypeArguments":
          return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
        case "TSTemplateLiteralType":
          return T(ee, W, ce);
        case "TSNamedTupleMember":
          return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
        case "TSRestType":
          return ["...", W("typeAnnotation")];
        case "TSOptionalType":
          return [W("typeAnnotation"), "?"];
        case "TSInterfaceDeclaration":
          return M(ee, ce, W);
        case "TSClassImplements":
          return [W("expression"), W("typeParameters")];
        case "TSTypeParameterDeclaration":
        case "TSTypeParameterInstantiation":
          return S(ee, ce, W, "params");
        case "TSTypeParameter":
          return v(ee, ce, W);
        case "TSSatisfiesExpression":
        case "TSAsExpression": {
          let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
          ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
          let z = ee.getParentNode();
          return E(z) && z.callee === K || _(z) && z.object === K ? l([p2([i, ...ue]), i]) : ue;
        }
        case "TSArrayType":
          return [W("elementType"), "[]"];
        case "TSPropertySignature":
          return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x2(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
        case "TSParameterProperty":
          return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
        case "TSTypeQuery":
          return ["typeof ", W("exprName"), W("typeParameters")];
        case "TSIndexSignature": {
          let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? y(f(ce) ? "," : "") : "", U = l([p2([i, a2([", ", i], ee.map(W, "parameters"))]), z, i]);
          return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
        }
        case "TSTypePredicate":
          return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
        case "TSNonNullExpression":
          return [W("expression"), "!"];
        case "TSImportType":
          return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
        case "TSLiteralType":
          return W("literal");
        case "TSIndexedAccessType":
          return j(ee, ce, W);
        case "TSConstructSignatureDeclaration":
        case "TSCallSignatureDeclaration":
        case "TSConstructorType": {
          if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($2(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
            let Fe = K.type === "TSConstructorType";
            ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
          }
          return ue;
        }
        case "TSTypeOperator":
          return [K.operator, " ", W("typeAnnotation")];
        case "TSMappedType": {
          let Fe = s2(ce.originalText, F(K), N(K));
          return l(["{", p2([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c2(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), y(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
        }
        case "TSMethodSignature": {
          let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
          ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x2(ee));
          let z = $2(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
          return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
        }
        case "TSNamespaceExportDeclaration":
          return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
        case "TSEnumDeclaration":
          return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p2([u, m2(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
        case "TSEnumMember":
          return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
        case "TSImportEqualsDeclaration":
          return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
        case "TSExternalModuleReference":
          return ["require(", W("expression"), ")"];
        case "TSModuleDeclaration": {
          let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
          if (U)
            ue.push(".");
          else {
            K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
            let se = ce.originalText.slice(F(K), F(K.id));
            K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
          }
          return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
        }
        case "TSConditionalType":
          return P(ee, ce, W);
        case "TSInferType":
          return ["infer", " ", W("typeParameter")];
        case "TSIntersectionType":
          return J(ee, ce, W);
        case "TSUnionType":
          return L(ee, ce, W);
        case "TSFunctionType":
          return Q(ee, ce, W);
        case "TSTupleType":
          return V(ee, ce, W);
        case "TSTypeReference":
          return [W("typeName"), S(ee, ce, W, "typeParameters")];
        case "TSTypeAnnotation":
          return W("typeAnnotation");
        case "TSEmptyBodyFunctionExpression":
          return k(ee, ce, W);
        case "TSJSDocAllType":
          return "*";
        case "TSJSDocUnknownType":
          return "?";
        case "TSJSDocNullableType":
          return Y(ee, W, "?");
        case "TSJSDocNonNullableType":
          return Y(ee, W, "!");
        case "TSInstantiationExpression":
          return [W("expression"), W("typeParameters")];
        default:
          throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
      }
    }
    r.exports = { printTypescript: ie };
  } }), ld = te({ "src/language-js/print/comment.js"(e, r) {
    ne();
    var { hasNewline: t } = Ue(), { builders: { join: s2, hardline: a2 }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p2 = _t();
    function d(c2, f) {
      let E = c2.getValue();
      if (u(E))
        return f.originalText.slice(i(E), l(E)).trimEnd();
      if (p2(E)) {
        if (y(E)) {
          let F = g(E);
          return E.trailing && !t(f.originalText, i(E), { backwards: true }) ? [a2, F] : F;
        }
        let _ = l(E), w = f.originalText.slice(_ - 3, _) === "*-/";
        return ["/*", n(E.value), w ? "*-/" : "*/"];
      }
      throw new Error("Not a comment: " + JSON.stringify(E));
    }
    function y(c2) {
      let f = `*${c2.value}*`.split(`
`);
      return f.length > 1 && f.every((E) => E.trim()[0] === "*");
    }
    function g(c2) {
      let f = c2.value.split(`
`);
      return ["/*", s2(a2, f.map((E, _) => _ === 0 ? E.trimEnd() : " " + (_ < f.length - 1 ? E.trim() : E.trimStart()))), "*/"];
    }
    r.exports = { printComment: d };
  } }), cd = te({ "src/language-js/print/literal.js"(e, r) {
    ne();
    var { printString: t, printNumber: s2 } = Ue(), { replaceTextEndOfLine: a2 } = Xt(), { printDirective: n } = ct();
    function u(d, y) {
      let g = d.getNode();
      switch (g.type) {
        case "RegExpLiteral":
          return p2(g);
        case "BigIntLiteral":
          return l(g.bigint || g.extra.raw);
        case "NumericLiteral":
          return s2(g.extra.raw);
        case "StringLiteral":
          return a2(t(g.extra.raw, y));
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return String(g.value);
        case "DecimalLiteral":
          return s2(g.value) + "m";
        case "Literal": {
          if (g.regex)
            return p2(g.regex);
          if (g.bigint)
            return l(g.raw);
          if (g.decimal)
            return s2(g.decimal) + "m";
          let { value: c2 } = g;
          return typeof c2 == "number" ? s2(g.raw) : typeof c2 == "string" ? i(d) ? n(g.raw, y) : a2(t(g.raw, y)) : String(c2);
        }
      }
    }
    function i(d) {
      if (d.getName() !== "expression")
        return;
      let y = d.getParentNode();
      return y.type === "ExpressionStatement" && y.directive;
    }
    function l(d) {
      return d.toLowerCase();
    }
    function p2(d) {
      let { pattern: y, flags: g } = d;
      return g = [...g].sort().join(""), `/${y}/${g}`;
    }
    r.exports = { printLiteral: u };
  } }), pd = te({ "src/language-js/printer-estree.js"(e, r) {
    ne();
    var { printDanglingComments: t } = et(), { hasNewline: s2 } = Ue(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p2 }, utils: { replaceTextEndOfLine: d } } = qe(), y = Um(), g = Jm(), { insertPragma: c2 } = po(), f = fo(), E = Ot(), _ = Do(), { hasFlowShorthandAnnotationComment: w, hasComment: F, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x2, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $2, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m2, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: h2 } = ut(), v = _t(), { printHtmlBinding: S, isVueEventBindingExpression: b } = rd(), { printAngular: B } = nd(), { printJsx: k, hasJsxIgnoreComment: M } = ud(), { printFlow: R } = id(), { printTypescript: q2 } = od(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = vo(), { printTernary: de } = Co(), { printTemplateLiteral: ue } = Lt(), { printArray: Fe } = Qt(), { printObject: z } = tu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = tr$1(), { printProperty: fe } = er(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = Or(), { printCallExpression: Ne } = yo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = Zt(), { printBinaryishExpression: H } = Zn(), { printSwitchCaseConsequent: pe } = Eo(), { printMemberExpression: X } = go(), { printBlock: le, printBlockBody: Ae } = Fo(), { printComment: Ee } = ld(), { printLiteral: De } = cd(), { printDecorators: A } = eu();
    function G(Ce, Be, ve, ze) {
      let xe = re2(Ce, Be, ve, ze);
      if (!xe)
        return "";
      let Ye = Ce.getValue(), { type: Se } = Ye;
      if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod")
        return xe;
      let Ie = [xe], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
      if (Oe && (Ie = [...Oe, xe], !Je))
        return l(Ie);
      if (!E(Ce, Be))
        return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === xe ? xe : Ie;
      if (Je && (Ie = [p2([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
        let [je] = Ye.trailingComments;
        Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
      }
      return Je && Ie.push(n), Ie.push(")"), Ie;
    }
    function re2(Ce, Be, ve, ze) {
      let xe = Ce.getValue(), Ye = Be.semi ? ";" : "";
      if (!xe)
        return "";
      if (typeof xe == "string")
        return xe;
      for (let Ie of [De, S, B, k, R, q2]) {
        let Oe = Ie(Ce, Be, ve);
        if (typeof Oe < "u")
          return Oe;
      }
      let Se = [];
      switch (xe.type) {
        case "JsExpressionRoot":
          return ve("node");
        case "JsonRoot":
          return [ve("node"), u];
        case "File":
          return xe.program && xe.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
        case "Program":
          return Ae(Ce, Be, ve);
        case "EmptyStatement":
          return "";
        case "ExpressionStatement": {
          if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
            let Oe = Ce.getParentNode();
            if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === xe)
              return [ve("expression"), b(xe.expression) ? ";" : ""];
          }
          let Ie = t(Ce, Be, true, (Oe) => {
            let { marker: Je } = Oe;
            return Je === C;
          });
          return [ve("expression"), x2(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
        }
        case "ParenthesizedExpression":
          return !F(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p2([i, ve("expression")]), i, ")"]);
        case "AssignmentExpression":
          return oe(Ce, Be, ve);
        case "VariableDeclarator":
          return Pe(Ce, Be, ve);
        case "BinaryExpression":
        case "LogicalExpression":
          return H(Ce, Be, ve);
        case "AssignmentPattern":
          return [ve("left"), " = ", ve("right")];
        case "OptionalMemberExpression":
        case "MemberExpression":
          return X(Ce, Be, ve);
        case "MetaProperty":
          return [ve("meta"), ".", ve("property")];
        case "BindExpression":
          return xe.object && Se.push(ve("object")), Se.push(l(p2([i, L(Ce, Be, ve)]))), Se;
        case "Identifier":
          return [xe.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
        case "V8IntrinsicIdentifier":
          return ["%", xe.name];
        case "SpreadElement":
        case "SpreadElementPattern":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "RestElement":
          return j(Ce, Be, ve);
        case "FunctionDeclaration":
        case "FunctionExpression":
          return ge(Ce, ve, Be, ze);
        case "ArrowFunctionExpression":
          return he(Ce, Be, ve, ze);
        case "YieldExpression":
          return Se.push("yield"), xe.delegate && Se.push("*"), xe.argument && Se.push(" ", ve("argument")), Se;
        case "AwaitExpression": {
          if (Se.push("await"), xe.argument) {
            Se.push(" ", ve("argument"));
            let Ie = Ce.getParentNode();
            if (T(Ie) && Ie.callee === xe || m2(Ie) && Ie.object === xe) {
              Se = [p2([i, ...Se]), i];
              let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
              if (!Oe || Oe.type !== "AwaitExpression")
                return l(Se);
            }
          }
          return Se;
        }
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return ce(Ce, Be, ve);
        case "ExportAllDeclaration":
          return W(Ce, Be, ve);
        case "ImportDeclaration":
          return ee(Ce, Be, ve);
        case "ImportSpecifier":
        case "ExportSpecifier":
        case "ImportNamespaceSpecifier":
        case "ExportNamespaceSpecifier":
        case "ImportDefaultSpecifier":
        case "ExportDefaultSpecifier":
          return K(Ce, Be, ve);
        case "ImportAttribute":
          return [ve("key"), ": ", ve("value")];
        case "Import":
          return "import";
        case "BlockStatement":
        case "StaticBlock":
        case "ClassBody":
          return le(Ce, Be, ve);
        case "ThrowStatement":
          return Re(Ce, Be, ve);
        case "ReturnStatement":
          return ke(Ce, Be, ve);
        case "NewExpression":
        case "ImportExpression":
        case "OptionalCallExpression":
        case "CallExpression":
          return Ne(Ce, Be, ve);
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          return z(Ce, Be, ve);
        case "ObjectProperty":
        case "Property":
          return xe.method || xe.kind === "get" || xe.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
        case "ObjectMethod":
          return we(Ce, Be, ve);
        case "Decorator":
          return ["@", ve("expression")];
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          return Fe(Ce, Be, ve);
        case "SequenceExpression": {
          let Ie = Ce.getParentNode(0);
          if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
            let Oe = [];
            return Ce.each((Je, be) => {
              be === 0 ? Oe.push(ve()) : Oe.push(",", p2([n, ve()]));
            }, "expressions"), l(Oe);
          }
          return l(a2([",", n], Ce.map(ve, "expressions")));
        }
        case "ThisExpression":
          return "this";
        case "Super":
          return "super";
        case "Directive":
          return [ve("value"), Ye];
        case "DirectiveLiteral":
          return ie(xe.extra.raw, Be);
        case "UnaryExpression":
          return Se.push(xe.operator), /[a-z]$/.test(xe.operator) && Se.push(" "), F(xe.argument) ? Se.push(l(["(", p2([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
        case "UpdateExpression":
          return Se.push(ve("argument"), xe.operator), xe.prefix && Se.reverse(), Se;
        case "ConditionalExpression":
          return de(Ce, Be, ve);
        case "VariableDeclaration": {
          let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", be = xe.declarations.some((Me) => Me.init), je;
          return Ie.length === 1 && !F(xe.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p2(Ie[0])), Se = [xe.declare ? "declare " : "", xe.kind, je ? [" ", je] : "", p2(Ie.slice(1).map((Me) => [",", be && !Je ? u : n, Me]))], Je && Oe.body !== xe || Se.push(Ye), l(Se);
        }
        case "WithStatement":
          return l(["with (", ve("object"), ")", V(xe.body, ve("body"))]);
        case "IfStatement": {
          let Ie = V(xe.consequent, ve("consequent")), Oe = l(["if (", l([p2([i, ve("test")]), i]), ")", Ie]);
          if (Se.push(Oe), xe.alternate) {
            let Je = F(xe.consequent, N.Trailing | N.Line) || $2(xe), be = xe.consequent.type === "BlockStatement" && !Je;
            Se.push(be ? " " : u), F(xe, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(xe.alternate, ve("alternate"), xe.alternate.type === "IfStatement")));
          }
          return Se;
        }
        case "ForStatement": {
          let Ie = V(xe.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
          return !xe.init && !xe.test && !xe.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p2([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
        }
        case "WhileStatement":
          return l(["while (", l([p2([i, ve("test")]), i]), ")", V(xe.body, ve("body"))]);
        case "ForInStatement":
          return l(["for (", ve("left"), " in ", ve("right"), ")", V(xe.body, ve("body"))]);
        case "ForOfStatement":
          return l(["for", xe.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(xe.body, ve("body"))]);
        case "DoWhileStatement": {
          let Ie = V(xe.body, ve("body"));
          return Se = [l(["do", Ie])], xe.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p2([i, ve("test")]), i]), ")", Ye), Se;
        }
        case "DoExpression":
          return [xe.async ? "async " : "", "do ", ve("body")];
        case "BreakStatement":
          return Se.push("break"), xe.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
        case "ContinueStatement":
          return Se.push("continue"), xe.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
        case "LabeledStatement":
          return xe.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
        case "TryStatement":
          return ["try ", ve("block"), xe.handler ? [" ", ve("handler")] : "", xe.finalizer ? [" finally ", ve("finalizer")] : ""];
        case "CatchClause":
          if (xe.param) {
            let Ie = F(xe.param, (Je) => !v(Je) || Je.leading && s2(Be.originalText, h2(Je)) || Je.trailing && s2(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
            return ["catch ", Ie ? ["(", p2([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
          }
          return ["catch ", ve("body")];
        case "SwitchStatement":
          return [l(["switch (", p2([i, ve("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? p2([u, a2(u, Ce.map((Ie, Oe, Je) => {
            let be = Ie.getValue();
            return [ve(), Oe !== Je.length - 1 && P(be, Be) ? u : ""];
          }, "cases"))]) : "", u, "}"];
        case "SwitchCase": {
          xe.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), F(xe, N.Dangling) && Se.push(" ", t(Ce, Be, true));
          let Ie = xe.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
          if (Ie.length > 0) {
            let Oe = pe(Ce, Be, ve);
            Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p2([u, Oe]));
          }
          return Se;
        }
        case "DebuggerStatement":
          return ["debugger", Ye];
        case "ClassDeclaration":
        case "ClassExpression":
          return U(Ce, Be, ve);
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "MethodDefinition":
          return Z(Ce, Be, ve);
        case "ClassProperty":
        case "PropertyDefinition":
        case "ClassPrivateProperty":
        case "ClassAccessorProperty":
        case "AccessorProperty":
          return se(Ce, Be, ve);
        case "TemplateElement":
          return d(xe.value.raw);
        case "TemplateLiteral":
          return ue(Ce, ve, Be);
        case "TaggedTemplateExpression":
          return [ve("tag"), ve("typeParameters"), ve("quasi")];
        case "PrivateIdentifier":
          return ["#", ve("name")];
        case "PrivateName":
          return ["#", ve("id")];
        case "InterpreterDirective":
          return Se.push("#!", xe.value, u), P(xe, Be) && Se.push(u), Se;
        case "TopicReference":
          return "%";
        case "ArgumentPlaceholder":
          return "?";
        case "ModuleExpression": {
          Se.push("module {");
          let Ie = ve("body");
          return Ie && Se.push(p2([u, Ie]), u), Se.push("}"), Se;
        }
        default:
          throw new Error("unknown type: " + JSON.stringify(xe.type));
      }
    }
    function ye(Ce) {
      return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
    }
    r.exports = { preprocess: _, print: G, embed: y, insertPragma: c2, massageAstNode: g, hasPrettierIgnore(Ce) {
      return D(Ce) || M(Ce);
    }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
  } }), fd = te({ "src/language-js/printer-estree-json.js"(e, r) {
    ne();
    var { builders: { hardline: t, indent: s2, join: a2 } } = qe(), n = Do();
    function u(d, y, g) {
      let c2 = d.getValue();
      switch (c2.type) {
        case "JsonRoot":
          return [g("node"), t];
        case "ArrayExpression": {
          if (c2.elements.length === 0)
            return "[]";
          let f = d.map(() => d.getValue() === null ? "null" : g(), "elements");
          return ["[", s2([t, a2([",", t], f)]), t, "]"];
        }
        case "ObjectExpression":
          return c2.properties.length === 0 ? "{}" : ["{", s2([t, a2([",", t], d.map(g, "properties"))]), t, "}"];
        case "ObjectProperty":
          return [g("key"), ": ", g("value")];
        case "UnaryExpression":
          return [c2.operator === "+" ? "" : c2.operator, g("argument")];
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return c2.value ? "true" : "false";
        case "StringLiteral":
          return JSON.stringify(c2.value);
        case "NumericLiteral":
          return i(d) ? JSON.stringify(String(c2.value)) : JSON.stringify(c2.value);
        case "Identifier":
          return i(d) ? JSON.stringify(c2.name) : c2.name;
        case "TemplateLiteral":
          return g(["quasis", 0]);
        case "TemplateElement":
          return JSON.stringify(c2.value.cooked);
        default:
          throw new Error("unknown type: " + JSON.stringify(c2.type));
      }
    }
    function i(d) {
      return d.getName() === "key" && d.getParentNode().type === "ObjectProperty";
    }
    var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
    function p2(d, y) {
      let { type: g } = d;
      if (g === "ObjectProperty") {
        let { key: c2 } = d;
        c2.type === "Identifier" ? y.key = { type: "StringLiteral", value: c2.name } : c2.type === "NumericLiteral" && (y.key = { type: "StringLiteral", value: String(c2.value) });
        return;
      }
      if (g === "UnaryExpression" && d.operator === "+")
        return y.argument;
      if (g === "ArrayExpression") {
        for (let [c2, f] of d.elements.entries())
          f === null && y.elements.splice(c2, 0, { type: "NullLiteral" });
        return;
      }
      if (g === "TemplateLiteral")
        return { type: "StringLiteral", value: d.quasis[0].value.cooked };
    }
    p2.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p2 };
  } }), jt = te({ "src/common/common-options.js"(e, r) {
    ne();
    var t = "Common";
    r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
  } }), Dd = te({ "src/language-js/options.js"(e, r) {
    ne();
    var t = jt(), s2 = "JavaScript";
    r.exports = { arrowParens: { since: "1.9.0", category: s2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
  } }), md = te({ "src/language-js/parse/parsers.js"() {
    ne();
  } }), In = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
    r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
  } }), dd$1 = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
    r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
  } }), gd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
    r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
  } }), Fa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
    r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
  } }), yd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
    r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
  } }), hd = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
    r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
  } }), vd = te({ "src/language-js/index.js"(e, r) {
    ne();
    var t = wt(), s2 = pd(), a2 = fd(), n = Dd(), u = md(), i = [t(In(), (p2) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p2.interpreters, "zx"], extensions: [...p2.extensions.filter((d) => d !== ".jsx"), ".wxs"] })), t(In(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(In(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(dd$1(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(gd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(Fa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(Fa(), (p2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p2.extensions.filter((d) => d !== ".jsonl") })), t(yd(), (p2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p2.filenames, ".eslintrc", ".swcrc"] })), t(hd(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s2, "estree-json": a2 };
    r.exports = { languages: i, options: n, printers: l, parsers: u };
  } }), Cd = te({ "src/language-css/clean.js"(e, r) {
    ne();
    var { isFrontMatterNode: t } = Ue(), s2 = lt(), a2 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
    function n(i, l, p2) {
      if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p2.type === "css-root" && p2.nodes.length > 0 && ((p2.nodes[0] === i || t(p2.nodes[0]) && p2.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p2.type === "css-root" && s2(p2.nodes) === i))
        return null;
      if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (d, y, g) => {
        let c2 = Number(y);
        return Number.isNaN(c2) ? d : c2 + g.toLowerCase();
      })), i.type === "selector-tag") {
        let d = i.value.toLowerCase();
        ["from", "to"].includes(d) && (l.value = d);
      }
      if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
        let d = i.groups.findIndex((y) => y.type === "value-number" && y.unit === "...");
        d !== -1 && (l.groups[d].unit = "", l.groups.splice(d + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
      }
      if (i.type === "value-comma_group" && i.groups.some((d) => d.type === "value-atword" && d.value.endsWith("[") || d.type === "value-word" && d.value.startsWith("]")))
        return { type: "value-atword", value: i.groups.map((d) => d.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
    }
    n.ignoredProperties = a2;
    function u(i) {
      return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
    }
    r.exports = n;
  } }), ru = te({ "src/utils/front-matter/print.js"(e, r) {
    ne();
    var { builders: { hardline: t, markAsRoot: s2 } } = qe();
    function a2(n, u) {
      if (n.lang === "yaml") {
        let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
        return s2([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
      }
    }
    r.exports = a2;
  } }), Ed = te({ "src/language-css/embed.js"(e, r) {
    ne();
    var { builders: { hardline: t } } = qe(), s2 = ru();
    function a2(n, u, i) {
      let l = n.getValue();
      if (l.type === "front-matter") {
        let p2 = s2(l, i);
        return p2 ? [p2, t] : "";
      }
    }
    r.exports = a2;
  } }), Ao = te({ "src/utils/front-matter/parse.js"(e, r) {
    ne();
    var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
    function s2(a2) {
      let n = a2.match(t);
      if (!n)
        return { content: a2 };
      let { startDelimiter: u, language: i, value: l = "", endDelimiter: p2 } = n.groups, d = i.trim() || "yaml";
      if (u === "+++" && (d = "toml"), d !== "yaml" && u !== p2)
        return { content: a2 };
      let [y] = n;
      return { frontMatter: { type: "front-matter", lang: d, value: l, startDelimiter: u, endDelimiter: p2, raw: y.replace(/\n$/, "") }, content: y.replace(/[^\n]/g, " ") + a2.slice(y.length) };
    }
    r.exports = s2;
  } }), Fd = te({ "src/language-css/pragma.js"(e, r) {
    ne();
    var t = po(), s2 = Ao();
    function a2(u) {
      return t.hasPragma(s2(u).content);
    }
    function n(u) {
      let { frontMatter: i, content: l } = s2(u);
      return (i ? i.raw + `

` : "") + t.insertPragma(l);
    }
    r.exports = { hasPragma: a2, insertPragma: n };
  } }), Ad = te({ "src/language-css/utils/index.js"(e, r) {
    ne();
    var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
    function s2(z, U) {
      let Z = Array.isArray(U) ? U : [U], se = -1, fe;
      for (; fe = z.getParentNode(++se); )
        if (Z.includes(fe.type))
          return se;
      return -1;
    }
    function a2(z, U) {
      let Z = s2(z, U);
      return Z === -1 ? null : z.getParentNode(Z);
    }
    function n(z) {
      var U;
      let Z = a2(z, "css-decl");
      return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
    }
    var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
    function i(z) {
      return u.has(z.toLowerCase());
    }
    function l(z, U) {
      let Z = a2(z, "css-atrule");
      return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
    }
    function p2(z) {
      return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
    }
    function d(z, U) {
      var Z;
      let se = a2(z, "value-func");
      return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
    }
    function y(z) {
      var U;
      let Z = a2(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
      return se && (se.startsWith(":import") || se.startsWith(":export"));
    }
    function g(z, U) {
      let Z = Array.isArray(U) ? U : [U], se = a2(z, "css-atrule");
      return se && Z.includes(se.name.toLowerCase());
    }
    function c2(z) {
      let U = z.getValue(), Z = a2(z, "css-atrule");
      return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
    }
    function f(z) {
      return z.type === "value-func" && z.value.toLowerCase() === "url";
    }
    function E(z, U) {
      var Z;
      let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
      return se && se.indexOf(U) === se.length - 1;
    }
    function _(z) {
      let { selector: U } = z;
      return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
    }
    function w(z) {
      return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
    }
    function F(z) {
      return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
    }
    function N(z) {
      return z.type === "value-word" && z.value === "in";
    }
    function x2(z) {
      return z.type === "value-operator" && z.value === "*";
    }
    function I(z) {
      return z.type === "value-operator" && z.value === "/";
    }
    function P(z) {
      return z.type === "value-operator" && z.value === "+";
    }
    function $2(z) {
      return z.type === "value-operator" && z.value === "-";
    }
    function D(z) {
      return z.type === "value-operator" && z.value === "%";
    }
    function T(z) {
      return x2(z) || I(z) || P(z) || $2(z) || D(z);
    }
    function m2(z) {
      return z.type === "value-word" && ["==", "!="].includes(z.value);
    }
    function C(z) {
      return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
    }
    function o(z) {
      return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
    }
    function h2(z) {
      var U;
      return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
    }
    function v(z) {
      return z.name.startsWith("prettier-placeholder");
    }
    function S(z) {
      return z.prop.startsWith("@prettier-placeholder");
    }
    function b(z, U) {
      return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
    }
    function B(z) {
      var U, Z;
      return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
    }
    function k(z) {
      var U, Z, se;
      return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
    }
    function M(z) {
      var U;
      return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
    }
    function R(z) {
      var U, Z;
      return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
    }
    function q2(z) {
      var U;
      return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
    }
    function J(z) {
      var U;
      let Z = z.getValue();
      if (Z.groups.length === 0)
        return false;
      let se = z.getParentNode(1);
      if (!q2(Z) && !(se && q2(se)))
        return false;
      let fe = a2(z, "css-decl");
      return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q2(se) || se.type === "value-func");
    }
    function L(z) {
      return z.type === "value-comment" && z.inline;
    }
    function Q(z) {
      return z.type === "value-word" && z.value === "#";
    }
    function V(z) {
      return z.type === "value-word" && z.value === "{";
    }
    function j(z) {
      return z.type === "value-word" && z.value === "}";
    }
    function Y(z) {
      return ["value-word", "value-atword"].includes(z.type);
    }
    function ie(z) {
      return (z == null ? void 0 : z.type) === "value-colon";
    }
    function ee(z, U) {
      if (!R(U))
        return false;
      let { groups: Z } = U, se = Z.indexOf(z);
      return se === -1 ? false : ie(Z[se + 1]);
    }
    function ce(z) {
      return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
    }
    function W(z) {
      return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
    }
    function K(z) {
      return /\/\//.test(z.split(/[\n\r]/).pop());
    }
    function de(z) {
      return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
    }
    function ue(z, U) {
      var Z, se;
      if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
        return false;
      if (U.type === "value-comma_group") {
        let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
        if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
          return true;
      }
      return false;
    }
    function Fe(z) {
      var U, Z;
      return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
    }
    r.exports = { getAncestorCounter: s2, getAncestorNode: a2, getPropOfDeclNode: n, maybeToLowerCase: p2, insideValueFunctionNode: d, insideICSSRuleNode: y, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c2, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: E, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m2, isMultiplicationNode: x2, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $2, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: F, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: h2, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q2, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
  } }), Sd = te({ "src/utils/line-column-to-index.js"(e, r) {
    ne(), r.exports = function(t, s2) {
      let a2 = 0;
      for (let n = 0; n < t.line - 1; ++n)
        a2 = s2.indexOf(`
`, a2) + 1;
      return a2 + t.column;
    };
  } }), xd = te({ "src/language-css/loc.js"(e, r) {
    ne();
    var { skipEverythingButNewLine: t } = wr(), s2 = lt(), a2 = Sd();
    function n(c2, f) {
      return typeof c2.sourceIndex == "number" ? c2.sourceIndex : c2.source ? a2(c2.source.start, f) - 1 : null;
    }
    function u(c2, f) {
      if (c2.type === "css-comment" && c2.inline)
        return t(f, c2.source.startOffset);
      let E = c2.nodes && s2(c2.nodes);
      return E && c2.source && !c2.source.end && (c2 = E), c2.source && c2.source.end ? a2(c2.source.end, f) : null;
    }
    function i(c2, f) {
      c2.source && (c2.source.startOffset = n(c2, f), c2.source.endOffset = u(c2, f));
      for (let E in c2) {
        let _ = c2[E];
        E === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p2(c2), _.text || _.value) : i(_, f));
      }
    }
    function l(c2, f, E) {
      c2.source && (c2.source.startOffset = n(c2, E) + f, c2.source.endOffset = u(c2, E) + f);
      for (let _ in c2) {
        let w = c2[_];
        _ === "source" || !w || typeof w != "object" || l(w, f, E);
      }
    }
    function p2(c2) {
      let f = c2.source.startOffset;
      return typeof c2.prop == "string" && (f += c2.prop.length), c2.type === "css-atrule" && typeof c2.name == "string" && (f += 1 + c2.name.length + c2.raws.afterName.match(/^\s*:?\s*/)[0].length), c2.type !== "css-atrule" && c2.raws && typeof c2.raws.between == "string" && (f += c2.raws.between.length), f;
    }
    function d(c2) {
      let f = "initial", E = "initial", _, w = false, F = [];
      for (let N = 0; N < c2.length; N++) {
        let x2 = c2[N];
        switch (f) {
          case "initial":
            if (x2 === "'") {
              f = "single-quotes";
              continue;
            }
            if (x2 === '"') {
              f = "double-quotes";
              continue;
            }
            if ((x2 === "u" || x2 === "U") && c2.slice(N, N + 4).toLowerCase() === "url(") {
              f = "url", N += 3;
              continue;
            }
            if (x2 === "*" && c2[N - 1] === "/") {
              f = "comment-block";
              continue;
            }
            if (x2 === "/" && c2[N - 1] === "/") {
              f = "comment-inline", _ = N - 1;
              continue;
            }
            continue;
          case "single-quotes":
            if (x2 === "'" && c2[N - 1] !== "\\" && (f = E, E = "initial"), x2 === `
` || x2 === "\r")
              return c2;
            continue;
          case "double-quotes":
            if (x2 === '"' && c2[N - 1] !== "\\" && (f = E, E = "initial"), x2 === `
` || x2 === "\r")
              return c2;
            continue;
          case "url":
            if (x2 === ")" && (f = "initial"), x2 === `
` || x2 === "\r")
              return c2;
            if (x2 === "'") {
              f = "single-quotes", E = "url";
              continue;
            }
            if (x2 === '"') {
              f = "double-quotes", E = "url";
              continue;
            }
            continue;
          case "comment-block":
            x2 === "/" && c2[N - 1] === "*" && (f = "initial");
            continue;
          case "comment-inline":
            (x2 === '"' || x2 === "'" || x2 === "*") && (w = true), (x2 === `
` || x2 === "\r") && (w && F.push([_, N]), f = "initial", w = false);
            continue;
        }
      }
      for (let [N, x2] of F)
        c2 = c2.slice(0, N) + c2.slice(N, x2).replace(/["'*]/g, " ") + c2.slice(x2);
      return c2;
    }
    function y(c2) {
      return c2.source.startOffset;
    }
    function g(c2) {
      return c2.source.endOffset;
    }
    r.exports = { locStart: y, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: d };
  } }), bd = te({ "src/language-css/utils/is-less-parser.js"(e, r) {
    ne();
    function t(s2) {
      return s2.parser === "css" || s2.parser === "less";
    }
    r.exports = t;
  } }), Td = te({ "src/language-css/utils/is-scss.js"(e, r) {
    ne();
    function t(s2, a2) {
      return s2 === "less" || s2 === "scss" ? s2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a2);
    }
    r.exports = t;
  } }), Bd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
    r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
  } }), Nd = te({ "src/language-css/utils/print-unit.js"(e, r) {
    ne();
    var t = Bd();
    function s2(a2) {
      let n = a2.toLowerCase();
      return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a2;
    }
    r.exports = s2;
  } }), wd = te({ "src/language-css/printer-postcss.js"(e, r) {
    ne();
    var t = lt(), { printNumber: s2, printString: a2, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p2, line: d, hardline: y, softline: g, group: c2, fill: f, indent: E, dedent: _, ifBreak: w, breakParent: F }, utils: { removeLines: N, getDocParts: x2 } } = qe(), I = Cd(), P = Ed(), { insertPragma: $2 } = Fd(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m2, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: h2, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q2, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Ad(), { locStart: Ae, locEnd: Ee } = xd(), De = bd(), A = Td(), G = Nd();
    function re2(be) {
      return be.trailingComma === "es5" || be.trailingComma === "all";
    }
    function ye(be, je, Me) {
      let ae = be.getValue();
      if (!ae)
        return "";
      if (typeof ae == "string")
        return ae;
      switch (ae.type) {
        case "front-matter":
          return [ae.raw, y];
        case "css-root": {
          let Ve = Ce(be, je, Me), We = ae.raws.after.trim();
          return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x2(Ve).length > 0 ? y : ""];
        }
        case "css-comment": {
          let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
          return Ve ? We.trimEnd() : We;
        }
        case "css-rule":
          return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? d : " ", "{", ae.nodes.length > 0 ? E([y, Ce(be, je, Me)]) : "", y, "}", M(ae) ? ";" : ""] : ";"];
        case "css-decl": {
          let Ve = be.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
          return !st && H(Xe) && (O = E([y, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(be) ? ae.prop : m2(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", E([g, Ce(be, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(be, ae) ? w(";") : ";"];
        }
        case "css-atrule": {
          let Ve = be.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
          if (De(je)) {
            if (ae.mixin)
              return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
            if (ae.function)
              return [ae.name, Me("params"), We ? "" : ";"];
            if (ae.variable)
              return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", E([ae.nodes.length > 0 ? g : "", Ce(be, je, Me)]), g, "}"] : "", We ? "" : ";"];
          }
          return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m2(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [y, y] : /^\s*\n/.test(ae.raws.afterName) ? y : " " : " ", Me("params")] : "", ae.selector ? E([" ", Me("selector")]) : "", ae.value ? c2([" ", Me("value"), k(ae) ? K(ae) ? " " : d : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? d : " ", "{", E([ae.nodes.length > 0 ? g : "", Ce(be, je, Me)]), g, "}"] : We ? "" : ";"];
        }
        case "media-query-list": {
          let Ve = [];
          return be.each((We) => {
            let Xe = We.getValue();
            Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
          }, "nodes"), c2(E(p2(d, Ve)));
        }
        case "media-query":
          return [p2(" ", be.map(Me, "nodes")), B(be, ae) ? "" : ","];
        case "media-type":
          return Oe(Se(ae.value, je));
        case "media-feature-expression":
          return ae.nodes ? ["(", ...be.map(Me, "nodes"), ")"] : ae.value;
        case "media-feature":
          return m2(Se(ae.value.replace(/ +/g, " "), je));
        case "media-colon":
          return [ae.value, " "];
        case "media-value":
          return Oe(Se(ae.value, je));
        case "media-keyword":
          return Se(ae.value, je);
        case "media-url":
          return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
        case "media-unknown":
          return ae.value;
        case "selector-root":
          return c2([h2(be, "custom-selector") ? [D(be, "css-atrule").customSelector, d] : "", p2([",", h2(be, ["extend", "custom-selector", "nest"]) ? d : y], be.map(Me, "nodes"))]);
        case "selector-selector":
          return c2(E(be.map(Me, "nodes")));
        case "selector-comment":
          return ae.value;
        case "selector-string":
          return Se(ae.value, je);
        case "selector-tag": {
          let Ve = be.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
          return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(be, ae.value) ? ae.value.toLowerCase() : ae.value)];
        }
        case "selector-id":
          return ["#", ae.value];
        case "selector-class":
          return [".", Oe(Se(ae.value, je))];
        case "selector-attribute": {
          var nt;
          return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
        }
        case "selector-combinator": {
          if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
            let Xe = be.getParentNode();
            return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : d, ae.value, B(be, ae) ? "" : " "];
          }
          let Ve = ae.value.trim().startsWith("(") ? d : "", We = Oe(Se(ae.value.trim(), je)) || d;
          return [Ve, We];
        }
        case "selector-universal":
          return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
        case "selector-pseudo":
          return [m2(ae.value), l(ae.nodes) ? c2(["(", E([g, p2([",", d], be.map(Me, "nodes"))]), g, ")"]) : ""];
        case "selector-nesting":
          return ae.value;
        case "selector-unknown": {
          let Ve = D(be, "css-rule");
          if (Ve && Ve.isSCSSNesterProperty)
            return Oe(Se(m2(ae.value), je));
          let We = be.getParentNode();
          if (We.raws && We.raws.selector) {
            let st = Ae(We), O = st + We.raws.selector.length;
            return je.originalText.slice(st, O).trim();
          }
          let Xe = be.getParentNode(1);
          if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
            let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
            return H(me) ? [F, me] : me;
          }
          return ae.value;
        }
        case "value-value":
        case "value-root":
          return Me("group");
        case "value-comment":
          return je.originalText.slice(Ae(ae), Ee(ae));
        case "value-comma_group": {
          let Ve = be.getParentNode(), We = be.getParentNode(1), Xe = T(be), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(be, "css-atrule"), me = O && k(O), _e = ae.groups.some((at2) => ge(at2)), He = be.map(Me, "groups"), Ge = [], it = C(be, "url"), Qe = false, rt = false;
          for (let at2 = 0; at2 < ae.groups.length; ++at2) {
            var tt;
            Ge.push(He[at2]);
            let Ze = ae.groups[at2 - 1], Le = ae.groups[at2], $e = ae.groups[at2 + 1], nr = ae.groups[at2 + 2];
            if (it) {
              ($e && Q($e) || Q(Le)) && Ge.push(" ");
              continue;
            }
            if (h2(be, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e))
              continue;
            if (Le.type === "value-string" && Le.quoted) {
              let Mr = Le.value.lastIndexOf("#{"), Rr = Le.value.lastIndexOf("}");
              Mr !== -1 && Rr !== -1 ? Qe = Mr > Rr : Mr !== -1 ? Qe = true : Rr !== -1 && (Qe = false);
            }
            if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e))
              continue;
            let qr = j(Le), su = j($e);
            if ((qr && he($e) || su && ke(Le)) && de($e) || !Ze && L(Le) || C(be, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e))
              continue;
            let No = (Q(Le) || V(Le)) && at2 === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), iu = nr && nr.type === "value-func" || nr && Re(nr) || Le.type === "value-func" || Re(Le), au = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
            if (!(!(J($e) || J(Le)) && !C(be, "calc") && !No && (L($e) && !iu || L(Le) && !au || Q($e) && !iu || Q(Le) && !au || V($e) || V(Le)) && (de($e) || qr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && qr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
              if (ge(Le)) {
                if (Ve.type === "value-paren_group") {
                  Ge.push(_(y));
                  continue;
                }
                Ge.push(y);
                continue;
              }
              if (me && (q2($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                Ge.push(" ");
                continue;
              }
              if (O && O.name.toLowerCase() === "namespace") {
                Ge.push(" ");
                continue;
              }
              if (st) {
                Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(y), rt = true) : Ge.push(" ");
                continue;
              }
              if (su) {
                Ge.push(" ");
                continue;
              }
              if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                  Ge.push(g);
                  continue;
                }
                if (Le.value === "with" && le($e)) {
                  Ge.push(" ");
                  continue;
                }
                (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(d);
              }
            }
          }
          return _e && Ge.push(F), rt && Ge.unshift(y), me ? c2(E(Ge)) : v(be) ? c2(f(Ge)) : c2(E(f(Ge)));
        }
        case "value-paren_group": {
          let Ve = be.getParentNode();
          if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
            return [ae.open ? Me("open") : "", p2(",", be.map(Me, "groups")), ae.close ? Me("close") : ""];
          if (!ae.open) {
            let it = be.map(Me, "groups"), Qe = [];
            for (let rt = 0; rt < it.length; rt++)
              rt !== 0 && Qe.push([",", d]), Qe.push(it[rt]);
            return c2(E(f(Qe)));
          }
          let We = fe(be), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c2([ae.open ? Me("open") : "", E([g, p2([d], be.map((it, Qe) => {
            let rt = it.getValue(), at2 = Qe === ae.groups.length - 1, Ze = [Me(), at2 ? "" : ","];
            if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
              let Le = x2(Ze[0].contents.contents);
              Le[1] = c2(Le[1]), Ze = [c2(_(Ze))];
            }
            if (!at2 && rt.type === "value-comma_group" && l(rt.groups)) {
              let Le = t(rt.groups);
              !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(y);
            }
            return Ze;
          }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re2(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
          return He ? _(Ge) : Ge;
        }
        case "value-func":
          return [ae.value, h2(be, "supports") && Pe(ae) ? " " : "", Me("group")];
        case "value-paren":
          return ae.value;
        case "value-number":
          return [Je(ae.value), G(ae.unit)];
        case "value-operator":
          return ae.value;
        case "value-word":
          return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
        case "value-colon": {
          let Ve = be.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
          return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(be, "url") ? "" : d];
        }
        case "value-comma":
          return [ae.value, " "];
        case "value-string":
          return a2(ae.raws.quote + ae.value + ae.raws.quote, je);
        case "value-atword":
          return ["@", ae.value];
        case "value-unicode-range":
          return ae.value;
        case "value-unknown":
          return ae.value;
        default:
          throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
      }
    }
    function Ce(be, je, Me) {
      let ae = [];
      return be.each((nt, tt, Ve) => {
        let We = Ve[tt - 1];
        if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
          let Xe = nt.getValue();
          ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
        } else
          ae.push(Me());
        tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? d : y), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(y)));
      }, "nodes"), ae;
    }
    var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, xe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${xe.source})?(${ve.source})(${ze.source})?`, "g");
    function Se(be, je) {
      return be.replace(Be, (Me) => a2(Me, je));
    }
    function Ie(be, je) {
      let Me = je.singleQuote ? "'" : '"';
      return be.includes('"') || be.includes("'") ? be : Me + be + Me;
    }
    function Oe(be) {
      return be.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m2(tt || "") : je);
    }
    function Je(be) {
      return s2(be).replace(/\.0(?=$|e)/, "");
    }
    r.exports = { print: ye, embed: P, insertPragma: $2, massageAstNode: I };
  } }), _d = te({ "src/language-css/options.js"(e, r) {
    ne();
    var t = jt();
    r.exports = { singleQuote: t.singleQuote };
  } }), Pd = te({ "src/language-css/parsers.js"() {
    ne();
  } }), Id = te({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
    r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
  } }), kd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
    r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
  } }), Ld = te({ "node_modules/linguist-languages/data/Less.json"(e, r) {
    r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
  } }), Od = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
    r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
  } }), jd = te({ "src/language-css/index.js"(e, r) {
    ne();
    var t = wt(), s2 = wd(), a2 = _d(), n = Pd(), u = [t(Id(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(kd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Ld(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Od(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s2 };
    r.exports = { languages: u, options: a2, printers: i, parsers: n };
  } }), qd = te({ "src/language-handlebars/loc.js"(e, r) {
    ne();
    function t(a2) {
      return a2.loc.start.offset;
    }
    function s2(a2) {
      return a2.loc.end.offset;
    }
    r.exports = { locStart: t, locEnd: s2 };
  } }), Md = te({ "src/language-handlebars/clean.js"(e, r) {
    ne();
    function t(s2, a2) {
      if (s2.type === "TextNode") {
        let n = s2.chars.trim();
        if (!n)
          return null;
        a2.chars = n.replace(/[\t\n\f\r ]+/g, " ");
      }
      s2.type === "AttrNode" && s2.name.toLowerCase() === "class" && delete a2.value;
    }
    t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
  } }), Rd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
    r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
  } }), $d = te({ "src/language-handlebars/utils.js"(e, r) {
    ne();
    var t = lt(), s2 = Rd();
    function a2(x2) {
      let I = x2.getValue(), P = x2.getParentNode(0);
      return !!(g(x2, ["ElementNode"]) && t(P.children) === I || g(x2, ["Block"]) && t(P.body) === I);
    }
    function n(x2) {
      return x2.toUpperCase() === x2;
    }
    function u(x2) {
      return y(x2, ["ElementNode"]) && typeof x2.tag == "string" && !x2.tag.startsWith(":") && (n(x2.tag[0]) || x2.tag.includes("."));
    }
    var i = new Set(s2);
    function l(x2) {
      return i.has(x2.toLowerCase()) && !n(x2[0]);
    }
    function p2(x2) {
      return x2.selfClosing === true || l(x2.tag) || u(x2) && x2.children.every((I) => d(I));
    }
    function d(x2) {
      return y(x2, ["TextNode"]) && !/\S/.test(x2.chars);
    }
    function y(x2, I) {
      return x2 && I.includes(x2.type);
    }
    function g(x2, I) {
      let P = x2.getParentNode(0);
      return y(P, I);
    }
    function c2(x2, I) {
      let P = _(x2);
      return y(P, I);
    }
    function f(x2, I) {
      let P = w(x2);
      return y(P, I);
    }
    function E(x2, I) {
      var P, $2, D, T;
      let m2 = x2.getValue(), C = (P = x2.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($2 = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $2 !== void 0 ? $2 : [], h2 = o.indexOf(m2);
      return h2 !== -1 && o[h2 + I];
    }
    function _(x2) {
      let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return E(x2, -I);
    }
    function w(x2) {
      return E(x2, 1);
    }
    function F(x2) {
      return y(x2, ["MustacheCommentStatement"]) && typeof x2.value == "string" && x2.value.trim() === "prettier-ignore";
    }
    function N(x2) {
      let I = x2.getValue(), P = _(x2, 2);
      return F(I) || F(P);
    }
    r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a2, isNextNodeOfSomeType: f, isNodeOfSomeType: y, isParentOfSomeType: g, isPreviousNodeOfSomeType: c2, isVoid: p2, isWhitespaceNode: d };
  } }), Vd = te({ "src/language-handlebars/printer-glimmer.js"(e, r) {
    ne();
    var { builders: { dedent: t, fill: s2, group: a2, hardline: n, ifBreak: u, indent: i, join: l, line: p2, softline: d }, utils: { getDocParts: y, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c2, isNonEmptyArray: f } = Ue(), { locStart: E, locEnd: _ } = qd(), w = Md(), { getNextNode: F, getPreviousNode: N, hasPrettierIgnore: x2, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $2, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m2, isWhitespaceNode: C } = $d(), o = 2;
    function h2(H, pe, X) {
      let le = H.getValue();
      if (!le)
        return "";
      if (x2(H))
        return pe.originalText.slice(E(le), _(le));
      let Ae = pe.singleQuote ? "'" : '"';
      switch (le.type) {
        case "Block":
        case "Program":
        case "Template":
          return a2(H.map(X, "body"));
        case "ElementNode": {
          let Ee = a2(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? d : "";
          if (m2(le))
            return [Ee, De];
          let A = ["</", le.tag, ">"];
          return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a2(b(H, pe, X))), i(A), De];
        }
        case "BlockStatement": {
          let Ee = H.getParentNode(1);
          return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a2([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
        }
        case "ElementModifierStatement":
          return a2(["{{", Re(H, X), "}}"]);
        case "MustacheStatement":
          return a2([k(le), Re(H, X), M(le)]);
        case "SubExpression":
          return a2(["(", ke(H, X), d, ")"]);
        case "AttrNode": {
          let Ee = le.value.type === "TextNode";
          if (Ee && le.value.chars === "" && E(le.value) === _(le.value))
            return le.name;
          let A = Ee ? c2(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c2(le.value.parts.filter((re2) => re2.type === "TextNode").map((re2) => re2.chars).join(""), Ae).quote : "", G = X("value");
          return [le.name, "=", A, le.name === "class" && A ? a2(i(G)) : G, A];
        }
        case "ConcatStatement":
          return H.map(X, "parts");
        case "Hash":
          return l(p2, H.map(X, "pairs"));
        case "HashPair":
          return [le.key, "=", X("value")];
        case "TextNode": {
          let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
          if (De) {
            if (De === "class") {
              let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
              return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p2 : "", Ye, Ie ? p2 : ""];
            }
            return g(Ee);
          }
          let G = /^[\t\n\f\r ]*$/.test(Ee), re2 = !N(H), ye = !F(H);
          if (pe.htmlWhitespaceSensitivity !== "ignore") {
            let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re2 && D(H, ["Template"]);
            if (G) {
              if (Oe || Ie)
                return "";
              let ae = [p2], nt = Z(Ee);
              return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
            }
            let [Je] = Ee.match(Ye), [be] = Ee.match(Se), je = [];
            if (Je) {
              je = [p2];
              let ae = Z(Je);
              ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
            }
            let Me = [];
            if (be) {
              if (!Ie) {
                Me = [p2];
                let ae = Z(be);
                ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
              }
              Ee = Ee.replace(Se, "");
            }
            return [...je, s2(Fe(Ee)), ...Me];
          }
          let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
          if ((re2 || ye) && G && D(H, ["Block", "ElementNode", "Template"]))
            return "";
          G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
          let ze = "", xe = "";
          return ve === 0 && P(H, ["MustacheStatement"]) && (xe = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re2 && (Be = 0, ze = ""), ye && (ve = 0, xe = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, xe), [...ge(Be), s2(Fe(Ee)), ...ge(ve)];
        }
        case "MustacheCommentStatement": {
          let Ee = E(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re2 = le.value.includes("}}") ? "--" : "";
          return ["{{", A ? "~" : "", "!", re2, le.value, re2, G ? "~" : "", "}}"];
        }
        case "PathExpression":
          return le.original;
        case "BooleanLiteral":
          return String(le.value);
        case "CommentStatement":
          return ["<!--", le.value, "-->"];
        case "StringLiteral": {
          if (we(H)) {
            let Ee = pe.singleQuote ? '"' : "'";
            return he(le.value, Ee);
          }
          return he(le.value, Ae);
        }
        case "NumberLiteral":
          return String(le.value);
        case "UndefinedLiteral":
          return "undefined";
        case "NullLiteral":
          return "null";
        default:
          throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
      }
    }
    function v(H, pe) {
      return E(H) - E(pe);
    }
    function S(H, pe) {
      let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
      for (let Ee of le)
        H.each((De) => {
          let A = Ae.indexOf(De.getValue());
          Ae.splice(A, 1, [p2, pe()]);
        }, Ee);
      return f(X.blockParams) && Ae.push(p2, oe(X)), ["<", X.tag, i(Ae), B(X)];
    }
    function b(H, pe, X) {
      let Ae = H.getValue().children.every((Ee) => C(Ee));
      return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
        let A = X();
        return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [d, A] : A;
      }, "children");
    }
    function B(H) {
      return m2(H) ? u([d, "/>"], [" />", d]) : u([d, ">"], ">");
    }
    function k(H) {
      let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
      return [pe, X];
    }
    function M(H) {
      let pe = H.escaped === false ? "}}}" : "}}";
      return [H.strip && H.strip.close ? "~" : "", pe];
    }
    function R(H) {
      let pe = k(H), X = H.openStrip.open ? "~" : "";
      return [pe, X, "#"];
    }
    function q2(H) {
      let pe = M(H);
      return [H.openStrip.close ? "~" : "", pe];
    }
    function J(H) {
      let pe = k(H), X = H.closeStrip.open ? "~" : "";
      return [pe, X, "/"];
    }
    function L(H) {
      let pe = M(H);
      return [H.closeStrip.close ? "~" : "", pe];
    }
    function Q(H) {
      let pe = k(H), X = H.inverseStrip.open ? "~" : "";
      return [pe, X];
    }
    function V(H) {
      let pe = M(H);
      return [H.inverseStrip.close ? "~" : "", pe];
    }
    function j(H, pe) {
      let X = H.getValue(), le = [], Ae = Pe(H, pe);
      return Ae && le.push(a2(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a2([R(X), Ne(H, pe), le.length > 0 ? i([p2, l(p2, le)]) : "", d, q2(X)]);
    }
    function Y(H, pe) {
      return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
    }
    function ie(H, pe, X) {
      let le = H.getValue(), Ae = H.getParentNode(1);
      return a2([Q(Ae), ["else", " ", X], i([p2, a2(Pe(H, pe)), ...f(le.program.blockParams) ? [p2, oe(le.program)] : []]), d, V(Ae)]);
    }
    function ee(H, pe, X) {
      let le = H.getValue();
      return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? d : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
    }
    function ce(H) {
      return $2(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
    }
    function W(H) {
      return K(H) && H.inverse.body.length === 1 && $2(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
    }
    function K(H) {
      return $2(H, ["BlockStatement"]) && H.inverse;
    }
    function de(H, pe, X) {
      let le = H.getValue();
      if (ce(le))
        return "";
      let Ae = pe("program");
      return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
    }
    function ue(H, pe, X) {
      let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
      return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
    }
    function Fe(H) {
      return y(l(p2, z(H)));
    }
    function z(H) {
      return H.split(/[\t\n\f\r ]+/);
    }
    function U(H) {
      for (let pe = 0; pe < 2; pe++) {
        let X = H.getParentNode(pe);
        if (X && X.type === "AttrNode")
          return X.name.toLowerCase();
      }
    }
    function Z(H) {
      return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
    }
    function se(H) {
      H = typeof H == "string" ? H : "";
      let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
      return Z(pe);
    }
    function fe(H) {
      H = typeof H == "string" ? H : "";
      let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
      return Z(pe);
    }
    function ge() {
      let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return Array.from({ length: Math.min(H, o) }).fill(n);
    }
    function he(H, pe) {
      let { quote: X, regex: le } = c2(H, pe);
      return [X, H.replace(le, `\\${X}`), X];
    }
    function we(H) {
      let pe = 0, X = H.getParentNode(pe);
      for (; X && $2(X, ["SubExpression"]); )
        pe++, X = H.getParentNode(pe);
      return !!(X && $2(H.getParentNode(pe + 1), ["ConcatStatement"]) && $2(H.getParentNode(pe + 2), ["AttrNode"]));
    }
    function ke(H, pe) {
      let X = Ne(H, pe), le = Pe(H, pe);
      return le ? i([X, p2, a2(le)]) : X;
    }
    function Re(H, pe) {
      let X = Ne(H, pe), le = Pe(H, pe);
      return le ? [i([X, p2, le]), d] : X;
    }
    function Ne(H, pe) {
      return pe("path");
    }
    function Pe(H, pe) {
      let X = H.getValue(), le = [];
      if (X.params.length > 0) {
        let Ae = H.map(pe, "params");
        le.push(...Ae);
      }
      if (X.hash && X.hash.pairs.length > 0) {
        let Ae = pe("hash");
        le.push(Ae);
      }
      return le.length === 0 ? "" : l(p2, le);
    }
    function oe(H) {
      return ["as |", H.blockParams.join(" "), "|"];
    }
    r.exports = { print: h2, massageAstNode: w };
  } }), Wd = te({ "src/language-handlebars/parsers.js"() {
    ne();
  } }), Hd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
    r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
  } }), Gd = te({ "src/language-handlebars/index.js"(e, r) {
    ne();
    var t = wt(), s2 = Vd(), a2 = Wd(), n = [t(Hd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s2 };
    r.exports = { languages: n, printers: u, parsers: a2 };
  } }), Ud = te({ "src/language-graphql/pragma.js"(e, r) {
    ne();
    function t(a2) {
      return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a2);
    }
    function s2(a2) {
      return `# @format

` + a2;
    }
    r.exports = { hasPragma: t, insertPragma: s2 };
  } }), Jd = te({ "src/language-graphql/loc.js"(e, r) {
    ne();
    function t(a2) {
      return typeof a2.start == "number" ? a2.start : a2.loc && a2.loc.start;
    }
    function s2(a2) {
      return typeof a2.end == "number" ? a2.end : a2.loc && a2.loc.end;
    }
    r.exports = { locStart: t, locEnd: s2 };
  } }), zd = te({ "src/language-graphql/printer-graphql.js"(e, r) {
    ne();
    var { builders: { join: t, hardline: s2, line: a2, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p2, isNonEmptyArray: d } = Ue(), { insertPragma: y } = Ud(), { locStart: g, locEnd: c2 } = Jd();
    function f(P, $2, D) {
      let T = P.getValue();
      if (!T)
        return "";
      if (typeof T == "string")
        return T;
      switch (T.kind) {
        case "Document": {
          let m2 = [];
          return P.each((C, o, h2) => {
            m2.push(D()), o !== h2.length - 1 && (m2.push(s2), p2($2.originalText, C.getValue(), c2) && m2.push(s2));
          }, "definitions"), [...m2, s2];
        }
        case "OperationDefinition": {
          let m2 = $2.originalText[g(T)] !== "{", C = Boolean(T.name);
          return [m2 ? T.operation : "", m2 && C ? [" ", D("name")] : "", m2 && !C && d(T.variableDefinitions) ? " " : "", d(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", E(P, D, T), T.selectionSet ? !m2 && !C ? "" : " " : "", D("selectionSet")];
        }
        case "FragmentDefinition":
          return ["fragment ", D("name"), d(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), E(P, D, T), " ", D("selectionSet")];
        case "SelectionSet":
          return ["{", i([s2, t(s2, _(P, $2, D, "selections"))]), s2, "}"];
        case "Field":
          return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", E(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
        case "Name":
          return T.value;
        case "StringValue": {
          if (T.block) {
            let m2 = T.value.replace(/"""/g, "\\$&").split(`
`);
            return m2.length === 1 && (m2[0] = m2[0].trim()), m2.every((C) => C === "") && (m2.length = 0), t(s2, ['"""', ...m2, '"""']);
          }
          return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
        }
        case "IntValue":
        case "FloatValue":
        case "EnumValue":
          return T.value;
        case "BooleanValue":
          return T.value ? "true" : "false";
        case "NullValue":
          return "null";
        case "Variable":
          return ["$", D("name")];
        case "ListValue":
          return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
        case "ObjectValue":
          return u(["{", $2.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $2.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
        case "ObjectField":
        case "Argument":
          return [D("name"), ": ", D("value")];
        case "Directive":
          return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : ""];
        case "NamedType":
          return D("name");
        case "VariableDefinition":
          return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E(P, D, T)];
        case "ObjectTypeExtension":
        case "ObjectTypeDefinition":
          return [D("description"), T.description ? s2 : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", E(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
        case "FieldDefinition":
          return [D("description"), T.description ? s2 : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), E(P, D, T)];
        case "DirectiveDefinition":
          return [D("description"), T.description ? s2 : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
        case "EnumTypeExtension":
        case "EnumTypeDefinition":
          return [D("description"), T.description ? s2 : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), E(P, D, T), T.values.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "values"))]), s2, "}"] : ""];
        case "EnumValueDefinition":
          return [D("description"), T.description ? s2 : "", D("name"), E(P, D, T)];
        case "InputValueDefinition":
          return [D("description"), T.description ? T.description.block ? s2 : a2 : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E(P, D, T)];
        case "InputObjectTypeExtension":
        case "InputObjectTypeDefinition":
          return [D("description"), T.description ? s2 : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), E(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
        case "SchemaExtension":
          return ["extend schema", E(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "operationTypes"))]), s2, "}"] : []];
        case "SchemaDefinition":
          return [D("description"), T.description ? s2 : "", "schema", E(P, D, T), " {", T.operationTypes.length > 0 ? i([s2, t(s2, _(P, $2, D, "operationTypes"))]) : "", s2, "}"];
        case "OperationTypeDefinition":
          return [D("operation"), ": ", D("type")];
        case "InterfaceTypeExtension":
        case "InterfaceTypeDefinition":
          return [D("description"), T.description ? s2 : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", E(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
        case "FragmentSpread":
          return ["...", D("name"), E(P, D, T)];
        case "InlineFragment":
          return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", E(P, D, T), " ", D("selectionSet")];
        case "UnionTypeExtension":
        case "UnionTypeDefinition":
          return u([D("description"), T.description ? s2 : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), E(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a2, "  "]), t([a2, "| "], P.map(D, "types"))])] : ""])]);
        case "ScalarTypeExtension":
        case "ScalarTypeDefinition":
          return [D("description"), T.description ? s2 : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), E(P, D, T)];
        case "NonNullType":
          return [D("type"), "!"];
        case "ListType":
          return ["[", D("type"), "]"];
        default:
          throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
      }
    }
    function E(P, $2, D) {
      if (D.directives.length === 0)
        return "";
      let T = t(a2, P.map($2, "directives"));
      return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a2, T]) : [" ", u(i([n, T]))];
    }
    function _(P, $2, D, T) {
      return P.map((m2, C, o) => {
        let h2 = D();
        return C < o.length - 1 && p2($2.originalText, m2.getValue(), c2) ? [h2, s2] : h2;
      }, T);
    }
    function w(P) {
      return P.kind && P.kind !== "Comment";
    }
    function F(P) {
      let $2 = P.getValue();
      if ($2.kind === "Comment")
        return "#" + $2.value.trimEnd();
      throw new Error("Not a comment: " + JSON.stringify($2));
    }
    function N(P, $2, D) {
      let T = P.getNode(), m2 = [], { interfaces: C } = T, o = P.map((h2) => D(h2), "interfaces");
      for (let h2 = 0; h2 < C.length; h2++) {
        let v = C[h2];
        m2.push(o[h2]);
        let S = C[h2 + 1];
        if (S) {
          let b = $2.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
          m2.push(k === "," ? "," : " &", B ? a2 : " ");
        }
      }
      return m2;
    }
    function x2(P, $2) {
      P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($2.value = $2.value.trim());
    }
    x2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
    function I(P) {
      var $2;
      let D = P.getValue();
      return D == null || ($2 = D.comments) === null || $2 === void 0 ? void 0 : $2.some((T) => T.value.trim() === "prettier-ignore");
    }
    r.exports = { print: f, massageAstNode: x2, hasPrettierIgnore: I, insertPragma: y, printComment: F, canAttachComment: w };
  } }), Xd = te({ "src/language-graphql/options.js"(e, r) {
    ne();
    var t = jt();
    r.exports = { bracketSpacing: t.bracketSpacing };
  } }), Kd = te({ "src/language-graphql/parsers.js"() {
    ne();
  } }), Yd = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
    r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
  } }), Qd = te({ "src/language-graphql/index.js"(e, r) {
    ne();
    var t = wt(), s2 = zd(), a2 = Xd(), n = Kd(), u = [t(Yd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s2 };
    r.exports = { languages: u, options: a2, printers: i, parsers: n };
  } }), So = te({ "node_modules/collapse-white-space/index.js"(e, r) {
    ne(), r.exports = t;
    function t(s2) {
      return String(s2).replace(/\s+/g, " ");
    }
  } }), xo = te({ "src/language-markdown/loc.js"(e, r) {
    ne();
    function t(a2) {
      return a2.position.start.offset;
    }
    function s2(a2) {
      return a2.position.end.offset;
    }
    r.exports = { locStart: t, locEnd: s2 };
  } }), Zd = te({ "src/language-markdown/constants.evaluate.js"(e, r) {
    r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
  } }), nu = te({ "src/language-markdown/utils.js"(e, r) {
    ne();
    var { getLast: t } = Ue(), { locStart: s2, locEnd: a2 } = xo(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = Zd(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p2 = [...l, "tableCell", "paragraph", "heading"], d = new RegExp(u), y = new RegExp(i);
    function g(F, N) {
      let x2 = "non-cjk", I = "cj-letter", P = "k-letter", $2 = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
      for (let [C, o] of T.entries()) {
        if (C % 2 === 1) {
          D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
          continue;
        }
        if ((C === 0 || C === T.length - 1) && o === "")
          continue;
        let h2 = o.split(new RegExp(`(${n})`));
        for (let [v, S] of h2.entries())
          if (!((v === 0 || v === h2.length - 1) && S === "")) {
            if (v % 2 === 0) {
              S !== "" && m2({ type: "word", value: S, kind: x2, hasLeadingPunctuation: y.test(S[0]), hasTrailingPunctuation: y.test(t(S)) });
              continue;
            }
            m2(y.test(S) ? { type: "word", value: S, kind: $2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: d.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
          }
      }
      return D;
      function m2(C) {
        let o = t(D);
        o && o.type === "word" && (o.kind === x2 && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x2 && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !h2(x2, $2) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
        function h2(v, S) {
          return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
        }
      }
    }
    function c2(F, N) {
      let [, x2, I, P] = N.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
      return { numberText: x2, marker: I, leadingSpaces: P };
    }
    function f(F, N) {
      if (!F.ordered || F.children.length < 2)
        return false;
      let x2 = Number(c2(F.children[0], N.originalText).numberText), I = Number(c2(F.children[1], N.originalText).numberText);
      if (x2 === 0 && F.children.length > 2) {
        let P = Number(c2(F.children[2], N.originalText).numberText);
        return I === 1 && P === 1;
      }
      return I === 1;
    }
    function E(F, N) {
      let { value: x2 } = F;
      return F.position.end.offset === N.length && x2.endsWith(`
`) && N.endsWith(`
`) ? x2.slice(0, -1) : x2;
    }
    function _(F, N) {
      return function x2(I, P, $2) {
        let D = Object.assign({}, N(I, P, $2));
        return D.children && (D.children = D.children.map((T, m2) => x2(T, m2, [D, ...$2]))), D;
      }(F, null, []);
    }
    function w(F) {
      if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1)
        return false;
      let [N] = F.children;
      return s2(F) === s2(N) && a2(F) === a2(N);
    }
    r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: E, getOrderedListItemInfo: c2, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p2, isAutolink: w };
  } }), eg = te({ "src/language-markdown/embed.js"(e, r) {
    ne();
    var { inferParserByLanguage: t, getMaxContinuousCount: s2 } = Ue(), { builders: { hardline: a2, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = ru(), { getFencedCodeBlockValue: l } = nu();
    function p2(d, y, g, c2) {
      let f = d.getValue();
      if (f.type === "code" && f.lang !== null) {
        let E = t(f.lang, c2);
        if (E) {
          let _ = c2.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s2(f.value, _) + 1)), F = { parser: E };
          f.lang === "tsx" && (F.filepath = "dummy.tsx");
          let N = g(l(f, c2.originalText), F, { stripTrailingHardline: true });
          return n([w, f.lang, f.meta ? " " + f.meta : "", a2, u(N), a2, w]);
        }
      }
      switch (f.type) {
        case "front-matter":
          return i(f, g);
        case "importExport":
          return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a2];
        case "jsx":
          return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
      }
      return null;
    }
    r.exports = p2;
  } }), bo = te({ "src/language-markdown/pragma.js"(e, r) {
    ne();
    var t = Ao(), s2 = ["format", "prettier"];
    function a2(n) {
      let u = `@(${s2.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
      return (l == null ? void 0 : l.index) === 0;
    }
    r.exports = { startWithPragma: a2, hasPragma: (n) => a2(t(n).content.trimStart()), insertPragma: (n) => {
      let u = t(n), i = `<!-- @${s2[0]} -->`;
      return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
    } };
  } }), tg = te({ "src/language-markdown/print-preprocess.js"(e, r) {
    ne();
    var t = lt(), { getOrderedListItemInfo: s2, mapAst: a2, splitText: n } = nu(), u = /^.$/su;
    function i(w, F) {
      return w = d(w, F), w = c2(w), w = p2(w, F), w = E(w, F), w = _(w, F), w = f(w, F), w = l(w), w = y(w), w;
    }
    function l(w) {
      return a2(w, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
    }
    function p2(w, F) {
      return a2(w, (N) => N.type !== "inlineCode" || F.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
    }
    function d(w, F) {
      return a2(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: F.originalText.slice(N.position.start.offset, N.position.end.offset) }));
    }
    function y(w) {
      return g(w, (F, N) => F.type === "importExport" && N.type === "importExport", (F, N) => ({ type: "importExport", value: F.value + `

` + N.value, position: { start: F.position.start, end: N.position.end } }));
    }
    function g(w, F, N) {
      return a2(w, (x2) => {
        if (!x2.children)
          return x2;
        let I = x2.children.reduce((P, $2) => {
          let D = t(P);
          return D && F(D, $2) ? P.splice(-1, 1, N(D, $2)) : P.push($2), P;
        }, []);
        return Object.assign(Object.assign({}, x2), {}, { children: I });
      });
    }
    function c2(w) {
      return g(w, (F, N) => F.type === "text" && N.type === "text", (F, N) => ({ type: "text", value: F.value + N.value, position: { start: F.position.start, end: N.position.end } }));
    }
    function f(w, F) {
      return a2(w, (N, x2, I) => {
        let [P] = I;
        if (N.type !== "text")
          return N;
        let { value: $2 } = N;
        return P.type === "paragraph" && (x2 === 0 && ($2 = $2.trimStart()), x2 === P.children.length - 1 && ($2 = $2.trimEnd())), { type: "sentence", position: N.position, children: n($2, F) };
      });
    }
    function E(w, F) {
      return a2(w, (N, x2, I) => {
        if (N.type === "code") {
          let P = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(N.position.start.offset, N.position.end.offset));
          if (N.isIndented = P, P)
            for (let $2 = 0; $2 < I.length; $2++) {
              let D = I[$2];
              if (D.hasIndentedCodeblock)
                break;
              D.type === "list" && (D.hasIndentedCodeblock = true);
            }
        }
        return N;
      });
    }
    function _(w, F) {
      return a2(w, (I, P, $2) => {
        if (I.type === "list" && I.children.length > 0) {
          for (let D = 0; D < $2.length; D++) {
            let T = $2[D];
            if (T.type === "list" && !T.isAligned)
              return I.isAligned = false, I;
          }
          I.isAligned = x2(I);
        }
        return I;
      });
      function N(I) {
        return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
      }
      function x2(I) {
        if (!I.ordered)
          return true;
        let [P, $2] = I.children;
        if (s2(P, F.originalText).leadingSpaces.length > 1)
          return true;
        let T = N(P);
        if (T === -1)
          return false;
        if (I.children.length === 1)
          return T % F.tabWidth === 0;
        let m2 = N($2);
        return T !== m2 ? false : T % F.tabWidth === 0 ? true : s2($2, F.originalText).leadingSpaces.length > 1;
      }
    }
    r.exports = i;
  } }), rg = te({ "src/language-markdown/clean.js"(e, r) {
    ne();
    var t = So(), { isFrontMatterNode: s2 } = Ue(), { startWithPragma: a2 } = bo(), n = /* @__PURE__ */ new Set(["position", "raw"]);
    function u(i, l, p2) {
      if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p2 && p2.type === "root" && p2.children.length > 0 && (p2.children[0] === i || s2(p2.children[0]) && p2.children[1] === i) && i.type === "html" && a2(i.value)))
        return null;
    }
    u.ignoredProperties = n, r.exports = u;
  } }), ng = te({ "src/language-markdown/printer-markdown.js"(e, r) {
    ne();
    var t = So(), { getLast: s2, getMinNotPresentContinuousCount: a2, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p2, line: d, literalline: y, markAsRoot: g, hardline: c2, softline: f, ifBreak: E, fill: _, align: w, indent: F, group: N, hardlineWithoutBreakParent: x2 }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $2 } } = qe(), D = eg(), { insertPragma: T } = bo(), { locStart: m2, locEnd: C } = xo(), o = tg(), h2 = rg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = nu(), q2 = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
    function Q(oe, H, pe) {
      let X = oe.getValue();
      if (ge(oe))
        return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
      switch (X.type) {
        case "front-matter":
          return H.originalText.slice(X.position.start.offset, X.position.end.offset);
        case "root":
          return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q2.has(z(X).type) ? "" : c2];
        case "paragraph":
          return ue(oe, H, pe, { postprocessor: _ });
        case "sentence":
          return ue(oe, H, pe);
        case "word": {
          let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re2, ye) => (G ? `${A}${G}` : `${re2}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
          return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
        }
        case "whitespace": {
          let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
          return W(oe, X.value, { proseWrap: De });
        }
        case "emphasis": {
          let le;
          if (R(X.children[0]))
            le = H.originalText[X.position.start.offset];
          else {
            let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
            le = De && De.type === "sentence" && De.children.length > 0 && s2(De.children).type === "word" && !s2(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
          }
          return [le, ue(oe, H, pe), le];
        }
        case "strong":
          return ["**", ue(oe, H, pe), "**"];
        case "delete":
          return ["~~", ue(oe, H, pe), "~~"];
        case "inlineCode": {
          let le = a2(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
          return [Ae, Ee, X.value, Ee, Ae];
        }
        case "wikiLink": {
          let le = "";
          return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
        }
        case "link":
          switch (H.originalText[X.position.start.offset]) {
            case "<": {
              let le = "mailto:";
              return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
            }
            case "[":
              return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
            default:
              return H.originalText.slice(X.position.start.offset, X.position.end.offset);
          }
        case "image":
          return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
        case "blockquote":
          return ["> ", w("> ", ue(oe, H, pe))];
        case "heading":
          return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
        case "code": {
          if (X.isIndented) {
            let Ee = " ".repeat(4);
            return w(Ee, [Ee, ...P(X.value, c2)]);
          }
          let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
          return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c2, ...P(v(X, H.originalText), c2), c2, Ae];
        }
        case "html": {
          let le = oe.getParentNode(), Ae = le.type === "root" && s2(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
          return P(Ae, Ee ? c2 : g(y));
        }
        case "list": {
          let le = Y(X, oe.getParentNode()), Ae = S(X, H);
          return ue(oe, H, pe, { processor: (Ee, De) => {
            let A = re2(), G = Ee.getValue();
            if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
              return [A, V(Ee, H, pe, A)];
            return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
            function re2() {
              let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
              return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
            }
          } });
        }
        case "thematicBreak": {
          let le = ee(oe, "list");
          return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
        }
        case "linkReference":
          return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
        case "imageReference":
          switch (X.referenceType) {
            case "full":
              return ["![", X.alt || "", "]", Ne(X)];
            default:
              return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
          }
        case "definition": {
          let le = H.proseWrap === "always" ? d : " ";
          return N([Ne(X), ":", F([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
        }
        case "footnote":
          return ["[^", ue(oe, H, pe), "]"];
        case "footnoteReference":
          return Pe(X);
        case "footnoteDefinition": {
          let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
          return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
        }
        case "table":
          return K(oe, H, pe);
        case "tableCell":
          return ue(oe, H, pe);
        case "break":
          return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(y)] : ["\\", c2];
        case "liquidNode":
          return P(X.value, c2);
        case "importExport":
          return [X.value, c2];
        case "esComment":
          return ["{/* ", X.value, " */}"];
        case "jsx":
          return X.value;
        case "math":
          return ["$$", c2, X.value ? [...P(X.value, c2), c2] : "", "$$"];
        case "inlineMath":
          return H.originalText.slice(m2(X), C(X));
        case "tableRow":
        case "listItem":
        default:
          throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
      }
    }
    function V(oe, H, pe, X) {
      let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
      return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
        if (De === 0 && Ee.getValue().type !== "list")
          return w(" ".repeat(Ae.length), pe());
        let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
        return [A, w(A, pe())];
      } })];
    }
    function j(oe, H) {
      let pe = X();
      return oe + " ".repeat(pe >= 4 ? 0 : pe);
      function X() {
        let le = oe.length % H.tabWidth;
        return le === 0 ? 0 : H.tabWidth - le;
      }
    }
    function Y(oe, H) {
      return ie(oe, H, (pe) => pe.ordered === oe.ordered);
    }
    function ie(oe, H, pe) {
      let X = -1;
      for (let le of H.children)
        if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe)
          return X;
    }
    function ee(oe, H) {
      let pe = Array.isArray(H) ? H : [H], X = -1, le;
      for (; le = oe.getParentNode(++X); )
        if (pe.includes(le.type))
          return X;
      return -1;
    }
    function ce(oe, H) {
      let pe = ee(oe, H);
      return pe === -1 ? null : oe.getParentNode(pe);
    }
    function W(oe, H, pe) {
      if (pe.proseWrap === "preserve" && H === `
`)
        return c2;
      let X = pe.proseWrap === "always" && !ce(oe, J);
      return H !== "" ? X ? d : " " : X ? f : "";
    }
    function K(oe, H, pe) {
      let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
        let ve = $2(pe(), H).formatted, ze = u(ve);
        return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
      }, "children"), "children"), Ee = A(false);
      if (H.proseWrap !== "never")
        return [l, Ee];
      let De = A(true);
      return [l, N(E(De, Ee))];
      function A(ye) {
        let Ce = [re2(Ae[0], ye), G(ye)];
        return Ae.length > 1 && Ce.push(p2(x2, Ae.slice(1).map((Be) => re2(Be, ye)))), p2(x2, Ce);
      }
      function G(ye) {
        return `| ${le.map((Be, ve) => {
          let ze = X.align[ve], xe = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
          return `${xe}${Se}${Ye}`;
        }).join(" | ")} |`;
      }
      function re2(ye, Ce) {
        return `| ${ye.map((ve, ze) => {
          let { text: xe, width: Ye } = ve;
          if (Ce)
            return xe;
          let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
          Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
          let Je = Se - Oe;
          return `${" ".repeat(Oe)}${xe}${" ".repeat(Je)}`;
        }).join(" | ")} |`;
      }
    }
    function de(oe, H, pe) {
      let X = [], le = null, { children: Ae } = oe.getValue();
      for (let [Ee, De] of Ae.entries())
        switch (U(De)) {
          case "start":
            le === null && (le = { index: Ee, offset: De.position.end.offset });
            break;
          case "end":
            le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
            break;
        }
      return ue(oe, H, pe, { processor: (Ee, De) => {
        if (X.length > 0) {
          let A = X[0];
          if (De === A.start.index)
            return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
          if (A.start.index < De && De < A.end.index)
            return false;
          if (De === A.end.index)
            return X.shift(), false;
        }
        return pe();
      } });
    }
    function ue(oe, H, pe) {
      let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
      return oe.each((G, re2) => {
        let ye = G.getValue(), Ce = Ae(G, re2);
        if (Ce !== false) {
          let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
          Z(ye, Be) && (De.push(c2), A && q2.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c2), fe(ye, Be) && De.push(c2)), De.push(Ce), A = ye;
        }
      }, "children"), le ? le(De) : De;
    }
    function Fe(oe) {
      if (oe.type === "html")
        return oe.value;
      if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
        return ["{/* ", oe.children[0].value, " */}"];
    }
    function z(oe) {
      let H = oe;
      for (; i(H.children); )
        H = s2(H.children);
      return H;
    }
    function U(oe) {
      let H;
      if (oe.type === "html")
        H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
      else {
        let pe;
        oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
      }
      return H ? H[1] || "next" : false;
    }
    function Z(oe, H) {
      let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
      return !pe && !X && !le;
    }
    function se(oe, H) {
      var pe, X, le;
      let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re2 = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
      return A || !(Ee || De || G || re2 || ye);
    }
    function fe(oe, H) {
      let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
      return pe && X;
    }
    function ge(oe) {
      let H = ce(oe, ["linkReference", "imageReference"]);
      return H && (H.type !== "linkReference" || H.referenceType !== "full");
    }
    function he(oe) {
      let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
      return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
    }
    function we(oe, H) {
      let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (!oe)
        return "";
      if (pe)
        return " " + we(oe, H, false);
      if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
        return `(${oe})`;
      let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
      return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
    }
    function ke(oe, H, pe) {
      return oe < H ? H : oe > pe ? pe : oe;
    }
    function Re(oe) {
      let H = Number(oe.getName());
      if (H === 0)
        return false;
      let pe = oe.getParentNode().children[H - 1];
      return U(pe) === "next";
    }
    function Ne(oe) {
      return `[${t(oe.label)}]`;
    }
    function Pe(oe) {
      return `[^${oe.label}]`;
    }
    r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: h2, hasPrettierIgnore: Re, insertPragma: T };
  } }), ug = te({ "src/language-markdown/options.js"(e, r) {
    ne();
    var t = jt();
    r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
  } }), sg = te({ "src/language-markdown/parsers.js"() {
    ne();
  } }), Aa = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
    r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
  } }), ig = te({ "src/language-markdown/index.js"(e, r) {
    ne();
    var t = wt(), s2 = ng(), a2 = ug(), n = sg(), u = [t(Aa(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p2) => p2 !== ".mdx") })), t(Aa(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s2 };
    r.exports = { languages: u, options: a2, printers: i, parsers: n };
  } }), ag = te({ "src/language-html/clean.js"(e, r) {
    ne();
    var { isFrontMatterNode: t } = Ue(), s2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
    function a2(n, u) {
      if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
        return null;
      n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
    }
    a2.ignoredProperties = s2, r.exports = a2;
  } }), og = te({ "src/language-html/constants.evaluate.js"(e, r) {
    r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
  } }), lg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
    ne();
    function t(s2) {
      return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
    }
    r.exports = t;
  } }), qt = te({ "src/language-html/utils/index.js"(e, r) {
    ne();
    var { inferParserByLanguage: t, isFrontMatterNode: s2 } = Ue(), { builders: { line: a2, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p2, CSS_DISPLAY_DEFAULT: d, CSS_WHITE_SPACE_TAGS: y, CSS_WHITE_SPACE_DEFAULT: g } = og(), c2 = lg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), E = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => E(_(A)), F = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => F(_(A)), x2 = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
      let [, G, re2, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
      return { leadingWhitespace: G, trailingWhitespace: ye, text: re2 };
    }, $2 = (A) => /[\t\n\f\r ]/.test(A);
    function D(A, G) {
      return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re2) => re2.type !== "text" && re2.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
    }
    function T(A) {
      return A.type === "attribute" || !A.parent || !A.prev ? false : m2(A.prev);
    }
    function m2(A) {
      return A.type === "comment" && A.value.trim() === "prettier-ignore";
    }
    function C(A) {
      return A.type === "text" || A.type === "comment";
    }
    function o(A) {
      return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c2(A) && (A.name === "script" || A.name === "style"));
    }
    function h2(A) {
      return A.children && !o(A);
    }
    function v(A) {
      return o(A) || A.type === "interpolation" || S(A);
    }
    function S(A) {
      return we(A).startsWith("pre");
    }
    function b(A, G) {
      let re2 = ye();
      if (re2 && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
        return A.type === "interpolation";
      return re2;
      function ye() {
        return s2(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
      }
    }
    function B(A, G) {
      return s2(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
    }
    function k(A) {
      return Z(A.cssDisplay) && !o(A);
    }
    function M(A) {
      return s2(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
    }
    function R(A) {
      return q2(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
    }
    function q2(A) {
      return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
    }
    function J(A) {
      return Y(A) || A.prev && L(A.prev) || Q(A);
    }
    function L(A) {
      return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
    }
    function Q(A) {
      return V(A) && j(A);
    }
    function V(A) {
      return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
    }
    function j(A) {
      return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
    }
    function Y(A) {
      switch (A.type) {
        case "ieConditionalComment":
        case "comment":
        case "directive":
          return true;
        case "element":
          return ["script", "select"].includes(A.name);
      }
      return false;
    }
    function ie(A) {
      return A.lastChild ? ie(A.lastChild) : A;
    }
    function ee(A) {
      return A.children && A.children.some((G) => G.type !== "text");
    }
    function ce(A) {
      let { type: G, lang: re2 } = A.attrMap;
      if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re2 === "jsx")
        return "babel";
      if (G === "application/x-typescript" || re2 === "ts" || re2 === "tsx")
        return "typescript";
      if (G === "text/markdown")
        return "markdown";
      if (G === "text/html")
        return "html";
      if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
        return "json";
      if (G === "text/x-handlebars-template")
        return "glimmer";
    }
    function W(A, G) {
      let { lang: re2 } = A.attrMap;
      if (!re2 || re2 === "postcss" || re2 === "css")
        return "css";
      if (re2 === "scss")
        return "scss";
      if (re2 === "less")
        return "less";
      if (re2 === "stylus")
        return t("stylus", G);
    }
    function K(A, G) {
      if (A.name === "script" && !A.attrMap.src)
        return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
      if (A.name === "style")
        return W(A, G);
      if (G && X(A, G))
        return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
    }
    function de(A) {
      return A === "block" || A === "list-item" || A.startsWith("table");
    }
    function ue(A) {
      return !de(A) && A !== "inline-block";
    }
    function Fe(A) {
      return !de(A) && A !== "inline-block";
    }
    function z(A) {
      return !de(A);
    }
    function U(A) {
      return !de(A);
    }
    function Z(A) {
      return !de(A) && A !== "inline-block";
    }
    function se(A) {
      return we(A).startsWith("pre");
    }
    function fe(A, G) {
      let re2 = 0;
      for (let ye = A.stack.length - 1; ye >= 0; ye--) {
        let Ce = A.stack[ye];
        Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re2++;
      }
      return re2;
    }
    function ge(A, G) {
      let re2 = A;
      for (; re2; ) {
        if (G(re2))
          return true;
        re2 = re2.parent;
      }
      return false;
    }
    function he(A, G) {
      if (A.prev && A.prev.type === "comment") {
        let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
        if (ye)
          return ye[1];
      }
      let re2 = false;
      if (A.type === "element" && A.namespace === "svg")
        if (ge(A, (ye) => ye.fullName === "svg:foreignObject"))
          re2 = true;
        else
          return A.name === "svg" ? "inline-block" : "block";
      switch (G.htmlWhitespaceSensitivity) {
        case "strict":
          return "inline";
        case "ignore":
          return "block";
        default:
          return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re2 || c2(A)) && p2[A.name] || d;
      }
    }
    function we(A) {
      return A.type === "element" && (!A.namespace || c2(A)) && y[A.name] || g;
    }
    function ke(A) {
      let G = Number.POSITIVE_INFINITY;
      for (let re2 of A.split(`
`)) {
        if (re2.length === 0)
          continue;
        if (!f.has(re2[0]))
          return 0;
        let ye = I(re2).length;
        re2.length !== ye && ye < G && (G = ye);
      }
      return G === Number.POSITIVE_INFINITY ? 0 : G;
    }
    function Re(A) {
      let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
      return G === 0 ? A : A.split(`
`).map((re2) => re2.slice(G)).join(`
`);
    }
    function Ne(A, G) {
      let re2 = 0;
      for (let ye = 0; ye < A.length; ye++)
        A[ye] === G && re2++;
      return re2;
    }
    function Pe(A) {
      return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
    var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
    function H(A, G) {
      return pe(A, G) && !oe.has(A.fullName);
    }
    function pe(A, G) {
      return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
    }
    function X(A, G) {
      return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
    }
    function le(A) {
      let G = A.fullName;
      return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
    }
    function Ae(A, G) {
      let re2 = A.parent;
      if (!pe(re2, G))
        return false;
      let ye = re2.fullName, Ce = A.fullName;
      return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
    }
    function Ee(A) {
      let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
      return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a2, x2(G)));
    }
    function De(A, G) {
      return pe(A, G) && A.name === "script";
    }
    r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $2, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: h2, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q2, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c2, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
  } }), cg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
    function r(i) {
      return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
    }
    e.isWhitespace = r;
    function t(i) {
      return e.$0 <= i && i <= e.$9;
    }
    e.isDigit = t;
    function s2(i) {
      return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
    }
    e.isAsciiLetter = s2;
    function a2(i) {
      return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
    }
    e.isAsciiHexDigit = a2;
    function n(i) {
      return i === e.$LF || i === e.$CR;
    }
    e.isNewLine = n;
    function u(i) {
      return e.$0 <= i && i <= e.$7;
    }
    e.isOctalDigit = u;
  } }), pg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = class {
      constructor(s2, a2, n) {
        this.filePath = s2, this.name = a2, this.members = n;
      }
      assertNoMembers() {
        if (this.members.length)
          throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
      }
    };
    e.StaticSymbol = r;
    var t = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(s2, a2, n) {
        n = n || [];
        let u = n.length ? `.${n.join(".")}` : "", i = `"${s2}".${a2}${u}`, l = this.cache.get(i);
        return l || (l = new r(s2, a2, n), this.cache.set(i, l)), l;
      }
    };
    e.StaticSymbolCache = t;
  } }), fg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = /-+([a-z0-9])/g;
    function t(o) {
      return o.replace(r, function() {
        for (var h2 = arguments.length, v = new Array(h2), S = 0; S < h2; S++)
          v[S] = arguments[S];
        return v[1].toUpperCase();
      });
    }
    e.dashCaseToCamelCase = t;
    function s2(o, h2) {
      return n(o, ":", h2);
    }
    e.splitAtColon = s2;
    function a2(o, h2) {
      return n(o, ".", h2);
    }
    e.splitAtPeriod = a2;
    function n(o, h2, v) {
      let S = o.indexOf(h2);
      return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
    }
    function u(o, h2, v) {
      return Array.isArray(o) ? h2.visitArray(o, v) : F(o) ? h2.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? h2.visitPrimitive(o, v) : h2.visitOther(o, v);
    }
    e.visitValue = u;
    function i(o) {
      return o != null;
    }
    e.isDefined = i;
    function l(o) {
      return o === void 0 ? null : o;
    }
    e.noUndefined = l;
    var p2 = class {
      visitArray(o, h2) {
        return o.map((v) => u(v, this, h2));
      }
      visitStringMap(o, h2) {
        let v = {};
        return Object.keys(o).forEach((S) => {
          v[S] = u(o[S], this, h2);
        }), v;
      }
      visitPrimitive(o, h2) {
        return o;
      }
      visitOther(o, h2) {
        return o;
      }
    };
    e.ValueTransformer = p2, e.SyncAsync = { assertSync: (o) => {
      if (P(o))
        throw new Error("Illegal state: value cannot be a promise");
      return o;
    }, then: (o, h2) => P(o) ? o.then(h2) : h2(o), all: (o) => o.some(P) ? Promise.all(o) : o };
    function d(o) {
      throw new Error(`Internal Error: ${o}`);
    }
    e.error = d;
    function y(o, h2) {
      let v = Error(o);
      return v[g] = true, h2 && (v[c2] = h2), v;
    }
    e.syntaxError = y;
    var g = "ngSyntaxError", c2 = "ngParseErrors";
    function f(o) {
      return o[g];
    }
    e.isSyntaxError = f;
    function E(o) {
      return o[c2] || [];
    }
    e.getParseErrors = E;
    function _(o) {
      return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    }
    e.escapeRegExp = _;
    var w = Object.getPrototypeOf({});
    function F(o) {
      return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
    }
    function N(o) {
      let h2 = "";
      for (let v = 0; v < o.length; v++) {
        let S = o.charCodeAt(v);
        if (S >= 55296 && S <= 56319 && o.length > v + 1) {
          let b = o.charCodeAt(v + 1);
          b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
        }
        S <= 127 ? h2 += String.fromCharCode(S) : S <= 2047 ? h2 += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? h2 += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (h2 += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
      }
      return h2;
    }
    e.utf8Encode = N;
    function x2(o) {
      if (typeof o == "string")
        return o;
      if (o instanceof Array)
        return "[" + o.map(x2).join(", ") + "]";
      if (o == null)
        return "" + o;
      if (o.overriddenName)
        return `${o.overriddenName}`;
      if (o.name)
        return `${o.name}`;
      if (!o.toString)
        return "object";
      let h2 = o.toString();
      if (h2 == null)
        return "" + h2;
      let v = h2.indexOf(`
`);
      return v === -1 ? h2 : h2.substring(0, v);
    }
    e.stringify = x2;
    function I(o) {
      return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
    }
    e.resolveForwardRef = I;
    function P(o) {
      return !!o && typeof o.then == "function";
    }
    e.isPromise = P;
    var $2 = class {
      constructor(o) {
        this.full = o;
        let h2 = o.split(".");
        this.major = h2[0], this.minor = h2[1], this.patch = h2.slice(2).join(".");
      }
    };
    e.Version = $2;
    var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m2 = typeof globalThis < "u" && globalThis, C = m2 || D || T;
    e.global = C;
  } }), Dg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = pg(), t = fg(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function a2(v) {
      return v.replace(/\W/g, "_");
    }
    e.sanitizeIdentifier = a2;
    var n = 0;
    function u(v) {
      if (!v || !v.reference)
        return null;
      let S = v.reference;
      if (S instanceof r.StaticSymbol)
        return S.name;
      if (S.__anonymousType)
        return S.__anonymousType;
      let b = t.stringify(S);
      return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a2(b), b;
    }
    e.identifierName = u;
    function i(v) {
      let S = v.reference;
      return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
    }
    e.identifierModuleUrl = i;
    function l(v, S) {
      return `View_${u({ reference: v })}_${S}`;
    }
    e.viewClassName = l;
    function p2(v) {
      return `RenderType_${u({ reference: v })}`;
    }
    e.rendererTypeName = p2;
    function d(v) {
      return `HostView_${u({ reference: v })}`;
    }
    e.hostViewClassName = d;
    function y(v) {
      return `${u({ reference: v })}NgFactory`;
    }
    e.componentFactoryName = y;
    var g;
    (function(v) {
      v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
    })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
    function c2(v) {
      return v.value != null ? a2(v.value) : u(v.identifier);
    }
    e.tokenName = c2;
    function f(v) {
      return v.identifier != null ? v.identifier.reference : v.value;
    }
    e.tokenReference = f;
    var E = class {
      constructor() {
        let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
      }
    };
    e.CompileStylesheetMetadata = E;
    var _ = class {
      constructor(v) {
        let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q2, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
        if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q2), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
          throw new Error("'interpolation' should have a start and an end symbol.");
        this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
      }
      toSummary() {
        return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
      }
    };
    e.CompileTemplateMetadata = _;
    var w = class {
      static create(v) {
        let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
        L != null && Object.keys(L).forEach((se) => {
          let fe = L[se], ge = se.match(s2);
          ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
        });
        let U = {};
        q2 != null && q2.forEach((se) => {
          let fe = t.splitAtColon(se, [se, se]);
          U[fe[0]] = fe[1];
        });
        let Z = {};
        return J != null && J.forEach((se) => {
          let fe = t.splitAtColon(se, [se, se]);
          Z[fe[0]] = fe[1];
        }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
      }
      constructor(v) {
        let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
        this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q2, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
      }
      toSummary() {
        return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
      }
    };
    e.CompileDirectiveMetadata = w;
    var F = class {
      constructor(v) {
        let { type: S, name: b, pure: B } = v;
        this.type = S, this.name = b, this.pure = !!B;
      }
      toSummary() {
        return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
      }
    };
    e.CompilePipeMetadata = F;
    var N = class {
    };
    e.CompileShallowModuleMetadata = N;
    var x2 = class {
      constructor(v) {
        let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q2, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
        this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q2), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
      }
      toSummary() {
        let v = this.transitiveModule;
        return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
      }
    };
    e.CompileNgModuleMetadata = x2;
    var I = class {
      constructor() {
        this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
      }
      addProvider(v, S) {
        this.providers.push({ provider: v, module: S });
      }
      addDirective(v) {
        this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
      }
      addExportedDirective(v) {
        this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
      }
      addPipe(v) {
        this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
      }
      addExportedPipe(v) {
        this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
      }
      addModule(v) {
        this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
      }
      addEntryComponent(v) {
        this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
      }
    };
    e.TransitiveCompileNgModuleMetadata = I;
    function P(v) {
      return v || [];
    }
    var $2 = class {
      constructor(v, S) {
        let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q2 } = S;
        this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q2;
      }
    };
    e.ProviderMeta = $2;
    function D(v) {
      return v.reduce((S, b) => {
        let B = Array.isArray(b) ? D(b) : b;
        return S.concat(B);
      }, []);
    }
    e.flatten = D;
    function T(v) {
      return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    function m2(v, S, b) {
      let B;
      return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
    }
    e.templateSourceUrl = m2;
    function C(v, S) {
      let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
      return T(`css/${S}${B}.ngstyle.js`);
    }
    e.sharedStylesheetJitUrl = C;
    function o(v) {
      return T(`${u(v.type)}/module.ngfactory.js`);
    }
    e.ngModuleJitUrl = o;
    function h2(v, S) {
      return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
    }
    e.templateJitUrl = h2;
  } }), mg = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
    ne(), Object.defineProperty(e, "__esModule", { value: true });
    var r = cg(), t = Dg(), s2 = class {
      constructor(d, y, g, c2) {
        this.file = d, this.offset = y, this.line = g, this.col = c2;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(d) {
        let y = this.file.content, g = y.length, c2 = this.offset, f = this.line, E = this.col;
        for (; c2 > 0 && d < 0; )
          if (c2--, d++, y.charCodeAt(c2) == r.$LF) {
            f--;
            let w = y.substr(0, c2 - 1).lastIndexOf(String.fromCharCode(r.$LF));
            E = w > 0 ? c2 - w : c2;
          } else
            E--;
        for (; c2 < g && d > 0; ) {
          let _ = y.charCodeAt(c2);
          c2++, d--, _ == r.$LF ? (f++, E = 0) : E++;
        }
        return new s2(this.file, c2, f, E);
      }
      getContext(d, y) {
        let g = this.file.content, c2 = this.offset;
        if (c2 != null) {
          c2 > g.length - 1 && (c2 = g.length - 1);
          let f = c2, E = 0, _ = 0;
          for (; E < d && c2 > 0 && (c2--, E++, !(g[c2] == `
` && ++_ == y)); )
            ;
          for (E = 0, _ = 0; E < d && f < g.length - 1 && (f++, E++, !(g[f] == `
` && ++_ == y)); )
            ;
          return { before: g.substring(c2, this.offset), after: g.substring(this.offset, f + 1) };
        }
        return null;
      }
    };
    e.ParseLocation = s2;
    var a2 = class {
      constructor(d, y) {
        this.content = d, this.url = y;
      }
    };
    e.ParseSourceFile = a2;
    var n = class {
      constructor(d, y) {
        let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        this.start = d, this.end = y, this.details = g;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    };
    e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s2(new a2("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
    var u;
    (function(d) {
      d[d.WARNING = 0] = "WARNING", d[d.ERROR = 1] = "ERROR";
    })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
    var i = class {
      constructor(d, y) {
        let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
        this.span = d, this.msg = y, this.level = g;
      }
      contextualMessage() {
        let d = this.span.start.getContext(100, 3);
        return d ? `${this.msg} ("${d.before}[${u[this.level]} ->]${d.after}")` : this.msg;
      }
      toString() {
        let d = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${d}`;
      }
    };
    e.ParseError = i;
    function l(d, y) {
      let g = t.identifierModuleUrl(y), c2 = g != null ? `in ${d} ${t.identifierName(y)} in ${g}` : `in ${d} ${t.identifierName(y)}`, f = new a2("", c2);
      return new n(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
    }
    e.typeSourceSpan = l;
    function p2(d, y, g) {
      let c2 = `in ${d} ${y} in ${g}`, f = new a2("", c2);
      return new n(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
    }
    e.r3JitTypeSourceSpan = p2;
  } }), dg = te({ "src/language-html/print-preprocess.js"(e, r) {
    ne();
    var { ParseSourceSpan: t } = mg(), { htmlTrim: s2, getLeadingAndTrailingHtmlWhitespace: a2, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p2, isLeadingSpaceSensitiveNode: d, isTrailingSpaceSensitiveNode: y, isWhitespaceSensitiveNode: g, isVueScriptTag: c2 } = qt(), f = [_, w, N, I, P, T, $2, D, m2, x2, C];
    function E(o, h2) {
      for (let v of f)
        v(o, h2);
      return o;
    }
    function _(o) {
      o.walk((h2) => {
        if (h2.type === "element" && h2.tagDefinition.ignoreFirstLf && h2.children.length > 0 && h2.children[0].type === "text" && h2.children[0].value[0] === `
`) {
          let v = h2.children[0];
          v.value.length === 1 ? h2.removeChild(v) : v.value = v.value.slice(1);
        }
      });
    }
    function w(o) {
      let h2 = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
      o.walk((v) => {
        if (v.children)
          for (let S = 0; S < v.children.length; S++) {
            let b = v.children[S];
            if (!h2(b))
              continue;
            let B = b.prev, k = b.firstChild;
            v.removeChild(B), S--;
            let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
            b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
          }
      });
    }
    function F(o, h2, v) {
      o.walk((S) => {
        if (S.children)
          for (let b = 0; b < S.children.length; b++) {
            let B = S.children[b];
            if (B.type !== "text" && !h2(B))
              continue;
            B.type !== "text" && (B.type = "text", B.value = v(B));
            let k = B.prev;
            !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
          }
      });
    }
    function N(o) {
      return F(o, (h2) => h2.type === "cdata", (h2) => `<![CDATA[${h2.value}]]>`);
    }
    function x2(o) {
      let h2 = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
      o.walk((v) => {
        if (v.children)
          for (let S = 0; S < v.children.length; S++) {
            let b = v.children[S];
            if (!h2(b))
              continue;
            let B = b.prev, k = b.next;
            B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
          }
      });
    }
    function I(o, h2) {
      if (h2.parser === "html")
        return;
      let v = /{{(.+?)}}/s;
      o.walk((S) => {
        if (u(S))
          for (let b of S.children) {
            if (b.type !== "text")
              continue;
            let B = b.sourceSpan.start, k = null, M = b.value.split(v);
            for (let R = 0; R < M.length; R++, B = k) {
              let q2 = M[R];
              if (R % 2 === 0) {
                k = B.moveBy(q2.length), q2.length > 0 && S.insertChildBefore(b, { type: "text", value: q2, sourceSpan: new t(B, k) });
                continue;
              }
              k = B.moveBy(q2.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q2.length === 0 ? [] : [{ type: "text", value: q2, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
            }
            S.removeChild(b);
          }
      });
    }
    function P(o) {
      o.walk((h2) => {
        if (!h2.children)
          return;
        if (h2.children.length === 0 || h2.children.length === 1 && h2.children[0].type === "text" && s2(h2.children[0].value).length === 0) {
          h2.hasDanglingSpaces = h2.children.length > 0, h2.children = [];
          return;
        }
        let v = g(h2), S = p2(h2);
        if (!v)
          for (let b = 0; b < h2.children.length; b++) {
            let B = h2.children[b];
            if (B.type !== "text")
              continue;
            let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a2(B.value), q2 = B.prev, J = B.next;
            M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q2 && (q2.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (h2.removeChild(B), b--, (k || R) && (q2 && (q2.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
          }
        h2.isWhitespaceSensitive = v, h2.isIndentationSensitive = S;
      });
    }
    function $2(o) {
      o.walk((h2) => {
        h2.isSelfClosing = !h2.children || h2.type === "element" && (h2.tagDefinition.isVoid || h2.startSourceSpan === h2.endSourceSpan);
      });
    }
    function D(o, h2) {
      o.walk((v) => {
        v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(h2.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
      });
    }
    function T(o, h2) {
      o.walk((v) => {
        v.cssDisplay = i(v, h2);
      });
    }
    function m2(o, h2) {
      o.walk((v) => {
        let { children: S } = v;
        if (S) {
          if (S.length === 0) {
            v.isDanglingSpaceSensitive = l(v);
            return;
          }
          for (let b of S)
            b.isLeadingSpaceSensitive = d(b, h2), b.isTrailingSpaceSensitive = y(b, h2);
          for (let b = 0; b < S.length; b++) {
            let B = S[b];
            B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
          }
        }
      });
    }
    function C(o, h2) {
      if (h2.parser === "vue") {
        let v = o.children.find((b) => c2(b, h2));
        if (!v)
          return;
        let { lang: S } = v.attrMap;
        (S === "ts" || S === "typescript") && (h2.__should_parse_vue_template_with_ts = true);
      }
    }
    r.exports = E;
  } }), gg = te({ "src/language-html/pragma.js"(e, r) {
    ne();
    function t(a2) {
      return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a2);
    }
    function s2(a2) {
      return `<!-- @format -->

` + a2.replace(/^\s*\n/, "");
    }
    r.exports = { hasPragma: t, insertPragma: s2 };
  } }), uu = te({ "src/language-html/loc.js"(e, r) {
    ne();
    function t(a2) {
      return a2.sourceSpan.start.offset;
    }
    function s2(a2) {
      return a2.sourceSpan.end.offset;
    }
    r.exports = { locStart: t, locEnd: s2 };
  } }), rr = te({ "src/language-html/print/tag.js"(e, r) {
    ne();
    var t = Yt(), { isNonEmptyArray: s2 } = Ue(), { builders: { indent: a2, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p2 } } = qe(), { locStart: d, locEnd: y } = uu(), { isTextLikeNode: g, getLastDescendant: c2, isPreLikeNode: f, hasPrettierIgnore: E, shouldPreserveContent: _, isVueSfcBlock: w } = qt();
    function F(L, Q) {
      return [L.isSelfClosing ? "" : N(L, Q), x2(L, Q)];
    }
    function N(L, Q) {
      return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $2(L, Q)];
    }
    function x2(L, Q) {
      return (L.next ? m2(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
    }
    function I(L, Q) {
      return C(L) ? D(L.lastChild, Q) : "";
    }
    function P(L, Q) {
      return o(L) ? $2(L.parent, Q) : h2(L) ? q2(L.next) : "";
    }
    function $2(L, Q) {
      if (t(!L.isSelfClosing), T(L, Q))
        return "";
      switch (L.type) {
        case "ieConditionalComment":
          return "<!";
        case "element":
          if (L.hasHtmComponentClosingTag)
            return "<//";
        default:
          return `</${L.rawName}`;
      }
    }
    function D(L, Q) {
      if (T(L, Q))
        return "";
      switch (L.type) {
        case "ieConditionalComment":
        case "ieConditionalEndComment":
          return "[endif]-->";
        case "ieConditionalStartComment":
          return "]><!-->";
        case "interpolation":
          return "}}";
        case "element":
          if (L.isSelfClosing)
            return "/>";
        default:
          return ">";
      }
    }
    function T(L, Q) {
      return !L.isSelfClosing && !L.endSourceSpan && (E(L) || _(L.parent, Q));
    }
    function m2(L) {
      return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
    }
    function C(L) {
      return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c2(L.lastChild)) && !f(L);
    }
    function o(L) {
      return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c2(L));
    }
    function h2(L) {
      return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
    }
    function v(L) {
      let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
      return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
    }
    function S(L) {
      return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
    }
    function b(L, Q, V) {
      let j = L.getValue();
      if (!s2(j.attrs))
        return j.isSelfClosing ? " " : "";
      let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
        let Fe = ue.getValue();
        return ie(Fe) ? p2(Q.originalText.slice(d(Fe), y(Fe))) : V();
      }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a2([ce ? " " : u, n(K, ee)])];
      return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
    }
    function B(L) {
      return L.firstChild && S(L.firstChild) ? "" : J(L);
    }
    function k(L, Q, V) {
      let j = L.getValue();
      return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
    }
    function M(L, Q) {
      return L.prev && h2(L.prev) ? "" : [R(L, Q), q2(L)];
    }
    function R(L, Q) {
      return S(L) ? J(L.parent) : m2(L) ? D(L.prev, Q) : "";
    }
    function q2(L) {
      switch (L.type) {
        case "ieConditionalComment":
        case "ieConditionalStartComment":
          return `<!--[if ${L.condition}`;
        case "ieConditionalEndComment":
          return "<!--<!";
        case "interpolation":
          return "{{";
        case "docType":
          return "<!DOCTYPE";
        case "element":
          if (L.condition)
            return `<!--[if ${L.condition}]><!--><${L.rawName}`;
        default:
          return `<${L.rawName}`;
      }
    }
    function J(L) {
      switch (t(!L.isSelfClosing), L.type) {
        case "ieConditionalComment":
          return "]>";
        case "element":
          if (L.condition)
            return "><!--<![endif]-->";
        default:
          return ">";
      }
    }
    r.exports = { printClosingTag: F, printClosingTagStart: N, printClosingTagStartMarker: $2, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x2, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m2, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q2, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: h2, needsToBorrowParentOpeningTagEndMarker: S };
  } }), yg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
    ne(), function(t, s2) {
      typeof define == "function" && define.amd ? define([], s2) : typeof r == "object" && r.exports ? r.exports = s2() : t.parseSrcset = s2();
    }(e, function() {
      return function(t, s2) {
        var a2 = s2 && s2.logger || console;
        function n($2) {
          return $2 === " " || $2 === "	" || $2 === `
` || $2 === "\f" || $2 === "\r";
        }
        function u($2) {
          var D, T = $2.exec(t.substring(N));
          if (T)
            return D = T[0], N += D.length, D;
        }
        for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p2 = /^[, \t\n\r\u000c]+/, d = /^[^ \t\n\r\u000c]+/, y = /[,]+$/, g = /^\d+$/, c2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, E, _, w, F, N = 0, x2 = []; ; ) {
          if (u(p2), N >= i)
            return x2;
          f = u(d), E = [], f.slice(-1) === "," ? (f = f.replace(y, ""), P()) : I();
        }
        function I() {
          for (u(l), _ = "", w = "in descriptor"; ; ) {
            if (F = t.charAt(N), w === "in descriptor")
              if (n(F))
                _ && (E.push(_), _ = "", w = "after descriptor");
              else if (F === ",") {
                N += 1, _ && E.push(_), P();
                return;
              } else if (F === "(")
                _ = _ + F, w = "in parens";
              else if (F === "") {
                _ && E.push(_), P();
                return;
              } else
                _ = _ + F;
            else if (w === "in parens")
              if (F === ")")
                _ = _ + F, w = "in descriptor";
              else if (F === "") {
                E.push(_), P();
                return;
              } else
                _ = _ + F;
            else if (w === "after descriptor" && !n(F))
              if (F === "") {
                P();
                return;
              } else
                w = "in descriptor", N -= 1;
            N += 1;
          }
        }
        function P() {
          var $2 = false, D, T, m2, C, o = {}, h2, v, S, b, B;
          for (C = 0; C < E.length; C++)
            h2 = E[C], v = h2[h2.length - 1], S = h2.substring(0, h2.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($2 = true), b === 0 ? $2 = true : D = b) : c2.test(S) && v === "x" ? ((D || T || m2) && ($2 = true), B < 0 ? $2 = true : T = B) : g.test(S) && v === "h" ? ((m2 || T) && ($2 = true), b === 0 ? $2 = true : m2 = b) : $2 = true;
          $2 ? a2 && a2.error && a2.error("Invalid srcset descriptor found in '" + t + "' at '" + h2 + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m2 && (o.h = m2), x2.push(o));
        }
      };
    });
  } }), hg = te({ "src/language-html/syntax-attribute.js"(e, r) {
    ne();
    var t = yg(), { builders: { ifBreak: s2, join: a2, line: n } } = qe();
    function u(l) {
      let p2 = t(l, { logger: { error(I) {
        throw new Error(I);
      } } }), d = p2.some((I) => {
        let { w: P } = I;
        return P;
      }), y = p2.some((I) => {
        let { h: P } = I;
        return P;
      }), g = p2.some((I) => {
        let { d: P } = I;
        return P;
      });
      if (d + y + g > 1)
        throw new Error("Mixed descriptor in srcset is not supported");
      let c2 = d ? "w" : y ? "h" : "d", f = d ? "w" : y ? "h" : "x", E = (I) => Math.max(...I), _ = p2.map((I) => I.url), w = E(_.map((I) => I.length)), F = p2.map((I) => I[c2]).map((I) => I ? I.toString() : ""), N = F.map((I) => {
        let P = I.indexOf(".");
        return P === -1 ? I.length : P;
      }), x2 = E(N);
      return a2([",", n], _.map((I, P) => {
        let $2 = [I], D = F[P];
        if (D) {
          let T = w - I.length + 1, m2 = x2 - N[P], C = " ".repeat(T + m2);
          $2.push(s2(C, " "), D + f);
        }
        return $2;
      }));
    }
    function i(l) {
      return l.trim().split(/\s+/).join(" ");
    }
    r.exports = { printImgSrcset: u, printClassNames: i };
  } }), vg = te({ "src/language-html/syntax-vue.js"(e, r) {
    ne();
    var { builders: { group: t } } = qe();
    function s2(i, l) {
      let { left: p2, operator: d, right: y } = a2(i);
      return [t(l(`function _(${p2}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", d, " ", l(y, { parser: "__js_expression" }, { stripTrailingHardline: true })];
    }
    function a2(i) {
      let l = /(.*?)\s+(in|of)\s+(.*)/s, p2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, d = /^\(|\)$/g, y = i.match(l);
      if (!y)
        return;
      let g = {};
      if (g.for = y[3].trim(), !g.for)
        return;
      let c2 = y[1].trim().replace(d, ""), f = c2.match(p2);
      f ? (g.alias = c2.replace(p2, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c2;
      let E = [g.alias, g.iterator1, g.iterator2];
      if (!E.some((_, w) => !_ && (w === 0 || E.slice(w + 1).some(Boolean))))
        return { left: E.filter(Boolean).join(","), operator: y[2], right: g.for };
    }
    function n(i, l) {
      return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
    }
    function u(i) {
      let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p2 = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, d = i.trim();
      return l.test(d) || p2.test(d);
    }
    r.exports = { isVueEventBindingExpression: u, printVueFor: s2, printVueBindings: n };
  } }), To = te({ "src/language-html/get-node-content.js"(e, r) {
    ne();
    var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s2, needsToBorrowLastChildClosingTagEndMarker: a2, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = rr();
    function l(p2, d) {
      let y = p2.startSourceSpan.end.offset;
      p2.firstChild && u(p2.firstChild) && (y -= i(p2).length);
      let g = p2.endSourceSpan.start.offset;
      return p2.lastChild && t(p2.lastChild) ? g += s2(p2, d).length : a2(p2) && (g -= n(p2.lastChild, d).length), d.originalText.slice(y, g);
    }
    r.exports = l;
  } }), Cg = te({ "src/language-html/embed.js"(e, r) {
    ne();
    var { builders: { breakParent: t, group: s2, hardline: a2, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p2, replaceTextEndOfLine: d } } = qe(), y = ru(), { printClosingTag: g, printClosingTagSuffix: c2, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: E, printOpeningTag: _ } = rr(), { printImgSrcset: w, printClassNames: F } = hg(), { printVueFor: N, printVueBindings: x2, isVueEventBindingExpression: I } = vg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $2, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m2, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: h2, getTextValueParts: v } = qt(), S = To();
    function b(k, M, R) {
      let q2 = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
        let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
        W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
      }, V = (ee) => s2(ee), j = function(ee) {
        let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return s2([n([l, ee]), ce ? l : ""]);
      }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
      if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
        return j(w(J()));
      if (k.fullName === "class" && !R.parentParser) {
        let ee = J();
        if (!ee.includes("{{"))
          return F(ee);
      }
      if (k.fullName === "style" && !R.parentParser) {
        let ee = J();
        if (!ee.includes("{{"))
          return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
      }
      if (R.parser === "vue") {
        if (k.fullName === "v-for")
          return N(J(), ie);
        if (o(k) || h2(k, R))
          return x2(J(), ie);
        let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
        if (q2(ee)) {
          let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
          return Y(ie(K, { parser: de }));
        }
        if (q2(ce))
          return Y(ie(J(), { parser: "__vue_expression" }));
        if (q2(W))
          return Y(ie(J(), { parser: "__js_expression" }));
      }
      if (R.parser === "angular") {
        let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
        if (q2(W))
          return Y(ee(J(), { parser: "__ng_action" }));
        if (q2(K))
          return Y(ee(J(), { parser: "__ng_binding" }));
        if (q2(de)) {
          let z = J().trim();
          return j(i(v(k, z)), !z.includes("@@"));
        }
        if (q2(ce))
          return Y(ee(J(), { parser: "__ng_directive" }));
        let ue = /{{(.+?)}}/s, Fe = J();
        if (ue.test(Fe)) {
          let z = [];
          for (let [U, Z] of Fe.split(ue).entries())
            if (U % 2 === 0)
              z.push(d(Z));
            else
              try {
                z.push(s2(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
              } catch {
                z.push("{{", d(Z), "}}");
              }
          return s2(z);
        }
      }
      return null;
    }
    function B(k, M, R, q2) {
      let J = k.getValue();
      switch (J.type) {
        case "element": {
          if (P(J) || J.type === "interpolation")
            return;
          if (!J.isSelfClosing && $2(J, q2)) {
            let L = D(J, q2);
            if (!L)
              return;
            let Q = S(J, q2), V = /^\s*$/.test(Q), j = "";
            return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [E(J, q2), s2(_(k, q2, M)), V ? "" : a2, j, V ? "" : a2, g(J, q2), c2(J, q2)];
          }
          break;
        }
        case "text": {
          if (P(J.parent)) {
            let L = D(J.parent, q2);
            if (L) {
              let Q = L === "markdown" ? m2(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
              if (q2.parser === "html" && L === "babel") {
                let j = "script", { attrMap: Y } = J.parent;
                Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
              }
              return [t, E(J, q2), R(Q, V, { stripTrailingHardline: true }), c2(J, q2)];
            }
          } else if (J.parent.type === "interpolation") {
            let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
            return q2.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q2.parser === "vue" ? L.parser = q2.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
          }
          break;
        }
        case "attribute": {
          if (!J.value)
            break;
          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q2.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
            return [J.rawName, "=", J.value];
          if (q2.parser === "lwc" && /^{.*}$/s.test(q2.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
            return [J.rawName, "=", J.value];
          let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q2);
          if (L)
            return [J.rawName, '="', s2(p2(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
          break;
        }
        case "front-matter":
          return y(J, R);
      }
    }
    r.exports = B;
  } }), Bo = te({ "src/language-html/print/children.js"(e, r) {
    ne();
    var { builders: { breakParent: t, group: s2, ifBreak: a2, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p2, locEnd: d } = uu(), { forceBreakChildren: y, forceNextEmptyLine: g, isTextLikeNode: c2, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: E } = qt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x2, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = rr();
    function $2(m2, C, o) {
      let h2 = m2.getValue();
      return f(h2) ? [_(h2, C), ...l(C.originalText.slice(p2(h2) + (h2.prev && w(h2.prev) ? F(h2).length : 0), d(h2) - (h2.next && N(h2.next) ? x2(h2, C).length : 0))), I(h2, C)] : o();
    }
    function D(m2, C) {
      return c2(m2) && c2(C) ? m2.isTrailingSpaceSensitive ? m2.hasTrailingSpaces ? E(C) ? i : n : "" : E(C) ? i : u : w(m2) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m2.type === "element" && m2.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || E(C) || N(C) && m2.lastChild && P(m2.lastChild) && m2.lastChild.lastChild && P(m2.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
    }
    function T(m2, C, o) {
      let h2 = m2.getValue();
      if (y(h2))
        return [t, ...m2.map((S) => {
          let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
          return [B ? [B, g(b.prev) ? i : ""] : "", $2(S, C, o)];
        }, "children")];
      let v = h2.children.map(() => Symbol(""));
      return m2.map((S, b) => {
        let B = S.getValue();
        if (c2(B)) {
          if (B.prev && c2(B.prev)) {
            let Q = D(B.prev, B);
            if (Q)
              return g(B.prev) ? [i, i, $2(S, C, o)] : [Q, $2(S, C, o)];
          }
          return $2(S, C, o);
        }
        let k = [], M = [], R = [], q2 = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
        return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c2(B.prev) ? M.push(J) : M.push(a2("", u, { groupId: v[b - 1] }))), L && (g(B) ? c2(B.next) && q2.push(i, i) : L === i ? c2(B.next) && q2.push(i) : R.push(L)), [...k, s2([...M, s2([$2(S, C, o), ...R], { id: v[b] })]), ...q2];
      }, "children");
    }
    r.exports = { printChildren: T };
  } }), Eg = te({ "src/language-html/print/element.js"(e, r) {
    ne();
    var { builders: { breakParent: t, dedentToRoot: s2, group: a2, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p2 }, utils: { replaceTextEndOfLine: d } } = qe(), y = To(), { shouldPreserveContent: g, isScriptLikeTag: c2, isVueCustomBlock: f, countParents: E, forceBreakContent: _ } = qt(), { printOpeningTagPrefix: w, printOpeningTag: F, printClosingTagSuffix: N, printClosingTag: x2, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = rr(), { printChildren: $2 } = Bo();
    function D(T, m2, C) {
      let o = T.getValue();
      if (g(o, m2))
        return [w(o, m2), a2(F(T, m2, C)), ...d(y(o, m2)), ...x2(o, m2), N(o, m2)];
      let h2 = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a2([a2(F(T, m2, C), { id: v }), M, x2(o, m2)]), b = (M) => h2 ? u(M, { groupId: v }) : (c2(o) || f(o, m2)) && o.parent.type === "root" && m2.parser === "vue" && !m2.vueIndentScriptAndStyle ? M : i(M), B = () => h2 ? n(p2, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s2(p2) : p2, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : h2 ? n(p2, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m2.tabWidth * E(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p2;
      return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $2(T, m2, C)]), k()]);
    }
    r.exports = { printElement: D };
  } }), Fg = te({ "src/language-html/printer-html.js"(e, r) {
    ne();
    var { builders: { fill: t, group: s2, hardline: a2, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p2 } } = qe(), d = ag(), { countChars: y, unescapeQuoteEntities: g, getTextValueParts: c2 } = qt(), f = dg(), { insertPragma: E } = gg(), { locStart: _, locEnd: w } = uu(), F = Cg(), { printClosingTagSuffix: N, printClosingTagEnd: x2, printOpeningTagPrefix: I, printOpeningTagStart: P } = rr(), { printElement: $2 } = Eg(), { printChildren: D } = Bo();
    function T(m2, C, o) {
      let h2 = m2.getValue();
      switch (h2.type) {
        case "front-matter":
          return p2(h2.raw);
        case "root":
          return C.__onHtmlRoot && C.__onHtmlRoot(h2), [s2(D(m2, C, o)), a2];
        case "element":
        case "ieConditionalComment":
          return $2(m2, C, o);
        case "ieConditionalStartComment":
        case "ieConditionalEndComment":
          return [P(h2), x2(h2)];
        case "interpolation":
          return [P(h2, C), ...m2.map(o, "children"), x2(h2, C)];
        case "text": {
          if (h2.parent.type === "interpolation") {
            let S = /\n[^\S\n]*$/, b = S.test(h2.value), B = b ? h2.value.replace(S, "") : h2.value;
            return [...p2(B), b ? a2 : ""];
          }
          let v = u([I(h2, C), ...c2(h2), N(h2, C)]);
          return l(v) || v.type === "fill" ? t(i(v)) : v;
        }
        case "docType":
          return [s2([P(h2, C), " ", h2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x2(h2, C)];
        case "comment":
          return [I(h2, C), ...p2(C.originalText.slice(_(h2), w(h2)), n), N(h2, C)];
        case "attribute": {
          if (h2.value === null)
            return h2.rawName;
          let v = g(h2.value), S = y(v, "'"), b = y(v, '"'), B = S < b ? "'" : '"';
          return [h2.rawName, "=", B, ...p2(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
        }
        default:
          throw new Error(`Unexpected node type ${h2.type}`);
      }
    }
    r.exports = { preprocess: f, print: T, insertPragma: E, massageAstNode: d, embed: F };
  } }), Ag = te({ "src/language-html/options.js"(e, r) {
    ne();
    var t = jt(), s2 = "HTML";
    r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
  } }), Sg = te({ "src/language-html/parsers.js"() {
    ne();
  } }), kn = te({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
    r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
  } }), xg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
    r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
  } }), bg = te({ "src/language-html/index.js"(e, r) {
    ne();
    var t = wt(), s2 = Fg(), a2 = Ag(), n = Sg(), u = [t(kn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(kn(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(kn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(xg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s2 };
    r.exports = { languages: u, printers: i, options: a2, parsers: n };
  } }), Tg = te({ "src/language-yaml/pragma.js"(e, r) {
    ne();
    function t(n) {
      return /^\s*@(?:prettier|format)\s*$/.test(n);
    }
    function s2(n) {
      return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
    }
    function a2(n) {
      return `# @format

${n}`;
    }
    r.exports = { isPragma: t, hasPragma: s2, insertPragma: a2 };
  } }), Bg = te({ "src/language-yaml/loc.js"(e, r) {
    ne();
    function t(a2) {
      return a2.position.start.offset;
    }
    function s2(a2) {
      return a2.position.end.offset;
    }
    r.exports = { locStart: t, locEnd: s2 };
  } }), Ng = te({ "src/language-yaml/embed.js"(e, r) {
    ne();
    function t(s2, a2, n, u) {
      if (s2.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
        return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
    }
    r.exports = t;
  } }), Mt = te({ "src/language-yaml/utils.js"(e, r) {
    ne();
    var { getLast: t, isNonEmptyArray: s2 } = Ue();
    function a2(D, T) {
      let m2 = 0, C = D.stack.length - 1;
      for (let o = 0; o < C; o++) {
        let h2 = D.stack[o];
        n(h2) && T(h2) && m2++;
      }
      return m2;
    }
    function n(D, T) {
      return D && typeof D.type == "string" && (!T || T.includes(D.type));
    }
    function u(D, T, m2) {
      return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m2);
    }
    function i(D, T, m2) {
      Object.defineProperty(D, T, { get: m2, enumerable: false });
    }
    function l(D, T) {
      let m2 = 0, C = T.length;
      for (let o = D.position.end.offset - 1; o < C; o++) {
        let h2 = T[o];
        if (h2 === `
` && m2++, m2 === 1 && /\S/.test(h2))
          return false;
        if (m2 === 2)
          return true;
      }
      return false;
    }
    function p2(D) {
      switch (D.getValue().type) {
        case "tag":
        case "anchor":
        case "comment":
          return false;
      }
      let m2 = D.stack.length;
      for (let C = 1; C < m2; C++) {
        let o = D.stack[C], h2 = D.stack[C - 1];
        if (Array.isArray(h2) && typeof o == "number" && o !== h2.length - 1)
          return false;
      }
      return true;
    }
    function d(D) {
      return s2(D.children) ? d(t(D.children)) : D;
    }
    function y(D) {
      return D.value.trim() === "prettier-ignore";
    }
    function g(D) {
      let T = D.getValue();
      if (T.type === "documentBody") {
        let m2 = D.getParentNode();
        return N(m2.head) && y(t(m2.head.endComments));
      }
      return E(T) && y(t(T.leadingComments));
    }
    function c2(D) {
      return !s2(D.children) && !f(D);
    }
    function f(D) {
      return E(D) || _(D) || w(D) || F(D) || N(D);
    }
    function E(D) {
      return s2(D == null ? void 0 : D.leadingComments);
    }
    function _(D) {
      return s2(D == null ? void 0 : D.middleComments);
    }
    function w(D) {
      return D == null ? void 0 : D.indicatorComment;
    }
    function F(D) {
      return D == null ? void 0 : D.trailingComment;
    }
    function N(D) {
      return s2(D == null ? void 0 : D.endComments);
    }
    function x2(D) {
      let T = [], m2;
      for (let C of D.split(/( +)/))
        C !== " " ? m2 === " " ? T.push(C) : T.push((T.pop() || "") + C) : m2 === void 0 && T.unshift(""), m2 = C;
      return m2 === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
    }
    function I(D, T, m2) {
      let C = T.split(`
`).map((o, h2, v) => h2 === 0 && h2 === v.length - 1 ? o : h2 !== 0 && h2 !== v.length - 1 ? o.trim() : h2 === 0 ? o.trimEnd() : o.trimStart());
      return m2.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x2(o)).reduce((o, h2, v) => v !== 0 && C[v - 1].length > 0 && h2.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...h2]] : [...o, h2], []).map((o) => m2.proseWrap === "never" ? [o.join(" ")] : o);
    }
    function P(D, T) {
      let { parentIndent: m2, isLastDescendant: C, options: o } = T, h2 = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
      if (D.indent === null) {
        let B = h2.match(/^(?<leadingSpace> *)[^\n\r ]/m);
        v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
      } else
        v = D.indent - 1 + m2;
      let S = h2.split(`
`).map((B) => B.slice(v));
      if (o.proseWrap === "preserve" || D.type === "blockLiteral")
        return b(S.map((B) => B.length === 0 ? [] : [B]));
      return b(S.map((B) => B.length === 0 ? [] : x2(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
      function b(B) {
        if (D.chomping === "keep")
          return t(B).length === 0 ? B.slice(0, -1) : B;
        let k = 0;
        for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
          k++;
        return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
      }
    }
    function $2(D) {
      if (!D)
        return true;
      switch (D.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
        case "alias":
        case "flowMapping":
        case "flowSequence":
          return true;
        default:
          return false;
      }
    }
    r.exports = { getLast: t, getAncestorCount: a2, isNode: n, isEmptyNode: c2, isInlineNode: $2, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p2, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: d, hasPrettierIgnore: g, hasLeadingComments: E, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: F, hasEndComments: N };
  } }), wg = te({ "src/language-yaml/print-preprocess.js"(e, r) {
    ne();
    var { defineShortcut: t, mapNode: s2 } = Mt();
    function a2(u) {
      return s2(u, n);
    }
    function n(u) {
      switch (u.type) {
        case "document":
          t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
          break;
        case "documentBody":
        case "sequenceItem":
        case "flowSequenceItem":
        case "mappingKey":
        case "mappingValue":
          t(u, "content", () => u.children[0]);
          break;
        case "mappingItem":
        case "flowMappingItem":
          t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
          break;
      }
      return u;
    }
    r.exports = a2;
  } }), jr = te({ "src/language-yaml/print/misc.js"(e, r) {
    ne();
    var { builders: { softline: t, align: s2 } } = qe(), { hasEndComments: a2, isNextLineEmpty: n, isNode: u } = Mt(), i = /* @__PURE__ */ new WeakMap();
    function l(y, g) {
      let c2 = y.getValue(), f = y.stack[0], E;
      return i.has(f) ? E = i.get(f) : (E = /* @__PURE__ */ new Set(), i.set(f, E)), !E.has(c2.position.end.line) && (E.add(c2.position.end.line), n(c2, g) && !p2(y.getParentNode())) ? t : "";
    }
    function p2(y) {
      return a2(y) && !u(y, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
    }
    function d(y, g) {
      return s2(" ".repeat(y), g);
    }
    r.exports = { alignWithSpaces: d, shouldPrintEndComments: p2, printNextEmptyLine: l };
  } }), _g = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
    ne();
    var { builders: { ifBreak: t, line: s2, softline: a2, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p2 } = Mt(), { printNextEmptyLine: d, alignWithSpaces: y } = jr();
    function g(f, E, _) {
      let w = f.getValue(), F = w.type === "flowMapping", N = F ? "{" : "[", x2 = F ? "}" : "]", I = a2;
      F && w.children.length > 0 && _.bracketSpacing && (I = s2);
      let P = l(w.children), $2 = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
      return [N, y(_.tabWidth, [I, c2(f, E, _), _.trailingComma === "none" ? "" : t(","), p2(w) ? [n, u(n, f.map(E, "endComments"))] : ""]), $2 ? "" : I, x2];
    }
    function c2(f, E, _) {
      let w = f.getValue();
      return f.map((N, x2) => [E(), x2 === w.children.length - 1 ? "" : [",", s2, w.children[x2].position.start.line !== w.children[x2 + 1].position.start.line ? d(N, _.originalText) : ""]], "children");
    }
    r.exports = { printFlowMapping: g, printFlowSequence: g };
  } }), Pg = te({ "src/language-yaml/print/mapping-item.js"(e, r) {
    ne();
    var { builders: { conditionalGroup: t, group: s2, hardline: a2, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p2, hasTrailingComment: d, hasEndComments: y, isNode: g, isEmptyNode: c2, isInlineNode: f } = Mt(), { alignWithSpaces: E } = jr();
    function _(x2, I, P, $2, D) {
      let { key: T, value: m2 } = x2, C = c2(T), o = c2(m2);
      if (C && o)
        return ": ";
      let h2 = $2("key"), v = F(x2) ? " " : "";
      if (o)
        return x2.type === "flowMappingItem" && I.type === "flowMapping" ? h2 : x2.type === "mappingItem" && w(T.content, D) && !d(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [h2, v, ":"] : ["? ", E(2, h2)];
      let S = $2("value");
      if (C)
        return [": ", E(2, S)];
      if (l(m2) || !f(T.content))
        return ["? ", E(2, h2), a2, u("", P.map($2, "value", "leadingComments").map((q2) => [q2, a2])), ": ", E(2, S)];
      if (N(T.content) && !l(T.content) && !p2(T.content) && !d(T.content) && !y(T) && !l(m2.content) && !p2(m2.content) && !y(m2) && w(m2.content, D))
        return [h2, v, ": ", S];
      let b = Symbol("mappingKey"), B = s2([n("? "), s2(E(2, h2), { id: b })]), k = [a2, ": ", E(2, S)], M = [v, ":"];
      l(m2.content) || y(m2) && m2.content && !g(m2.content, ["mapping", "sequence"]) || I.type === "mapping" && d(T.content) && f(m2.content) || g(m2.content, ["mapping", "sequence"]) && m2.content.tag === null && m2.content.anchor === null ? M.push(a2) : m2.content && M.push(i), M.push(S);
      let R = E(D.tabWidth, M);
      return w(T.content, D) && !l(T.content) && !p2(T.content) && !y(T) ? t([[h2, R]]) : t([[B, n(k, R, { groupId: b })]]);
    }
    function w(x2, I) {
      if (!x2)
        return true;
      switch (x2.type) {
        case "plain":
        case "quoteSingle":
        case "quoteDouble":
          break;
        case "alias":
          return true;
        default:
          return false;
      }
      if (I.proseWrap === "preserve")
        return x2.position.start.line === x2.position.end.line;
      if (/\\$/m.test(I.originalText.slice(x2.position.start.offset, x2.position.end.offset)))
        return false;
      switch (I.proseWrap) {
        case "never":
          return !x2.value.includes(`
`);
        case "always":
          return !/[\n ]/.test(x2.value);
        default:
          return false;
      }
    }
    function F(x2) {
      return x2.key.content && x2.key.content.type === "alias";
    }
    function N(x2) {
      if (!x2)
        return true;
      switch (x2.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
          return x2.position.start.line === x2.position.end.line;
        case "alias":
          return true;
        default:
          return false;
      }
    }
    r.exports = _;
  } }), Ig = te({ "src/language-yaml/print/block.js"(e, r) {
    ne();
    var { builders: { dedent: t, dedentToRoot: s2, fill: a2, hardline: n, join: u, line: i, literalline: l, markAsRoot: p2 }, utils: { getDocParts: d } } = qe(), { getAncestorCount: y, getBlockValueLineContents: g, hasIndicatorComment: c2, isLastDescendantNode: f, isNode: E } = Mt(), { alignWithSpaces: _ } = jr();
    function w(F, N, x2) {
      let I = F.getValue(), P = y(F, (C) => E(C, ["sequence", "mapping"])), $2 = f(F), D = [I.type === "blockFolded" ? ">" : "|"];
      I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c2(I) && D.push(" ", N("indicatorComment"));
      let T = g(I, { parentIndent: P, isLastDescendant: $2, options: x2 }), m2 = [];
      for (let [C, o] of T.entries())
        C === 0 && m2.push(n), m2.push(a2(d(u(i, o)))), C !== T.length - 1 ? m2.push(o.length === 0 ? n : p2(l)) : I.chomping === "keep" && $2 && m2.push(s2(o.length === 0 ? n : l));
      return I.indent === null ? D.push(t(_(x2.tabWidth, m2))) : D.push(s2(_(I.indent - 1 + P, m2))), D;
    }
    r.exports = w;
  } }), kg = te({ "src/language-yaml/printer-yaml.js"(e, r) {
    ne();
    var { builders: { breakParent: t, fill: s2, group: a2, hardline: n, join: u, line: i, lineSuffix: l, literalline: p2 }, utils: { getDocParts: d, replaceTextEndOfLine: y } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c2, isPragma: f } = Tg(), { locStart: E } = Bg(), _ = Ng(), { getFlowScalarLineContents: w, getLastDescendantNode: F, hasLeadingComments: N, hasMiddleComments: x2, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $2, isLastDescendantNode: D, isNode: T, isInlineNode: m2 } = Mt(), C = wg(), { alignWithSpaces: o, printNextEmptyLine: h2, shouldPrintEndComments: v } = jr(), { printFlowMapping: S, printFlowSequence: b } = _g(), B = Pg(), k = Ig();
    function M(j, Y, ie) {
      let ee = j.getValue(), ce = [];
      ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
      let { tag: W, anchor: K } = ee;
      W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
      let de = "";
      T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = h2(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x2(ee) ? ce.push(n) : ce.push(" ")), x2(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
      let ue = j.getParentNode();
      return $2(j) ? ce.push(y(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p2)) : ce.push(a2(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m2(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), E) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
    }
    function R(j, Y, ie, ee, ce) {
      switch (j.type) {
        case "root": {
          let { children: W } = j, K = [];
          ie.each((ue, Fe) => {
            let z = W[Fe], U = W[Fe + 1];
            Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
          }, "children");
          let de = F(j);
          return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
        }
        case "document": {
          let W = Y.children[ie.getName() + 1], K = [];
          return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q2(j) && K.push(ce("body")), u(n, K);
        }
        case "documentHead":
          return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
        case "documentBody": {
          let { children: W, endComments: K } = j, de = "";
          if (W.length > 0 && K.length > 0) {
            let ue = F(j);
            T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
          }
          return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
        }
        case "directive":
          return ["%", u(" ", [j.name, ...j.parameters])];
        case "comment":
          return ["#", j.value];
        case "alias":
          return ["*", j.value];
        case "tag":
          return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
        case "anchor":
          return ["&", j.value];
        case "plain":
          return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
        case "quoteDouble":
        case "quoteSingle": {
          let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
          if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
            let Fe = j.type === "quoteDouble" ? K : W;
            return [Fe, Q(j.type, de, ee), Fe];
          }
          if (de.includes(K))
            return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
          if (de.includes(W))
            return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
          let ue = ee.singleQuote ? W : K;
          return [ue, Q(j.type, de, ee), ue];
        }
        case "blockFolded":
        case "blockLiteral":
          return k(ie, ce, ee);
        case "mapping":
        case "sequence":
          return u(n, ie.map(ce, "children"));
        case "sequenceItem":
          return ["- ", o(2, j.content ? ce("content") : "")];
        case "mappingKey":
        case "mappingValue":
          return j.content ? ce("content") : "";
        case "mappingItem":
        case "flowMappingItem":
          return B(j, Y, ie, ce, ee);
        case "flowMapping":
          return S(ie, ce, ee);
        case "flowSequence":
          return b(ie, ce, ee);
        case "flowSequenceItem":
          return ce("content");
        default:
          throw new Error(`Unexpected node type ${j.type}`);
      }
    }
    function q2(j) {
      return j.body.children.length > 0 || P(j.body);
    }
    function J(j, Y) {
      return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
    }
    function L(j, Y, ie, ee) {
      return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(E(j), E(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
    }
    function Q(j, Y, ie) {
      let ee = w(j, Y, ie);
      return u(n, ee.map((ce) => s2(d(u(i, ce)))));
    }
    function V(j, Y) {
      if (T(Y))
        switch (delete Y.position, Y.type) {
          case "comment":
            if (f(Y.value))
              return null;
            break;
          case "quoteDouble":
          case "quoteSingle":
            Y.type = "quote";
            break;
        }
    }
    r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c2 };
  } }), Lg = te({ "src/language-yaml/options.js"(e, r) {
    ne();
    var t = jt();
    r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
  } }), Og = te({ "src/language-yaml/parsers.js"() {
    ne();
  } }), jg = te({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
    r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
  } }), qg = te({ "src/language-yaml/index.js"(e, r) {
    ne();
    var t = wt(), s2 = kg(), a2 = Lg(), n = Og(), u = [t(jg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
    r.exports = { languages: u, printers: { yaml: s2 }, options: a2, parsers: n };
  } }), Mg = te({ "src/languages.js"(e, r) {
    ne(), r.exports = [vd(), jd(), Gd(), Qd(), ig(), bg(), qg()];
  } }), Rg = te({ "src/standalone.js"(e, r) {
    ne();
    var { version: t } = xa(), s2 = Om(), { getSupportInfo: a2 } = Un(), n = jm(), u = Mg(), i = qe();
    function l(d) {
      let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return function() {
        for (var g = arguments.length, c2 = new Array(g), f = 0; f < g; f++)
          c2[f] = arguments[f];
        let E = c2[y] || {}, _ = E.plugins || [];
        return c2[y] = Object.assign(Object.assign({}, E), {}, { plugins: [...u, ...Array.isArray(_) ? _ : Object.values(_)] }), d(...c2);
      };
    }
    var p2 = l(s2.formatWithCursor);
    r.exports = { formatWithCursor: p2, format(d, y) {
      return p2(d, y).formatted;
    }, check(d, y) {
      let { formatted: g } = p2(d, y);
      return g === d;
    }, doc: i, getSupportInfo: l(a2, 0), version: t, util: n, __debug: { parse: l(s2.parse), formatAST: l(s2.formatAST), formatDoc: l(s2.formatDoc), printToDoc: l(s2.printToDoc), printDocToString: l(s2.printDocToString) } };
  } }), Ty = Rg();
  var __defProp = Object.defineProperty;
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp(target, name2, { get: all2[name2], enumerable: true });
  };
  var public_exports = {};
  __export(public_exports, {
    builders: () => builders,
    printer: () => printer,
    utils: () => utils$1
  });
  var DOC_TYPE_STRING = "string";
  var DOC_TYPE_ARRAY = "array";
  var DOC_TYPE_CURSOR = "cursor";
  var DOC_TYPE_INDENT = "indent";
  var DOC_TYPE_ALIGN = "align";
  var DOC_TYPE_TRIM = "trim";
  var DOC_TYPE_GROUP = "group";
  var DOC_TYPE_FILL = "fill";
  var DOC_TYPE_IF_BREAK = "if-break";
  var DOC_TYPE_INDENT_IF_BREAK = "indent-if-break";
  var DOC_TYPE_LINE_SUFFIX = "line-suffix";
  var DOC_TYPE_LINE_SUFFIX_BOUNDARY = "line-suffix-boundary";
  var DOC_TYPE_LINE = "line";
  var DOC_TYPE_LABEL = "label";
  var DOC_TYPE_BREAK_PARENT = "break-parent";
  var VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
    DOC_TYPE_CURSOR,
    DOC_TYPE_INDENT,
    DOC_TYPE_ALIGN,
    DOC_TYPE_TRIM,
    DOC_TYPE_GROUP,
    DOC_TYPE_FILL,
    DOC_TYPE_IF_BREAK,
    DOC_TYPE_INDENT_IF_BREAK,
    DOC_TYPE_LINE_SUFFIX,
    DOC_TYPE_LINE_SUFFIX_BOUNDARY,
    DOC_TYPE_LINE,
    DOC_TYPE_LABEL,
    DOC_TYPE_BREAK_PARENT
  ]);
  function getDocType(doc) {
    if (typeof doc === "string") {
      return DOC_TYPE_STRING;
    }
    if (Array.isArray(doc)) {
      return DOC_TYPE_ARRAY;
    }
    if (!doc) {
      return;
    }
    const { type } = doc;
    if (VALID_OBJECT_DOC_TYPES.has(type)) {
      return type;
    }
  }
  var get_doc_type_default = getDocType;
  var disjunctionListFormat = (list2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list2);
  function getDocErrorMessage(doc) {
    const type = doc === null ? "null" : typeof doc;
    if (type !== "string" && type !== "object") {
      return `Unexpected doc '${type}', 
Expected it to be 'string' or 'object'.`;
    }
    if (get_doc_type_default(doc)) {
      throw new Error("doc is valid.");
    }
    const objectType = Object.prototype.toString.call(doc);
    if (objectType !== "[object Object]") {
      return `Unexpected doc '${objectType}'.`;
    }
    const EXPECTED_TYPE_VALUES = disjunctionListFormat(
      [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)
    );
    return `Unexpected doc.type '${doc.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
  }
  var InvalidDocError = class extends Error {
    constructor(doc) {
      super(getDocErrorMessage(doc));
      __publicField(this, "name", "InvalidDocError");
      this.doc = doc;
    }
  };
  var invalid_doc_error_default = InvalidDocError;
  var traverseDocOnExitStackMarker = {};
  function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
    const docsStack = [doc];
    while (docsStack.length > 0) {
      const doc2 = docsStack.pop();
      if (doc2 === traverseDocOnExitStackMarker) {
        onExit(docsStack.pop());
        continue;
      }
      if (onExit) {
        docsStack.push(doc2, traverseDocOnExitStackMarker);
      }
      const docType = get_doc_type_default(doc2);
      if (!docType) {
        throw new invalid_doc_error_default(doc2);
      }
      if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {
        continue;
      }
      switch (docType) {
        case DOC_TYPE_ARRAY:
        case DOC_TYPE_FILL: {
          const parts2 = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;
          for (let ic = parts2.length, i = ic - 1; i >= 0; --i) {
            docsStack.push(parts2[i]);
          }
          break;
        }
        case DOC_TYPE_IF_BREAK:
          docsStack.push(doc2.flatContents, doc2.breakContents);
          break;
        case DOC_TYPE_GROUP:
          if (shouldTraverseConditionalGroups && doc2.expandedStates) {
            for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {
              docsStack.push(doc2.expandedStates[i]);
            }
          } else {
            docsStack.push(doc2.contents);
          }
          break;
        case DOC_TYPE_ALIGN:
        case DOC_TYPE_INDENT:
        case DOC_TYPE_INDENT_IF_BREAK:
        case DOC_TYPE_LABEL:
        case DOC_TYPE_LINE_SUFFIX:
          docsStack.push(doc2.contents);
          break;
        case DOC_TYPE_STRING:
        case DOC_TYPE_CURSOR:
        case DOC_TYPE_TRIM:
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        case DOC_TYPE_LINE:
        case DOC_TYPE_BREAK_PARENT:
          break;
        default:
          throw new invalid_doc_error_default(doc2);
      }
    }
  }
  var traverse_doc_default = traverseDoc;
  var noop = () => {
  };
  var assertDocArray = noop;
  function indent$1(contents) {
    return { type: DOC_TYPE_INDENT, contents };
  }
  function align(widthOrString, contents) {
    return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };
  }
  function group$2(contents, opts = {}) {
    assertDocArray(
      opts.expandedStates
    );
    return {
      type: DOC_TYPE_GROUP,
      id: opts.id,
      contents,
      break: Boolean(opts.shouldBreak),
      expandedStates: opts.expandedStates
    };
  }
  function dedentToRoot(contents) {
    return align(Number.NEGATIVE_INFINITY, contents);
  }
  function markAsRoot$1(contents) {
    return align({ type: "root" }, contents);
  }
  function dedent(contents) {
    return align(-1, contents);
  }
  function conditionalGroup(states, opts) {
    return group$2(states[0], { ...opts, expandedStates: states });
  }
  function fill$1(parts2) {
    return { type: DOC_TYPE_FILL, parts: parts2 };
  }
  function ifBreak$1(breakContents, flatContents = "", opts = {}) {
    return {
      type: DOC_TYPE_IF_BREAK,
      breakContents,
      flatContents,
      groupId: opts.groupId
    };
  }
  function indentIfBreak(contents, opts) {
    return {
      type: DOC_TYPE_INDENT_IF_BREAK,
      contents,
      groupId: opts.groupId,
      negate: opts.negate
    };
  }
  function lineSuffix$1(contents) {
    return { type: DOC_TYPE_LINE_SUFFIX, contents };
  }
  var lineSuffixBoundary$1 = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };
  var breakParent$1 = { type: DOC_TYPE_BREAK_PARENT };
  var trim$1 = { type: DOC_TYPE_TRIM };
  var hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };
  var literallineWithoutBreakParent = {
    type: DOC_TYPE_LINE,
    hard: true,
    literal: true
  };
  var line$1 = { type: DOC_TYPE_LINE };
  var softline$1 = { type: DOC_TYPE_LINE, soft: true };
  var hardline$1 = [hardlineWithoutBreakParent, breakParent$1];
  var literalline = [literallineWithoutBreakParent, breakParent$1];
  var cursor = { type: DOC_TYPE_CURSOR };
  function join$5(separator, docs) {
    const parts2 = [];
    for (let i = 0; i < docs.length; i++) {
      if (i !== 0) {
        parts2.push(separator);
      }
      parts2.push(docs[i]);
    }
    return parts2;
  }
  function addAlignmentToDoc(doc, size, tabWidth) {
    let aligned = doc;
    if (size > 0) {
      for (let i = 0; i < Math.floor(size / tabWidth); ++i) {
        aligned = indent$1(aligned);
      }
      aligned = align(size % tabWidth, aligned);
      aligned = align(Number.NEGATIVE_INFINITY, aligned);
    }
    return aligned;
  }
  function label(label2, contents) {
    return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;
  }
  var at = (isOptionalObject, object2, index2) => {
    if (isOptionalObject && (object2 === void 0 || object2 === null)) {
      return;
    }
    if (Array.isArray(object2) || typeof object2 === "string") {
      return object2[index2 < 0 ? object2.length + index2 : index2];
    }
    return object2.at(index2);
  };
  var at_default = at;
  var stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {
    if (isOptionalObject && (original === void 0 || original === null)) {
      return;
    }
    if (original.replaceAll) {
      return original.replaceAll(pattern, replacement);
    }
    if (pattern.global) {
      return original.replace(pattern, replacement);
    }
    return original.split(pattern).join(replacement);
  };
  var string_replace_all_default = stringReplaceAll;
  function convertEndOfLineToChars(value2) {
    switch (value2) {
      case "cr":
        return "\r";
      case "crlf":
        return "\r\n";
      default:
        return "\n";
    }
  }
  var emoji_regex_default = () => {
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
  };
  var eastasianwidth_default = {
    eastAsianWidth(character) {
      var x2 = character.charCodeAt(0);
      var y = character.length == 2 ? character.charCodeAt(1) : 0;
      var codePoint = x2;
      if (55296 <= x2 && x2 <= 56319 && 56320 <= y && y <= 57343) {
        x2 &= 1023;
        y &= 1023;
        codePoint = x2 << 10 | y;
        codePoint += 65536;
      }
      if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {
        return "F";
      }
      if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {
        return "W";
      }
      return "N";
    }
  };
  var notAsciiRegex = /[^\x20-\x7F]/;
  function getStringWidth(text2) {
    if (!text2) {
      return 0;
    }
    if (!notAsciiRegex.test(text2)) {
      return text2.length;
    }
    text2 = text2.replace(emoji_regex_default(), "  ");
    let width = 0;
    for (const character of text2) {
      const codePoint = character.codePointAt(0);
      if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
        continue;
      }
      if (codePoint >= 768 && codePoint <= 879) {
        continue;
      }
      const code2 = eastasianwidth_default.eastAsianWidth(character);
      width += code2 === "F" || code2 === "W" ? 2 : 1;
    }
    return width;
  }
  var get_string_width_default = getStringWidth;
  var getDocParts = (doc) => {
    if (Array.isArray(doc)) {
      return doc;
    }
    if (doc.type !== DOC_TYPE_FILL) {
      throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);
    }
    return doc.parts;
  };
  function mapDoc(doc, cb) {
    if (typeof doc === "string") {
      return cb(doc);
    }
    const mapped = /* @__PURE__ */ new Map();
    return rec(doc);
    function rec(doc2) {
      if (mapped.has(doc2)) {
        return mapped.get(doc2);
      }
      const result = process2(doc2);
      mapped.set(doc2, result);
      return result;
    }
    function process2(doc2) {
      switch (get_doc_type_default(doc2)) {
        case DOC_TYPE_ARRAY:
          return cb(doc2.map(rec));
        case DOC_TYPE_FILL:
          return cb({
            ...doc2,
            parts: doc2.parts.map(rec)
          });
        case DOC_TYPE_IF_BREAK:
          return cb({
            ...doc2,
            breakContents: rec(doc2.breakContents),
            flatContents: rec(doc2.flatContents)
          });
        case DOC_TYPE_GROUP: {
          let {
            expandedStates,
            contents
          } = doc2;
          if (expandedStates) {
            expandedStates = expandedStates.map(rec);
            contents = expandedStates[0];
          } else {
            contents = rec(contents);
          }
          return cb({
            ...doc2,
            contents,
            expandedStates
          });
        }
        case DOC_TYPE_ALIGN:
        case DOC_TYPE_INDENT:
        case DOC_TYPE_INDENT_IF_BREAK:
        case DOC_TYPE_LABEL:
        case DOC_TYPE_LINE_SUFFIX:
          return cb({
            ...doc2,
            contents: rec(doc2.contents)
          });
        case DOC_TYPE_STRING:
        case DOC_TYPE_CURSOR:
        case DOC_TYPE_TRIM:
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        case DOC_TYPE_LINE:
        case DOC_TYPE_BREAK_PARENT:
          return cb(doc2);
        default:
          throw new invalid_doc_error_default(doc2);
      }
    }
  }
  function findInDoc(doc, fn, defaultValue) {
    let result = defaultValue;
    let shouldSkipFurtherProcessing = false;
    function findInDocOnEnterFn(doc2) {
      if (shouldSkipFurtherProcessing) {
        return false;
      }
      const maybeResult = fn(doc2);
      if (maybeResult !== void 0) {
        shouldSkipFurtherProcessing = true;
        result = maybeResult;
      }
    }
    traverse_doc_default(doc, findInDocOnEnterFn);
    return result;
  }
  function willBreakFn(doc) {
    if (doc.type === DOC_TYPE_GROUP && doc.break) {
      return true;
    }
    if (doc.type === DOC_TYPE_LINE && doc.hard) {
      return true;
    }
    if (doc.type === DOC_TYPE_BREAK_PARENT) {
      return true;
    }
  }
  function willBreak(doc) {
    return findInDoc(doc, willBreakFn, false);
  }
  function breakParentGroup(groupStack) {
    if (groupStack.length > 0) {
      const parentGroup = at_default(
        /* isOptionalObject*/
        false,
        groupStack,
        -1
      );
      if (!parentGroup.expandedStates && !parentGroup.break) {
        parentGroup.break = "propagated";
      }
    }
    return null;
  }
  function propagateBreaks(doc) {
    const alreadyVisitedSet = /* @__PURE__ */ new Set();
    const groupStack = [];
    function propagateBreaksOnEnterFn(doc2) {
      if (doc2.type === DOC_TYPE_BREAK_PARENT) {
        breakParentGroup(groupStack);
      }
      if (doc2.type === DOC_TYPE_GROUP) {
        groupStack.push(doc2);
        if (alreadyVisitedSet.has(doc2)) {
          return false;
        }
        alreadyVisitedSet.add(doc2);
      }
    }
    function propagateBreaksOnExitFn(doc2) {
      if (doc2.type === DOC_TYPE_GROUP) {
        const group2 = groupStack.pop();
        if (group2.break) {
          breakParentGroup(groupStack);
        }
      }
    }
    traverse_doc_default(
      doc,
      propagateBreaksOnEnterFn,
      propagateBreaksOnExitFn,
      /* shouldTraverseConditionalGroups */
      true
    );
  }
  function removeLinesFn(doc) {
    if (doc.type === DOC_TYPE_LINE && !doc.hard) {
      return doc.soft ? "" : " ";
    }
    if (doc.type === DOC_TYPE_IF_BREAK) {
      return doc.flatContents;
    }
    return doc;
  }
  function removeLines(doc) {
    return mapDoc(doc, removeLinesFn);
  }
  function stripTrailingHardlineFromParts(parts2) {
    parts2 = [...parts2];
    while (parts2.length >= 2 && at_default(
      /* isOptionalObject*/
      false,
      parts2,
      -2
    ).type === DOC_TYPE_LINE && at_default(
      /* isOptionalObject*/
      false,
      parts2,
      -1
    ).type === DOC_TYPE_BREAK_PARENT) {
      parts2.length -= 2;
    }
    if (parts2.length > 0) {
      const lastPart = stripTrailingHardlineFromDoc(at_default(
        /* isOptionalObject*/
        false,
        parts2,
        -1
      ));
      parts2[parts2.length - 1] = lastPart;
    }
    return parts2;
  }
  function stripTrailingHardlineFromDoc(doc) {
    switch (get_doc_type_default(doc)) {
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_GROUP:
      case DOC_TYPE_LINE_SUFFIX:
      case DOC_TYPE_LABEL: {
        const contents = stripTrailingHardlineFromDoc(doc.contents);
        return {
          ...doc,
          contents
        };
      }
      case DOC_TYPE_IF_BREAK:
        return {
          ...doc,
          breakContents: stripTrailingHardlineFromDoc(doc.breakContents),
          flatContents: stripTrailingHardlineFromDoc(doc.flatContents)
        };
      case DOC_TYPE_FILL:
        return {
          ...doc,
          parts: stripTrailingHardlineFromParts(doc.parts)
        };
      case DOC_TYPE_ARRAY:
        return stripTrailingHardlineFromParts(doc);
      case DOC_TYPE_STRING:
        return doc.replace(/[\n\r]*$/, "");
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc);
    }
    return doc;
  }
  function stripTrailingHardline(doc) {
    return stripTrailingHardlineFromDoc(cleanDoc(doc));
  }
  function cleanDocFn(doc) {
    switch (get_doc_type_default(doc)) {
      case DOC_TYPE_FILL:
        if (doc.parts.every((part) => part === "")) {
          return "";
        }
        break;
      case DOC_TYPE_GROUP:
        if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {
          return "";
        }
        if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {
          return doc.contents;
        }
        break;
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LINE_SUFFIX:
        if (!doc.contents) {
          return "";
        }
        break;
      case DOC_TYPE_IF_BREAK:
        if (!doc.flatContents && !doc.breakContents) {
          return "";
        }
        break;
      case DOC_TYPE_ARRAY: {
        const parts2 = [];
        for (const part of doc) {
          if (!part) {
            continue;
          }
          const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
          if (typeof currentPart === "string" && typeof at_default(
            /* isOptionalObject*/
            false,
            parts2,
            -1
          ) === "string") {
            parts2[parts2.length - 1] += currentPart;
          } else {
            parts2.push(currentPart);
          }
          parts2.push(...restParts);
        }
        if (parts2.length === 0) {
          return "";
        }
        if (parts2.length === 1) {
          return parts2[0];
        }
        return parts2;
      }
      case DOC_TYPE_STRING:
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_LABEL:
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc);
    }
    return doc;
  }
  function cleanDoc(doc) {
    return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));
  }
  function replaceEndOfLine(doc, replacement = literalline) {
    return mapDoc(doc, (currentDoc) => typeof currentDoc === "string" ? join$5(replacement, currentDoc.split("\n")) : currentDoc);
  }
  function canBreakFn(doc) {
    if (doc.type === DOC_TYPE_LINE) {
      return true;
    }
  }
  function canBreak(doc) {
    return findInDoc(doc, canBreakFn, false);
  }
  var MODE_BREAK = Symbol("MODE_BREAK");
  var MODE_FLAT = Symbol("MODE_FLAT");
  var CURSOR_PLACEHOLDER = Symbol("cursor");
  function rootIndent() {
    return {
      value: "",
      length: 0,
      queue: []
    };
  }
  function makeIndent(ind, options2) {
    return generateInd(ind, {
      type: "indent"
    }, options2);
  }
  function makeAlign(indent22, widthOrDoc, options2) {
    if (widthOrDoc === Number.NEGATIVE_INFINITY) {
      return indent22.root || rootIndent();
    }
    if (widthOrDoc < 0) {
      return generateInd(indent22, {
        type: "dedent"
      }, options2);
    }
    if (!widthOrDoc) {
      return indent22;
    }
    if (widthOrDoc.type === "root") {
      return {
        ...indent22,
        root: indent22
      };
    }
    const alignType = typeof widthOrDoc === "string" ? "stringAlign" : "numberAlign";
    return generateInd(indent22, {
      type: alignType,
      n: widthOrDoc
    }, options2);
  }
  function generateInd(ind, newPart, options2) {
    const queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];
    let value2 = "";
    let length = 0;
    let lastTabs = 0;
    let lastSpaces = 0;
    for (const part of queue) {
      switch (part.type) {
        case "indent":
          flush();
          if (options2.useTabs) {
            addTabs(1);
          } else {
            addSpaces(options2.tabWidth);
          }
          break;
        case "stringAlign":
          flush();
          value2 += part.n;
          length += part.n.length;
          break;
        case "numberAlign":
          lastTabs += 1;
          lastSpaces += part.n;
          break;
        default:
          throw new Error(`Unexpected type '${part.type}'`);
      }
    }
    flushSpaces();
    return {
      ...ind,
      value: value2,
      length,
      queue
    };
    function addTabs(count) {
      value2 += "	".repeat(count);
      length += options2.tabWidth * count;
    }
    function addSpaces(count) {
      value2 += " ".repeat(count);
      length += count;
    }
    function flush() {
      if (options2.useTabs) {
        flushTabs();
      } else {
        flushSpaces();
      }
    }
    function flushTabs() {
      if (lastTabs > 0) {
        addTabs(lastTabs);
      }
      resetLast();
    }
    function flushSpaces() {
      if (lastSpaces > 0) {
        addSpaces(lastSpaces);
      }
      resetLast();
    }
    function resetLast() {
      lastTabs = 0;
      lastSpaces = 0;
    }
  }
  function trim2(out) {
    let trimCount = 0;
    let cursorCount = 0;
    let outIndex = out.length;
    outer:
      while (outIndex--) {
        const last = out[outIndex];
        if (last === CURSOR_PLACEHOLDER) {
          cursorCount++;
          continue;
        }
        for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {
          const char = last[charIndex];
          if (char === " " || char === "	") {
            trimCount++;
          } else {
            out[outIndex] = last.slice(0, charIndex + 1);
            break outer;
          }
        }
      }
    if (trimCount > 0 || cursorCount > 0) {
      out.length = outIndex + 1;
      while (cursorCount-- > 0) {
        out.push(CURSOR_PLACEHOLDER);
      }
    }
    return trimCount;
  }
  function fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {
    if (width === Number.POSITIVE_INFINITY) {
      return true;
    }
    let restIdx = restCommands.length;
    const cmds = [next];
    const out = [];
    while (width >= 0) {
      if (cmds.length === 0) {
        if (restIdx === 0) {
          return true;
        }
        cmds.push(restCommands[--restIdx]);
        continue;
      }
      const {
        mode,
        doc
      } = cmds.pop();
      switch (get_doc_type_default(doc)) {
        case DOC_TYPE_STRING:
          out.push(doc);
          width -= get_string_width_default(doc);
          break;
        case DOC_TYPE_ARRAY:
        case DOC_TYPE_FILL: {
          const parts2 = getDocParts(doc);
          for (let i = parts2.length - 1; i >= 0; i--) {
            cmds.push({
              mode,
              doc: parts2[i]
            });
          }
          break;
        }
        case DOC_TYPE_INDENT:
        case DOC_TYPE_ALIGN:
        case DOC_TYPE_INDENT_IF_BREAK:
        case DOC_TYPE_LABEL:
          cmds.push({
            mode,
            doc: doc.contents
          });
          break;
        case DOC_TYPE_TRIM:
          width += trim2(out);
          break;
        case DOC_TYPE_GROUP: {
          if (mustBeFlat && doc.break) {
            return false;
          }
          const groupMode = doc.break ? MODE_BREAK : mode;
          const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(
            /* isOptionalObject*/
            false,
            doc.expandedStates,
            -1
          ) : doc.contents;
          cmds.push({
            mode: groupMode,
            doc: contents
          });
          break;
        }
        case DOC_TYPE_IF_BREAK: {
          const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;
          const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;
          if (contents) {
            cmds.push({
              mode,
              doc: contents
            });
          }
          break;
        }
        case DOC_TYPE_LINE:
          if (mode === MODE_BREAK || doc.hard) {
            return true;
          }
          if (!doc.soft) {
            out.push(" ");
            width--;
          }
          break;
        case DOC_TYPE_LINE_SUFFIX:
          hasLineSuffix = true;
          break;
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
          if (hasLineSuffix) {
            return false;
          }
          break;
      }
    }
    return false;
  }
  function printDocToString(doc, options2) {
    const groupModeMap = {};
    const width = options2.printWidth;
    const newLine = convertEndOfLineToChars(options2.endOfLine);
    let pos = 0;
    const cmds = [{
      ind: rootIndent(),
      mode: MODE_BREAK,
      doc
    }];
    const out = [];
    let shouldRemeasure = false;
    const lineSuffix2 = [];
    let printedCursorCount = 0;
    propagateBreaks(doc);
    while (cmds.length > 0) {
      const {
        ind,
        mode,
        doc: doc2
      } = cmds.pop();
      switch (get_doc_type_default(doc2)) {
        case DOC_TYPE_STRING: {
          const formatted = newLine !== "\n" ? string_replace_all_default(
            /* isOptionalObject*/
            false,
            doc2,
            "\n",
            newLine
          ) : doc2;
          out.push(formatted);
          if (cmds.length > 0) {
            pos += get_string_width_default(formatted);
          }
          break;
        }
        case DOC_TYPE_ARRAY:
          for (let i = doc2.length - 1; i >= 0; i--) {
            cmds.push({
              ind,
              mode,
              doc: doc2[i]
            });
          }
          break;
        case DOC_TYPE_CURSOR:
          if (printedCursorCount >= 2) {
            throw new Error("There are too many 'cursor' in doc.");
          }
          out.push(CURSOR_PLACEHOLDER);
          printedCursorCount++;
          break;
        case DOC_TYPE_INDENT:
          cmds.push({
            ind: makeIndent(ind, options2),
            mode,
            doc: doc2.contents
          });
          break;
        case DOC_TYPE_ALIGN:
          cmds.push({
            ind: makeAlign(ind, doc2.n, options2),
            mode,
            doc: doc2.contents
          });
          break;
        case DOC_TYPE_TRIM:
          pos -= trim2(out);
          break;
        case DOC_TYPE_GROUP:
          switch (mode) {
            case MODE_FLAT:
              if (!shouldRemeasure) {
                cmds.push({
                  ind,
                  mode: doc2.break ? MODE_BREAK : MODE_FLAT,
                  doc: doc2.contents
                });
                break;
              }
            case MODE_BREAK: {
              shouldRemeasure = false;
              const next = {
                ind,
                mode: MODE_FLAT,
                doc: doc2.contents
              };
              const rem = width - pos;
              const hasLineSuffix = lineSuffix2.length > 0;
              if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {
                cmds.push(next);
              } else {
                if (doc2.expandedStates) {
                  const mostExpanded = at_default(
                    /* isOptionalObject*/
                    false,
                    doc2.expandedStates,
                    -1
                  );
                  if (doc2.break) {
                    cmds.push({
                      ind,
                      mode: MODE_BREAK,
                      doc: mostExpanded
                    });
                    break;
                  } else {
                    for (let i = 1; i < doc2.expandedStates.length + 1; i++) {
                      if (i >= doc2.expandedStates.length) {
                        cmds.push({
                          ind,
                          mode: MODE_BREAK,
                          doc: mostExpanded
                        });
                        break;
                      } else {
                        const state = doc2.expandedStates[i];
                        const cmd = {
                          ind,
                          mode: MODE_FLAT,
                          doc: state
                        };
                        if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {
                          cmds.push(cmd);
                          break;
                        }
                      }
                    }
                  }
                } else {
                  cmds.push({
                    ind,
                    mode: MODE_BREAK,
                    doc: doc2.contents
                  });
                }
              }
              break;
            }
          }
          if (doc2.id) {
            groupModeMap[doc2.id] = at_default(
              /* isOptionalObject*/
              false,
              cmds,
              -1
            ).mode;
          }
          break;
        case DOC_TYPE_FILL: {
          const rem = width - pos;
          const {
            parts: parts2
          } = doc2;
          if (parts2.length === 0) {
            break;
          }
          const [content2, whitespace2] = parts2;
          const contentFlatCmd = {
            ind,
            mode: MODE_FLAT,
            doc: content2
          };
          const contentBreakCmd = {
            ind,
            mode: MODE_BREAK,
            doc: content2
          };
          const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
          if (parts2.length === 1) {
            if (contentFits) {
              cmds.push(contentFlatCmd);
            } else {
              cmds.push(contentBreakCmd);
            }
            break;
          }
          const whitespaceFlatCmd = {
            ind,
            mode: MODE_FLAT,
            doc: whitespace2
          };
          const whitespaceBreakCmd = {
            ind,
            mode: MODE_BREAK,
            doc: whitespace2
          };
          if (parts2.length === 2) {
            if (contentFits) {
              cmds.push(whitespaceFlatCmd, contentFlatCmd);
            } else {
              cmds.push(whitespaceBreakCmd, contentBreakCmd);
            }
            break;
          }
          parts2.splice(0, 2);
          const remainingCmd = {
            ind,
            mode,
            doc: fill$1(parts2)
          };
          const secondContent = parts2[0];
          const firstAndSecondContentFlatCmd = {
            ind,
            mode: MODE_FLAT,
            doc: [content2, whitespace2, secondContent]
          };
          const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);
          if (firstAndSecondContentFits) {
            cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);
          } else if (contentFits) {
            cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);
          } else {
            cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);
          }
          break;
        }
        case DOC_TYPE_IF_BREAK:
        case DOC_TYPE_INDENT_IF_BREAK: {
          const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;
          if (groupMode === MODE_BREAK) {
            const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent$1(doc2.contents);
            if (breakContents) {
              cmds.push({
                ind,
                mode,
                doc: breakContents
              });
            }
          }
          if (groupMode === MODE_FLAT) {
            const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent$1(doc2.contents) : doc2.contents;
            if (flatContents) {
              cmds.push({
                ind,
                mode,
                doc: flatContents
              });
            }
          }
          break;
        }
        case DOC_TYPE_LINE_SUFFIX:
          lineSuffix2.push({
            ind,
            mode,
            doc: doc2.contents
          });
          break;
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
          if (lineSuffix2.length > 0) {
            cmds.push({
              ind,
              mode,
              doc: hardlineWithoutBreakParent
            });
          }
          break;
        case DOC_TYPE_LINE:
          switch (mode) {
            case MODE_FLAT:
              if (!doc2.hard) {
                if (!doc2.soft) {
                  out.push(" ");
                  pos += 1;
                }
                break;
              } else {
                shouldRemeasure = true;
              }
            case MODE_BREAK:
              if (lineSuffix2.length > 0) {
                cmds.push({
                  ind,
                  mode,
                  doc: doc2
                }, ...lineSuffix2.reverse());
                lineSuffix2.length = 0;
                break;
              }
              if (doc2.literal) {
                if (ind.root) {
                  out.push(newLine, ind.root.value);
                  pos = ind.root.length;
                } else {
                  out.push(newLine);
                  pos = 0;
                }
              } else {
                pos -= trim2(out);
                out.push(newLine + ind.value);
                pos = ind.length;
              }
              break;
          }
          break;
        case DOC_TYPE_LABEL:
          cmds.push({
            ind,
            mode,
            doc: doc2.contents
          });
          break;
        case DOC_TYPE_BREAK_PARENT:
          break;
        default:
          throw new invalid_doc_error_default(doc2);
      }
      if (cmds.length === 0 && lineSuffix2.length > 0) {
        cmds.push(...lineSuffix2.reverse());
        lineSuffix2.length = 0;
      }
    }
    const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);
    if (cursorPlaceholderIndex !== -1) {
      const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);
      const beforeCursor = out.slice(0, cursorPlaceholderIndex).join("");
      const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join("");
      const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
      return {
        formatted: beforeCursor + aroundCursor + afterCursor,
        cursorNodeStart: beforeCursor.length,
        cursorNodeText: aroundCursor
      };
    }
    return {
      formatted: out.join("")
    };
  }
  var builders = {
    join: join$5,
    line: line$1,
    softline: softline$1,
    hardline: hardline$1,
    literalline,
    group: group$2,
    conditionalGroup,
    fill: fill$1,
    lineSuffix: lineSuffix$1,
    lineSuffixBoundary: lineSuffixBoundary$1,
    cursor,
    breakParent: breakParent$1,
    ifBreak: ifBreak$1,
    trim: trim$1,
    indent: indent$1,
    indentIfBreak,
    align,
    addAlignmentToDoc,
    markAsRoot: markAsRoot$1,
    dedentToRoot,
    dedent,
    hardlineWithoutBreakParent,
    literallineWithoutBreakParent,
    label,
    // TODO: Remove this in v4
    concat: (parts2) => parts2
  };
  var printer = { printDocToString };
  var utils$1 = {
    willBreak,
    traverseDoc: traverse_doc_default,
    findInDoc,
    mapDoc,
    removeLines,
    stripTrailingHardline,
    replaceEndOfLine,
    canBreak
  };
  const linebreak = Symbol("linebreak");
  const ESCAPE$1 = "\\";
  function _printRaw(node2) {
    if (typeof node2 === "string") {
      return [node2];
    }
    if (Array.isArray(node2)) {
      return [].concat(
        ...node2.map((n) => _printRaw(n))
      );
    }
    let argsString, escape2;
    switch (node2.type) {
      case "root":
        return _printRaw(node2.content);
      case "argument":
        return [node2.openMark, ..._printRaw(node2.content), node2.closeMark];
      case "comment":
        let suffix = node2.suffixParbreak ? "" : linebreak;
        let leadingWhitespace = "";
        if (node2.sameline && node2.leadingWhitespace) {
          leadingWhitespace = " ";
        }
        if (node2.sameline) {
          return [
            leadingWhitespace,
            "%",
            ..._printRaw(node2.content),
            suffix
          ];
        }
        return [linebreak, "%", ..._printRaw(node2.content), suffix];
      case "environment":
      case "mathenv":
      case "verbatim":
        let env2 = _printRaw(node2.env);
        let envStart = [ESCAPE$1 + "begin{", ...env2, "}"];
        let envEnd = [ESCAPE$1 + "end{", ...env2, "}"];
        argsString = node2.args == null ? [] : _printRaw(node2.args);
        return [
          ...envStart,
          ...argsString,
          ..._printRaw(node2.content),
          ...envEnd
        ];
      case "displaymath":
        return [ESCAPE$1 + "[", ..._printRaw(node2.content), ESCAPE$1 + "]"];
      case "group":
        return ["{", ..._printRaw(node2.content), "}"];
      case "inlinemath":
        return ["$", ..._printRaw(node2.content), "$"];
      case "macro":
        argsString = node2.args == null ? [] : _printRaw(node2.args);
        escape2 = node2.escapeToken == null ? ESCAPE$1 : node2.escapeToken;
        return [escape2, ..._printRaw(node2.content), ...argsString];
      case "parbreak":
        return [linebreak, linebreak];
      case "string":
        return [node2.content];
      case "verb":
        return [
          ESCAPE$1,
          node2.env,
          node2.escape,
          ..._printRaw(node2.content),
          node2.escape
        ];
      case "whitespace":
        return [" "];
      default:
        console.warn(
          "Cannot find render for node ",
          node2,
          `(of type ${typeof node2})`
        );
        return ["" + node2];
    }
  }
  function printRaw(node2, options2) {
    const asArray = options2 != null ? options2.asArray : false;
    const printedTokens = _printRaw(node2);
    if (asArray) {
      return printedTokens;
    }
    return printedTokens.map((x2) => x2 === linebreak ? "\n" : x2).join("");
  }
  function createMacroMatcher(macros2) {
    const macrosHash = Array.isArray(macros2) ? macros2.length > 0 ? typeof macros2[0] === "string" ? Object.fromEntries(
      macros2.map((macro2) => {
        if (typeof macro2 !== "string") {
          throw new Error("Wrong branch of map function");
        }
        return [macro2, {}];
      })
    ) : Object.fromEntries(
      macros2.map((macro2) => {
        if (typeof macro2 === "string") {
          throw new Error("Wrong branch of map function");
        }
        if (macro2.escapeToken != null) {
          return [
            macro2.content,
            { escapeToken: macro2.escapeToken }
          ];
        }
        return [macro2.content, {}];
      })
    ) : {} : macros2;
    return function matchAgainstMacros(node2) {
      if (node2 == null || node2.type !== "macro") {
        return false;
      }
      const spec = macrosHash[node2.content];
      if (!spec) {
        return false;
      }
      if (typeof spec === "object" && "escapeToken" in spec) {
        return spec.escapeToken == null || spec.escapeToken === node2.escapeToken;
      }
      return true;
    };
  }
  function createEnvironmentMatcher(macros2) {
    const environmentsHash = Array.isArray(macros2) ? Object.fromEntries(
      macros2.map((str) => {
        return [str, {}];
      })
    ) : macros2;
    return function matchAgainstEnvironments(node2) {
      if (!match.anyEnvironment(node2)) {
        return false;
      }
      const envName = printRaw(node2.env);
      const spec = environmentsHash[envName];
      if (!spec) {
        return false;
      }
      return true;
    };
  }
  const match = {
    macro(node2, macroName) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "macro" && (macroName == null || node2.content === macroName);
    },
    anyMacro(node2) {
      return match.macro(node2);
    },
    environment(node2, envName) {
      if (node2 == null) {
        return false;
      }
      return (node2.type === "environment" || node2.type === "mathenv") && (envName == null || printRaw(node2.env) === envName);
    },
    anyEnvironment(node2) {
      return match.environment(node2);
    },
    comment(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "comment";
    },
    parbreak(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "parbreak";
    },
    whitespace(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "whitespace" || node2.type === "whitespace" && node2.leadingWhitespace === true;
    },
    string(node2, value2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "string" && (value2 == null || node2.content === value2);
    },
    anyString(node2) {
      return match.string(node2);
    },
    group(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "group";
    },
    argument(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "argument";
    },
    blankArgument(node2) {
      if (!match.argument(node2)) {
        return false;
      }
      return node2.openMark === "" && node2.closeMark === "" && node2.content.length === 0;
    },
    math(node2) {
      if (node2 == null) {
        return false;
      }
      return node2.type === "displaymath" || node2.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher
  };
  const {
    anyEnvironment,
    anyMacro,
    anyString,
    argument,
    blankArgument,
    comment: comment$4,
    environment,
    group: group$1,
    macro,
    math,
    parbreak,
    string,
    whitespace: whitespace$3
  } = match;
  function listMathChildren(node2) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node2)) {
      return NULL_RETURN;
    }
    if (match.math(node2)) {
      return { enter: ["content"], leave: [] };
    }
    const renderInfo = node2._renderInfo || {};
    if (renderInfo.inMathMode == null) {
      return NULL_RETURN;
    }
    if (match.macro(node2)) {
      if (renderInfo.inMathMode === true) {
        return { enter: ["args"], leave: [] };
      } else if (renderInfo.inMathMode === false) {
        return { enter: [], leave: ["args"] };
      }
    }
    if (match.environment(node2)) {
      if (renderInfo.inMathMode === true) {
        return { enter: ["content"], leave: [] };
      } else {
        return { enter: [], leave: ["content"] };
      }
    }
    return NULL_RETURN;
  }
  const CONTINUE$2 = Symbol("continue");
  const SKIP$2 = Symbol("skip");
  const EXIT$2 = Symbol("exit");
  const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false
  };
  function visit$3(tree, visitor2, options2) {
    const {
      startingContext = DEFAULT_CONTEXT,
      test = () => true,
      includeArrays = false
    } = options2 || {};
    let enter;
    let leave;
    if (typeof visitor2 === "function") {
      enter = visitor2;
    } else if (visitor2 && typeof visitor2 === "object") {
      enter = visitor2.enter;
      leave = visitor2.leave;
    }
    walk(tree, {
      key: void 0,
      index: void 0,
      parents: [],
      containingArray: void 0,
      context: { ...startingContext }
    });
    function walk(node2, { key: key2, index: index2, parents, context, containingArray }) {
      const nodePassesTest = includeArrays ? test(node2, { key: key2, index: index2, parents, context, containingArray }) : !Array.isArray(node2) && test(node2, { key: key2, index: index2, parents, context, containingArray });
      const result = enter && nodePassesTest ? toResult$2(
        enter(node2, {
          key: key2,
          index: index2,
          parents,
          context,
          containingArray
        })
      ) : [CONTINUE$2];
      if (result[0] === EXIT$2) {
        return result;
      }
      if (result[0] === SKIP$2) {
        return leave && nodePassesTest ? toResult$2(
          leave(node2, {
            key: key2,
            index: index2,
            parents,
            context,
            containingArray
          })
        ) : result;
      }
      if (Array.isArray(node2)) {
        for (let index22 = 0; index22 > -1 && index22 < node2.length; index22++) {
          const item = node2[index22];
          const result2 = walk(item, {
            key: key2,
            index: index22,
            parents,
            context,
            containingArray: node2
          });
          if (result2[0] === EXIT$2) {
            return result2;
          }
          if (typeof result2[1] === "number") {
            index22 = result2[1] - 1;
          }
        }
      } else {
        let childProps = ["content", "args"];
        switch (node2.type) {
          case "macro":
            childProps = ["args"];
            break;
          case "comment":
          case "string":
          case "verb":
          case "verbatim":
            childProps = [];
            break;
        }
        const mathModeProps = listMathChildren(node2);
        for (const key22 of childProps) {
          const value2 = node2[key22];
          const grandparents = [node2].concat(parents);
          if (value2 == null) {
            continue;
          }
          const newContext = { ...context };
          if (mathModeProps.enter.includes(key22)) {
            newContext.inMathMode = true;
            newContext.hasMathModeAncestor = true;
          } else if (mathModeProps.leave.includes(key22)) {
            newContext.inMathMode = false;
          }
          const result2 = walk(value2, {
            key: key22,
            index: void 0,
            parents: grandparents,
            context: newContext,
            containingArray: void 0
          });
          if (result2[0] === EXIT$2) {
            return result2;
          }
        }
      }
      return leave && nodePassesTest ? toResult$2(
        leave(node2, {
          key: key2,
          index: index2,
          parents,
          context,
          containingArray
        })
      ) : result;
    }
  }
  function toResult$2(value2) {
    if (value2 == null) {
      return [CONTINUE$2];
    }
    if (Array.isArray(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      return [CONTINUE$2, value2];
    }
    return [value2];
  }
  function trim(nodes) {
    if (!Array.isArray(nodes)) {
      console.warn("Trying to trim a non-array ast", nodes);
      return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
  }
  function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    for (const leadingToken of nodes) {
      if (!match.comment(leadingToken)) {
        break;
      }
      if (leadingToken.leadingWhitespace || leadingToken.sameline) {
        leadingToken.leadingWhitespace = false;
      }
      if (start > 0 && leadingToken.sameline) {
        leadingToken.sameline = false;
      }
    }
    return { trimmedStart: start };
  }
  function trimEnd(nodes) {
    const { end: end2 } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end2, end2);
    for (let i = nodes.length - 1; i >= 0; i--) {
      const trailingToken = nodes[i];
      if (!match.comment(trailingToken)) {
        break;
      }
      delete trailingToken.suffixParbreak;
      if (match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
        trailingToken.leadingWhitespace = false;
      }
    }
    return { trimmedEnd: end2 };
  }
  function amountOfLeadingAndTrailingWhitespace(ast2) {
    let start = 0;
    let end2 = 0;
    for (const node2 of ast2) {
      if (match.whitespace(node2) || match.parbreak(node2)) {
        start++;
      } else {
        break;
      }
    }
    if (start === ast2.length) {
      return { start, end: 0 };
    }
    for (let i = ast2.length - 1; i >= 0; i--) {
      const node2 = ast2[i];
      if (match.whitespace(node2) || match.parbreak(node2)) {
        end2++;
      } else {
        break;
      }
    }
    return { start, end: end2 };
  }
  const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
    return (tree) => {
      visit$3(tree, (node2) => {
        if (!(match.math(node2) || match.anyEnvironment(node2))) {
          return;
        }
        let firstNode = node2.content[0];
        if (match.comment(firstNode) && firstNode.sameline) {
          firstNode.suffixParbreak = false;
          trimEnd(node2.content);
          const { trimmedStart } = trimStart(node2.content.slice(1));
          node2.content.splice(1, trimmedStart);
        } else {
          trim(node2.content);
        }
      });
    };
  };
  const unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
    return (tree) => {
      trim(tree.content);
    };
  };
  function normalizeNode(node2) {
    if (typeof node2 === "string") {
      return s$1(node2);
    }
    return node2;
  }
  function normalizeArgument(arg2, openMark = "{", closeMark = "}") {
    if (arg2 == null) {
      return { type: "argument", content: [], openMark: "", closeMark: "" };
    }
    if (typeof arg2 === "string") {
      return {
        type: "argument",
        openMark,
        closeMark,
        content: [s$1(arg2)]
      };
    }
    if (arg2.type === "argument") {
      return arg2;
    }
    return { type: "argument", openMark, closeMark, content: [arg2] };
  }
  function normalizeArgumentsList(args2, openMark = "{", closeMark = "}") {
    if (args2 == null) {
      return [];
    }
    if (Array.isArray(args2)) {
      return args2.map((arg2) => normalizeArgument(arg2, openMark, closeMark));
    }
    return [normalizeArgument(args2, openMark, closeMark)];
  }
  const BRACES_MAP = {
    "*": { openMark: "", closeMark: "" },
    "{": { openMark: "{", closeMark: "}" },
    "[": { openMark: "[", closeMark: "]" },
    "(": { openMark: "(", closeMark: ")" },
    "<": { openMark: "<", closeMark: ">" }
  };
  const CLOSE_BRACES = new Set(
    Object.values(BRACES_MAP).map((x2) => x2.closeMark).filter((x2) => x2)
  );
  function bracesToOpenAndCloseMarks(braces) {
    const ret = [];
    for (const char of braces.split("")) {
      if (CLOSE_BRACES.has(char)) {
        continue;
      }
      const braces2 = BRACES_MAP[char];
      if (braces2 == null) {
        throw new Error(`Unknown open/close mark type "${char}"`);
      }
      ret.push(braces2);
    }
    return ret;
  }
  function arg(args2, special) {
    if (args2 == null) {
      return { type: "argument", content: [], openMark: "", closeMark: "" };
    }
    if (typeof args2 === "string") {
      args2 = s$1(args2);
    }
    if (!Array.isArray(args2) && args2.type === "argument") {
      return args2;
    }
    let openMark = (special == null ? void 0 : special.openMark) ?? "{";
    let closeMark = (special == null ? void 0 : special.closeMark) ?? "}";
    if (special == null ? void 0 : special.braces) {
      const braces = bracesToOpenAndCloseMarks(special.braces);
      if (braces[0]) {
        openMark = braces[0].openMark;
        closeMark = braces[0].closeMark;
      }
    }
    if (!Array.isArray(args2)) {
      args2 = [args2];
    }
    return { type: "argument", content: args2, openMark, closeMark };
  }
  function m(name2, marcoArgs, special) {
    const args2 = normalizeArgumentsList(marcoArgs);
    const escapeToken = special == null ? void 0 : special.escapeToken;
    const ret = { type: "macro", content: name2 };
    if (args2.length > 0) {
      ret.args = args2;
    }
    if (escapeToken != null) {
      ret.escapeToken = escapeToken;
    }
    return ret;
  }
  function s$1(value2) {
    if (typeof value2 === "string") {
      return { type: "string", content: value2 };
    }
    return value2;
  }
  function env$1(name2, body2, envArgs, special) {
    if (!Array.isArray(body2)) {
      body2 = [body2];
    }
    const args2 = normalizeArgumentsList(envArgs, "[", "]");
    const ret = {
      type: "environment",
      env: name2,
      content: body2.map(normalizeNode)
    };
    if (args2.length > 0) {
      ret.args = args2;
    }
    return ret;
  }
  function decorateArrayForPegjs(array) {
    array.charAt = function(i) {
      return this[i];
    };
    array.charCodeAt = () => 0;
    array.substring = function(i, j) {
      return this.slice(i, j);
    };
    array.replace = function(a2, b) {
      const ret = JSON.stringify(this);
      return ret.replace(a2, b);
    };
    return array;
  }
  function splitStringsIntoSingleChars(nodes) {
    return nodes.flatMap(
      (node2) => match.anyString(node2) ? Array.from(node2.content).map((c2) => ({
        type: "string",
        content: c2
      })) : node2
    );
  }
  const _LatexPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
        var peg$startRuleFunction = peg$parsedocument;
        var peg$c0 = "%";
        var peg$c1 = ".";
        var peg$c2 = "verb*";
        var peg$c3 = "verb";
        var peg$c4 = "[";
        var peg$c5 = "]";
        var peg$c6 = "lstinline";
        var peg$c7 = "mintinline";
        var peg$c8 = "mint";
        var peg$c9 = "minted";
        var peg$c10 = "verbatim*";
        var peg$c11 = "verbatim";
        var peg$c12 = "filecontents*";
        var peg$c13 = "filecontents";
        var peg$c14 = "comment";
        var peg$c15 = "lstlisting";
        var peg$c16 = "(";
        var peg$c17 = ")";
        var peg$c18 = "begin";
        var peg$c19 = "end";
        var peg$c20 = "equation*";
        var peg$c21 = "equation";
        var peg$c22 = "align*";
        var peg$c23 = "align";
        var peg$c24 = "alignat*";
        var peg$c25 = "alignat";
        var peg$c26 = "gather*";
        var peg$c27 = "gather";
        var peg$c28 = "multline*";
        var peg$c29 = "multline";
        var peg$c30 = "flalign*";
        var peg$c31 = "flalign";
        var peg$c32 = "split";
        var peg$c33 = "math";
        var peg$c34 = "displaymath";
        var peg$c35 = "\\";
        var peg$c36 = "{";
        var peg$c37 = "}";
        var peg$c38 = "$";
        var peg$c39 = "&";
        var peg$c40 = "\r";
        var peg$c41 = "\n";
        var peg$c42 = "\r\n";
        var peg$c43 = "#";
        var peg$c44 = "^";
        var peg$c45 = "_";
        var peg$c46 = "\0";
        var peg$r0 = /^[^ \t\n\r]/;
        var peg$r1 = /^[ \t]/;
        var peg$r2 = /^[a-zA-Z]/;
        var peg$r3 = /^[0-9]/;
        var peg$r4 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
        var peg$e0 = peg$otherExpectation("document");
        var peg$e1 = peg$otherExpectation("math");
        var peg$e2 = peg$otherExpectation("token");
        var peg$e3 = peg$anyExpectation();
        var peg$e4 = peg$otherExpectation("parbreak");
        var peg$e5 = peg$otherExpectation("math token");
        var peg$e6 = peg$otherExpectation("nonchar token");
        var peg$e7 = peg$literalExpectation("%", false);
        var peg$e8 = peg$otherExpectation("whitespace");
        var peg$e9 = peg$otherExpectation("number");
        var peg$e10 = peg$literalExpectation(".", false);
        var peg$e11 = peg$otherExpectation("special macro");
        var peg$e12 = peg$literalExpectation("verb*", false);
        var peg$e13 = peg$literalExpectation("verb", false);
        var peg$e14 = peg$literalExpectation("[", false);
        var peg$e15 = peg$literalExpectation("]", false);
        var peg$e16 = peg$classExpectation([" ", "	", "\n", "\r"], true, false);
        var peg$e17 = peg$otherExpectation("verbatim listings");
        var peg$e18 = peg$literalExpectation("lstinline", false);
        var peg$e19 = peg$otherExpectation("verbatim minted");
        var peg$e20 = peg$literalExpectation("mintinline", false);
        var peg$e21 = peg$literalExpectation("mint", false);
        var peg$e22 = peg$otherExpectation("verbatim minted environment");
        var peg$e23 = peg$literalExpectation("minted", false);
        var peg$e24 = peg$otherExpectation("verbatim environment");
        var peg$e25 = peg$literalExpectation("verbatim*", false);
        var peg$e26 = peg$literalExpectation("verbatim", false);
        var peg$e27 = peg$literalExpectation("filecontents*", false);
        var peg$e28 = peg$literalExpectation("filecontents", false);
        var peg$e29 = peg$literalExpectation("comment", false);
        var peg$e30 = peg$literalExpectation("lstlisting", false);
        var peg$e31 = peg$otherExpectation("macro");
        var peg$e32 = peg$otherExpectation("group");
        var peg$e33 = peg$otherExpectation("environment");
        var peg$e34 = peg$otherExpectation("math environment");
        var peg$e36 = peg$literalExpectation("(", false);
        var peg$e37 = peg$literalExpectation(")", false);
        var peg$e38 = peg$literalExpectation("begin", false);
        var peg$e39 = peg$literalExpectation("end", false);
        var peg$e40 = peg$literalExpectation("equation*", false);
        var peg$e41 = peg$literalExpectation("equation", false);
        var peg$e42 = peg$literalExpectation("align*", false);
        var peg$e43 = peg$literalExpectation("align", false);
        var peg$e44 = peg$literalExpectation("alignat*", false);
        var peg$e45 = peg$literalExpectation("alignat", false);
        var peg$e46 = peg$literalExpectation("gather*", false);
        var peg$e47 = peg$literalExpectation("gather", false);
        var peg$e48 = peg$literalExpectation("multline*", false);
        var peg$e49 = peg$literalExpectation("multline", false);
        var peg$e50 = peg$literalExpectation("flalign*", false);
        var peg$e51 = peg$literalExpectation("flalign", false);
        var peg$e52 = peg$literalExpectation("split", false);
        var peg$e53 = peg$literalExpectation("math", false);
        var peg$e54 = peg$literalExpectation("displaymath", false);
        var peg$e55 = peg$otherExpectation("escape");
        var peg$e56 = peg$literalExpectation("\\", false);
        var peg$e57 = peg$literalExpectation("{", false);
        var peg$e58 = peg$literalExpectation("}", false);
        var peg$e59 = peg$literalExpectation("$", false);
        var peg$e60 = peg$literalExpectation("&", false);
        var peg$e61 = peg$otherExpectation("newline");
        var peg$e62 = peg$literalExpectation("\r", false);
        var peg$e63 = peg$literalExpectation("\n", false);
        var peg$e64 = peg$literalExpectation("\r\n", false);
        var peg$e65 = peg$literalExpectation("#", false);
        var peg$e66 = peg$literalExpectation("^", false);
        var peg$e67 = peg$literalExpectation("_", false);
        var peg$e68 = peg$literalExpectation("\0", false);
        var peg$e69 = peg$classExpectation([" ", "	"], false, false);
        var peg$e70 = peg$otherExpectation("letter");
        var peg$e71 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
        var peg$e72 = peg$otherExpectation("digit");
        var peg$e73 = peg$classExpectation([["0", "9"]], false, false);
        var peg$e74 = peg$otherExpectation("punctuation");
        var peg$e75 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
        var peg$e76 = peg$otherExpectation("full comment");
        var peg$e77 = peg$otherExpectation("comment");
        var peg$f0 = function(content2) {
          return createNode("root", { content: content2.flatMap((x2) => x2) });
        };
        var peg$f1 = function(t) {
          return t;
        };
        var peg$f2 = function(eq) {
          return createNode("inlinemath", { content: eq.flatMap((x2) => x2) });
        };
        var peg$f3 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f4 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f5 = function() {
          return createNode("parbreak");
        };
        var peg$f6 = function(x2) {
          return x2;
        };
        var peg$f7 = function(x2) {
          return x2;
        };
        var peg$f8 = function() {
          return createNode("macro", { content: "^", escapeToken: "" });
        };
        var peg$f9 = function() {
          return createNode("macro", { content: "_", escapeToken: "" });
        };
        var peg$f10 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f11 = function() {
          return createNode("whitespace");
        };
        var peg$f12 = function(a2, b) {
          return a2.join("") + "." + b.join("");
        };
        var peg$f13 = function(b) {
          return "." + b.join("");
        };
        var peg$f14 = function(a2) {
          return a2.join("") + ".";
        };
        var peg$f15 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f16 = function(env2, e, end2) {
          return end2 == e;
        };
        var peg$f17 = function(env2, e, x2) {
          return x2;
        };
        var peg$f18 = function(env2, e, x2, end2) {
          return end2 == e;
        };
        var peg$f19 = function(env2, e, x2) {
          return createNode("verb", {
            env: env2,
            escape: e,
            content: x2.join("")
          });
        };
        var peg$f20 = function(x2) {
          return x2;
        };
        var peg$f21 = function(x2) {
          return createNode("displaymath", { content: x2.flatMap((x22) => x22) });
        };
        var peg$f22 = function(x2) {
          return x2;
        };
        var peg$f23 = function(x2) {
          return createNode("inlinemath", { content: x2.flatMap((x22) => x22) });
        };
        var peg$f24 = function(x2) {
          return x2;
        };
        var peg$f25 = function(x2) {
          return createNode("displaymath", { content: x2.flatMap((x22) => x22) });
        };
        var peg$f26 = function(end2) {
          return end2.type === "string" && end2.content === "]";
        };
        var peg$f27 = function(x2) {
          return x2;
        };
        var peg$f28 = function(o) {
          return [
            createNode("string", { content: "[" }),
            ...o,
            createNode("string", { content: "]" })
          ];
        };
        var peg$f29 = function(x2) {
          return x2;
        };
        var peg$f30 = function(v) {
          return createNode("group", {
            content: createNode("string", { content: v.join("") })
          });
        };
        var peg$f31 = function(d, end2) {
          return end2 == d;
        };
        var peg$f32 = function(d, x2) {
          return x2;
        };
        var peg$f33 = function(d, v, end2) {
          return end2 == d;
        };
        var peg$f34 = function(d, v) {
          return [
            createNode("string", { content: d }),
            createNode("string", { content: v.join("") }),
            createNode("string", { content: d })
          ];
        };
        var peg$f35 = function(macro2, option2, verbatim) {
          return [
            createNode("macro", { content: macro2 }),
            ...option2 || [],
            ...[].concat(verbatim)
          ];
        };
        var peg$f36 = function(macro2, option2, language, verbatim) {
          return [
            createNode("macro", { content: macro2 }),
            ...option2 || [],
            language,
            ...[].concat(verbatim)
          ];
        };
        var peg$f37 = function(env2, option2, language, end_env) {
          return compare_env({ content: [env2] }, end_env);
        };
        var peg$f38 = function(env2, option2, language, body2) {
          const content2 = [
            ...option2 || [],
            language,
            { type: "string", content: body2 }
          ];
          return createNode("environment", {
            env: env2,
            content: content2
          });
        };
        var peg$f39 = function(env2, end_env) {
          return compare_env({ content: [env2] }, end_env);
        };
        var peg$f40 = function(env2, x2) {
          return x2;
        };
        var peg$f41 = function(env2, body2) {
          return createNode("verbatim", {
            env: env2,
            content: body2
          });
        };
        var peg$f42 = function(n) {
          return n.join("");
        };
        var peg$f43 = function(n) {
          return n;
        };
        var peg$f44 = function(m2) {
          return createNode("macro", { content: m2 });
        };
        var peg$f45 = function(c2) {
          return c2;
        };
        var peg$f46 = function(x2) {
          return createNode("group", { content: x2.flatMap((x22) => x22) });
        };
        var peg$f47 = function(g) {
          return text2().slice(1, -1);
        };
        var peg$f48 = function(env2, env_comment, end_env) {
          return compare_env(env2, end_env);
        };
        var peg$f49 = function(env2, env_comment, x2) {
          return x2;
        };
        var peg$f50 = function(env2, env_comment, body2) {
          body2 = body2.flatMap((x2) => x2);
          return createNode("environment", {
            env: env2,
            content: env_comment ? [env_comment, ...body2] : body2
          });
        };
        var peg$f51 = function(env2, env_comment, end_env) {
          return compare_env({ content: [env2] }, end_env);
        };
        var peg$f52 = function(env2, env_comment, x2) {
          return x2;
        };
        var peg$f53 = function(env2, env_comment, body2) {
          body2 = body2.flatMap((x2) => x2);
          return createNode("mathenv", {
            env: env2,
            content: env_comment ? [env_comment, ...body2] : body2
          });
        };
        var peg$f56 = function(e) {
          return createNode("string", { content: e });
        };
        var peg$f57 = function() {
          return createNode("string", { content: "\\" });
        };
        var peg$f58 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f59 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f60 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f61 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f62 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f63 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f64 = function(s2) {
          return createNode("string", { content: s2 });
        };
        var peg$f65 = function() {
          return " ";
        };
        var peg$f66 = function(p2) {
          return createNode("string", { content: p2 });
        };
        var peg$f67 = function(leading_sp, comment2) {
          return createNode("comment", {
            ...comment2,
            sameline: false,
            leadingWhitespace: leading_sp.length > 0
          });
        };
        var peg$f68 = function(spaces, x2) {
          return createNode("comment", {
            ...x2,
            sameline: true,
            leadingWhitespace: spaces.length > 0
          });
        };
        var peg$f69 = function(c2) {
          return c2;
        };
        var peg$f70 = function(c2) {
          return { content: c2.join(""), suffixParbreak: true };
        };
        var peg$f71 = function(c2) {
          return c2;
        };
        var peg$f72 = function(c2) {
          return { content: c2.join("") };
        };
        var peg$f73 = function() {
          var loc = location2();
          return loc.start.column === 1;
        };
        var peg$currPos = 0;
        var peg$savedPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$resultsCache = {};
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function text2() {
          return input2.substring(peg$savedPos, peg$currPos);
        }
        function location2() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function peg$literalExpectation(text22, ignoreCase) {
          return { type: "literal", text: text22, ignoreCase };
        }
        function peg$classExpectation(parts2, inverted, ignoreCase) {
          return { type: "class", parts: parts2, inverted, ignoreCase };
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location22) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location22
          );
        }
        function peg$parsedocument() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 0;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsetoken();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsetoken();
          }
          peg$savedPos = s0;
          s1 = peg$f0(s1);
          s0 = s1;
          peg$silentFails--;
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemath() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 1;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = [];
          s1 = peg$parsemath_token();
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsemath_token();
          }
          peg$silentFails--;
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetoken() {
          var s0, s1, s2, s3, s4, s5;
          var key2 = peg$currPos * 52 + 2;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$parsespecial_macro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemacro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefull_comment();
              if (s0 === peg$FAILED) {
                s0 = peg$parsegroup();
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsemath_shift();
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parsemath_shift();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = void 0;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsemath_token();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s3 = peg$f1(s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parsemath_shift();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                          s4 = void 0;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_token();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s3 = peg$f1(s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                    } else {
                      s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsemath_shift();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f2(s2);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsealignment_tab();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseparbreak();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsemacro_parameter();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseignore();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsenumber();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsewhitespace();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsepunctuation();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$currPos;
                                  s2 = [];
                                  s3 = peg$currPos;
                                  s4 = peg$currPos;
                                  peg$silentFails++;
                                  s5 = peg$parsenonchar_token();
                                  peg$silentFails--;
                                  if (s5 === peg$FAILED) {
                                    s4 = void 0;
                                  } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                  }
                                  if (s4 !== peg$FAILED) {
                                    if (input2.length > peg$currPos) {
                                      s5 = input2.charAt(peg$currPos);
                                      peg$currPos++;
                                    } else {
                                      s5 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e3);
                                      }
                                    }
                                    if (s5 !== peg$FAILED) {
                                      s4 = [s4, s5];
                                      s3 = s4;
                                    } else {
                                      peg$currPos = s3;
                                      s3 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                  }
                                  if (s3 !== peg$FAILED) {
                                    while (s3 !== peg$FAILED) {
                                      s2.push(s3);
                                      s3 = peg$currPos;
                                      s4 = peg$currPos;
                                      peg$silentFails++;
                                      s5 = peg$parsenonchar_token();
                                      peg$silentFails--;
                                      if (s5 === peg$FAILED) {
                                        s4 = void 0;
                                      } else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                      }
                                      if (s4 !== peg$FAILED) {
                                        if (input2.length > peg$currPos) {
                                          s5 = input2.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s5 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s5 !== peg$FAILED) {
                                          s4 = [s4, s5];
                                          s3 = s4;
                                        } else {
                                          peg$currPos = s3;
                                          s3 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                      }
                                    }
                                  } else {
                                    s2 = peg$FAILED;
                                  }
                                  if (s2 !== peg$FAILED) {
                                    s1 = input2.substring(s1, peg$currPos);
                                  } else {
                                    s1 = s2;
                                  }
                                  if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$f3(s1);
                                  }
                                  s0 = s1;
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parsebegin_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parseend_group();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parsemath_shift();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          if (input2.length > peg$currPos) {
                                            s1 = input2.charAt(peg$currPos);
                                            peg$currPos++;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e3);
                                            }
                                          }
                                          if (s1 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$f4(s1);
                                          }
                                          s0 = s1;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseparbreak() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key2 = peg$currPos * 52 + 3;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parsesp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsesp();
          }
          s3 = peg$parsenl();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsesp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsesp();
            }
            s3 = peg$parsenl();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = [];
                  s7 = peg$parsesp();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parsesp();
                  }
                  s7 = peg$parsenl();
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f5();
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemath_token() {
          var s0, s1, s2, s3, s4;
          var key2 = peg$currPos * 52 + 4;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$parsespecial_macro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemacro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefull_comment();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parsewhitespace();
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsewhitespace();
                }
                s2 = peg$parsegroup();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parsewhitespace();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f6(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = [];
                  s2 = peg$parsewhitespace();
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parsewhitespace();
                  }
                  s2 = peg$parsealignment_tab();
                  if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parsewhitespace();
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parsewhitespace();
                    }
                    peg$savedPos = s0;
                    s0 = peg$f7(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsemacro_parameter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s2 = peg$parsewhitespace();
                      while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        s2 = peg$parsewhitespace();
                      }
                      s2 = peg$parsesuperscript();
                      if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parsewhitespace();
                        while (s4 !== peg$FAILED) {
                          s3.push(s4);
                          s4 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f8();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$parsewhitespace();
                        while (s2 !== peg$FAILED) {
                          s1.push(s2);
                          s2 = peg$parsewhitespace();
                        }
                        s2 = peg$parsesubscript();
                        if (s2 !== peg$FAILED) {
                          s3 = [];
                          s4 = peg$parsewhitespace();
                          while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$parsewhitespace();
                          }
                          peg$savedPos = s0;
                          s0 = peg$f9();
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseignore();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              if (input2.length > peg$currPos) {
                                s1 = input2.charAt(peg$currPos);
                                peg$currPos++;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e3);
                                }
                              }
                              if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$f10(s1);
                              }
                              s0 = s1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsenonchar_token() {
          var s0;
          var key2 = peg$currPos * 52 + 5;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$parseescape();
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 37) {
              s0 = peg$c0;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parsebegin_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parseend_group();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_shift();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsealignment_tab();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsenl();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsemacro_parameter();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseignore();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsesp();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseEOF();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsewhitespace() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key2 = peg$currPos * 52 + 6;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsenl();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsesp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsesp();
            }
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsesp();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsesp();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsenl();
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsecomment_start();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsesp();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsesp();
                  }
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parsenl();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s2 = [s2, s3, s4, s5, s6];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = [];
              s2 = peg$parsesp();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsesp();
                }
              } else {
                s1 = peg$FAILED;
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsenumber() {
          var s0, s1, s2, s3, s4, s5;
          var key2 = peg$currPos * 52 + 7;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parsenum();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsenum();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c1;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsenum();
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsenum();
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f12(s2, s4);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsenum();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsenum();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f13(s3);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsenum();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsenum();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input2.charCodeAt(peg$currPos) === 46) {
                  s3 = peg$c1;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s1 = peg$f14(s2);
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f15(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsespecial_macro() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          var key2 = peg$currPos * 52 + 8;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.substr(peg$currPos, 5) === peg$c2) {
              s2 = peg$c2;
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            if (s2 === peg$FAILED) {
              if (input2.substr(peg$currPos, 4) === peg$c3) {
                s2 = peg$c3;
                peg$currPos += 4;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e13);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s3 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input2.length > peg$currPos) {
                  s8 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s2, s3, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input2.length > peg$currPos) {
                    s7 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s2, s3, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  if (input2.length > peg$currPos) {
                    s8 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s9 = peg$f16(s2, s3, s8);
                    if (s9) {
                      s9 = void 0;
                    } else {
                      s9 = peg$FAILED;
                    }
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input2.length > peg$currPos) {
                      s7 = input2.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s5 = peg$f17(s2, s3, s7);
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                s5 = peg$currPos;
                if (input2.length > peg$currPos) {
                  s6 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s7 = peg$f18(s2, s3, s4, s6);
                  if (s7) {
                    s7 = void 0;
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f19(s2, s3, s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseverbatim_listings();
            if (s0 === peg$FAILED) {
              s0 = peg$parseverbatim_minted();
              if (s0 === peg$FAILED) {
                s0 = peg$parseverbatim_minted_environment();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseverbatim_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsebegin_display_math();
                    if (s1 !== peg$FAILED) {
                      s2 = [];
                      s3 = peg$currPos;
                      s4 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parseend_display_math();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s4 = void 0;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s3 = peg$f20(s5);
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parseend_display_math();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                          s4 = void 0;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_token();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s3 = peg$f20(s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                      s3 = peg$parseend_display_math();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f21(s2);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsebegin_inline_math();
                      if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parseend_inline_math();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                          s4 = void 0;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_token();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s3 = peg$f22(s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          s3 = peg$currPos;
                          s4 = peg$currPos;
                          peg$silentFails++;
                          s5 = peg$parseend_inline_math();
                          peg$silentFails--;
                          if (s5 === peg$FAILED) {
                            s4 = void 0;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsemath_token();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s3 = peg$f22(s5);
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        }
                        s3 = peg$parseend_inline_math();
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f23(s2);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsemath_shift();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parsemath_shift();
                          if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$currPos;
                            s5 = peg$currPos;
                            peg$silentFails++;
                            s6 = peg$currPos;
                            s7 = peg$parsemath_shift();
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parsemath_shift();
                              if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                              } else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                            peg$silentFails--;
                            if (s6 === peg$FAILED) {
                              s5 = void 0;
                            } else {
                              peg$currPos = s5;
                              s5 = peg$FAILED;
                            }
                            if (s5 !== peg$FAILED) {
                              s6 = peg$parsemath_token();
                              if (s6 !== peg$FAILED) {
                                peg$savedPos = s4;
                                s4 = peg$f24(s6);
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                            while (s4 !== peg$FAILED) {
                              s3.push(s4);
                              s4 = peg$currPos;
                              s5 = peg$currPos;
                              peg$silentFails++;
                              s6 = peg$currPos;
                              s7 = peg$parsemath_shift();
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parsemath_shift();
                                if (s8 !== peg$FAILED) {
                                  s7 = [s7, s8];
                                  s6 = s7;
                                } else {
                                  peg$currPos = s6;
                                  s6 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                              }
                              peg$silentFails--;
                              if (s6 === peg$FAILED) {
                                s5 = void 0;
                              } else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                              }
                              if (s5 !== peg$FAILED) {
                                s6 = peg$parsemath_token();
                                if (s6 !== peg$FAILED) {
                                  peg$savedPos = s4;
                                  s4 = peg$f24(s6);
                                } else {
                                  peg$currPos = s4;
                                  s4 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                            }
                            s4 = peg$parsemath_shift();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsemath_shift();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f25(s3);
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsemath_environment();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseenvironment();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesquare_bracket_argument() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key2 = peg$currPos * 52 + 9;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c4;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$currPos;
            s6 = peg$parsetoken();
            if (s6 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s7 = peg$f26(s6);
              if (s7) {
                s7 = void 0;
              } else {
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f27(s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$currPos;
              s6 = peg$parsetoken();
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f26(s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsetoken();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f27(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (input2.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f28(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_group() {
          var s0, s1, s2, s3, s4, s5;
          var key2 = peg$currPos * 52 + 10;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsebegin_group();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s5 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f29(s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_group();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s5 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f29(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s3 = peg$parseend_group();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_delimited_by_char() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key2 = peg$currPos * 52 + 11;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (peg$r0.test(input2.charAt(peg$currPos))) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$currPos;
            if (input2.length > peg$currPos) {
              s6 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s6 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s7 = peg$f31(s1, s6);
              if (s7) {
                s7 = void 0;
              } else {
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s5 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f32(s1, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$currPos;
              if (input2.length > peg$currPos) {
                s6 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f31(s1, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s5 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f32(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s3 = peg$currPos;
            if (input2.length > peg$currPos) {
              s4 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s5 = peg$f33(s1, s2, s4);
              if (s5) {
                s5 = void 0;
              } else {
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_listings() {
          var s0, s1, s2, s3, s4;
          var key2 = peg$currPos * 52 + 12;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.substr(peg$currPos, 9) === peg$c6) {
              s2 = peg$c6;
              peg$currPos += 9;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsesquare_bracket_argument();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$parseverbatim_group();
              if (s4 === peg$FAILED) {
                s4 = peg$parseverbatim_delimited_by_char();
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s2, s3, s4);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_minted() {
          var s0, s1, s2, s3, s4, s5;
          var key2 = peg$currPos * 52 + 13;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.substr(peg$currPos, 10) === peg$c7) {
              s2 = peg$c7;
              peg$currPos += 10;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            if (s2 === peg$FAILED) {
              if (input2.substr(peg$currPos, 4) === peg$c8) {
                s2 = peg$c8;
                peg$currPos += 4;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e21);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsesquare_bracket_argument();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$parsegroup();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseverbatim_group();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseverbatim_delimited_by_char();
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f36(s2, s3, s4, s5);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_minted_environment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
          var key2 = peg$currPos * 52 + 14;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsebegin_env();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsebegin_group();
            if (s2 !== peg$FAILED) {
              if (input2.substr(peg$currPos, 6) === peg$c9) {
                s3 = peg$c9;
                peg$currPos += 6;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseend_group();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsesquare_bracket_argument();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  s6 = peg$parsegroup();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$currPos;
                    s8 = [];
                    s9 = peg$currPos;
                    s10 = peg$currPos;
                    peg$silentFails++;
                    s11 = peg$currPos;
                    s12 = peg$parseend_env();
                    if (s12 !== peg$FAILED) {
                      s13 = peg$parsegroup();
                      if (s13 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s14 = peg$f37(s3, s5, s6, s13);
                        if (s14) {
                          s14 = void 0;
                        } else {
                          s14 = peg$FAILED;
                        }
                        if (s14 !== peg$FAILED) {
                          s12 = [s12, s13, s14];
                          s11 = s12;
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s11;
                      s11 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s11 === peg$FAILED) {
                      s10 = void 0;
                    } else {
                      peg$currPos = s10;
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      if (input2.length > peg$currPos) {
                        s11 = input2.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s11 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s11 !== peg$FAILED) {
                        s10 = [s10, s11];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$currPos;
                      s10 = peg$currPos;
                      peg$silentFails++;
                      s11 = peg$currPos;
                      s12 = peg$parseend_env();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parsegroup();
                        if (s13 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s14 = peg$f37(s3, s5, s6, s13);
                          if (s14) {
                            s14 = void 0;
                          } else {
                            s14 = peg$FAILED;
                          }
                          if (s14 !== peg$FAILED) {
                            s12 = [s12, s13, s14];
                            s11 = s12;
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s11 === peg$FAILED) {
                        s10 = void 0;
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                      if (s10 !== peg$FAILED) {
                        if (input2.length > peg$currPos) {
                          s11 = input2.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          s10 = [s10, s11];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    }
                    s7 = input2.substring(s7, peg$currPos);
                    s8 = peg$parseend_env();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsebegin_group();
                      if (s9 !== peg$FAILED) {
                        if (input2.substr(peg$currPos, 6) === peg$c9) {
                          s10 = peg$c9;
                          peg$currPos += 6;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e23);
                          }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseend_group();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f38(s3, s5, s6, s7);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_environment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
          var key2 = peg$currPos * 52 + 15;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsebegin_env();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsebegin_group();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseverbatim_env_name();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseend_group();
                if (s4 !== peg$FAILED) {
                  s5 = peg$currPos;
                  s6 = [];
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f39(s3, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    if (input2.length > peg$currPos) {
                      s9 = input2.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f40(s3, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$currPos;
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$currPos;
                    s10 = peg$parseend_env();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsegroup();
                      if (s11 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s12 = peg$f39(s3, s11);
                        if (s12) {
                          s12 = void 0;
                        } else {
                          s12 = peg$FAILED;
                        }
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = void 0;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      if (input2.length > peg$currPos) {
                        s9 = input2.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s7;
                        s7 = peg$f40(s3, s9);
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  }
                  s5 = input2.substring(s5, peg$currPos);
                  s6 = peg$parseend_env();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsebegin_group();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseverbatim_env_name();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseend_group();
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f41(s3, s5);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseverbatim_env_name() {
          var s0;
          var key2 = peg$currPos * 52 + 16;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input2.substr(peg$currPos, 9) === peg$c10) {
            s0 = peg$c10;
            peg$currPos += 9;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e25);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.substr(peg$currPos, 8) === peg$c11) {
              s0 = peg$c11;
              peg$currPos += 8;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e26);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.substr(peg$currPos, 13) === peg$c12) {
                s0 = peg$c12;
                peg$currPos += 13;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e27);
                }
              }
              if (s0 === peg$FAILED) {
                if (input2.substr(peg$currPos, 12) === peg$c13) {
                  s0 = peg$c13;
                  peg$currPos += 12;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e28);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input2.substr(peg$currPos, 7) === peg$c14) {
                    s0 = peg$c14;
                    peg$currPos += 7;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e29);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input2.substr(peg$currPos, 10) === peg$c15) {
                      s0 = peg$c15;
                      peg$currPos += 10;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e30);
                      }
                    }
                  }
                }
              }
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemacro() {
          var s0, s1, s2, s3, s4;
          var key2 = peg$currPos * 52 + 17;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseescape();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsechar();
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsechar();
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f42(s3);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseescape();
            if (s2 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s3 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f43(s3);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f44(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsegroup() {
          var s0, s1, s2, s3, s4, s5;
          var key2 = peg$currPos * 52 + 18;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsebegin_group();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f45(s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_group();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsetoken();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f45(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s3 = peg$parseend_group();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f46(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e32);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsegroup_contents_as_string() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 19;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsegroup();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f47();
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseenvironment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key2 = peg$currPos * 52 + 20;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsebegin_env();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsegroup_contents_as_string();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsesameline_comment();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f48(s2, s3, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f49(s2, s3, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = peg$parseend_env();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsegroup_contents_as_string();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s10 = peg$f48(s2, s3, s9);
                    if (s10) {
                      s10 = void 0;
                    } else {
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      s8 = [s8, s9, s10];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsetoken();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f49(s2, s3, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$parseend_env();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsegroup_contents_as_string();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f50(s2, s3, s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemath_environment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
          var key2 = peg$currPos * 52 + 21;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsebegin_env();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsebegin_group();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsemath_env_name();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseend_group();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsesameline_comment();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  s6 = [];
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f51(s3, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f52(s3, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$currPos;
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$currPos;
                    s10 = peg$parseend_env();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsegroup();
                      if (s11 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s12 = peg$f51(s3, s5, s11);
                        if (s12) {
                          s12 = void 0;
                        } else {
                          s12 = peg$FAILED;
                        }
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = void 0;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsemath_token();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s7;
                        s7 = peg$f52(s3, s5, s9);
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  }
                  s7 = peg$parseend_env();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsebegin_group();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsemath_env_name();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseend_group();
                        if (s10 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f53(s3, s5, s6);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsebegin_display_math() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 23;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c4;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseend_display_math() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 24;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 93) {
              s2 = peg$c5;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsebegin_inline_math() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 25;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 40) {
              s2 = peg$c16;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseend_inline_math() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 26;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 41) {
              s2 = peg$c17;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e37);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsebegin_env() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 27;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.substr(peg$currPos, 5) === peg$c18) {
              s2 = peg$c18;
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e38);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseend_env() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 28;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input2.substr(peg$currPos, 3) === peg$c19) {
              s2 = peg$c19;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemath_env_name() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 29;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.substr(peg$currPos, 9) === peg$c20) {
            s1 = peg$c20;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e40);
            }
          }
          if (s1 === peg$FAILED) {
            if (input2.substr(peg$currPos, 8) === peg$c21) {
              s1 = peg$c21;
              peg$currPos += 8;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e41);
              }
            }
            if (s1 === peg$FAILED) {
              if (input2.substr(peg$currPos, 6) === peg$c22) {
                s1 = peg$c22;
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e42);
                }
              }
              if (s1 === peg$FAILED) {
                if (input2.substr(peg$currPos, 5) === peg$c23) {
                  s1 = peg$c23;
                  peg$currPos += 5;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e43);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input2.substr(peg$currPos, 8) === peg$c24) {
                    s1 = peg$c24;
                    peg$currPos += 8;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e44);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input2.substr(peg$currPos, 7) === peg$c25) {
                      s1 = peg$c25;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e45);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input2.substr(peg$currPos, 7) === peg$c26) {
                        s1 = peg$c26;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e46);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input2.substr(peg$currPos, 6) === peg$c27) {
                          s1 = peg$c27;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e47);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input2.substr(peg$currPos, 9) === peg$c28) {
                            s1 = peg$c28;
                            peg$currPos += 9;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e48);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input2.substr(peg$currPos, 8) === peg$c29) {
                              s1 = peg$c29;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e49);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input2.substr(peg$currPos, 8) === peg$c30) {
                                s1 = peg$c30;
                                peg$currPos += 8;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e50);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input2.substr(peg$currPos, 7) === peg$c31) {
                                  s1 = peg$c31;
                                  peg$currPos += 7;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e51);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input2.substr(peg$currPos, 5) === peg$c32) {
                                    s1 = peg$c32;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e52);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input2.substr(peg$currPos, 4) === peg$c33) {
                                      s1 = peg$c33;
                                      peg$currPos += 4;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e53);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input2.substr(peg$currPos, 11) === peg$c34) {
                                        s1 = peg$c34;
                                        peg$currPos += 11;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e54);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f56(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseescape() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 30;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e56);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f57();
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsebegin_group() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 31;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c36;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e57);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f58(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseend_group() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 32;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 125) {
            s1 = peg$c37;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e58);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f59(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemath_shift() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 33;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 36) {
            s1 = peg$c38;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e59);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f60(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsealignment_tab() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 34;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c39;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e60);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f61(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsenl() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 35;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input2.charCodeAt(peg$currPos) === 13) {
            s2 = peg$c40;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e62);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c41;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e63);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c40;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e62);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.substr(peg$currPos, 2) === peg$c42) {
                s0 = peg$c42;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e64);
                }
              }
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e61);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemacro_parameter() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 36;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c43;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e65);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f62(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesuperscript() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 37;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 94) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e66);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f63(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesubscript() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 38;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c45;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e67);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f64(s1);
          }
          s0 = s1;
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseignore() {
          var s0;
          var key2 = peg$currPos * 52 + 39;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input2.charCodeAt(peg$currPos) === 0) {
            s0 = peg$c46;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e68);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesp() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 40;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          if (peg$r1.test(input2.charAt(peg$currPos))) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e69);
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s2 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e69);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f65();
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsechar() {
          var s0;
          var key2 = peg$currPos * 52 + 41;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          if (peg$r2.test(input2.charAt(peg$currPos))) {
            s0 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e71);
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e70);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsenum() {
          var s0;
          var key2 = peg$currPos * 52 + 42;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          if (peg$r3.test(input2.charAt(peg$currPos))) {
            s0 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e73);
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e72);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepunctuation() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 43;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          if (peg$r4.test(input2.charAt(peg$currPos))) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e75);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f66(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e74);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment_start() {
          var s0;
          var key2 = peg$currPos * 52 + 44;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input2.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefull_comment() {
          var s0;
          var key2 = peg$currPos * 52 + 45;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$parseownline_comment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesameline_comment();
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e76);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseownline_comment() {
          var s0, s1, s2, s3;
          var key2 = peg$currPos * 52 + 46;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parsesp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsesp();
          }
          s3 = peg$parsenl();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s2 = peg$parseleading_sp();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecomment();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f67(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesameline_comment() {
          var s0, s1, s2;
          var key2 = peg$currPos * 52 + 47;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsesp();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsesp();
          }
          s2 = peg$parsecomment();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f68(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key2 = peg$currPos * 52 + 48;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s5 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f69(s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s5 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f69(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseparbreak();
            peg$silentFails--;
            if (s4 !== peg$FAILED) {
              peg$currPos = s3;
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f70(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomment_start();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s5 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f71(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsenl();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input2.length > peg$currPos) {
                    s5 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f71(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s3 = peg$currPos;
              s4 = peg$parsenl();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsecomment_start();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parsenl();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseEOF();
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f72(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e77);
            }
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseleading_sp() {
          var s0, s1, s2, s3, s4;
          var key2 = peg$currPos * 52 + 49;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsestart_of_line();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsesp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsesp();
            }
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestart_of_line() {
          var s0;
          var key2 = peg$currPos * 52 + 50;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          peg$savedPos = peg$currPos;
          s0 = peg$f73();
          if (s0) {
            s0 = void 0;
          } else {
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key2 = peg$currPos * 52 + 51;
          var cached = peg$resultsCache[key2];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key2] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function toString2(e) {
          if (typeof e === "string") {
            return e;
          }
          if (typeof e.content === "string") {
            return e.content;
          }
          if (e && e.type === "whitespace") {
            return " ";
          }
          return e;
        }
        function compare_env(g1, g2) {
          const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString2).join("");
          const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString2).join("");
          return g1Name === g2Name;
        }
        function createNode(type, extra = {}) {
          return { type, ...extra, position: location2() };
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _AlignEnvironmentPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e0 = peg$anyExpectation();
        var peg$f0 = function() {
          return [];
        };
        var peg$f1 = function(x2) {
          return { cells: [], colSeps: [], ...x2 };
        };
        var peg$f2 = function(rowItems, rowSep, trailingComment) {
          return { ...rowItems, rowSep, trailingComment };
        };
        var peg$f3 = function(rowItems, trailingComment) {
          return { ...rowItems, rowSep: null, trailingComment };
        };
        var peg$f4 = function(x2) {
          return x2;
        };
        var peg$f5 = function(x2) {
          return {
            cells: [],
            colSeps: [],
            rowSep: null,
            trailingComment: x2
          };
        };
        var peg$f6 = function(x2) {
          return x2;
        };
        var peg$f7 = function(colSep, cell2) {
          return { colSep, cell: cell2 };
        };
        var peg$f8 = function(colSep) {
          return { colSep };
        };
        var peg$f9 = function(a2, b) {
          return processRow(a2, b);
        };
        var peg$f10 = function(b) {
          return processRow(null, b);
        };
        var peg$f11 = function(tok) {
          return options2.isSameLineComment(tok);
        };
        var peg$f12 = function(tok) {
          return tok;
        };
        var peg$f13 = function(tok) {
          return options2.isOwnLineComment(tok);
        };
        var peg$f14 = function(tok) {
          return tok;
        };
        var peg$f15 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$f16 = function(tok) {
          return tok;
        };
        var peg$f17 = function(tok) {
          return options2.isRowSep(tok);
        };
        var peg$f18 = function(tok) {
          return tok;
        };
        var peg$f19 = function(tok) {
          return options2.isColSep(tok);
        };
        var peg$f20 = function(tok) {
          return tok;
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1;
          s0 = [];
          s1 = peg$parsecomment_only_line();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_with_end();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_without_end();
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$parsecomment_only_line();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_with_end();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserow_without_end();
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEOL();
            if (s1 !== peg$FAILED) {
              s1 = peg$f0();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parserow_with_end() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parserow_items();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s2 = peg$f1(s2);
          s1 = s2;
          s2 = peg$parserow_sep();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetrailing_comment();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s0 = peg$f2(s1, s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parserow_without_end() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parserow_items();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetrailing_comment();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s0 = peg$f3(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetrailing_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace();
          }
          s2 = peg$parsesame_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f4(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecomment_only_line() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace();
          }
          s2 = peg$parseown_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f5(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetoken() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parserow_sep();
          if (s2 === peg$FAILED) {
            s2 = peg$parsecol_sep();
            if (s2 === peg$FAILED) {
              s2 = peg$parsetrailing_comment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseown_line_comment();
              }
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f6(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecell() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsetoken();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsetoken();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parseseparated_cell() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecell();
            if (s2 !== peg$FAILED) {
              s0 = peg$f7(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecol_sep();
            if (s1 !== peg$FAILED) {
              s1 = peg$f8(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parserow_items() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsecell();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseseparated_cell();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseseparated_cell();
            }
            s0 = peg$f9(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseseparated_cell();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseseparated_cell();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f10(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsesame_line_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f11(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f12(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseown_line_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f13(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f14(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsewhitespace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f15(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f16(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parserow_sep() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f17(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f18(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecol_sep() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f19(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f20(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function processRow(leadCell, otherCells) {
          const cells2 = [leadCell || []];
          const seps = [];
          for (const x2 of otherCells) {
            cells2.push(x2.cell || []);
            seps.push(x2.colSep);
          }
          return { cells: cells2, colSeps: seps };
        }
        if (!options2.isWhitespace) {
          try {
            Object.assign(
              options2,
              createMatchers(["\\", "hline", "cr"], ["&"])
            );
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _ArgSpecPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
        var peg$startRuleFunction = peg$parseargs_spec_list;
        var peg$c1 = "v";
        var peg$c2 = "b";
        var peg$c3 = "!";
        var peg$c4 = "D";
        var peg$c5 = "d";
        var peg$c6 = "s";
        var peg$c7 = "O";
        var peg$c8 = "o";
        var peg$c9 = "e";
        var peg$c10 = "E";
        var peg$c11 = "t";
        var peg$c12 = "R";
        var peg$c13 = "r";
        var peg$c14 = "u";
        var peg$c15 = "m";
        var peg$c16 = "{";
        var peg$c17 = "}";
        var peg$c18 = " ";
        var peg$c19 = "\n";
        var peg$c20 = "\r";
        var peg$c21 = "\\";
        var peg$r0 = /^[{ ]/;
        var peg$r1 = /^[a-zA-Z]/;
        var peg$r2 = /^[{}]/;
        var peg$e0 = peg$literalExpectation("+", false);
        var peg$e1 = peg$literalExpectation("v", false);
        var peg$e2 = peg$anyExpectation();
        var peg$e3 = peg$literalExpectation("b", false);
        var peg$e4 = peg$literalExpectation("!", false);
        var peg$e5 = peg$literalExpectation("D", false);
        var peg$e6 = peg$literalExpectation("d", false);
        var peg$e7 = peg$literalExpectation("s", false);
        var peg$e8 = peg$literalExpectation("O", false);
        var peg$e9 = peg$literalExpectation("o", false);
        var peg$e10 = peg$literalExpectation("e", false);
        var peg$e11 = peg$literalExpectation("E", false);
        var peg$e12 = peg$literalExpectation("t", false);
        var peg$e13 = peg$literalExpectation("R", false);
        var peg$e14 = peg$literalExpectation("r", false);
        var peg$e15 = peg$literalExpectation("u", false);
        var peg$e16 = peg$classExpectation(["{", " "], false, false);
        var peg$e17 = peg$literalExpectation("m", false);
        var peg$e18 = peg$literalExpectation("{", false);
        var peg$e19 = peg$literalExpectation("}", false);
        var peg$e20 = peg$literalExpectation(" ", false);
        var peg$e21 = peg$literalExpectation("\n", false);
        var peg$e22 = peg$literalExpectation("\r", false);
        var peg$e23 = peg$literalExpectation("\\", false);
        var peg$e24 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
        var peg$e25 = peg$classExpectation(["{", "}"], false, false);
        var peg$f0 = function(x2) {
          return x2;
        };
        var peg$f1 = function(spec) {
          return spec;
        };
        var peg$f2 = function(spec) {
          return spec;
        };
        var peg$f3 = function(openBrace) {
          return createNode("verbatim", { openBrace, closeBrace: openBrace });
        };
        var peg$f4 = function() {
          return createNode("body");
        };
        var peg$f5 = function(leading_bang, spec) {
          return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
        };
        var peg$f6 = function(braceSpec, defaultArg) {
          return createNode("optional", { ...braceSpec, defaultArg });
        };
        var peg$f7 = function(braceSpec) {
          return createNode("optional", braceSpec);
        };
        var peg$f8 = function() {
          return createNode("optionalStar");
        };
        var peg$f9 = function(g) {
          return createNode("optional", { defaultArg: g });
        };
        var peg$f10 = function() {
          return createNode("optional");
        };
        var peg$f11 = function(args) {
          return createNode("embellishment", {
            embellishmentTokens: args
          });
        };
        var peg$f12 = function(args, g) {
          return createNode("embellishment", {
            embellishmentTokens: args,
            defaultArg: g
          });
        };
        var peg$f13 = function(tok) {
          return createNode("optionalToken", { token: tok });
        };
        var peg$f14 = function(braceSpec, defaultArg) {
          return createNode("mandatory", { ...braceSpec, defaultArg });
        };
        var peg$f15 = function(braceSpec) {
          return createNode("mandatory", braceSpec);
        };
        var peg$f16 = function(stopTokens) {
          return createNode("until", { stopTokens });
        };
        var peg$f17 = function(x2) {
          return [x2];
        };
        var peg$f18 = function(g) {
          return g.content;
        };
        var peg$f19 = function() {
          return createNode("mandatory");
        };
        var peg$f20 = function(openBrace, closeBrace) {
          return { openBrace, closeBrace };
        };
        var peg$f21 = function(g) {
          return g.content.map(groupToStr).join("");
        };
        var peg$f22 = function(t) {
          return [t];
        };
        var peg$f23 = function(args) {
          return args.filter((a2) => !a2.match(/^\s*$/));
        };
        var peg$f24 = function(content2) {
          return { type: "group", content: content2 };
        };
        var peg$f25 = function() {
          return "";
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$literalExpectation(text2, ignoreCase) {
          return { type: "literal", text: text2, ignoreCase };
        }
        function peg$classExpectation(parts2, inverted, ignoreCase) {
          return { type: "class", parts: parts2, inverted, ignoreCase };
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parseargs_spec_list() {
          var s0, s1, s2, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          peg$parsewhitespace();
          s4 = peg$parsearg_spec();
          if (s4 !== peg$FAILED) {
            s2 = peg$f0(s4);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            peg$parsewhitespace();
            s4 = peg$parsearg_spec();
            if (s4 !== peg$FAILED) {
              s2 = peg$f0(s4);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          }
          s2 = peg$parsewhitespace();
          s0 = peg$f1(s1);
          return s0;
        }
        function peg$parsearg_spec() {
          var s0, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 43) {
            peg$currPos++;
          } else {
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          s2 = peg$parseoptional();
          if (s2 === peg$FAILED) {
            s2 = peg$parsemandatory();
            if (s2 === peg$FAILED) {
              s2 = peg$parseverbatim();
              if (s2 === peg$FAILED) {
                s2 = peg$parserequired();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsebody();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseuntil();
                  }
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s0 = peg$f2(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseverbatim() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 118) {
            s1 = peg$c1;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f3(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsebody() {
          var s0, s1;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 98) {
            s1 = peg$c2;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f4();
          }
          s0 = s1;
          return s0;
        }
        function peg$parseoptional() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s2 = peg$parseoptional_star();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoptional_standard();
            if (s2 === peg$FAILED) {
              s2 = peg$parseoptional_delimited();
              if (s2 === peg$FAILED) {
                s2 = peg$parseoptional_embellishment();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseoptional_token();
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s0 = peg$f5(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseoptional_delimited() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 68) {
            s1 = peg$c4;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsebrace_spec();
            s3 = peg$parsearg();
            if (s3 !== peg$FAILED) {
              s0 = peg$f6(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 100) {
              s1 = peg$c5;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebrace_spec();
              s0 = peg$f7(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseoptional_star() {
          var s0, s1;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 115) {
            s1 = peg$c6;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f8();
          }
          s0 = s1;
          return s0;
        }
        function peg$parseoptional_standard() {
          var s0, s1, s3;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 79) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$parsewhitespace();
            s3 = peg$parsearg();
            if (s3 !== peg$FAILED) {
              s0 = peg$f9(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 111) {
              s1 = peg$c8;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f10();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseoptional_embellishment() {
          var s0, s1, s3, s5;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 101) {
            s1 = peg$c9;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$parsewhitespace();
            s3 = peg$parseargs();
            if (s3 !== peg$FAILED) {
              s0 = peg$f11(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 69) {
              s1 = peg$c10;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$parsewhitespace();
              s3 = peg$parseargs();
              if (s3 !== peg$FAILED) {
                peg$parsewhitespace();
                s5 = peg$parseargs();
                if (s5 !== peg$FAILED) {
                  s0 = peg$f12(s3, s5);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseoptional_token() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 116) {
            s1 = peg$c11;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f13(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parserequired() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 82) {
            s1 = peg$c12;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsebrace_spec();
            s3 = peg$parsearg();
            if (s3 !== peg$FAILED) {
              s0 = peg$f14(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 114) {
              s1 = peg$c13;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebrace_spec();
              s0 = peg$f15(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseuntil() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 117) {
            s1 = peg$c14;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e15);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseuntil_stop_token();
            if (s2 !== peg$FAILED) {
              s0 = peg$f16(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseuntil_stop_token() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (peg$r0.test(input2.charAt(peg$currPos))) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f17(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebraced_group();
            if (s1 !== peg$FAILED) {
              s1 = peg$f18(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsemandatory() {
          var s0, s1;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 109) {
            s1 = peg$c15;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f19();
          }
          s0 = s1;
          return s0;
        }
        function peg$parsebrace_spec() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parsewhitespace_token();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsemacro();
            if (s4 === peg$FAILED) {
              if (input2.length > peg$currPos) {
                s4 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s1 = input2.substring(s1, peg$currPos);
          s2 = peg$currPos;
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsewhitespace_token();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemacro();
            if (s5 === peg$FAILED) {
              if (input2.length > peg$currPos) {
                s5 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s2 = input2.substring(s2, peg$currPos);
          s0 = peg$f20(s1, s2);
          return s0;
        }
        function peg$parsearg() {
          var s0, s1;
          s0 = peg$parsetoken();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebraced_group();
            if (s1 !== peg$FAILED) {
              s1 = peg$f21(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseargs() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsetoken();
          if (s1 !== peg$FAILED) {
            s1 = peg$f22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c16;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearg();
              if (s3 === peg$FAILED) {
                s3 = peg$parsewhitespace_token();
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsearg();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsewhitespace_token();
                }
              }
              if (input2.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c17;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s3 !== peg$FAILED) {
                s0 = peg$f23(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parsebraced_group() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e18);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input2.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 === peg$FAILED) {
                  s7 = peg$parsewhitespace_token();
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s3 = input2.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parsebraced_group();
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              if (input2.charCodeAt(peg$currPos) === 125) {
                s6 = peg$c17;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsebraced_group();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsetoken();
                  if (s7 === peg$FAILED) {
                    s7 = peg$parsewhitespace_token();
                  }
                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s3 = input2.substring(s3, peg$currPos);
              } else {
                s3 = s4;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parsebraced_group();
              }
            }
            if (input2.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c17;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            if (s3 !== peg$FAILED) {
              s0 = peg$f24(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsewhitespace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace_token();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace_token();
          }
          s1 = peg$f25();
          s0 = s1;
          return s0;
        }
        function peg$parsewhitespace_token() {
          var s0;
          if (input2.charCodeAt(peg$currPos) === 32) {
            s0 = peg$c18;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c19;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e21);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 13) {
                s0 = peg$c20;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
            }
          }
          return s0;
        }
        function peg$parsemacro() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 92) {
            s2 = peg$c21;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r1.test(input2.charAt(peg$currPos))) {
              s4 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e24);
              }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$r1.test(input2.charAt(peg$currPos))) {
                  s4 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e24);
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c21;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s4 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e24);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s4 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input2.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
          }
          return s0;
        }
        function peg$parsetoken() {
          var s0, s1, s2, s3;
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$r2.test(input2.charAt(peg$currPos))) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e25);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parsewhitespace_token();
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s3 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s0 = s3;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        const DEFAULT_OPTIONS2 = {
          optional: { openBrace: "[", closeBrace: "]" },
          mandatory: { openBrace: "{", closeBrace: "}" }
        };
        function createNode(type, options22) {
          const computedOptions = DEFAULT_OPTIONS2[type] || {};
          return { type, ...computedOptions, ...options22 };
        }
        function groupToStr(node2) {
          if (typeof node2 !== "object" || !node2) {
            return node2;
          }
          if (node2.type === "group") {
            return `{${node2.content.map(groupToStr).join("")}}`;
          }
          return node2;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _PgfkeysPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e0 = peg$anyExpectation();
        var peg$f0 = function() {
          return [];
        };
        var peg$f1 = function(rowItems, trailingComment) {
          return {
            itemParts: [],
            ...rowItems,
            trailingComment,
            trailingComma: true
          };
        };
        var peg$f2 = function(rowItems, trailingComment) {
          return { ...rowItems, trailingComment };
        };
        var peg$f3 = function(a2, b) {
          return processItem(a2, b);
        };
        var peg$f4 = function(b) {
          return processItem(null, b);
        };
        var peg$f5 = function(cell2) {
          return { cell: cell2 };
        };
        var peg$f6 = function() {
          return {};
        };
        var peg$f7 = function(part) {
          return part;
        };
        var peg$f8 = function(x2) {
          return x2;
        };
        var peg$f9 = function(space, x2) {
          return {
            trailingComment: x2,
            leadingParbreak: space.parbreak > 0
          };
        };
        var peg$f10 = function(list2) {
          return {
            whitespace: list2.filter((x2) => options2.isWhitespace(x2)).length,
            parbreak: list2.filter((x2) => options2.isParbreak(x2)).length
          };
        };
        var peg$f11 = function() {
          return !options2.allowParenGroups;
        };
        var peg$f12 = function(tok) {
          return options2.isSameLineComment(tok);
        };
        var peg$f13 = function(tok) {
          return tok;
        };
        var peg$f14 = function(tok) {
          return options2.isOwnLineComment(tok);
        };
        var peg$f15 = function(tok) {
          return tok;
        };
        var peg$f16 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$f17 = function(tok) {
          return tok;
        };
        var peg$f18 = function(tok) {
          return options2.isParbreak(tok);
        };
        var peg$f19 = function(tok) {
          return tok;
        };
        var peg$f20 = function(tok) {
          return options2.isComma(tok);
        };
        var peg$f21 = function(tok) {
          return tok;
        };
        var peg$f22 = function(tok) {
          return options2.isEquals(tok);
        };
        var peg$f23 = function(tok) {
          return tok;
        };
        var peg$f24 = function(tok) {
          return options2.isChar(tok, "(");
        };
        var peg$f25 = function(tok) {
          return tok;
        };
        var peg$f26 = function(tok) {
          return options2.isChar(tok, ")");
        };
        var peg$f27 = function(tok) {
          return tok;
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1, s2;
          s0 = [];
          s1 = peg$parsecomment_only_line();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_with_end();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_without_end();
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$parsecomment_only_line();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_with_end();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseitem_without_end();
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$parseEOL();
            if (s2 !== peg$FAILED) {
              s0 = peg$f0();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseitem_with_end() {
          var s0, s2, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          peg$parsewhitespace_or_parbreaks();
          s2 = peg$parserow_items();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$parsewhitespace_or_parbreaks();
          s4 = peg$parseitem_sep();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsewhitespace();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsewhitespace();
            }
            s6 = peg$parsetrailing_comment();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s7 = [];
            s8 = peg$parsewhitespace();
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              s8 = peg$parsewhitespace();
            }
            s0 = peg$f1(s2, s6);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseitem_without_end() {
          var s0, s2, s3;
          s0 = peg$currPos;
          peg$parsewhitespace_or_parbreaks();
          s2 = peg$parserow_items();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetrailing_comment();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s0 = peg$f2(s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parserow_items() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseitem_part();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseseparated_part();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseseparated_part();
            }
            s0 = peg$f3(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseseparated_part();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseseparated_part();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f4(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseseparated_part() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseparbreak();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseparbreak();
          }
          s2 = peg$parseequals();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseparbreak();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseparbreak();
            }
            s4 = peg$parseitem_part();
            if (s4 !== peg$FAILED) {
              s0 = peg$f5(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseparbreak();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseparbreak();
            }
            s2 = peg$parseequals();
            if (s2 !== peg$FAILED) {
              s0 = peg$f6();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseitem_part() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace();
          }
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parsenon_whitespace_non_parbreak_token();
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parsewhitespace();
            if (s5 === peg$FAILED) {
              s5 = peg$parseparbreak();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = [];
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
              }
              s9 = peg$parsenon_whitespace_non_parbreak_token();
              if (s9 !== peg$FAILED) {
                s8 = [s8, s9];
                s7 = s8;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 !== peg$FAILED) {
                peg$currPos = s6;
                s6 = void 0;
              } else {
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsenon_whitespace_non_parbreak_token();
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parsewhitespace();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseparbreak();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  s8 = [];
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parsewhitespace();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parseparbreak();
                    }
                  }
                  s9 = peg$parsenon_whitespace_non_parbreak_token();
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 !== peg$FAILED) {
                    peg$currPos = s6;
                    s6 = void 0;
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s2 = input2.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewhitespace();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewhitespace();
            }
            s0 = peg$f7(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetrailing_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace();
          }
          s2 = peg$parsesame_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f8(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecomment_only_line() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsewhitespace_or_parbreaks();
          s2 = peg$parseown_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f9(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetoken() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parsenon_token();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s3 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parsenon_whitespace_non_parbreak_token() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parsewhitespace();
          if (s3 === peg$FAILED) {
            s3 = peg$parseparbreak();
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseparen_block();
            if (s3 === peg$FAILED) {
              s3 = peg$parsetoken();
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parsenon_token() {
          var s0;
          s0 = peg$parseitem_sep();
          if (s0 === peg$FAILED) {
            s0 = peg$parseequals();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetrailing_comment();
              if (s0 === peg$FAILED) {
                s0 = peg$parseown_line_comment();
              }
            }
          }
          return s0;
        }
        function peg$parsewhitespace_or_parbreaks() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseparbreak();
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewhitespace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseparbreak();
            }
          }
          s1 = peg$f10(s1);
          s0 = s1;
          return s0;
        }
        function peg$parseparen_block() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$f11();
          if (s1) {
            s1 = peg$FAILED;
          } else {
            s1 = void 0;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parseopen_paren();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s8 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$parseclose_paren();
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input2.length > peg$currPos) {
                    s8 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    s7 = [s7, s8];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              s6 = peg$parseclose_paren();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = input2.substring(s2, peg$currPos);
            } else {
              s2 = s3;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesame_line_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f12(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f13(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseown_line_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f14(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f15(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsewhitespace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f16(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f17(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseparbreak() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f18(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f19(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseitem_sep() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f20(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f21(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseequals() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f22(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f23(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseopen_paren() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f24(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f25(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseclose_paren() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f26(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f27(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function processItem(leadCell, otherCells) {
          const cells2 = [leadCell || []];
          for (const x2 of otherCells) {
            cells2.push(x2.cell || []);
          }
          return { itemParts: cells2 };
        }
        if (!options2.isWhitespace) {
          try {
            Object.assign(options2, {
              isChar: (node2, char) => node2.type === "string" && node2.content === char,
              isComma(node2) {
                return node2.type === "string" && node2.content === ",";
              },
              isEquals(node2) {
                return node2.type === "string" && node2.content === "=";
              },
              isParbreak(node2) {
                return node2.type === "parbreak";
              },
              isWhitespace(node2) {
                return node2.type === "whitespace";
              },
              isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
              isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline,
              isComment: (node2) => node2.type === "comment",
              allowParenGroups: true
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _MacroSubstitutionPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e0 = peg$anyExpectation();
        var peg$f0 = function(e) {
          return [].concat(...e).filter((n) => !!n);
        };
        var peg$f1 = function() {
          return [];
        };
        var peg$f2 = function(tok) {
          return options2.isHash(tok);
        };
        var peg$f3 = function(tok) {
          return tok;
        };
        var peg$f4 = function(tok) {
          return options2.isNumber(tok);
        };
        var peg$f5 = function(tok) {
          return tok;
        };
        var peg$f6 = function() {
          return { type: "string", content: "#" };
        };
        var peg$f7 = function(num) {
          const split2 = options2.splitNumber(num);
          return [{ type: "hash_number", number: split2.number }, split2.rest];
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsedouble_hash();
          if (s2 === peg$FAILED) {
            s2 = peg$parsehash_number();
            if (s2 === peg$FAILED) {
              if (input2.length > peg$currPos) {
                s2 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsedouble_hash();
              if (s2 === peg$FAILED) {
                s2 = peg$parsehash_number();
                if (s2 === peg$FAILED) {
                  if (input2.length > peg$currPos) {
                    s2 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f0(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEOL();
            if (s1 !== peg$FAILED) {
              s1 = peg$f1();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsehash() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f2(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f3(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsenumber() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f4(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f5(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedouble_hash() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsehash();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsehash();
            if (s2 !== peg$FAILED) {
              s0 = peg$f6();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsehash_number() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsehash();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              s0 = peg$f7(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        if (!options2.isHash) {
          try {
            Object.assign(options2, {
              isHash: (node2) => node2.type === "string" && node2.content === "#",
              isNumber: (node2) => node2.type === "string" && 0 < +node2.content.charAt(0),
              splitNumber: (node2) => {
                const number2 = +node2.content.charAt(0);
                if (node2.content.length > 1) {
                  return {
                    number: number2,
                    rest: {
                      type: "string",
                      content: node2.content.slice(1)
                    }
                  };
                }
                return { number: number2 };
              }
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _LigaturesPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e0 = peg$anyExpectation();
        var peg$f0 = function(e) {
          return [].concat(...e).filter((n) => !!n);
        };
        var peg$f1 = function() {
          return [];
        };
        var peg$f2 = function(toks) {
          return options2.isRecognized(toks);
        };
        var peg$f3 = function(toks) {
          return options2.isRecognized(toks);
        };
        var peg$f4 = function(tok1, tok2) {
          const split2 = options2.split(tok2);
          return options2.isRecognized([tok1, split2[0]]);
        };
        var peg$f5 = function(tok1, tok2) {
          const split2 = options2.split(tok2);
          return [options2.isRecognized([tok1, split2[0]]), split2[1]];
        };
        var peg$f6 = function(tok1, tok2) {
          return options2.isRecognized([tok1, tok2]);
        };
        var peg$f7 = function(tok1, tok2) {
          return options2.isRecognized([tok1, tok2]);
        };
        var peg$f8 = function(toks) {
          return options2.isRecognized(toks);
        };
        var peg$f9 = function(toks) {
          return options2.isRecognized(toks);
        };
        var peg$f10 = function(tok) {
          return options2.isRecognized([tok]);
        };
        var peg$f11 = function(tok) {
          return options2.isRecognized([tok]);
        };
        var peg$f12 = function(tok) {
          return options2.isMacro(tok);
        };
        var peg$f13 = function(tok) {
          return tok;
        };
        var peg$f14 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$f15 = function(tok) {
          return tok;
        };
        var peg$f16 = function(tok) {
          return options2.isSplitable(tok);
        };
        var peg$f17 = function(tok) {
          return tok;
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsetriple_ligature();
          if (s2 === peg$FAILED) {
            s2 = peg$parsedouble_ligature();
            if (s2 === peg$FAILED) {
              s2 = peg$parsemono_ligature();
              if (s2 === peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s2 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsetriple_ligature();
              if (s2 === peg$FAILED) {
                s2 = peg$parsedouble_ligature();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsemono_ligature();
                  if (s2 === peg$FAILED) {
                    if (input2.length > peg$currPos) {
                      s2 = input2.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f0(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEOL();
            if (s1 !== peg$FAILED) {
              s1 = peg$f1();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsetriple_ligature() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input2.length > peg$currPos) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s3 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s3 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s4 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f2(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f3(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedouble_ligature() {
          var s0;
          s0 = peg$parsedouble_macro_ligature();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_macro_ligature_extracted();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedouble_char_ligature();
            }
          }
          return s0;
        }
        function peg$parsedouble_macro_ligature_extracted() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parsemacro();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewhitespace();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewhitespace();
            }
            s3 = peg$parsesplitable();
            if (s3 !== peg$FAILED) {
              s4 = peg$f4(s1, s3);
              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s0 = peg$f5(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedouble_macro_ligature() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parsemacro();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewhitespace();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsewhitespace();
            }
            if (input2.length > peg$currPos) {
              s3 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$f6(s1, s3);
              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s0 = peg$f7(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedouble_char_ligature() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input2.length > peg$currPos) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s3 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f8(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f9(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemono_ligature() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f10(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f11(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemacro() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f12(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f13(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsewhitespace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f14(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f15(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesplitable() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f16(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f17(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        if (!options2.isWhitespace) {
          try {
            Object.assign(options2, {
              isMacro: (node2) => node2.type === "macro",
              isWhitespace: (node2) => node2.type === "whitespace",
              isRecognized: (nodes) => {
                if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                  return { type: "string", content: "Ã´" };
                }
                return null;
              },
              isSplitable: (node2) => node2.type === "string" && node2.content.length > 1,
              split: (node2) => [
                { type: "string", content: node2.content.charAt(0) },
                { type: "string", content: node2.content.slice(1) }
              ]
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _XColorPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { start: peg$parsestart };
        var peg$startRuleFunction = peg$parsestart;
        var peg$c0 = ";";
        var peg$c1 = ",";
        var peg$c2 = ":";
        var peg$c3 = "/";
        var peg$c4 = ">";
        var peg$c5 = "!";
        var peg$c6 = ".";
        var peg$c7 = "!![";
        var peg$c8 = "]";
        var peg$c9 = "!!";
        var peg$c10 = "+";
        var peg$c11 = "-";
        var peg$r0 = /^[a-zA-Z0-9]/;
        var peg$r1 = /^[0-9]/;
        var peg$r2 = /^[ \t\n\r]/;
        var peg$r3 = /^[0-9a-fA-F]/;
        var peg$e0 = peg$anyExpectation();
        var peg$e1 = peg$literalExpectation(";", false);
        var peg$e2 = peg$literalExpectation(",", false);
        var peg$e3 = peg$otherExpectation("model list");
        var peg$e4 = peg$literalExpectation(":", false);
        var peg$e5 = peg$literalExpectation("/", false);
        var peg$e6 = peg$otherExpectation("model");
        var peg$e7 = peg$otherExpectation("color spec list");
        var peg$e8 = peg$otherExpectation("color spec");
        var peg$e9 = peg$otherExpectation("color");
        var peg$e10 = peg$otherExpectation("function expression");
        var peg$e11 = peg$literalExpectation(">", false);
        var peg$e12 = peg$otherExpectation("function");
        var peg$e13 = peg$otherExpectation("extended expression");
        var peg$e14 = peg$otherExpectation("core model");
        var peg$e15 = peg$otherExpectation("expr");
        var peg$e16 = peg$literalExpectation("!", false);
        var peg$e17 = peg$otherExpectation("mix expr");
        var peg$e18 = peg$otherExpectation("name");
        var peg$e19 = peg$literalExpectation(".", false);
        var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
        var peg$e21 = peg$otherExpectation("postfix");
        var peg$e22 = peg$literalExpectation("!![", false);
        var peg$e23 = peg$literalExpectation("]", false);
        var peg$e24 = peg$literalExpectation("!!", false);
        var peg$e25 = peg$otherExpectation("prefix");
        var peg$e26 = peg$otherExpectation("plus");
        var peg$e27 = peg$literalExpectation("+", false);
        var peg$e28 = peg$otherExpectation("minus");
        var peg$e29 = peg$literalExpectation("-", false);
        var peg$e30 = peg$otherExpectation("num");
        var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
        var peg$e32 = peg$otherExpectation("positive float");
        var peg$e33 = peg$otherExpectation("divisor");
        var peg$e34 = peg$otherExpectation("int");
        var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
        var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
        var peg$f0 = function(m2) {
          return m2;
        };
        var peg$f1 = function(m2) {
          return m2;
        };
        var peg$f2 = function(m2) {
          return m2;
        };
        var peg$f3 = function(m2) {
          return m2;
        };
        var peg$f4 = function(m2) {
          return m2;
        };
        var peg$f5 = function(a2) {
          return { type: "invalid_spec", content: a2 };
        };
        var peg$f6 = function(f, c2) {
          return c2;
        };
        var peg$f7 = function(f, r) {
          return { type: "color_set", content: [f].concat(r) };
        };
        var peg$f8 = function(n, s2) {
          return { type: "color_set_item", name: n, spec_list: s2 };
        };
        var peg$f9 = function(c2, m2) {
          return { type: "model_list", contents: m2, core_model: c2 };
        };
        var peg$f10 = function(m2) {
          return { type: "model_list", contents: m2, core_model: null };
        };
        var peg$f11 = function(m2, a2) {
          return a2;
        };
        var peg$f12 = function(m2, r) {
          return [m2].concat(r);
        };
        var peg$f13 = function(s2, a2) {
          return a2;
        };
        var peg$f14 = function(s2, r) {
          return { type: "spec_list", content: [s2].concat(r) };
        };
        var peg$f15 = function(c2) {
          return { type: "hex_spec", content: [c2] };
        };
        var peg$f16 = function(c2, d) {
          return d;
        };
        var peg$f17 = function(c2, d) {
          return d;
        };
        var peg$f18 = function(c2, r) {
          return { type: "num_spec", content: r ? [c2].concat(r) : [c2] };
        };
        var peg$f19 = function(c2, fs) {
          return { type: "color", color: c2, functions: fs };
        };
        var peg$f20 = function(f, n) {
          return n;
        };
        var peg$f21 = function(f, args) {
          return { type: "function", name: f, args };
        };
        var peg$f22 = function(core2, d, e, es) {
          return {
            type: "extended_expr",
            core_model: core2,
            div: d,
            expressions: [e].concat(es)
          };
        };
        var peg$f23 = function(core2, e, es) {
          return {
            type: "extended_expr",
            core_model: core2,
            div: null,
            expressions: [e].concat(es)
          };
        };
        var peg$f24 = function(e, d) {
          return { type: "weighted_expr", color: e, weight: d };
        };
        var peg$f25 = function(e) {
          return e;
        };
        var peg$f26 = function(p2, n, e, po2) {
          return {
            type: "expr",
            prefix: p2,
            name: n,
            mix_expr: e,
            postfix: po2
          };
        };
        var peg$f27 = function(p2, n) {
          return { type: "complete_mix", mix_percent: p2, name: n };
        };
        var peg$f28 = function(p2) {
          return { type: "partial_mix", mix_percent: p2 };
        };
        var peg$f29 = function(c2, p2) {
          return c2.concat(p2 || []);
        };
        var peg$f30 = function(n) {
          return { type: "postfix", num: n };
        };
        var peg$f31 = function(p2) {
          return { type: "postfix", plusses: p2 };
        };
        var peg$f32 = function(n) {
          return parseInt(n, 10);
        };
        var peg$f33 = function(n) {
          return parseFloat(n);
        };
        var peg$f34 = function(n) {
          return n;
        };
        var peg$f35 = function(n) {
          return -n;
        };
        var peg$f36 = function(m2, n) {
          return m2 ? -n : n;
        };
        var peg$f37 = function(h2) {
          return h2.toUpperCase();
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$literalExpectation(text2, ignoreCase) {
          return { type: "literal", text: text2, ignoreCase };
        }
        function peg$classExpectation(parts2, inverted, ignoreCase) {
          return { type: "class", parts: parts2, inverted, ignoreCase };
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsestart() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsespec();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseEOL();
            if (s2 !== peg$FAILED) {
              s0 = peg$f0(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsespec_list();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseEOL();
              if (s2 !== peg$FAILED) {
                s0 = peg$f1(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecolor();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseEOL();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f2(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemodel_list();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseEOL();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f3(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsecolor_set_spec();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseEOL();
                    if (s2 !== peg$FAILED) {
                      s0 = peg$f4(s1);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    s2 = [];
                    if (input2.length > peg$currPos) {
                      s3 = input2.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      if (input2.length > peg$currPos) {
                        s3 = input2.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e0);
                        }
                      }
                    }
                    s1 = input2.substring(s1, peg$currPos);
                    s1 = peg$f5(s1);
                    s0 = s1;
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parsecolor_set_spec() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parsecolor_set_item();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 59) {
              s4 = peg$c0;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                s3 = peg$f6(s1, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 59) {
                s4 = peg$c0;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecolor_set_item();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f6(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s0 = peg$f7(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecolor_set_item() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsename();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 44) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsespec_list();
              if (s3 !== peg$FAILED) {
                s0 = peg$f8(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemodel_list() {
          var s0, s1, s2, s3;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c2;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsemodel_list_tail();
              if (s3 !== peg$FAILED) {
                s0 = peg$f9(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsemodel_list_tail();
            if (s1 !== peg$FAILED) {
              s1 = peg$f10(s1);
            }
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          return s0;
        }
        function peg$parsemodel_list_tail() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parsemodel();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                s3 = peg$f11(s1, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 47) {
                s4 = peg$c3;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsemodel();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f11(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s0 = peg$f12(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemodel() {
          var s0;
          peg$silentFails++;
          s0 = peg$parsecore_model();
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          return s0;
        }
        function peg$parsespec_list() {
          var s0, s1, s2, s3, s4, s5;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsespec();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                s3 = peg$f13(s1, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 47) {
                s4 = peg$c3;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsespec();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f13(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            s0 = peg$f14(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          return s0;
        }
        function peg$parsespec() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parsehex();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsehex();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsehex();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsehex();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsehex();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsehex();
                    if (s8 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6, s7, s8];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input2.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f15(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedec();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c1;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f16(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  if (input2.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c1;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f16(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$parsesp();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f17(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$parsesp();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsedec();
                      if (s5 !== peg$FAILED) {
                        s3 = peg$f17(s1, s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  }
                } else {
                  s2 = peg$FAILED;
                }
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s0 = peg$f18(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          return s0;
        }
        function peg$parsecolor() {
          var s0, s1, s2, s3;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsecolor_expr();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsefunc_expr();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsefunc_expr();
            }
            s0 = peg$f19(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          return s0;
        }
        function peg$parsecolor_expr() {
          var s0;
          s0 = peg$parseext_expr();
          if (s0 === peg$FAILED) {
            s0 = peg$parseexpr();
            if (s0 === peg$FAILED) {
              s0 = peg$parsename();
            }
          }
          return s0;
        }
        function peg$parsefunc_expr() {
          var s0, s1, s2, s3, s4, s5, s6;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c4;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsefunction();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  s4 = peg$f20(s2, s6);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input2.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c1;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseint();
                  if (s6 !== peg$FAILED) {
                    s4 = peg$f20(s2, s6);
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              s0 = peg$f21(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          return s0;
        }
        function peg$parsefunction() {
          var s0;
          peg$silentFails++;
          s0 = peg$parsename();
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          return s0;
        }
        function peg$parseext_expr() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 44) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsediv();
              if (s3 !== peg$FAILED) {
                if (input2.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c2;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseweighted_expr();
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseadditional_weighted_expr();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parseadditional_weighted_expr();
                    }
                    s0 = peg$f22(s1, s3, s5, s6);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecore_model();
            if (s1 !== peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c2;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseweighted_expr();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseadditional_weighted_expr();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseadditional_weighted_expr();
                  }
                  s0 = peg$f23(s1, s3, s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
          return s0;
        }
        function peg$parseweighted_expr() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseexpr();
          if (s1 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 44) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsedec();
              if (s3 !== peg$FAILED) {
                s0 = peg$f24(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseadditional_weighted_expr() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 59) {
            s1 = peg$c0;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseweighted_expr();
            if (s2 !== peg$FAILED) {
              s0 = peg$f25(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecore_model() {
          var s0;
          peg$silentFails++;
          s0 = peg$parsename();
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          return s0;
        }
        function peg$parseexpr() {
          var s0, s1, s2, s3, s4;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseprefix();
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsemix_expr();
            s4 = peg$parsepostfix();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            s0 = peg$f26(s1, s2, s3, s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e15);
            }
          }
          return s0;
        }
        function peg$parsecomplete_mix() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsepct();
            if (s2 !== peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 33) {
                s3 = peg$c5;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsename();
                if (s4 !== peg$FAILED) {
                  s0 = peg$f27(s2, s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsepartial_mix() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsepct();
            if (s2 !== peg$FAILED) {
              s0 = peg$f28(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemix_expr() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsecomplete_mix();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsecomplete_mix();
          }
          s2 = peg$parsepartial_mix();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s0 = peg$f29(s1, s2);
          peg$silentFails--;
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
          return s0;
        }
        function peg$parsename() {
          var s0, s1, s2;
          peg$silentFails++;
          if (input2.charCodeAt(peg$currPos) === 46) {
            s0 = peg$c6;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$r0.test(input2.charAt(peg$currPos))) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$r0.test(input2.charAt(peg$currPos))) {
                  s2 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input2.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e18);
            }
          }
          return s0;
        }
        function peg$parsepostfix() {
          var s0, s1, s2, s3, s4;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.substr(peg$currPos, 3) === peg$c7) {
            s1 = peg$c7;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenum();
            if (s2 !== peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c8;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s3 !== peg$FAILED) {
                s0 = peg$f30(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.substr(peg$currPos, 2) === peg$c9) {
              s1 = peg$c9;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e24);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = [];
              s4 = peg$parseplus();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseplus();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s2 = input2.substring(s2, peg$currPos);
              } else {
                s2 = s3;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f31(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          return s0;
        }
        function peg$parseprefix() {
          var s0;
          peg$silentFails++;
          s0 = peg$parseminus();
          if (s0 === peg$FAILED) {
            s0 = null;
          }
          peg$silentFails--;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
          return s0;
        }
        function peg$parseplus() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          if (input2.charCodeAt(peg$currPos) === 43) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (input2.charCodeAt(peg$currPos) === 43) {
                s2 = peg$c10;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e27);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          return s0;
        }
        function peg$parseminus() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          if (input2.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c11;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (input2.charCodeAt(peg$currPos) === 45) {
                s2 = peg$c11;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e29);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input2.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          return s0;
        }
        function peg$parsenum() {
          var s0, s1, s2, s3;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          if (peg$r1.test(input2.charAt(peg$currPos))) {
            s3 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s3 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input2.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f32(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          return s0;
        }
        function peg$parsepct() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$currPos;
          s4 = [];
          if (peg$r1.test(input2.charAt(peg$currPos))) {
            s5 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s5 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = input2.substring(s3, peg$currPos);
          } else {
            s3 = s4;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 46) {
              s6 = peg$c6;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$currPos;
              s8 = [];
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s9 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                if (peg$r1.test(input2.charAt(peg$currPos))) {
                  s9 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
              s7 = input2.substring(s7, peg$currPos);
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s4 = input2.substring(s4, peg$currPos);
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input2.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c6;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = [];
              if (peg$r1.test(input2.charAt(peg$currPos))) {
                s6 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (peg$r1.test(input2.charAt(peg$currPos))) {
                    s6 = input2.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                }
              } else {
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s4 = input2.substring(s4, peg$currPos);
              } else {
                s4 = s5;
              }
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = input2.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f33(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e32);
            }
          }
          return s0;
        }
        function peg$parsediv() {
          var s0;
          peg$silentFails++;
          s0 = peg$parsepct();
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          return s0;
        }
        function peg$parsedec() {
          var s0, s1, s2;
          s0 = peg$parsepct();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c10;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsepct();
              if (s2 !== peg$FAILED) {
                s0 = peg$f34(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c11;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e29);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepct();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f35(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parseint() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s2 = peg$parsenum();
          if (s2 !== peg$FAILED) {
            s0 = peg$f36(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          return s0;
        }
        function peg$parsesp() {
          var s0, s1;
          s0 = [];
          if (peg$r2.test(input2.charAt(peg$currPos))) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              if (peg$r2.test(input2.charAt(peg$currPos))) {
                s1 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e36);
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsehex() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$r3.test(input2.charAt(peg$currPos))) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e37);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f37(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _TabularPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e0 = peg$otherExpectation("decl_start");
        var peg$e1 = peg$otherExpectation("decl_end");
        var peg$e2 = peg$otherExpectation("vert");
        var peg$e3 = peg$anyExpectation();
        var peg$e4 = peg$otherExpectation("l");
        var peg$e5 = peg$otherExpectation("r");
        var peg$e6 = peg$otherExpectation("c");
        var peg$e7 = peg$otherExpectation("p");
        var peg$e8 = peg$otherExpectation("m");
        var peg$e9 = peg$otherExpectation("b");
        var peg$e10 = peg$otherExpectation("w");
        var peg$e11 = peg$otherExpectation("W");
        var peg$e12 = peg$otherExpectation("X");
        var peg$e13 = peg$otherExpectation("!");
        var peg$e14 = peg$otherExpectation("@");
        var peg$e15 = peg$otherExpectation("<");
        var peg$e16 = peg$otherExpectation(">");
        var peg$e17 = peg$otherExpectation("group");
        var peg$e18 = peg$otherExpectation("whitespace");
        var peg$f0 = function(c2) {
          return c2;
        };
        var peg$f1 = function(cols) {
          return cols;
        };
        var peg$f2 = function() {
          return [];
        };
        var peg$f3 = function(divs1, start, a2, end2, divs2) {
          return {
            type: "column",
            pre_dividers: divs1,
            post_dividers: divs2,
            before_start_code: start,
            before_end_code: end2,
            alignment: a2
          };
        };
        var peg$f4 = function() {
          return {
            type: "vert_divider"
          };
        };
        var peg$f5 = function(b, g) {
          return {
            type: "bang_divider",
            content: g[0].content
          };
        };
        var peg$f6 = function(g) {
          return {
            type: "at_divider",
            content: g[0].content
          };
        };
        var peg$f7 = function(div) {
          return div;
        };
        var peg$f8 = function(g) {
          return { type: "decl_code", code: g[0].content };
        };
        var peg$f9 = function(g) {
          return { type: "decl_code", code: g[0].content };
        };
        var peg$f10 = function() {
          return { type: "alignment", alignment: "left" };
        };
        var peg$f11 = function() {
          return { type: "alignment", alignment: "center" };
        };
        var peg$f12 = function() {
          return { type: "alignment", alignment: "right" };
        };
        var peg$f13 = function() {
          return { type: "alignment", alignment: "X" };
        };
        var peg$f14 = function() {
          return "top";
        };
        var peg$f15 = function() {
          return "default";
        };
        var peg$f16 = function() {
          return "bottom";
        };
        var peg$f17 = function(a2, g) {
          return {
            type: "alignment",
            alignment: "parbox",
            baseline: a2,
            size: g[0].content
          };
        };
        var peg$f18 = function(g1, g2) {
          return {
            type: "alignment",
            alignment: "parbox",
            baseline: g1[0].content,
            size: g2[0].content
          };
        };
        var peg$f19 = function(tok) {
          return options2.matchChar(tok, "|");
        };
        var peg$f20 = function(tok) {
          return options2.matchChar(tok, "l");
        };
        var peg$f21 = function(tok) {
          return options2.matchChar(tok, "r");
        };
        var peg$f22 = function(tok) {
          return options2.matchChar(tok, "c");
        };
        var peg$f23 = function(tok) {
          return options2.matchChar(tok, "p");
        };
        var peg$f24 = function(tok) {
          return options2.matchChar(tok, "m");
        };
        var peg$f25 = function(tok) {
          return options2.matchChar(tok, "b");
        };
        var peg$f26 = function(tok) {
          return options2.matchChar(tok, "w");
        };
        var peg$f27 = function(tok) {
          return options2.matchChar(tok, "W");
        };
        var peg$f28 = function(tok) {
          return options2.matchChar(tok, "X");
        };
        var peg$f29 = function(tok) {
          return options2.matchChar(tok, "!");
        };
        var peg$f30 = function(tok) {
          return options2.matchChar(tok, "@");
        };
        var peg$f31 = function(tok) {
          return options2.matchChar(tok, "<");
        };
        var peg$f32 = function(tok) {
          return options2.matchChar(tok, ">");
        };
        var peg$f33 = function(tok) {
          return options2.isGroup(tok);
        };
        var peg$f34 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parsecolumn();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            s2 = peg$f0(s3);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parsecolumn();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                s2 = peg$f0(s3);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f1(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEOL();
            if (s1 !== peg$FAILED) {
              s1 = peg$f2();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsecolumn() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsecolumn_divider();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsecolumn_divider();
          }
          s2 = peg$parsedecl_start();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s3 = peg$parsealignment();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedecl_end();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            s5 = [];
            s6 = peg$parsecolumn_divider();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsecolumn_divider();
            }
            s0 = peg$f3(s1, s2, s3, s4, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecolumn_divider() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          s2 = peg$currPos;
          s3 = peg$parsevert();
          if (s3 !== peg$FAILED) {
            s3 = peg$f4();
          }
          s2 = s3;
          if (s2 === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsebang();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsegroup();
              if (s4 !== peg$FAILED) {
                s2 = peg$f5(s3, s4);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseat();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsegroup();
                if (s4 !== peg$FAILED) {
                  s2 = peg$f6(s4);
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s0 = peg$f7(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedecl_start() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parsegreater();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsegroup();
            if (s2 !== peg$FAILED) {
              s0 = peg$f8(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          return s0;
        }
        function peg$parsedecl_end() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseless();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsegroup();
            if (s2 !== peg$FAILED) {
              s0 = peg$f9(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          return s0;
        }
        function peg$parsealignment() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parsel();
          if (s1 !== peg$FAILED) {
            s1 = peg$f10();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsec();
            if (s1 !== peg$FAILED) {
              s1 = peg$f11();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parser();
              if (s1 !== peg$FAILED) {
                s1 = peg$f12();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseX();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f13();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s2 = peg$parsep();
                  if (s2 !== peg$FAILED) {
                    s2 = peg$f14();
                  }
                  s1 = s2;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s2 = peg$parsem();
                    if (s2 !== peg$FAILED) {
                      s2 = peg$f15();
                    }
                    s1 = s2;
                    if (s1 === peg$FAILED) {
                      s1 = peg$currPos;
                      s2 = peg$parseb();
                      if (s2 !== peg$FAILED) {
                        s2 = peg$f16();
                      }
                      s1 = s2;
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parse_();
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parse_();
                    }
                    s3 = peg$parsegroup();
                    if (s3 !== peg$FAILED) {
                      s0 = peg$f17(s1, s3);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsew();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseW();
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = [];
                      s3 = peg$parse_();
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$parse_();
                      }
                      s3 = peg$parsegroup();
                      if (s3 !== peg$FAILED) {
                        s4 = [];
                        s5 = peg$parse_();
                        while (s5 !== peg$FAILED) {
                          s4.push(s5);
                          s5 = peg$parse_();
                        }
                        s5 = peg$parsegroup();
                        if (s5 !== peg$FAILED) {
                          s0 = peg$f18(s3, s5);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parsevert() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f19(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          return s0;
        }
        function peg$parsel() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f20(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          return s0;
        }
        function peg$parser() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f21(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          return s0;
        }
        function peg$parsec() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f22(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          return s0;
        }
        function peg$parsep() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f23(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          return s0;
        }
        function peg$parsem() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f24(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          return s0;
        }
        function peg$parseb() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f25(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          return s0;
        }
        function peg$parsew() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f26(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          return s0;
        }
        function peg$parseW() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f27(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          return s0;
        }
        function peg$parseX() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f28(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          return s0;
        }
        function peg$parsebang() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f29(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
          return s0;
        }
        function peg$parseat() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f30(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          return s0;
        }
        function peg$parseless() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f31(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e15);
            }
          }
          return s0;
        }
        function peg$parsegreater() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f32(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          return s0;
        }
        function peg$parsegroup() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f33(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          return s0;
        }
        function peg$parse_() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f34(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e18);
            }
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        if (!options2.isHash) {
          try {
            Object.assign(options2, {
              matchChar: (node2, char) => node2.type === "string" && node2.content === char,
              isGroup: (node2) => node2.type === "group",
              isWhitespace: (node2) => node2.type === "whitespace"
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _SystemePegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { body: peg$parsebody };
        var peg$startRuleFunction = peg$parsebody;
        var peg$e1 = peg$otherExpectation("item");
        var peg$e2 = peg$anyExpectation();
        var peg$e3 = peg$otherExpectation("equation");
        var peg$e4 = peg$otherExpectation("trailing comment");
        var peg$e5 = peg$otherExpectation("comment only line");
        var peg$e6 = peg$otherExpectation("non-var token");
        var peg$e7 = peg$otherExpectation("token");
        var peg$e8 = peg$otherExpectation("same line comment");
        var peg$e9 = peg$otherExpectation("own line comment");
        var peg$e10 = peg$otherExpectation(",");
        var peg$e11 = peg$otherExpectation("@");
        var peg$e12 = peg$otherExpectation("variable token");
        var peg$e13 = peg$otherExpectation("+/-");
        var peg$e14 = peg$otherExpectation("=");
        var peg$f0 = function(a2, b) {
          return a2.concat(b ? b : []);
        };
        var peg$f1 = function() {
          return [];
        };
        var peg$f3 = function(op2, a2, b, c2) {
          return { type: "item", op: op2, variable: b, content: a2.concat(b, c2) };
        };
        var peg$f4 = function(op2, a2) {
          return { type: "item", op: op2, variable: null, content: a2 };
        };
        var peg$f5 = function(line2, sep, comment2) {
          return { ...line2, sep: [].concat(sep), trailingComment: comment2 };
        };
        var peg$f6 = function(line2, comment2) {
          return { ...line2, trailingComment: comment2 };
        };
        var peg$f7 = function(eq, ann) {
          return {
            type: "line",
            equation: eq,
            annotation: ann,
            sep: null
          };
        };
        var peg$f8 = function(at2, ann) {
          return at2 ? { type: "annotation", marker: at2, content: ann } : null;
        };
        var peg$f9 = function(left, eq, right) {
          return { type: "equation", left, right, equals: eq };
        };
        var peg$f10 = function(x2) {
          return x2;
        };
        var peg$f11 = function(x2) {
          return {
            type: "line",
            trailingComment: x2
          };
        };
        var peg$f12 = function(v, s2) {
          return [v].concat(s2 ? s2 : []);
        };
        var peg$f13 = function(t) {
          return t;
        };
        var peg$f14 = function(x2) {
          return x2;
        };
        var peg$f15 = function(x2) {
          return x2;
        };
        var peg$f16 = function(tok) {
          return options2.isSameLineComment(tok);
        };
        var peg$f17 = function(tok) {
          return tok;
        };
        var peg$f18 = function(tok) {
          return options2.isOwnLineComment(tok);
        };
        var peg$f19 = function(tok) {
          return tok;
        };
        var peg$f20 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$f21 = function(tok) {
          return tok;
        };
        var peg$f22 = function(tok) {
          return options2.isSep(tok);
        };
        var peg$f23 = function(tok) {
          return tok;
        };
        var peg$f24 = function(tok) {
          return options2.isAt(tok);
        };
        var peg$f25 = function(tok) {
          return tok;
        };
        var peg$f26 = function(tok) {
          return options2.isVar(tok);
        };
        var peg$f27 = function(tok) {
          return tok;
        };
        var peg$f28 = function(tok) {
          return options2.isOperation(tok);
        };
        var peg$f29 = function(tok) {
          return tok;
        };
        var peg$f30 = function(tok) {
          return options2.isEquals(tok);
        };
        var peg$f31 = function(tok) {
          return tok;
        };
        var peg$f32 = function(tok) {
          return options2.isSubscript(tok);
        };
        var peg$f33 = function(tok) {
          return tok;
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsebody() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsecomment_only_line();
          if (s2 === peg$FAILED) {
            s2 = peg$parseline_with_sep();
            if (s2 === peg$FAILED) {
              s2 = peg$parsepartial_line_with_comment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsecomment_only_line();
            if (s2 === peg$FAILED) {
              s2 = peg$parseline_with_sep();
              if (s2 === peg$FAILED) {
                s2 = peg$parsepartial_line_with_comment();
              }
            }
          }
          s2 = peg$parseline_without_sep();
          if (s2 === peg$FAILED) {
            s2 = peg$parseEOL();
          }
          if (s2 !== peg$FAILED) {
            s0 = peg$f0(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEOL();
            if (s1 !== peg$FAILED) {
              s1 = peg$f1();
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseitem() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = [];
          s4 = peg$parsenon_var_token();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsenon_var_token();
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          s5 = peg$parsevar();
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parse_();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parse_();
            }
            s7 = [];
            s8 = peg$parsetoken();
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              s8 = peg$parsetoken();
            }
            s8 = [];
            s9 = peg$parse_();
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parse_();
            }
            s0 = peg$f3(s1, s3, s5, s7);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseoperation();
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            s2 = [];
            s3 = peg$parse_();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_();
            }
            s3 = [];
            s4 = peg$parsenon_var_token();
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsenon_var_token();
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              s0 = peg$f4(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          return s0;
        }
        function peg$parseline_with_sep() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseline_without_sep();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsesep();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetrailing_comment();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = peg$f5(s1, s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsepartial_line_with_comment() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseline_without_sep();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetrailing_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f6(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseline_without_sep() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          peg$silentFails--;
          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseequation();
            s3 = peg$parseannotation();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s0 = peg$f7(s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseannotation() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseat();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsenon_sep_token();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsenon_sep_token();
            }
            s0 = peg$f8(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseequation() {
          var s0, s1, s2, s3, s4;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseitem();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseitem();
          }
          s2 = peg$parseequals();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s3 = [];
          s4 = peg$parsetoken();
          if (s4 === peg$FAILED) {
            s4 = peg$parseoperation();
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsetoken();
            if (s4 === peg$FAILED) {
              s4 = peg$parseoperation();
            }
          }
          s0 = peg$f9(s1, s2, s3);
          peg$silentFails--;
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
          return s0;
        }
        function peg$parsetrailing_comment() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          s2 = peg$parsesame_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f10(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          return s0;
        }
        function peg$parsecomment_only_line() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          s2 = peg$parseown_line_comment();
          if (s2 !== peg$FAILED) {
            s0 = peg$f11(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          return s0;
        }
        function peg$parsevar() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsevar_token();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parse_();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_();
            }
            s3 = peg$parsesubscript();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s0 = peg$f12(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsenon_var_token() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parsevar();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetoken();
            if (s2 !== peg$FAILED) {
              s0 = peg$f13(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          return s0;
        }
        function peg$parsenon_sep_token() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parsesep();
          if (s2 === peg$FAILED) {
            s2 = peg$parsetrailing_comment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseown_line_comment();
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f14(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetoken() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parsesep();
          if (s2 === peg$FAILED) {
            s2 = peg$parseat();
            if (s2 === peg$FAILED) {
              s2 = peg$parseoperation();
              if (s2 === peg$FAILED) {
                s2 = peg$parseequals();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsetrailing_comment();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseown_line_comment();
                  }
                }
              }
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s2 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f15(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          return s0;
        }
        function peg$parsesame_line_comment() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f16(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f17(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          return s0;
        }
        function peg$parseown_line_comment() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f18(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f19(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          return s0;
        }
        function peg$parse_() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f20(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f21(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesep() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f22(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f23(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          return s0;
        }
        function peg$parseat() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f24(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f25(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          return s0;
        }
        function peg$parsevar_token() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f26(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f27(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          return s0;
        }
        function peg$parseoperation() {
          var s0, s1, s2, s3, s4;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          if (input2.length > peg$currPos) {
            s2 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$f28(s2);
            if (s4) {
              s4 = void 0;
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s0 = peg$f29(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
          return s0;
        }
        function peg$parseequals() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f30(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f31(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          return s0;
        }
        function peg$parsesubscript() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f32(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f33(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOL() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        if (!options2.isWhitespace) {
          try {
            Object.assign(options2, {
              isSep: (node2) => node2.type === "string" && node2.content === ",",
              isVar: (node2) => node2.type === "string" && node2.content.match(/[a-zA-Z]/),
              isOperation: (node2) => node2.type === "string" && node2.content.match(/[+-]/),
              isEquals: (node2) => node2.type === "string" && node2.content === "=",
              isAt: (node2) => node2.type === "string" && node2.content === "@",
              isSubscript: (node2) => node2.content === "_",
              isWhitespace: (node2) => node2.type === "whitespace",
              isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
              isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _GluePegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { root: peg$parseroot };
        var peg$startRuleFunction = peg$parseroot;
        var peg$c0 = "plus";
        var peg$c1 = "minus";
        var peg$c2 = "pt";
        var peg$c3 = "mm";
        var peg$c4 = "cm";
        var peg$c5 = "in";
        var peg$c6 = "ex";
        var peg$c7 = "em";
        var peg$c8 = "bp";
        var peg$c9 = "pc";
        var peg$c10 = "dd";
        var peg$c11 = "cc";
        var peg$c12 = "nd";
        var peg$c13 = "nc";
        var peg$c14 = "sp";
        var peg$c15 = "filll";
        var peg$c16 = "fill";
        var peg$c17 = "fil";
        var peg$c18 = ".";
        var peg$c19 = "+";
        var peg$c20 = "-";
        var peg$r0 = /^[0-9]/;
        var peg$e0 = peg$anyExpectation();
        var peg$e1 = peg$literalExpectation("plus", false);
        var peg$e2 = peg$literalExpectation("minus", false);
        var peg$e3 = peg$literalExpectation("pt", false);
        var peg$e4 = peg$literalExpectation("mm", false);
        var peg$e5 = peg$literalExpectation("cm", false);
        var peg$e6 = peg$literalExpectation("in", false);
        var peg$e7 = peg$literalExpectation("ex", false);
        var peg$e8 = peg$literalExpectation("em", false);
        var peg$e9 = peg$literalExpectation("bp", false);
        var peg$e10 = peg$literalExpectation("pc", false);
        var peg$e11 = peg$literalExpectation("dd", false);
        var peg$e12 = peg$literalExpectation("cc", false);
        var peg$e13 = peg$literalExpectation("nd", false);
        var peg$e14 = peg$literalExpectation("nc", false);
        var peg$e15 = peg$literalExpectation("sp", false);
        var peg$e16 = peg$literalExpectation("filll", false);
        var peg$e17 = peg$literalExpectation("fill", false);
        var peg$e18 = peg$literalExpectation("fil", false);
        var peg$e19 = peg$otherExpectation("number");
        var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
        var peg$e21 = peg$literalExpectation(".", false);
        var peg$e22 = peg$literalExpectation("+", false);
        var peg$e23 = peg$literalExpectation("-", false);
        var peg$f0 = function(b, st, sh) {
          return {
            type: "glue",
            fixed: b,
            stretchable: st,
            shrinkable: sh,
            position: location2()
          };
        };
        var peg$f1 = function(glue) {
          return glue;
        };
        var peg$f2 = function(n, u) {
          return { type: "dim", value: n, unit: u };
        };
        var peg$f3 = function(n, u) {
          return { type: "dim", value: n, unit: u };
        };
        var peg$f4 = function(n, u) {
          return { type: "dim", value: n, unit: u };
        };
        var peg$f5 = function(n) {
          return parseFloat(n);
        };
        var peg$currPos = 0;
        var peg$savedPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function location2() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function peg$literalExpectation(text2, ignoreCase) {
          return { type: "literal", text: text2, ignoreCase };
        }
        function peg$classExpectation(parts2, inverted, ignoreCase) {
          return { type: "class", parts: parts2, inverted, ignoreCase };
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location22) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location22
          );
        }
        function peg$parseroot() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsebase();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsestretchable();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s4 = peg$parseshrinkable();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            peg$savedPos = s1;
            s1 = peg$f0(s2, s3, s4);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (input2.length > peg$currPos) {
              s3 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (input2.length > peg$currPos) {
                s3 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
            peg$savedPos = s0;
            s0 = peg$f1(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsebase() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsenumber();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseunit();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f2(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsestretchable() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input2.substr(peg$currPos, 4) === peg$c0) {
            s1 = peg$c0;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              s3 = peg$parserubber_unit();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseshrinkable() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input2.substr(peg$currPos, 5) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              s3 = peg$parserubber_unit();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f4(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseunit() {
          var s0;
          if (input2.substr(peg$currPos, 2) === peg$c2) {
            s0 = peg$c2;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.substr(peg$currPos, 2) === peg$c3) {
              s0 = peg$c3;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.substr(peg$currPos, 2) === peg$c4) {
                s0 = peg$c4;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s0 === peg$FAILED) {
                if (input2.substr(peg$currPos, 2) === peg$c5) {
                  s0 = peg$c5;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e6);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input2.substr(peg$currPos, 2) === peg$c6) {
                    s0 = peg$c6;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e7);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input2.substr(peg$currPos, 2) === peg$c7) {
                      s0 = peg$c7;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e8);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input2.substr(peg$currPos, 2) === peg$c8) {
                        s0 = peg$c8;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e9);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input2.substr(peg$currPos, 2) === peg$c9) {
                          s0 = peg$c9;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e10);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input2.substr(peg$currPos, 2) === peg$c10) {
                            s0 = peg$c10;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e11);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input2.substr(peg$currPos, 2) === peg$c11) {
                              s0 = peg$c11;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e12);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input2.substr(peg$currPos, 2) === peg$c12) {
                                s0 = peg$c12;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e13);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input2.substr(peg$currPos, 2) === peg$c13) {
                                  s0 = peg$c13;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e14);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input2.substr(peg$currPos, 2) === peg$c14) {
                                    s0 = peg$c14;
                                    peg$currPos += 2;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e15);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parserubber_unit() {
          var s0;
          s0 = peg$parseunit();
          if (s0 === peg$FAILED) {
            if (input2.substr(peg$currPos, 5) === peg$c15) {
              s0 = peg$c15;
              peg$currPos += 5;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.substr(peg$currPos, 4) === peg$c16) {
                s0 = peg$c16;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e17);
                }
              }
              if (s0 === peg$FAILED) {
                if (input2.substr(peg$currPos, 3) === peg$c17) {
                  s0 = peg$c17;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e18);
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parsenumber() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parsesign();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$currPos;
          s5 = [];
          if (peg$r0.test(input2.charAt(peg$currPos))) {
            s6 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$r0.test(input2.charAt(peg$currPos))) {
              s6 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
          }
          if (input2.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c18;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = [];
            if (peg$r0.test(input2.charAt(peg$currPos))) {
              s8 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            if (s8 !== peg$FAILED) {
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                if (peg$r0.test(input2.charAt(peg$currPos))) {
                  s8 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
              }
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s5 = [s5, s6, s7];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = [];
            if (peg$r0.test(input2.charAt(peg$currPos))) {
              s5 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$r0.test(input2.charAt(peg$currPos))) {
                  s5 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input2.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f5(s1);
          }
          s0 = s1;
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          return s0;
        }
        function peg$parsesign() {
          var s0;
          if (input2.charCodeAt(peg$currPos) === 43) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 45) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
          }
          return s0;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const _TikzPegParser = (
    // Generated by Peggy 3.0.2.
    //
    // https://peggyjs.org/
    function() {
      function peg$subclass2(child, parent) {
        function C() {
          this.constructor = child;
        }
        C.prototype = parent.prototype;
        child.prototype = new C();
      }
      function peg$SyntaxError2(message, expected, found, location2) {
        var self2 = Error.call(this, message);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(self2, peg$SyntaxError2.prototype);
        }
        self2.expected = expected;
        self2.found = found;
        self2.location = location2;
        self2.name = "SyntaxError";
        return self2;
      }
      peg$subclass2(peg$SyntaxError2, Error);
      function peg$padEnd(str, targetLength, padString) {
        padString = padString || " ";
        if (str.length > targetLength) {
          return str;
        }
        targetLength -= str.length;
        padString += padString.repeat(targetLength);
        return str + padString.slice(0, targetLength);
      }
      peg$SyntaxError2.prototype.format = function(sources) {
        var str = "Error: " + this.message;
        if (this.location) {
          var src = null;
          var k;
          for (k = 0; k < sources.length; k++) {
            if (sources[k].source === this.location.source) {
              src = sources[k].text.split(/\r\n|\n|\r/g);
              break;
            }
          }
          var s2 = this.location.start;
          var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
          var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
          if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line2 = src[s2.line - 1];
            var last = s2.line === e.line ? e.column : line2.length + 1;
            var hatLen = last - s2.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line2 + "\n" + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
          } else {
            str += "\n at " + loc;
          }
        }
        return str;
      };
      peg$SyntaxError2.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
          },
          any: function() {
            return "any character";
          },
          end: function() {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex2(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function classEscape(s2) {
          return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex2(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex2(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = expected2.map(describeExpectation);
          var i, j;
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse2(input2, options2) {
        options2 = options2 !== void 0 ? options2 : {};
        var peg$FAILED = {};
        var peg$source = options2.grammarSource;
        var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
        var peg$startRuleFunction = peg$parsepath_spec;
        var peg$e0 = peg$anyExpectation();
        var peg$e3 = peg$otherExpectation("comment");
        var peg$e4 = peg$otherExpectation("floating comment");
        var peg$e5 = peg$otherExpectation("operation");
        var peg$e6 = peg$otherExpectation("=");
        var peg$f0 = function(v) {
          return v;
        };
        var peg$f1 = function(ops) {
          return { type: "path_spec", content: ops };
        };
        var peg$f2 = function(c1, op2, comment2) {
          return { op: op2, comment: comment2 };
        };
        var peg$f3 = function(c1, ops, c2, body2) {
          const comments = [c1, ...ops.map((x2) => x2.comment), c2].filter(
            (x2) => x2
          );
          const attribute = ops.map((x2) => x2.op.content.content).join(" ");
          return {
            type: "animation",
            comments,
            attribute,
            content: body2.content
          };
        };
        var peg$f4 = function(start, b) {
          return { ...b, start, type: "foreach" };
        };
        var peg$f5 = function(c1, variables, options22, c2, c3, list2, c4, command) {
          const comments = [c1, c2, c3, c4].filter((x2) => x2);
          return {
            type: "foreach_body",
            variables,
            options: options22 && options22.content,
            list: list2,
            command,
            comments
          };
        };
        var peg$f6 = function(c1, options22, c2, body2) {
          const comments = [c1, c2].filter((x2) => x2);
          return {
            type: "svg_operation",
            options: options22 && options22.content,
            content: body2,
            comments
          };
        };
        var peg$f7 = function(c1, c2, coord, c3, c4, x2) {
          return { coord: x2, comment: c4 };
        };
        var peg$f8 = function(c1, c2, coord, c3, a2, c5) {
          const comments = [c1, c2, c3, a2 && a2.comment, c5].filter((x2) => x2);
          return {
            type: "curve_to",
            controls: a2 ? [coord, a2.coord] : [coord],
            comments
          };
        };
        var peg$f9 = function() {
          return { type: "line_to", command: "|-" };
        };
        var peg$f10 = function() {
          return { type: "line_to", command: "-|" };
        };
        var peg$f11 = function() {
          return { type: "line_to", command: "--" };
        };
        var peg$f12 = function(prefix2, content2) {
          return { type: "coordinate", content: content2, prefix: prefix2 };
        };
        var peg$f13 = function(content2) {
          return { type: "square_brace_group", content: content2 };
        };
        var peg$f14 = function(v) {
          return { type: "unknown", content: v };
        };
        var peg$f19 = function(tok) {
          return options2.isComment(tok);
        };
        var peg$f20 = function(tok) {
          return tok;
        };
        var peg$f21 = function(tok) {
          return options2.isWhitespace(tok);
        };
        var peg$f22 = function(tok) {
          return tok;
        };
        var peg$f23 = function(c2) {
          return c2;
        };
        var peg$f24 = function(tok) {
          return options2.isOperation(tok);
        };
        var peg$f25 = function(tok) {
          return { type: "operation", content: tok };
        };
        var peg$f26 = function(tok) {
          return options2.isChar(tok, "=");
        };
        var peg$f27 = function(tok) {
          return tok;
        };
        var peg$f28 = function(tok) {
          return options2.isChar(tok, "[");
        };
        var peg$f29 = function(tok) {
          return tok;
        };
        var peg$f30 = function(tok) {
          return options2.isChar(tok, "]");
        };
        var peg$f31 = function(tok) {
          return tok;
        };
        var peg$f32 = function(tok) {
          return options2.isChar(tok, "(");
        };
        var peg$f33 = function(tok) {
          return tok;
        };
        var peg$f34 = function(tok) {
          return options2.isChar(tok, ")");
        };
        var peg$f35 = function(tok) {
          return tok;
        };
        var peg$f36 = function(tok) {
          return options2.isChar(tok, "+");
        };
        var peg$f37 = function(tok) {
          return tok;
        };
        var peg$f38 = function(tok) {
          return options2.isChar(tok, "-");
        };
        var peg$f39 = function(tok) {
          return tok;
        };
        var peg$f40 = function(tok) {
          return options2.isChar(tok, "|");
        };
        var peg$f41 = function(tok) {
          return tok;
        };
        var peg$f42 = function(tok) {
          return options2.isChar(tok, ".");
        };
        var peg$f43 = function(tok) {
          return tok;
        };
        var peg$f44 = function(tok) {
          return options2.isChar(tok, "controls");
        };
        var peg$f45 = function(tok) {
          return tok;
        };
        var peg$f46 = function(tok) {
          return options2.isChar(tok, "and");
        };
        var peg$f47 = function(tok) {
          return tok;
        };
        var peg$f48 = function(tok) {
          return options2.isChar(tok, "svg");
        };
        var peg$f49 = function(tok) {
          return tok;
        };
        var peg$f50 = function(tok) {
          return options2.isGroup(tok);
        };
        var peg$f51 = function(tok) {
          return tok;
        };
        var peg$f52 = function(tok) {
          return options2.isAnyMacro(tok);
        };
        var peg$f53 = function(tok) {
          return tok;
        };
        var peg$f54 = function(tok) {
          return options2.isChar(tok, "foreach");
        };
        var peg$f55 = function(tok) {
          return tok;
        };
        var peg$f56 = function(tok) {
          return options2.isMacro(tok, "foreach");
        };
        var peg$f57 = function(tok) {
          return tok;
        };
        var peg$f58 = function(tok) {
          return options2.isChar(tok, "in");
        };
        var peg$f59 = function(tok) {
          return tok;
        };
        var peg$f60 = function(tok) {
          return options2.isChar(tok, ":");
        };
        var peg$f61 = function(tok) {
          return tok;
        };
        var peg$currPos = 0;
        var peg$posDetailsCache = [{ line: 1, column: 1 }];
        var peg$maxFailPos = 0;
        var peg$maxFailExpected = [];
        var peg$silentFails = 0;
        var peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos];
          var p2;
          if (details) {
            return details;
          } else {
            p2 = pos - 1;
            while (!peg$posDetailsCache[p2]) {
              p2--;
            }
            details = peg$posDetailsCache[p2];
            details = {
              line: details.line,
              column: details.column
            };
            while (p2 < pos) {
              if (input2.charCodeAt(p2) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p2++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos, offset2) {
          var startPosDetails = peg$computePosDetails(startPos);
          var endPosDetails = peg$computePosDetails(endPos);
          var res = {
            source: peg$source,
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
          return res;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError2(
            peg$SyntaxError2.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parsepath_spec() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parsesquare_brace_group();
          if (s3 === peg$FAILED) {
            s3 = peg$parsecoordinate();
            if (s3 === peg$FAILED) {
              s3 = peg$parsecurve_to();
              if (s3 === peg$FAILED) {
                s3 = peg$parseline_to();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsesvg();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseforeach();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseoperation();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parsecomment();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseanimation();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parseunknown();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            s2 = peg$f0(s3);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parsesquare_brace_group();
              if (s3 === peg$FAILED) {
                s3 = peg$parsecoordinate();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsecurve_to();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseline_to();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parsesvg();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseforeach();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseoperation();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parsecomment();
                            if (s3 === peg$FAILED) {
                              s3 = peg$parseanimation();
                              if (s3 === peg$FAILED) {
                                s3 = peg$parseunknown();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                s2 = peg$f0(s3);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f1(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseanimation() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parsecolon();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_comment_();
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parseoperation();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s4 = peg$f2(s2, s5, s6);
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseoperation();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_comment_();
                  s4 = peg$f2(s2, s5, s6);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseequals();
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_comment_();
                s6 = peg$parsegroup();
                if (s6 !== peg$FAILED) {
                  s0 = peg$f3(s2, s3, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseforeach() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseforeach_keyword();
          if (s1 === peg$FAILED) {
            s1 = peg$parseforeach_macro();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseforeach_body();
            if (s2 !== peg$FAILED) {
              s0 = peg$f4(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseforeach_body() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$parse_comment_();
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input2.length > peg$currPos) {
              s6 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parsein_keyword();
            if (s6 === peg$FAILED) {
              s6 = peg$parsesquare_brace_group();
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s6 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          s2 = input2.substring(s2, peg$currPos);
          s3 = peg$parsesquare_brace_group();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parse_comment_();
          s5 = peg$parsein_keyword();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            s7 = peg$parsegroup();
            if (s7 === peg$FAILED) {
              s7 = peg$parsemacro();
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_comment_();
              s9 = peg$parseforeach();
              if (s9 === peg$FAILED) {
                s9 = peg$parsegroup();
                if (s9 === peg$FAILED) {
                  s9 = peg$parsemacro();
                }
              }
              if (s9 !== peg$FAILED) {
                s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesvg() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parsesvg_keyword();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_comment_();
            s3 = peg$parsesquare_brace_group();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s4 = peg$parse_comment_();
            s5 = peg$parsegroup();
            if (s5 !== peg$FAILED) {
              s0 = peg$f6(s2, s3, s4, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecurve_to() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          s0 = peg$currPos;
          s1 = peg$parsedotdot();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_comment_();
            s3 = peg$parsecontrols_keyword();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_comment_();
              s5 = peg$parsecoordinate();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                s7 = peg$currPos;
                s8 = peg$parseand_keyword();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_comment_();
                  s10 = peg$parsecoordinate();
                  if (s10 !== peg$FAILED) {
                    s7 = peg$f7(s2, s4, s5, s6, s9, s10);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                s8 = peg$parse_comment_();
                s9 = peg$parsedotdot();
                if (s9 !== peg$FAILED) {
                  s0 = peg$f8(s2, s4, s5, s6, s7, s8);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseline_to() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsepipe();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseminus();
            if (s2 !== peg$FAILED) {
              s0 = peg$f9();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsepipe();
              if (s2 !== peg$FAILED) {
                s0 = peg$f10();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseminus();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseminus();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f11();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parsecoordinate() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parseplus();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseplus();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s1 = input2.substring(s1, peg$currPos);
          s2 = peg$parseopen_paren();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s7 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseclose_paren();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s7 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s3 = input2.substring(s3, peg$currPos);
            s4 = peg$parseclose_paren();
            if (s4 !== peg$FAILED) {
              s0 = peg$f12(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesquare_brace_group() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parseopen_square_brace();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input2.length > peg$currPos) {
                s6 = input2.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              s6 = peg$parseclose_square_brace();
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                if (input2.length > peg$currPos) {
                  s6 = input2.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
            s2 = input2.substring(s2, peg$currPos);
            s3 = peg$parseclose_square_brace();
            if (s3 !== peg$FAILED) {
              s0 = peg$f13(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedotdot() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsedot();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsedot();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseunknown() {
          var s0, s1;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$f14(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f19(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f20(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          return s0;
        }
        function peg$parse_() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f21(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f22(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_comment_() {
          var s0, s1, s2, s3, s4;
          peg$silentFails++;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          s2 = peg$parsecomment();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s0 = peg$f23(s2);
          peg$silentFails--;
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
          return s0;
        }
        function peg$parseoperation() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f24(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f25(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          return s0;
        }
        function peg$parseequals() {
          var s0, s1, s2;
          peg$silentFails++;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f26(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f27(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$silentFails--;
          if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          return s0;
        }
        function peg$parseopen_square_brace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f28(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f29(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseclose_square_brace() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f30(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f31(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseopen_paren() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f32(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f33(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseclose_paren() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f34(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f35(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseplus() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f36(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f37(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseminus() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f38(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f39(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsepipe() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f40(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f41(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsedot() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f42(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f43(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecontrols_keyword() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f44(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f45(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseand_keyword() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f46(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f47(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesvg_keyword() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f48(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f49(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsegroup() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f50(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f51(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsemacro() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f52(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f53(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseforeach_keyword() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f54(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f55(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseforeach_macro() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f56(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f57(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsein_keyword() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f58(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f59(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecolon() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input2.length > peg$currPos) {
            s1 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$f60(s1);
            if (s2) {
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f61(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        if (!options2.isWhitespace) {
          try {
            Object.assign(options2, {
              isChar: (node2, char) => node2.type === "string" && node2.content === char,
              isOperation: (node2) => node2.type === "string" && node2.content.match(/[a-zA-Z]/),
              isWhitespace: (node2) => node2.type === "whitespace" || node2.type === "parbreak",
              isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
              isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline,
              isComment: (node2) => node2.type === "comment",
              isGroup: (node2) => node2.type === "group",
              isMacro: (node2, name2) => node2.type === "macro" && node2.content === name2,
              isAnyMacro: (node2) => node2.type === "macro"
            });
          } catch (e) {
            console.warn("Error when initializing parser", e);
          }
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError2,
        parse: peg$parse2
      };
    }()
  );
  const LatexPegParser = _LatexPegParser;
  const AlignEnvironmentPegParser = _AlignEnvironmentPegParser;
  const ArgSpecPegParser = _ArgSpecPegParser;
  const PgfkeysPegParser = _PgfkeysPegParser;
  const MacroSubstitutionPegParser = _MacroSubstitutionPegParser;
  const LigaturesPegParser = _LigaturesPegParser;
  const XColorPegParser = _XColorPegParser;
  const TabularPegParser = _TabularPegParser;
  const SystemePegParser = _SystemePegParser;
  const GluePegParser = _GluePegParser;
  const TikzPegParser = _TikzPegParser;
  const parseCache$2 = {};
  function parse$6(str = "") {
    parseCache$2[str] = parseCache$2[str] || ArgSpecPegParser.parse(str);
    return parseCache$2[str];
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var dist = { exports: {} };
  var create$4 = { exports: {} };
  var append = { exports: {} };
  var config = { exports: {} };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    };
    module.exports = exports["default"];
  })(config, config.exports);
  var configExports = config.exports;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = append2;
    var _config = configExports;
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function append2(trie, letter, index2, array) {
      var isEndWordLetter = letter === _config2.default.END_WORD;
      var isLastLetter = index2 === array.length - 1;
      if (isEndWordLetter && !isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
        trie[_config2.default.END_WORD_REPLACER] = {};
        trie = trie[_config2.default.END_WORD_REPLACER];
      } else {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
      }
      if (isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
      }
      return trie;
    }
    module.exports = exports["default"];
  })(append, append.exports);
  var appendExports = append.exports;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = create2;
    var _append = appendExports;
    var _append2 = _interopRequireDefault(_append);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function create2(input2) {
      if (!Array.isArray(input2)) {
        throw "Expected parameter Array, received " + (typeof input2 === "undefined" ? "undefined" : _typeof(input2));
      }
      var trie = input2.reduce(function(accumulator, item) {
        item.toLowerCase().split("").reduce(_append2.default, accumulator);
        return accumulator;
      }, {});
      return trie;
    }
    module.exports = exports["default"];
  })(create$4, create$4.exports);
  var createExports = create$4.exports;
  var checkPrefix = { exports: {} };
  var utils = { exports: {} };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      objectCopy: function objectCopy(obj) {
        if (typeof obj === "undefined") {
          return {};
        }
        return JSON.parse(JSON.stringify(obj));
      },
      stringify: function stringify2(obj) {
        var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        if (typeof obj === "undefined") {
          return "";
        }
        return JSON.stringify(obj, null, spacer);
      }
    };
    module.exports = exports["default"];
  })(utils, utils.exports);
  var utilsExports = utils.exports;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = checkPrefix2;
    var _utils = utilsExports;
    _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkPrefix2(prefixNode, prefix2) {
      var input2 = prefix2.toLowerCase().split("");
      var prefixFound = input2.every(function(letter, index2) {
        if (!prefixNode[letter]) {
          return false;
        }
        return prefixNode = prefixNode[letter];
      });
      return {
        prefixFound,
        prefixNode
      };
    }
    module.exports = exports["default"];
  })(checkPrefix, checkPrefix.exports);
  var checkPrefixExports = checkPrefix.exports;
  var recursePrefix = { exports: {} };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recursePrefix2;
    var _config = configExports;
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pushInOrder = function pushInOrder2(word, prefixes) {
      var i = 0;
      while (i < prefixes.length) {
        if (word < prefixes[i]) {
          break;
        }
        i += 1;
      }
      prefixes.splice(i, 0, word);
      return prefixes;
    };
    function recursePrefix2(node2, prefix2, sorted) {
      var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var word = prefix2;
      for (var branch in node2) {
        var currentLetter = branch;
        if (branch === _config2.default.END_WORD && typeof node2[branch] === "number") {
          if (sorted) {
            pushInOrder(word, prefixes);
          } else {
            prefixes.push(word);
          }
          word = "";
        } else if (branch === _config2.default.END_WORD_REPLACER) {
          currentLetter = _config2.default.END_WORD;
        }
        recursePrefix2(node2[branch], prefix2 + currentLetter, sorted, prefixes);
      }
      return prefixes;
    }
    module.exports = exports["default"];
  })(recursePrefix, recursePrefix.exports);
  var recursePrefixExports = recursePrefix.exports;
  var recurseRandomWord = { exports: {} };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recurseRandomWord2;
    var _config = configExports;
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function recurseRandomWord2(node2, prefix2) {
      var word = prefix2;
      var branches = Object.keys(node2);
      var branch = branches[Math.floor(Math.random() * branches.length)];
      if (branch === _config2.default.END_WORD) {
        return word;
      }
      return recurseRandomWord2(node2[branch], prefix2 + branch);
    }
    module.exports = exports["default"];
  })(recurseRandomWord, recurseRandomWord.exports);
  var recurseRandomWordExports = recurseRandomWord.exports;
  var permutations = { exports: {} };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = permutations2;
    var _config = configExports;
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function permutations2(letters, trie) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof letters !== "string") {
        throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
      }
      var words = [];
      var permute = function permute2(word, node2) {
        var prefix2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        var wordIsEmpty = word.length === 0;
        var wordFound = words.indexOf(prefix2) !== -1;
        var endWordFound = node2[_config2.default.END_WORD] === 1;
        if (wordIsEmpty && endWordFound && !wordFound) {
          words.push(prefix2);
        }
        for (var i = 0, len = word.length; i < len; i++) {
          var letter = word[i];
          if (opts.type === "sub-anagram") {
            if (endWordFound && !(words.indexOf(prefix2) !== -1)) {
              words.push(prefix2);
            }
          }
          if (node2[letter]) {
            var remaining = word.substring(0, i) + word.substring(i + 1, len);
            permute2(remaining, node2[letter], prefix2 + letter, words);
          }
        }
        return words.sort();
      };
      return permute(letters, trie);
    }
    module.exports = exports["default"];
  })(permutations, permutations.exports);
  var permutationsExports = permutations.exports;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = function(input2) {
      if (!Array.isArray(input2)) {
        throw "Expected parameter Array, received " + (typeof input2 === "undefined" ? "undefined" : _typeof(input2));
      }
      var trie = (0, _create2.default)([].concat(_toConsumableArray(input2)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function tree() {
          return trie;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function dump() {
          var spacer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return _utils2.default.stringify(trie, spacer);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function addWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var reducer = function reducer2() {
            return _append2.default.apply(void 0, arguments);
          };
          var input3 = word.toLowerCase().split("");
          input3.reduce(reducer, trie);
          return this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function removeWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
          if (prefixFound) {
            delete prefixNode[_config2.default.END_WORD];
          }
          return this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function isPrefix(prefix2) {
          if (typeof prefix2 !== "string") {
            throw "Expected string prefix, received " + (typeof prefix2 === "undefined" ? "undefined" : _typeof(prefix2));
          }
          var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix2), prefixFound = _checkPrefix2.prefixFound;
          return prefixFound;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function getPrefix(strPrefix) {
          var sorted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (typeof sorted !== "boolean") {
            throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
          }
          if (!this.isPrefix(strPrefix)) {
            return [];
          }
          var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
          return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (!this.isPrefix(strPrefix)) {
            return "";
          }
          var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
          return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function countPrefix(strPrefix) {
          var prefixes = this.getPrefix(strPrefix);
          return prefixes.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function getWords() {
          var sorted = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return this.getPrefix("", sorted);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function hasWord(word) {
          if (typeof word !== "string") {
            throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
          if (prefixFound) {
            return prefixNode[_config2.default.END_WORD] === 1;
          }
          return false;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function getAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function getSubAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "sub-anagram"
          });
        }
      };
    };
    var _create = createExports;
    var _create2 = _interopRequireDefault(_create);
    var _append = appendExports;
    var _append2 = _interopRequireDefault(_append);
    var _checkPrefix5 = checkPrefixExports;
    var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
    var _recursePrefix = recursePrefixExports;
    var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
    var _recurseRandomWord = recurseRandomWordExports;
    var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
    var _utils = utilsExports;
    var _utils2 = _interopRequireDefault(_utils);
    var _config = configExports;
    var _config2 = _interopRequireDefault(_config);
    var _permutations = permutationsExports;
    var _permutations2 = _interopRequireDefault(_permutations);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
    module.exports = exports["default"];
  })(dist, dist.exports);
  var distExports = dist.exports;
  var Trie = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
  function scan(nodes, token, options2) {
    const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options2 || {};
    if (typeof token === "string") {
      token = { type: "string", content: token };
    }
    for (let i = startIndex || 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (node2.type === token.type) {
        switch (node2.type) {
          case "comment":
          case "displaymath":
          case "inlinemath":
          case "root":
          case "parbreak":
          case "whitespace":
          case "verb":
          case "verbatim":
          case "group":
            return i;
          case "macro":
            if (node2.content === token.content) {
              return i;
            }
            break;
          case "environment":
          case "mathenv":
            if (printRaw(node2.env) === printRaw(token.env)) {
              return i;
            }
            break;
          case "string":
            if (node2.content === token.content) {
              return i;
            }
            if (allowSubstringMatches && node2.content.indexOf(token.content) >= 0) {
              return i;
            }
            break;
        }
      }
      if (onlySkipWhitespaceAndComments && !match.whitespace(node2) && !match.comment(node2)) {
        return null;
      }
    }
    return null;
  }
  function prefixMatch(nodes, prefixes, options2) {
    const {
      startIndex = 0,
      matchSubstrings = false,
      assumeOneCharStrings = false
    } = options2 || {};
    if (typeof prefixes === "string") {
      prefixes = [prefixes];
    }
    if (Array.isArray(prefixes)) {
      prefixes = Trie(prefixes);
    }
    const prefixTree2 = prefixes;
    const history = {
      lastPrefix: "",
      lastWord: "",
      index: startIndex,
      partialMatch: ""
    };
    function tryToMatchNextChar(char, index2) {
      let ret = false;
      if (prefixTree2.isPrefix(history.lastPrefix + char)) {
        history.lastPrefix += char;
        history.index = index2;
        ret = true;
      }
      if (prefixTree2.hasWord(history.lastPrefix)) {
        history.lastWord = history.lastPrefix;
      }
      return ret;
    }
    for (let i = 0; startIndex + i < nodes.length; i++) {
      const node2 = nodes[startIndex + i];
      if (!match.string(node2)) {
        break;
      }
      if (assumeOneCharStrings && node2.content.length !== 1) {
        break;
      }
      if (matchSubstrings) {
        let fullMatch = true;
        history.partialMatch = "";
        for (let j = 0; j < node2.content.length; j++) {
          const char = node2.content[j];
          if (tryToMatchNextChar(char, startIndex + i)) {
            history.partialMatch += char;
          } else {
            fullMatch = false;
            break;
          }
        }
        if (fullMatch) {
          history.partialMatch = "";
        } else {
          break;
        }
      } else {
        if (!tryToMatchNextChar(node2.content, startIndex + i)) {
          break;
        }
      }
    }
    return history.lastWord ? {
      match: history.lastWord,
      endNodeIndex: history.index,
      endNodePartialMatch: history.partialMatch ? history.partialMatch : null
    } : null;
  }
  function updateRenderInfo(node2, renderInfo) {
    if (renderInfo != null) {
      node2._renderInfo = { ...node2._renderInfo || {}, ...renderInfo };
    }
    return node2;
  }
  function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
    if (typeof argSpec === "string" || !argSpec.type) {
      throw new Error(
        `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
          argSpec
        )}"`
      );
    }
    let argument2 = null;
    let currPos = startPos;
    const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
    } : () => {
      while (currPos < nodes.length) {
        if (!match.whitespace(nodes[currPos])) {
          break;
        }
        currPos++;
      }
    };
    const openMark = argSpec.openBrace || "";
    const closeMark = argSpec.closeBrace || "";
    const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
    gobbleWhitespace();
    const currNode = nodes[currPos];
    if (currNode == null || match.comment(currNode) || match.parbreak(currNode)) {
      const ret = {
        argument: argument2,
        nodesRemoved: 0
      };
      return ret;
    }
    switch (argSpec.type) {
      case "mandatory":
        if (acceptGroup) {
          let content2 = [currNode];
          if (match.group(currNode)) {
            content2 = currNode.content;
          }
          argument2 = arg(content2, {
            openMark,
            closeMark
          });
          currPos++;
          break;
        } else {
          const bracePos2 = findBracePositions(
            nodes,
            currPos,
            openMark,
            closeMark
          );
          if (bracePos2) {
            argument2 = arg(nodes.slice(bracePos2[0] + 1, bracePos2[1]), {
              openMark,
              closeMark
            });
            currPos = bracePos2[1] + 1;
            break;
          }
        }
      case "optional":
        if (acceptGroup && match.group(currNode)) {
          argument2 = arg(currNode.content, {
            openMark,
            closeMark
          });
          currPos++;
          break;
        }
        const bracePos = findBracePositions(
          nodes,
          currPos,
          openMark,
          closeMark
        );
        if (bracePos) {
          argument2 = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {
            openMark,
            closeMark
          });
          currPos = bracePos[1] + 1;
          break;
        }
        break;
      case "optionalStar":
      case "optionalToken": {
        const bracePos2 = findBracePositions(
          nodes,
          currPos,
          argSpec.type === "optionalStar" ? "*" : argSpec.token
        );
        if (bracePos2) {
          argument2 = arg(currNode, { openMark: "", closeMark: "" });
          currPos = bracePos2[0] + 1;
        }
        break;
      }
      case "until": {
        if (argSpec.stopTokens.length > 1) {
          console.warn(
            `"until" matches with multi-token stop conditions are not yet implemented`
          );
          break;
        }
        const rawToken = argSpec.stopTokens[0];
        const stopToken = rawToken === " " ? { type: "whitespace" } : rawToken;
        let bracePos2 = findBracePositions(
          nodes,
          startPos,
          void 0,
          stopToken
        );
        if (!bracePos2) {
          break;
        }
        argument2 = arg(nodes.slice(startPos, bracePos2[1]), {
          openMark: "",
          closeMark: rawToken
        });
        currPos = bracePos2[1];
        if (currPos < nodes.length) {
          currPos++;
        }
        break;
      }
      case "embellishment": {
        for (const token of argSpec.embellishmentTokens) {
          const bracePos2 = findBracePositions(nodes, currPos, token);
          if (!bracePos2) {
            continue;
          }
          let argNode = nodes[bracePos2[0] + 1];
          argument2 = arg(
            match.group(argNode) ? argNode.content : argNode,
            {
              openMark: token,
              closeMark: ""
            }
          );
          currPos = bracePos2[1] + 1;
          break;
        }
        break;
      }
      default:
        console.warn(
          `Don't know how to find an argument of argspec type "${argSpec.type}"`
        );
    }
    const nodesRemoved = argument2 ? currPos - startPos : 0;
    nodes.splice(startPos, nodesRemoved);
    return { argument: argument2, nodesRemoved };
  }
  function cloneStringNode(node2, content2) {
    return Object.assign({}, node2, { content: content2 });
  }
  function findBracePositions(nodes, startPos, openMark, closeMark) {
    const currNode = nodes[startPos];
    let openMarkPos = startPos;
    let closeMarkPos = startPos;
    if (openMark) {
      if (!match.anyString(currNode)) {
        return;
      }
      const nodeContent = currNode.content;
      if (!nodeContent.startsWith(openMark)) {
        return;
      }
      openMarkPos = startPos;
      if (currNode.content.length > openMark.length) {
        const nodeContent2 = currNode.content;
        currNode.content = openMark;
        nodes.splice(
          openMarkPos + 1,
          0,
          cloneStringNode(currNode, nodeContent2.slice(openMark.length))
        );
      }
      closeMarkPos = openMarkPos + 1;
    }
    if (!closeMark) {
      const argNode = nodes[closeMarkPos];
      if (!argNode) {
        return;
      }
      if (match.anyString(argNode) && argNode.content.length > 1) {
        const argContent = argNode.content;
        argNode.content = argContent[0];
        nodes.splice(
          closeMarkPos + 1,
          0,
          cloneStringNode(argNode, argContent.slice(1))
        );
      }
      return [openMarkPos, closeMarkPos];
    }
    closeMarkPos = scan(nodes, closeMark, {
      startIndex: closeMarkPos,
      allowSubstringMatches: true
    });
    if (closeMarkPos === null) {
      return;
    }
    const closingNode = nodes[closeMarkPos];
    if (match.anyString(closingNode) && typeof closeMark === "string") {
      const closingNodeContent = closingNode.content;
      let closeMarkIndex = closingNodeContent.indexOf(closeMark);
      if (closingNodeContent.length > closeMark.length) {
        closingNode.content = closeMark;
        const prev = closingNodeContent.slice(0, closeMarkIndex);
        const next = closingNodeContent.slice(
          closeMarkIndex + closeMark.length
        );
        if (prev) {
          nodes.splice(
            closeMarkPos,
            0,
            cloneStringNode(closingNode, prev)
          );
          closeMarkPos++;
        }
        if (next) {
          nodes.splice(
            closeMarkPos + 1,
            0,
            cloneStringNode(closingNode, next)
          );
        }
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  function gobbleArguments(nodes, argSpec, startPos = 0) {
    if (typeof argSpec === "function") {
      return argSpec(nodes, startPos);
    }
    if (typeof argSpec === "string") {
      argSpec = parse$6(argSpec);
    }
    const args = [];
    let nodesRemoved = 0;
    for (const spec of argSpec) {
      if (spec.type === "embellishment") {
        const remainingTokens = new Set(spec.embellishmentTokens);
        const argForToken = Object.fromEntries(
          spec.embellishmentTokens.map((t, i) => {
            var _a3;
            const defaultArg = "defaultArg" in spec ? (_a3 = spec.defaultArg) == null ? void 0 : _a3[i] : void 0;
            return [t, emptyArg(defaultArg)];
          })
        );
        let { argument: argument2, nodesRemoved: removed } = gobbleSingleArgument(
          nodes,
          embellishmentSpec(remainingTokens),
          startPos
        );
        while (argument2) {
          const token = argument2.openMark;
          remainingTokens.delete(token);
          argForToken[token] = argument2;
          nodesRemoved += removed;
          const newSpec = embellishmentSpec(remainingTokens);
          ({ argument: argument2, nodesRemoved: removed } = gobbleSingleArgument(
            nodes,
            newSpec,
            startPos
          ));
        }
        args.push(...spec.embellishmentTokens.map((t) => argForToken[t]));
      } else {
        const { argument: argument2, nodesRemoved: removed } = gobbleSingleArgument(
          nodes,
          spec,
          startPos
        );
        const defaultArg = "defaultArg" in spec ? spec.defaultArg : void 0;
        args.push(argument2 || emptyArg(defaultArg));
        nodesRemoved += removed;
      }
    }
    return { args, nodesRemoved };
  }
  function embellishmentSpec(tokens) {
    return {
      type: "embellishment",
      embellishmentTokens: [...tokens]
    };
  }
  function emptyArg(defaultArg) {
    const ret = arg([], { openMark: "", closeMark: "" });
    if (defaultArg != null) {
      updateRenderInfo(ret, { defaultArg });
    }
    return ret;
  }
  function attachMacroArgsInArray(nodes, macros2) {
    let currIndex;
    const isRelevantMacro = match.createMacroMatcher(macros2);
    function gobbleUntilMacro() {
      while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
        currIndex--;
      }
    }
    currIndex = nodes.length - 1;
    while (currIndex >= 0) {
      gobbleUntilMacro();
      if (currIndex < 0) {
        return;
      }
      const macroIndex = currIndex;
      const macro2 = nodes[macroIndex];
      const macroName = macro2.content;
      const macroInfo2 = macros2[macroName];
      updateRenderInfo(macro2, macroInfo2.renderInfo);
      const signatureOrParser = macroInfo2.argumentParser || macroInfo2.signature;
      if (signatureOrParser == null) {
        currIndex--;
        continue;
      }
      if (macro2.args != null) {
        currIndex = macroIndex - 1;
        continue;
      }
      currIndex++;
      const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);
      macro2.args = args;
      currIndex = macroIndex - 1;
    }
  }
  function attachMacroArgs(tree, macros2) {
    visit$3(
      tree,
      (nodes) => {
        attachMacroArgsInArray(nodes, macros2);
      },
      { includeArrays: true, test: Array.isArray }
    );
  }
  function getArgsContent(node2) {
    if (!Array.isArray(node2.args)) {
      return [];
    }
    return node2.args.map((arg2) => {
      if (arg2.openMark === "" && arg2.content.length === 0) {
        return null;
      }
      return arg2.content;
    });
  }
  function getNamedArgsContent(node2, namedArgumentsFallback = []) {
    var _a3;
    const names = ((_a3 = node2._renderInfo) == null ? void 0 : _a3.namedArguments) || namedArgumentsFallback;
    if (!Array.isArray(node2.args) || !Array.isArray(names) || names.length === 0) {
      return {};
    }
    const ret = {};
    node2.args.forEach((arg2, i) => {
      const name2 = names[i];
      if (name2 == null) {
        return;
      }
      let val = arg2.content;
      if (arg2.openMark === "" && arg2.content.length === 0) {
        val = null;
      }
      ret[name2] = val;
    });
    return ret;
  }
  const OPTIONAL_ARGUMENT_ARG_SPEC = parse$6("o")[0];
  function blankArg() {
    return arg([], { openMark: "", closeMark: "" });
  }
  const tikzCommandArgumentParser = (nodes, startPos) => {
    const origStartPos = startPos;
    let pos = startPos;
    let nodesRemoved = 0;
    const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);
    let animationArg = blankArg();
    if (cursorPosAfterAnimations !== pos) {
      const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);
      trim(argContent);
      animationArg = arg(argContent, {
        openMark: " ",
        closeMark: " "
      });
    }
    nodesRemoved += cursorPosAfterAnimations - pos;
    const {
      argument: _optionalArgument,
      nodesRemoved: optionalArgumentNodesRemoved
    } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos);
    nodesRemoved += optionalArgumentNodesRemoved;
    const optionalArg = _optionalArgument || blankArg();
    while (match.whitespace(nodes[pos])) {
      pos++;
    }
    const firstNode = nodes[pos];
    if (!firstNode) {
      return {
        args: [animationArg, optionalArg, blankArg()],
        nodesRemoved: 0
      };
    }
    if (match.group(firstNode)) {
      const args = [animationArg, optionalArg, arg(firstNode.content)];
      nodes.splice(origStartPos, pos - origStartPos + 1);
      return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };
    }
    const semicolonPosition = scan(nodes, ";", { startIndex: pos });
    if (semicolonPosition != null) {
      const argNodes = nodes.splice(
        origStartPos,
        semicolonPosition - origStartPos + 1
      );
      trim(argNodes);
      const args = [animationArg, optionalArg, arg(argNodes)];
      return {
        args,
        nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved
      };
    }
    return {
      args: [animationArg, optionalArg, blankArg()],
      nodesRemoved: 0
    };
  };
  function eatAllAnimationSpecs(nodes, startPos) {
    const colonPos = scan(nodes, ":", {
      startIndex: startPos,
      allowSubstringMatches: true,
      onlySkipWhitespaceAndComments: true
    });
    if (!colonPos) {
      return startPos;
    }
    let lastMatchPos = startPos;
    let i = colonPos + 1;
    for (; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (match.string(node2, "[")) {
        break;
      }
      if (match.string(node2, "=")) {
        i++;
        while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {
          i++;
        }
        if (!match.group(nodes[i])) {
          break;
        }
        lastMatchPos = i + 1;
        const colonPos2 = scan(nodes, ":", {
          startIndex: lastMatchPos,
          allowSubstringMatches: true,
          onlySkipWhitespaceAndComments: true
        });
        if (colonPos2 == null) {
          break;
        }
        i = colonPos2 + 1;
      }
    }
    return lastMatchPos;
  }
  const macros$g = {
    pgfkeys: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    tikzoption: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    tikzstyle: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    usetikzlibrary: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    usepgfmodule: { signature: "m", renderInfo: { pgfkeysArgs: true } },
    usepgflibrary: { signature: "m", renderInfo: { pgfkeysArgs: true } },
    pgfplotsset: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    pgfplotstabletypeset: {
      signature: "o m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    tikz: {
      signature: "o o m",
      argumentParser: tikzCommandArgumentParser,
      renderInfo: { namedArguments: ["animation", "options", "command"] }
    }
  };
  const environments$g = {
    tikzpicture: {
      signature: "o",
      renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    axis: {
      signature: "o",
      renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    scope: {
      signature: "o",
      renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    pgfonlayer: {
      signature: "m",
      renderInfo: { tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    pgflowlevelscope: {
      signature: "m",
      renderInfo: { tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    pgfviewboxscope: {
      signature: "m m m m m",
      renderInfo: { tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    pgftransparencygroup: {
      signature: "o",
      renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
      processContent: processTikzEnvironmentContent
    },
    behindforegroundpath: {
      signature: "m",
      processContent: processTikzEnvironmentContent
    },
    pgfmetadecoration: {
      signature: "m",
      processContent: processTikzEnvironmentContent
    },
    colormixin: { signature: "m", renderInfo: { pgfkeysArgs: true } }
  };
  function processTikzEnvironmentContent(nodes) {
    attachMacroArgsInArray(nodes, conditionalMacros);
    return nodes;
  }
  const conditionalMacros = {
    pgfextra: { signature: "m" },
    beginpgfgraphicnamed: { signature: "m" },
    pgfrealjobname: { signature: "m" },
    pgfplotstreampoint: { signature: "m" },
    pgfplotstreampointoutlier: { signature: "m" },
    pgfplotstreamspecial: { signature: "m" },
    pgfplotxyfile: { signature: "m" },
    pgfplotxyzfile: { signature: "m" },
    pgfplotfunction: { signature: "mmm" },
    pgfplotgnuplot: { signature: "o m" },
    pgfplothandlerrecord: { signature: "m" },
    pgfdeclareplothandler: { signature: "m m m" },
    pgfdeclarelayer: { signature: "m" },
    pgfsetlayers: { signature: "m", renderInfo: { pgfkeysArgs: true } },
    pgfonlayer: { signature: "m" },
    startpgfonlayer: { signature: "m" },
    pgfdeclarehorizontalshading: { signature: "o m m m " },
    pgfdeclareradialshading: { signature: "o m m m" },
    pgfdeclarefunctionalshading: { signature: "o m m m m m" },
    pgfshadecolortorgb: { signature: "m m" },
    pgfshadecolortocmyk: { signature: "m m" },
    pgfshadecolortogray: { signature: "m m" },
    pgfuseshading: { signature: "m" },
    pgfshadepath: { signature: "m m" },
    pgfsetadditionalshadetransform: { signature: "m" },
    pgfsetstrokeopacity: { signature: "m" },
    pgfsetfillopacity: { signature: "m" },
    pgfsetblendmode: { signature: "m" },
    pgfdeclarefading: { signature: "m m" },
    pgfsetfading: { signature: "m m" },
    pgfsetfadingforcurrentpath: { signature: "m m" },
    pgfsetfadingforcurrentpathstroked: { signature: "m m" },
    pgfanimateattribute: { signature: "m m" },
    pgfsnapshot: { signature: "m" },
    pgfqpoint: { signature: "m m" },
    pgfqpointxy: { signature: "m m" },
    pgfqpointxyz: { signature: "m m m" },
    pgfqpointscale: { signature: "m m" },
    pgfpathqmoveto: { signature: "m m" },
    pgfpathqlineto: { signature: "m m" },
    pgfpathqcurveto: { signature: "m m m m m m" },
    pgfpathqcircle: { signature: "m" },
    pgfqbox: { signature: "m" },
    pgfqboxsynced: { signature: "m" },
    pgfaliasimage: { signature: "m m" },
    pgfuseimage: { signature: "m" },
    pgfimage: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
    pgfdeclaremask: { signature: "o m m", renderInfo: { pgfkeysArgs: true } },
    pgfdeclarepatternformonly: { signature: "o m m m m m" },
    pgfdeclarepatterninherentlycolored: { signature: "o m m m m m" },
    pgfsetfillpattern: { signature: "m m" },
    // Coordinate canvas and nonlinear transformations
    pgftransformshift: { signature: "m" },
    pgftransformxshift: { signature: "m" },
    pgftransformyshift: { signature: "m" },
    pgftransformscale: { signature: "m" },
    pgftransformxscale: { signature: "m" },
    pgftransformyscale: { signature: "m" },
    pgftransformxslant: { signature: "m" },
    pgftransformyslant: { signature: "m" },
    pgftransformrotate: { signature: "m" },
    pgftransformtriangle: { signature: "m m m" },
    pgftransformcm: { signature: "m m m m m" },
    pgftransformarrow: { signature: "m m" },
    pgftransformlineattime: { signature: "m m m" },
    pgftransformcurveattime: { signature: "m m m m m" },
    pgftransformarcaxesattime: { signature: "m m m m m m" },
    pgfgettransform: { signature: "m" },
    pgfsettransform: { signature: "m" },
    pgfgettransformentries: { signature: "m m m m m m" },
    pgfsettransformentries: { signature: "m m m m m m" },
    pgfpointtransformed: { signature: "m" },
    pgflowlevel: { signature: "m" },
    pgflowlevelobj: { signature: "m m" },
    pgflowlevelscope: { signature: "m" },
    startpgflowlevelscope: { signature: "m" },
    pgfviewboxscope: { signature: "m m m m m" },
    startpgfviewboxscope: { signature: "m m m m m" },
    pgftransformnonlinear: { signature: "m" },
    pgfpointtransformednonlinear: { signature: "m" },
    pgfsetcurvilinearbeziercurve: { signature: "m m m m" },
    pgfcurvilineardistancetotime: { signature: "m" },
    pgfpointcurvilinearbezierorthogonal: { signature: "m m" },
    pgfpointcurvilinearbezierpolar: { signature: "m m" },
    // Matrices
    pgfmatrix: { signature: "m m m m m m m" },
    pgfsetmatrixcolumnsep: { signature: "m" },
    pgfmatrixnextcell: { signature: "o" },
    pgfsetmatrixrowsep: { signature: "m" },
    pgfmatrixendrow: { signature: "o" },
    // Nodes and shapes
    pgfnode: { signature: "m m m m m" },
    pgfmultipartnode: { signature: "m m m m" },
    pgfcoordinate: { signature: "m m" },
    pgfnodealias: { signature: "m m" },
    pgfnoderename: { signature: "m m" },
    pgfpositionnodelater: { signature: "m" },
    pgfpositionnodenow: { signature: "m" },
    pgfnodepostsetupcode: { signature: "m m" },
    pgfpointanchor: { signature: "m m" },
    pgfpointshapeborder: { signature: "m m" },
    pgfdeclareshape: { signature: "m m" },
    saveddimen: { signature: "m m" },
    savedmacro: { signature: " m" },
    anchor: { signature: "m m" },
    deferredanchor: { signature: "m m" },
    anchorborder: { signature: "m" },
    backgroundpath: { signature: "m" },
    foregroundpath: { signature: "m" },
    behindbackgroundpath: { signature: "m" },
    beforebackgroundpath: { signature: "m" },
    beforeforegroundpath: { signature: "m" },
    behindforegroundpath: { signature: "m" },
    // Arrows
    pgfdeclarearrow: { signature: "m" },
    pgfarrowssettipend: { signature: "m" },
    pgfarrowssetbackend: { signature: "m" },
    pgfarrowssetlineend: { signature: "m" },
    pgfarrowssetvisualbackend: { signature: "m" },
    pgfarrowssetvisualtipend: { signature: "m" },
    pgfarrowshullpoint: { signature: "m m" },
    pgfarrowsupperhullpoint: { signature: "m m" },
    pgfarrowssave: { signature: "m" },
    pgfarrowssavethe: { signature: "m" },
    pgfarrowsaddtooptions: { signature: "m" },
    pgfarrowsaddtolateoptions: { signature: "m" },
    pgfarrowsaddtolengthscalelist: { signature: "m" },
    pgfarrowsaddtowidthscalelist: { signature: "m" },
    pgfarrowsthreeparameters: { signature: "m" },
    pgfarrowslinewidthdependent: { signature: "m m m" },
    pgfarrowslengthdependent: { signature: "m" },
    // Path
    pgfusepath: { signature: "m" },
    pgfsetlinewidth: { signature: "m" },
    pgfsetmiterlimit: { signature: "m" },
    pgfsetdash: { signature: "m m" },
    pgfsetstrokecolor: { signature: "m" },
    pgfsetcolor: { signature: "m" },
    pgfsetinnerlinewidth: { signature: "m" },
    pgfsetinnerstrokecolor: { signature: "m" },
    pgfsetarrowsstart: { signature: "m" },
    pgfsetarrowsend: { signature: "m" },
    pgfsetarrows: { signature: "m" },
    pgfsetshortenstart: { signature: "m" },
    pgfsetshortenend: { signature: "m" },
    pgfsetfillcolor: { signature: "m" },
    // Decorations
    pgfdeclaredecoration: { signature: "m m m" },
    state: { signature: "m o m" },
    pgfdecoratepath: { signature: "m m" },
    startpgfdecoration: { signature: "m" },
    pgfdecoration: { signature: "m" },
    pgfdecoratecurrentpath: { signature: "m" },
    pgfsetdecorationsegmenttransformation: { signature: "m" },
    pgfdeclaremetadecorate: { signature: "m m m" },
    pgfmetadecoration: { signature: "m" },
    startpgfmetadecoration: { signature: "m" },
    // Constructing paths
    pgfpathmoveto: { signature: "m" },
    pgfpathlineto: { signature: "m" },
    pgfpathcurveto: { signature: "m m m" },
    pgfpathquadraticcurveto: { signature: "m m" },
    pgfpathcurvebetweentime: { signature: "m m m m m m" },
    pgfpathcurvebetweentimecontinue: { signature: "m m m m m m" },
    pgfpatharc: { signature: "m m m" },
    pgfpatharcaxes: { signature: "m m m m" },
    pgfpatharcto: { signature: "m m m m m m" },
    pgfpatharctoprecomputed: { signature: "m m m m m m m m" },
    pgfpathellipse: { signature: "m m m" },
    pgfpathcircle: { signature: "m m" },
    pgfpathrectangle: { signature: "m m" },
    pgfpathrectanglecorners: { signature: "m m" },
    pgfpathgrid: { signature: " o m m" },
    pgfpathparabola: { signature: "m m" },
    pgfpathsine: { signature: "m" },
    pgfpathcosine: { signature: "m" },
    pgfsetcornersarced: { signature: "m" },
    "pgf@protocolsizes": { signature: "m m" },
    // Specifying coordinates
    pgfpoint: { signature: "m m" },
    pgfpointpolar: { signature: "m m m" },
    pgfpointxy: { signature: "m m" },
    pgfsetxvec: { signature: "m" },
    pgfsetyvec: { signature: "m" },
    pgfpointpolarxy: { signature: "m m" },
    pgfpointxyz: { signature: "m m m" },
    pgfsetzvec: { signature: "m" },
    pgfpointcylindrical: { signature: "m m m" },
    pgfpointspherical: { signature: "m m m" },
    pgfpointadd: { signature: "m m" },
    pgfpointscale: { signature: "m m" },
    pgfpointdiff: { signature: "m m" },
    pgfpointnormalised: { signature: "m" },
    pgfpointlineattime: { signature: "m m m" },
    pgfpointlineatdistance: { signature: "m m m" },
    pgfpointarcaxesattime: { signature: "m m m m m m" },
    pgfpointcurveattime: { signature: "m m m m m" },
    pgfpointborderrectangle: { signature: "m m" },
    pgfpointborderellipse: { signature: "m m" },
    pgfpointintersectionoflines: { signature: "m m m m" },
    pgfpointintersectionofcircles: { signature: "m m m m m" },
    pgfintersectionofpaths: { signature: "m m" },
    pgfpointintersectionsolution: { signature: "m" },
    pgfextractx: { signature: "m m" },
    pgfextracty: { signature: "m m" },
    pgfgetlastxy: { signature: "m m" },
    "pgf@process": { signature: "m" },
    // Heirarchical structres ...
    pgfsetbaseline: { signature: "m" },
    pgfsetbaselinepointnow: { signature: "m" },
    pgfsetbaselinepointlater: { signature: "m" },
    pgftext: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
    pgfuseid: { signature: "m" },
    pgfusetype: { signature: "m" },
    pgfidrefnextuse: { signature: "m m" },
    pgfidrefprevuse: { signature: "m m" },
    pgfaliasid: { signature: "m m" },
    pgfgaliasid: { signature: "m m" },
    pgfifidreferenced: { signature: "m m m" },
    pgfrdfabout: { signature: "m" },
    pgfrdfcontent: { signature: "m" },
    pgfrdfdatatype: { signature: "m" },
    pgfrdfhref: { signature: "m" },
    pgfrdfprefix: { signature: "m" },
    pgfrdfproperty: { signature: "m" },
    pgfrdfrel: { signature: "m" },
    pgfrdfresource: { signature: "m" },
    pgfrdfrev: { signature: "m" },
    pgfrdfsrc: { signature: "m" },
    pgfrdftypeof: { signature: "m" },
    pgfrdfvocab: { signature: "m" },
    pgferror: { signature: "m" },
    pgfwarning: { signature: "m" },
    path: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    draw: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    fill: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    filldraw: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    pattern: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    shade: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    clip: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    useasboundingbox: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    node: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    coordinate: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    graph: {
      signature: "u;",
      renderInfo: { breakAround: true, tikzPathCommand: true }
    },
    scoped: {
      signature: "o o m",
      argumentParser: tikzCommandArgumentParser,
      renderInfo: {
        namedArguments: ["animation", "options", "command"],
        breakAround: true
      }
    }
  };
  function createMatchers$7() {
    return {
      isChar: match.string,
      isTerminal: (node2) => match.string(node2, ";"),
      isOperation: (node2) => match.anyString(node2) && node2.content.match(/[a-zA-Z]/),
      isWhitespace: (node2) => match.whitespace(node2) || match.parbreak(node2),
      isComment: match.comment,
      isGroup: match.group,
      isMacro: match.macro,
      isAnyMacro: match.anyMacro
    };
  }
  const matchers = createMatchers$7();
  function parse$5(ast2, options2) {
    const { startRule = "path_spec" } = options2 || {};
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = decorateArrayForPegjs([...ast2]);
    return TikzPegParser.parse(ast2, {
      ...matchers,
      startRule
    });
  }
  function createMatchers$6() {
    return {
      isChar: (node2, char) => match.string(node2, char),
      isComma: (node2) => match.string(node2, ","),
      isEquals: (node2) => match.string(node2, "="),
      isWhitespace: (node2) => match.whitespace(node2),
      isParbreak: (node2) => match.parbreak(node2),
      isSameLineComment: (node2) => match.comment(node2) && node2.sameline,
      isOwnLineComment: (node2) => match.comment(node2) && !node2.sameline
    };
  }
  function parsePgfkeys(ast2, options2) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    const { allowParenGroups = false } = options2 || {};
    ast2 = decorateArrayForPegjs([...ast2]);
    return PgfkeysPegParser.parse(ast2, {
      ...createMatchers$6(),
      allowParenGroups
    });
  }
  function createMatchers$5(rowSepMacros, colSep) {
    const isRowSep = match.createMacroMatcher(rowSepMacros);
    return {
      isRowSep,
      isColSep: (node2) => colSep.some((sep) => match.string(node2, sep)),
      isWhitespace: (node2) => match.whitespace(node2),
      isSameLineComment: (node2) => match.comment(node2) && node2.sameline,
      isOwnLineComment: (node2) => match.comment(node2) && !node2.sameline
    };
  }
  function parseAlignEnvironment(ast2, colSep = ["&"], rowSepMacros = ["\\", "hline", "cr"]) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = decorateArrayForPegjs([...ast2]);
    return AlignEnvironmentPegParser.parse(
      ast2,
      createMatchers$5(rowSepMacros, colSep)
    );
  }
  function bail(error) {
    if (error) {
      throw error;
    }
  }
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var isBuffer = function isBuffer2(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
  var isBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer);
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject$1 = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key2;
    for (key2 in obj) {
    }
    return typeof key2 === "undefined" || hasOwn.call(obj, key2);
  };
  var setProperty = function setProperty2(target, options2) {
    if (defineProperty && options2.name === "__proto__") {
      defineProperty(target, options2.name, {
        enumerable: true,
        configurable: true,
        value: options2.newValue,
        writable: true
      });
    } else {
      target[options2.name] = options2.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name2) {
    if (name2 === "__proto__") {
      if (!hasOwn.call(obj, name2)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name2).value;
      }
    }
    return obj[name2];
  };
  var extend = function extend2() {
    var options2, name2, src, copy, copyIsArray, clone2;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options2 = arguments[i];
      if (options2 != null) {
        for (name2 in options2) {
          src = getProperty(target, name2);
          copy = getProperty(options2, name2);
          if (target !== copy) {
            if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone2 = src && isArray(src) ? src : [];
              } else {
                clone2 = src && isPlainObject$1(src) ? src : {};
              }
              setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name: name2, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
  var extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
  function isPlainObject(value2) {
    if (typeof value2 !== "object" || value2 === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value2);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
  }
  function trough() {
    const fns = [];
    const pipeline = { run, use };
    return pipeline;
    function run(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next(null, ...values);
      function next(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index2 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index2 < values.length) {
          if (output[index2] === null || output[index2] === void 0) {
            output[index2] = values[index2];
          }
        }
        values = output;
        if (fn) {
          wrap$1(fn, next)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap$1(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result instanceof Promise) {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value2) {
      done(null, value2);
    }
  }
  function stringifyPosition$1(value2) {
    if (!value2 || typeof value2 !== "object") {
      return "";
    }
    if ("position" in value2 || "type" in value2) {
      return position$3(value2.position);
    }
    if ("start" in value2 || "end" in value2) {
      return position$3(value2);
    }
    if ("line" in value2 || "column" in value2) {
      return point$4(value2);
    }
    return "";
  }
  function point$4(point2) {
    return index$1(point2 && point2.line) + ":" + index$1(point2 && point2.column);
  }
  function position$3(pos) {
    return point$4(pos && pos.start) + "-" + point$4(pos && pos.end);
  }
  function index$1(value2) {
    return value2 && typeof value2 === "number" ? value2 : 1;
  }
  let VFileMessage$1 = class VFileMessage extends Error {
    /**
     * Create a message for `reason` at `place` from `origin`.
     *
     * When an error is passed in as `reason`, the `stack` is copied.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     *
     *   > ð **Note**: you should use markdown.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // To do: next major: expose `undefined` everywhere instead of `null`.
    constructor(reason, place, origin) {
      const parts2 = [null, null];
      let position2 = {
        // @ts-expect-error: we always follows the structure of `position`.
        start: { line: null, column: null },
        // @ts-expect-error: "
        end: { line: null, column: null }
      };
      super();
      if (typeof place === "string") {
        origin = place;
        place = void 0;
      }
      if (typeof origin === "string") {
        const index2 = origin.indexOf(":");
        if (index2 === -1) {
          parts2[1] = origin;
        } else {
          parts2[0] = origin.slice(0, index2);
          parts2[1] = origin.slice(index2 + 1);
        }
      }
      if (place) {
        if ("type" in place || "position" in place) {
          if (place.position) {
            position2 = place.position;
          }
        } else if ("start" in place || "end" in place) {
          position2 = place;
        } else if ("line" in place || "column" in place) {
          position2.start = place;
        }
      }
      this.name = stringifyPosition$1(place) || "1:1";
      this.message = typeof reason === "object" ? reason.message : reason;
      this.stack = "";
      if (typeof reason === "object" && reason.stack) {
        this.stack = reason.stack;
      }
      this.reason = this.message;
      this.fatal;
      this.line = position2.start.line;
      this.column = position2.start.column;
      this.position = position2;
      this.source = parts2[0];
      this.ruleId = parts2[1];
      this.file;
      this.actual;
      this.expected;
      this.url;
      this.note;
    }
  };
  VFileMessage$1.prototype.file = "";
  VFileMessage$1.prototype.name = "";
  VFileMessage$1.prototype.reason = "";
  VFileMessage$1.prototype.message = "";
  VFileMessage$1.prototype.stack = "";
  VFileMessage$1.prototype.fatal = null;
  VFileMessage$1.prototype.column = null;
  VFileMessage$1.prototype.line = null;
  VFileMessage$1.prototype.source = null;
  VFileMessage$1.prototype.ruleId = null;
  VFileMessage$1.prototype.position = null;
  const path = { basename: basename$1, dirname: dirname$1, extname: extname$1, join: join$4, sep: "/" };
  function basename$1(path2, ext) {
    if (ext !== void 0 && typeof ext !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath$3(path2);
    let start = 0;
    let end2 = -1;
    let index2 = path2.length;
    let seenNonSlash;
    if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
      while (index2--) {
        if (path2.charCodeAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else if (end2 < 0) {
          seenNonSlash = true;
          end2 = index2 + 1;
        }
      }
      return end2 < 0 ? "" : path2.slice(start, end2);
    }
    if (ext === path2) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extIndex = ext.length - 1;
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extIndex > -1) {
          if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
            if (extIndex < 0) {
              end2 = index2;
            }
          } else {
            extIndex = -1;
            end2 = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end2) {
      end2 = firstNonSlashEnd;
    } else if (end2 < 0) {
      end2 = path2.length;
    }
    return path2.slice(start, end2);
  }
  function dirname$1(path2) {
    assertPath$3(path2);
    if (path2.length === 0) {
      return ".";
    }
    let end2 = -1;
    let index2 = path2.length;
    let unmatchedSlash;
    while (--index2) {
      if (path2.charCodeAt(index2) === 47) {
        if (unmatchedSlash) {
          end2 = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end2 < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end2 === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end2);
  }
  function extname$1(path2) {
    assertPath$3(path2);
    let index2 = path2.length;
    let end2 = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code2 = path2.charCodeAt(index2);
      if (code2 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end2 < 0) {
        unmatchedSlash = true;
        end2 = index2 + 1;
      }
      if (code2 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end2);
  }
  function join$4(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath$3(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize$2(joined);
  }
  function normalize$2(path2) {
    assertPath$3(path2);
    const absolute = path2.charCodeAt(0) === 47;
    let value2 = normalizeString$1(path2, !absolute);
    if (value2.length === 0 && !absolute) {
      value2 = ".";
    }
    if (value2.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
      value2 += "/";
    }
    return absolute ? "/" + value2 : value2;
  }
  function normalizeString$1(path2, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code2;
    let lastSlashIndex;
    while (++index2 <= path2.length) {
      if (index2 < path2.length) {
        code2 = path2.charCodeAt(index2);
      } else if (code2 === 47) {
        break;
      } else {
        code2 = 47;
      }
      if (code2 === 47) {
        if (lastSlash === index2 - 1 || dots === 1)
          ;
        else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path2.slice(lastSlash + 1, index2);
          } else {
            result = path2.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code2 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath$3(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path2)
      );
    }
  }
  const proc = { cwd: cwd$1 };
  function cwd$1() {
    return "/";
  }
  function isUrl$1(fileUrlOrPath) {
    return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
    fileUrlOrPath.href && // @ts-expect-error: indexable.
    fileUrlOrPath.origin;
  }
  function urlToPath$1(path2) {
    if (typeof path2 === "string") {
      path2 = new URL(path2);
    } else if (!isUrl$1(path2)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path2.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix$1(path2);
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
        const third = pathname.charCodeAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  const order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
  let VFile$1 = class VFile {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Buffer` â `{value: options}`
     * *   `URL` â `{path: options}`
     * *   `VFile` â shallow copies its data over to the new file
     * *   `object` â all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value2) {
      let options2;
      if (!value2) {
        options2 = {};
      } else if (typeof value2 === "string" || buffer(value2)) {
        options2 = { value: value2 };
      } else if (isUrl$1(value2)) {
        options2 = { path: value2 };
      } else {
        options2 = value2;
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = proc.cwd();
      this.value;
      this.stored;
      this.result;
      this.map;
      let index2 = -1;
      while (++index2 < order$1.length) {
        const prop2 = order$1[index2];
        if (prop2 in options2 && options2[prop2] !== void 0 && options2[prop2] !== null) {
          this[prop2] = prop2 === "history" ? [...options2[prop2]] : options2[prop2];
        }
      }
      let prop;
      for (prop in options2) {
        if (!order$1.includes(prop)) {
          this[prop] = options2[prop];
        }
      }
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {string | URL} path
     */
    set path(path2) {
      if (isUrl$1(path2)) {
        path2 = urlToPath$1(path2);
      }
      assertNonEmpty$1(path2, "path");
      if (this.path !== path2) {
        this.history.push(path2);
      }
    }
    /**
     * Get the parent path (example: `'~'`).
     */
    get dirname() {
      return typeof this.path === "string" ? path.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if thereâs no `path` yet.
     */
    set dirname(dirname2) {
      assertPath$2(this.basename, "dirname");
      this.path = path.join(dirname2 || "", this.basename);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     */
    get basename() {
      return typeof this.path === "string" ? path.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     */
    set basename(basename2) {
      assertNonEmpty$1(basename2, "basename");
      assertPart$1(basename2, "basename");
      this.path = path.join(this.dirname || "", basename2);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     */
    get extname() {
      return typeof this.path === "string" ? path.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if thereâs no `path` yet.
     */
    set extname(extname2) {
      assertPart$1(extname2, "extname");
      assertPath$2(this.dirname, "extname");
      if (extname2) {
        if (extname2.charCodeAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = path.join(this.dirname, this.stem + (extname2 || ""));
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     */
    get stem() {
      return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     */
    set stem(stem) {
      assertNonEmpty$1(stem, "stem");
      assertPart$1(stem, "stem");
      this.path = path.join(this.dirname || "", stem + (this.extname || ""));
    }
    /**
     * Serialize the file.
     *
     * @param {BufferEncoding | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when itâs a `Buffer`
     *   (default: `'utf8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      return (this.value || "").toString(encoding || void 0);
    }
    /**
     * Create a warning message associated with the file.
     *
     * Its `fatal` is set to `false` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(reason, place, origin) {
      const message = new VFileMessage$1(reason, place, origin);
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Create an info message associated with the file.
     *
     * Its `fatal` is set to `null` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(reason, place, origin) {
      const message = this.message(reason, place, origin);
      message.fatal = null;
      return message;
    }
    /**
     * Create a fatal error associated with the file.
     *
     * Its `fatal` is set to `true` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * > ð **Note**: a fatal error means that a file is no longer processable.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Message.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(reason, place, origin) {
      const message = this.message(reason, place, origin);
      message.fatal = true;
      throw message;
    }
  };
  function assertPart$1(part, name2) {
    if (part && part.includes(path.sep)) {
      throw new Error(
        "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
      );
    }
  }
  function assertNonEmpty$1(part, name2) {
    if (!part) {
      throw new Error("`" + name2 + "` cannot be empty");
    }
  }
  function assertPath$2(path2, name2) {
    if (!path2) {
      throw new Error("Setting `" + name2 + "` requires `path` to be set too");
    }
  }
  function buffer(value2) {
    return isBuffer$1(value2);
  }
  const unified = base$1().freeze();
  const own$d = {}.hasOwnProperty;
  function base$1() {
    const transformers = trough();
    const attachers = [];
    let namespace = {};
    let frozen;
    let freezeIndex = -1;
    processor.data = data;
    processor.Parser = void 0;
    processor.Compiler = void 0;
    processor.freeze = freeze;
    processor.attachers = attachers;
    processor.use = use;
    processor.parse = parse2;
    processor.stringify = stringify2;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process;
    processor.processSync = processSync;
    return processor;
    function processor() {
      const destination = base$1();
      let index2 = -1;
      while (++index2 < attachers.length) {
        destination.use(...attachers[index2]);
      }
      destination.data(extend$1(true, {}, namespace));
      return destination;
    }
    function data(key2, value2) {
      if (typeof key2 === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", frozen);
          namespace[key2] = value2;
          return processor;
        }
        return own$d.call(namespace, key2) && namespace[key2] || null;
      }
      if (key2) {
        assertUnfrozen("data", frozen);
        namespace = key2;
        return processor;
      }
      return namespace;
    }
    function freeze() {
      if (frozen) {
        return processor;
      }
      while (++freezeIndex < attachers.length) {
        const [attacher, ...options2] = attachers[freezeIndex];
        if (options2[0] === false) {
          continue;
        }
        if (options2[0] === true) {
          options2[0] = void 0;
        }
        const transformer = attacher.call(processor, ...options2);
        if (typeof transformer === "function") {
          transformers.use(transformer);
        }
      }
      frozen = true;
      freezeIndex = Number.POSITIVE_INFINITY;
      return processor;
    }
    function use(value2, ...options2) {
      let settings;
      assertUnfrozen("use", frozen);
      if (value2 === null || value2 === void 0)
        ;
      else if (typeof value2 === "function") {
        addPlugin(value2, ...options2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          addList(value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
      if (settings) {
        namespace.settings = Object.assign(namespace.settings || {}, settings);
      }
      return processor;
      function add(value3) {
        if (typeof value3 === "function") {
          addPlugin(value3);
        } else if (typeof value3 === "object") {
          if (Array.isArray(value3)) {
            const [plugin, ...options3] = value3;
            addPlugin(plugin, ...options3);
          } else {
            addPreset(value3);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value3 + "`");
        }
      }
      function addPreset(result) {
        addList(result.plugins);
        if (result.settings) {
          settings = Object.assign(settings || {}, result.settings);
        }
      }
      function addList(plugins) {
        let index2 = -1;
        if (plugins === null || plugins === void 0)
          ;
        else if (Array.isArray(plugins)) {
          while (++index2 < plugins.length) {
            const thing = plugins[index2];
            add(thing);
          }
        } else {
          throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, value3) {
        let index2 = -1;
        let entry;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            entry = attachers[index2];
            break;
          }
        }
        if (entry) {
          if (isPlainObject(entry[1]) && isPlainObject(value3)) {
            value3 = extend$1(true, entry[1], value3);
          }
          entry[1] = value3;
        } else {
          attachers.push([...arguments]);
        }
      }
    }
    function parse2(doc) {
      processor.freeze();
      const file = vfile(doc);
      const Parser2 = processor.Parser;
      assertParser("parse", Parser2);
      if (newable(Parser2, "parse")) {
        return new Parser2(String(file), file).parse();
      }
      return Parser2(String(file), file);
    }
    function stringify2(node2, doc) {
      processor.freeze();
      const file = vfile(doc);
      const Compiler = processor.Compiler;
      assertCompiler("stringify", Compiler);
      assertNode(node2);
      if (newable(Compiler, "compile")) {
        return new Compiler(node2, file).compile();
      }
      return Compiler(node2, file);
    }
    function run(node2, doc, callback) {
      assertNode(node2);
      processor.freeze();
      if (!callback && typeof doc === "function") {
        callback = doc;
        doc = void 0;
      }
      if (!callback) {
        return new Promise(executor);
      }
      executor(null, callback);
      function executor(resolve2, reject) {
        transformers.run(node2, vfile(doc), done);
        function done(error, tree, file) {
          tree = tree || node2;
          if (error) {
            reject(error);
          } else if (resolve2) {
            resolve2(tree);
          } else {
            callback(null, tree, file);
          }
        }
      }
    }
    function runSync(node2, file) {
      let result;
      let complete;
      processor.run(node2, file, done);
      assertDone("runSync", "run", complete);
      return result;
      function done(error, tree) {
        bail(error);
        result = tree;
        complete = true;
      }
    }
    function process(doc, callback) {
      processor.freeze();
      assertParser("process", processor.Parser);
      assertCompiler("process", processor.Compiler);
      if (!callback) {
        return new Promise(executor);
      }
      executor(null, callback);
      function executor(resolve2, reject) {
        const file = vfile(doc);
        processor.run(processor.parse(file), file, (error, tree, file2) => {
          if (error || !tree || !file2) {
            done(error);
          } else {
            const result = processor.stringify(tree, file2);
            if (result === void 0 || result === null)
              ;
            else if (looksLikeAVFileValue(result)) {
              file2.value = result;
            } else {
              file2.result = result;
            }
            done(error, file2);
          }
        });
        function done(error, file2) {
          if (error || !file2) {
            reject(error);
          } else if (resolve2) {
            resolve2(file2);
          } else {
            callback(null, file2);
          }
        }
      }
    }
    function processSync(doc) {
      let complete;
      processor.freeze();
      assertParser("processSync", processor.Parser);
      assertCompiler("processSync", processor.Compiler);
      const file = vfile(doc);
      processor.process(file, done);
      assertDone("processSync", "process", complete);
      return file;
      function done(error) {
        complete = true;
        bail(error);
      }
    }
  }
  function newable(value2, name2) {
    return typeof value2 === "function" && // Prototypes do exist.
    // type-coverage:ignore-next-line
    value2.prototype && // A function with keys in its prototype is probably a constructor.
    // Classesâ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    // type-coverage:ignore-next-line
    (keys$1(value2.prototype) || name2 in value2.prototype);
  }
  function keys$1(value2) {
    let key2;
    for (key2 in value2) {
      if (own$d.call(value2, key2)) {
        return true;
      }
    }
    return false;
  }
  function assertParser(name2, value2) {
    if (typeof value2 !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `Parser`");
    }
  }
  function assertCompiler(name2, value2) {
    if (typeof value2 !== "function") {
      throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
    }
  }
  function assertUnfrozen(name2, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node2) {
    if (!isPlainObject(node2) || typeof node2.type !== "string") {
      throw new TypeError("Expected node, got `" + node2 + "`");
    }
  }
  function assertDone(name2, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value2) {
    return looksLikeAVFile(value2) ? value2 : new VFile$1(value2);
  }
  function looksLikeAVFile(value2) {
    return Boolean(
      value2 && typeof value2 === "object" && "message" in value2 && "messages" in value2
    );
  }
  function looksLikeAVFileValue(value2) {
    return typeof value2 === "string" || isBuffer$1(value2);
  }
  const macros$f = {
    author: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    address: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    curraddr: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    email: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    title: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    urladdr: {
      signature: "o m",
      renderInfo: { breakAround: true, inParMode: true }
    }
  };
  const environments$f = {};
  const macros$e = {
    cref: { signature: "s m" },
    Cref: { signature: "s m" },
    crefrange: { signature: "s m m" },
    Crefrange: { signature: "s m m" },
    cpageref: { signature: "s m" },
    Cpageref: { signature: "s m" },
    ref: { signature: "m" },
    pageref: { signature: "m" },
    namecref: { signature: "m" },
    nameCref: { signature: "m" },
    lcnamecref: { signature: "m" },
    namecrefs: { signature: "m" },
    nameCrefs: { signature: "m" },
    lcnamecrefs: { signature: "m" },
    labelcref: { signature: "m" },
    labelcpageref: { signature: "m" },
    crefalias: { signature: "m m" },
    crefname: { signature: "m m m" },
    // XXX there are many more obscure commands to add here
    // https://ctan.org/pkg/cleveref
    crefdefaultlabelformat: { signature: "m" },
    crefrangeconjunction: { signature: "m" }
  };
  const environments$e = {};
  function splitOnCondition(nodes, splitFunc = () => false, options2) {
    if (!Array.isArray(nodes)) {
      throw new Error(`Can only split an Array, not ${nodes}`);
    }
    const { onlySplitOnFirstOccurrence = false } = options2 || {};
    const splitIndices = [];
    for (let i = 0; i < nodes.length; i++) {
      if (splitFunc(nodes[i])) {
        splitIndices.push(i);
        if (onlySplitOnFirstOccurrence) {
          break;
        }
      }
    }
    if (splitIndices.length === 0) {
      return { segments: [nodes], separators: [] };
    }
    let separators = splitIndices.map((i) => nodes[i]);
    let segments = splitIndices.map((splitEnd, i) => {
      const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
      return nodes.slice(splitStart, splitEnd);
    });
    segments.push(
      nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
    );
    return { segments, separators };
  }
  function splitOnMacro(ast2, macroName) {
    if (typeof macroName === "string") {
      macroName = [macroName];
    }
    if (!Array.isArray(macroName)) {
      throw new Error("Type coercion failed");
    }
    const isSeparator = match.createMacroMatcher(macroName);
    const { segments, separators } = splitOnCondition(ast2, isSeparator);
    return { segments, macros: separators };
  }
  function unsplitOnMacro({
    segments,
    macros: macros2
  }) {
    if (segments.length === 0) {
      console.warn("Trying to join zero segments");
      return [];
    }
    if (segments.length !== macros2.length + 1) {
      console.warn(
        "Mismatch between lengths of macros and segments when trying to unsplit"
      );
    }
    let ret = segments[0];
    for (let i = 0; i < macros2.length; i++) {
      ret = ret.concat(macros2[i]).concat(segments[i + 1]);
    }
    return ret;
  }
  function arrayJoin(array, sep) {
    return array.flatMap((item, i) => {
      if (i === 0) {
        return item;
      }
      if (Array.isArray(sep)) {
        return [...sep, ...item];
      } else {
        return [sep, ...item];
      }
    });
  }
  function replaceNode(ast2, visitor2) {
    visit$3(ast2, {
      leave: (node2, info) => {
        let replacement = visitor2(node2, info);
        if (typeof replacement === "undefined" || replacement === node2) {
          return;
        }
        if (!info.containingArray || info.index == null) {
          throw new Error(
            "Trying to replace node, but cannot find containing array"
          );
        }
        if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
          info.containingArray.splice(info.index, 1);
          return info.index;
        }
        if (!Array.isArray(replacement)) {
          replacement = [replacement];
        }
        info.containingArray.splice(info.index, 1, ...replacement);
        return info.index + replacement.length;
      }
    });
  }
  function firstSignificantNode(nodes, parbreaksAreInsignificant) {
    const index2 = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
    if (index2 == null) {
      return null;
    }
    return nodes[index2];
  }
  function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node2 = nodes[i];
      if (match.whitespace(node2) || match.comment(node2) || parbreaksAreInsignificant && match.parbreak(node2)) {
        continue;
      }
      return i;
    }
    return void 0;
  }
  function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (match.whitespace(node2) || match.comment(node2) || parbreaksAreInsignificant && match.parbreak(node2)) {
        continue;
      }
      return i;
    }
    return void 0;
  }
  function isSpaceLike(node2) {
    return match.whitespace(node2) || match.comment(node2) && Boolean(node2.leadingWhitespace);
  }
  function joinWithoutExcessWhitespace(head2, tail) {
    if (tail.length === 0) {
      return;
    }
    if (head2.length === 0) {
      head2.push(...tail);
      return;
    }
    const headEnd = head2[head2.length - 1];
    const tailStart = tail[0];
    if (match.whitespace(headEnd) && match.whitespace(tailStart)) {
      head2.push(...tail.slice(1));
      return;
    }
    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
      if (match.whitespace(headEnd) && match.comment(tailStart)) {
        const comment22 = {
          type: "comment",
          content: tailStart.content,
          sameline: true,
          leadingWhitespace: true
        };
        tail = tail.slice(1);
        trimStart(tail);
        head2.pop();
        head2.push(comment22, ...tail);
        return;
      }
      head2.push(...tail);
      return;
    }
    if (match.comment(headEnd) && match.comment(tailStart)) {
      if (tailStart.leadingWhitespace || tailStart.sameline) {
        head2.push(
          { type: "comment", content: tailStart.content },
          ...tail.slice(1)
        );
        return;
      }
      head2.push(...tail);
      return;
    }
    let comment2 = match.comment(headEnd) ? headEnd : tailStart;
    if (!match.comment(comment2)) {
      throw new Error(
        `Expected a comment but found ${JSON.stringify(comment2)}`
      );
    }
    if (!comment2.leadingWhitespace || !comment2.sameline) {
      comment2 = {
        type: "comment",
        content: comment2.content,
        leadingWhitespace: true,
        sameline: true
      };
    }
    head2.pop();
    head2.push(comment2, ...tail.slice(1));
  }
  function wrapSignificantContent(content2, wrapper) {
    let hoistUntil = 0;
    let hoistAfter = content2.length;
    for (let i = 0; i < content2.length; i++) {
      if (match.whitespace(content2[i]) || match.comment(content2[i])) {
        hoistUntil = i + 1;
        continue;
      }
      break;
    }
    for (let j = content2.length - 1; j >= 0; j--) {
      if (match.whitespace(content2[j]) || match.comment(content2[j])) {
        hoistAfter = j;
        continue;
      }
      break;
    }
    if (hoistUntil === 0 && hoistAfter === content2.length) {
      return ensureArray(wrapper(content2));
    }
    const frontMatter = content2.slice(0, hoistUntil);
    const middle = content2.slice(hoistUntil, hoistAfter);
    const backMatter = content2.slice(hoistAfter, content2.length);
    return frontMatter.concat(wrapper(middle), backMatter);
  }
  function ensureArray(x2) {
    if (!Array.isArray(x2)) {
      return [x2];
    }
    return x2;
  }
  function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
      nodes.pop();
      trimEnd(nodes);
    }
    const foundStreamingCommands = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node2 = nodes[i];
      if (isStreamingCommand(node2)) {
        const wrapper = (content2) => replacer(content2, node2);
        let tail = nodes.slice(i + 1);
        trimStart(tail);
        tail = wrapSignificantContent(tail, wrapper);
        foundStreamingCommands.push(node2);
        nodes.splice(i);
        joinWithoutExcessWhitespace(nodes, tail);
      }
    }
    return { foundStreamingCommands };
  }
  function replaceStreamingCommandInGroup(group2, isStreamingCommand, replacer, options2) {
    const content2 = group2.content;
    let popFromGroup = isStreamingCommand(firstSignificantNode(content2));
    let innerProcessed = replaceStreamingCommand(
      content2,
      isStreamingCommand,
      replacer,
      options2
    );
    if (innerProcessed.length === 0) {
      return [];
    }
    if (popFromGroup) {
      return innerProcessed;
    } else {
      return [{ type: "group", content: innerProcessed }];
    }
  }
  function replaceStreamingCommand(ast2, isStreamingCommand, replacer, options2) {
    if (typeof isStreamingCommand !== "function") {
      throw new Error(
        `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`
      );
    }
    const {
      macrosThatBreakPars = [
        "part",
        "chapter",
        "section",
        "subsection",
        "subsubsection",
        "vspace",
        "smallskip",
        "medskip",
        "bigskip",
        "hfill"
      ],
      environmentsThatDontBreakPars = []
    } = options2 || {};
    let processedContent = [];
    if (match.group(ast2)) {
      processedContent = replaceStreamingCommandInGroup(
        ast2,
        isStreamingCommand,
        replacer
      );
    }
    if (Array.isArray(ast2)) {
      const nodes = ast2;
      let scanIndex = nodes.length;
      let sliceIndex = scanIndex;
      while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || match.whitespace(nodes[scanIndex - 1]))) {
        scanIndex--;
        if (isStreamingCommand(nodes[scanIndex])) {
          sliceIndex = scanIndex;
        }
      }
      if (sliceIndex !== nodes.length) {
        nodes.splice(sliceIndex);
      }
      const macroThatBreaks = match.createMacroMatcher(macrosThatBreakPars);
      const envThatDoesntBreak = match.createEnvironmentMatcher(
        environmentsThatDontBreakPars
      );
      const isPar = (node2) => match.parbreak(node2) || match.macro(node2, "par") || macroThatBreaks(node2) || match.environment(node2) && !envThatDoesntBreak(node2) || node2.type === "displaymath";
      const splitByPar = splitOnCondition(nodes, isPar);
      splitByPar.separators = splitByPar.separators.map(
        (sep) => match.macro(sep, "par") ? { type: "parbreak" } : sep
      );
      const replacers = [];
      let segments = splitByPar.segments.map((segment) => {
        if (segment.length === 0) {
          return segment;
        }
        function applyAccumulatedReplacers(nodes2) {
          if (replacers.length === 0) {
            return nodes2;
          }
          return wrapSignificantContent(
            nodes2,
            composeReplacers(replacers)
          );
        }
        const { foundStreamingCommands } = replaceStreamingCommandInArray(
          segment,
          isStreamingCommand,
          replacer
        );
        const ret = applyAccumulatedReplacers(segment);
        foundStreamingCommands.forEach((macro2) => {
          replacers.push((nodes2) => {
            const ret2 = replacer(nodes2, macro2);
            if (!Array.isArray(ret2)) {
              return [ret2];
            }
            return ret2;
          });
        });
        return ret;
      });
      if (segments.length > 1) {
        segments.forEach((segment, i) => {
          if (i === 0) {
            trimEnd(segment);
          } else if (i === segments.length - 1) {
            trimStart(segment);
          } else {
            trim(segment);
          }
        });
      }
      processedContent = unsplitOnMacro({
        segments,
        macros: splitByPar.separators
      });
    }
    return processedContent;
  }
  function composeReplacers(replacers) {
    if (replacers.length === 0) {
      throw new Error("Cannot compose zero replacement functions");
    }
    return (nodes) => {
      let ret = nodes;
      for (let i = 0; i < replacers.length; i++) {
        const func = replacers[i];
        ret = func(ret);
      }
      return ret;
    };
  }
  function replaceNodeDuringVisit(replacement, info) {
    const parent = info.parents[0];
    if (!parent) {
      throw new Error(`Cannot replace node: parent not found`);
    }
    const container = parent[info.key];
    if (!Array.isArray(container)) {
      throw new Error(`Cannot replace node: containing array not found`);
    }
    if (info.index == null) {
      throw new Error(`Cannot replace node: node index undefined`);
    }
    if (!Array.isArray(replacement)) {
      container[info.index] = replacement;
    } else {
      container.splice(info.index, 1, ...replacement);
    }
  }
  const unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options2) {
    const { replacers = {} } = options2 || {};
    const isReplaceable2 = match.createMacroMatcher(replacers);
    return (tree) => {
      visit$3(
        tree,
        (group2, info) => {
          if (info.context.hasMathModeAncestor || !group2.content.some(isReplaceable2)) {
            return;
          }
          let fixed = replaceStreamingCommand(
            group2,
            isReplaceable2,
            (content2, command) => {
              return replacers[command.content](content2, command);
            }
          );
          if (!info.containingArray || info.index == null) {
            return;
          }
          const prevToken = info.containingArray[info.index - 1];
          const nextToken = info.containingArray[info.index + 1];
          if (match.whitespaceLike(prevToken) && match.whitespaceLike(fixed[0])) {
            trimStart(fixed);
          }
          if (match.whitespaceLike(nextToken) && match.whitespaceLike(fixed[fixed.length - 1])) {
            trimEnd(fixed);
          }
          replaceNodeDuringVisit(fixed, info);
        },
        { test: match.group }
      );
      visit$3(
        tree,
        (nodes, info) => {
          if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable2)) {
            return;
          }
          const replaced = replaceStreamingCommand(
            nodes,
            isReplaceable2,
            (content2, command) => {
              return replacers[command.content](content2, command);
            }
          );
          if (replaced !== nodes) {
            nodes.length = 0;
            nodes.push(...replaced);
          }
        },
        { includeArrays: true, test: Array.isArray }
      );
    };
  };
  function cleanEnumerateBody(ast2, itemName = "item") {
    let { segments, macros: macros2 } = splitOnMacro(ast2, itemName);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === 0) {
        trimEnd(segment);
      } else {
        trim(segment);
      }
      if (segment.length > 0 && i > 0) {
        segment.unshift({ type: "whitespace" });
      }
    }
    let insertParbreakBefore = /* @__PURE__ */ new WeakSet();
    let body2 = macros2.flatMap((node2, i) => {
      var _a3;
      const segment = segments[i + 1];
      const trailingComments = popTrailingComments(segment);
      node2.args = node2.args || [];
      node2.args.push(arg(segment, { openMark: "", closeMark: "" }));
      updateRenderInfo(node2, { inParMode: true });
      if (i > 0 || ((_a3 = segments[0]) == null ? void 0 : _a3.length) > 0) {
        insertParbreakBefore.add(node2);
      }
      return [node2, ...trailingComments];
    });
    body2 = body2.flatMap(
      (node2) => insertParbreakBefore.has(node2) ? [{ type: "parbreak" }, node2] : node2
    );
    body2.unshift(...segments[0]);
    for (let i = 0; i < body2.length - 1; i++) {
      const node2 = body2[i];
      const nextNode = body2[i + 1];
      if (!match.parbreak(nextNode)) {
        continue;
      }
      if (match.comment(node2)) {
        node2.suffixParbreak = true;
      }
      if (match.macro(node2) && node2.args && node2.args[node2.args.length - 1].closeMark === "") {
        const args = node2.args[node2.args.length - 1].content;
        const lastArg = args[args.length - 1];
        if (match.comment(lastArg)) {
          lastArg.suffixParbreak = true;
        }
      }
    }
    return body2;
  }
  function popTrailingComments(nodes) {
    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);
    if (lastNodeIndex === nodes.length - 1 || lastNodeIndex == null && nodes.length === 0) {
      return [];
    }
    if (lastNodeIndex == null) {
      lastNodeIndex = -1;
    }
    return nodes.splice(lastNodeIndex + 1);
  }
  const macros$d = {
    answerline: { signature: "o" },
    fillin: { signature: "o o" },
    fullwidth: { signature: "m" },
    fillwidthlines: { signature: "m" },
    fillwidthdottedlines: { signature: "m" },
    fillwidthgrid: { signature: "m" },
    makeemptybox: { signature: "m" },
    CorrectChoiceEmphasis: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    SolutionEmphasis: { signature: "m", renderInfo: { breakAround: true } },
    uplevel: { signature: "m", renderInfo: { breakAround: true } },
    checkboxchar: { signature: "m", renderInfo: { breakAround: true } },
    checkedchar: { signature: "m", renderInfo: { breakAround: true } },
    pointname: { signature: "m", renderInfo: { breakAround: true } },
    marginpointname: { signature: "m", renderInfo: { breakAround: true } },
    extrawidth: { signature: "m", renderInfo: { breakAround: true } },
    pointformat: { signature: "m", renderInfo: { breakAround: true } },
    bonuspointformat: { signature: "m", renderInfo: { breakAround: true } },
    totalformat: { signature: "m", renderInfo: { breakAround: true } },
    qformat: { signature: "m", renderInfo: { breakAround: true } },
    titledquestion: { signature: "m o", renderInfo: { breakAround: true } },
    pointpoints: { signature: "m m", renderInfo: { breakAround: true } },
    bonuspointpoints: { signature: "m m", renderInfo: { breakAround: true } }
  };
  const environments$d = {
    choices: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
    },
    checkboxes: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
    },
    oneparchoices: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
    },
    oneparcheckboxes: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
    },
    parts: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "part")
    },
    subparts: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "subpart")
    },
    subsubparts: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "subsubpart")
    },
    questions: {
      signature: "o",
      processContent: (nodes) => cleanEnumerateBody(nodes, "question")
    }
  };
  const macros$c = {
    geometry: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    }
  };
  const environments$c = {};
  const macros$b = {
    hypersetup: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    href: { signature: "o m m" },
    url: { signature: "m" },
    nolinkurl: { signature: "m" },
    hyperbaseurl: { signature: "m" },
    hyperimage: { signature: "m m" },
    hyperdef: { signature: "m m m" },
    hyperref: { signature: "o m" },
    hyperlink: { signature: "m m" },
    hypertarget: { signature: "m m" },
    autoref: { signature: "s m" },
    pageref: { signature: "s m" },
    autopageref: { signature: "s m" },
    pdfstringdef: { signature: "m m" },
    pdfbookmark: { signature: "o m m" },
    currentpdfbookmark: { signature: "m m" },
    subpdfbookmark: { signature: "m m" },
    belowpdfbookmark: { signature: "m m" },
    texorpdfstring: { signature: "m m" },
    thispdfpagelabel: { signature: "m" },
    hypercalcbp: { signature: "m" }
  };
  const environments$b = {};
  const macros$a = {
    // Special
    "\\": { signature: "!s !o", renderInfo: { breakAfter: true } },
    _: { signature: "m", escapeToken: "" },
    "^": { signature: "m", escapeToken: "" },
    // \newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands
    // List can be found in latex2e.pdf "An unofficial reference manual"
    newcommand: {
      signature: "s +m o +o +m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", "name", "numArgs", "default", "body"]
      }
    },
    renewcommand: {
      signature: "s +m o +o +m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", "name", "numArgs", "default", "body"]
      }
    },
    providecommand: {
      signature: "s +m o +o +m",
      renderInfo: { breakAround: true }
    },
    // Counters
    newcounter: {
      signature: "m o",
      renderInfo: { breakAround: true }
    },
    usecounter: {
      signature: "m"
    },
    setcounter: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    addtocounter: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    stepcounter: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    refstepcounter: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    // Lengths
    newlength: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    addtolength: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    settodepth: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    settoheight: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    settowidth: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    // Spaces
    stretch: { signature: "m" },
    hspace: { signature: "s m" },
    vspace: { signature: "s m", renderInfo: { breakAround: true } },
    vfill: { renderInfo: { breakAround: true } },
    indent: { renderInfo: { breakAround: true } },
    phantom: { signature: "m" },
    vphantom: { signature: "m" },
    hphantom: { signature: "m" },
    noindent: { renderInfo: { breakAround: true } },
    smallskip: { renderInfo: { breakAround: true } },
    medskip: { renderInfo: { breakAround: true } },
    bigskip: { renderInfo: { breakAround: true } },
    smallbreak: { renderInfo: { breakAround: true } },
    medbreak: { renderInfo: { breakAround: true } },
    bigbreak: { renderInfo: { breakAround: true } },
    newline: { renderInfo: { breakAround: true } },
    linebreak: { signature: "o", renderInfo: { breakAround: true } },
    nolinebreak: { signature: "o", renderInfo: { breakAround: true } },
    clearpage: { renderInfo: { breakAround: true } },
    cleardoublepage: { renderInfo: { breakAround: true } },
    newpage: { renderInfo: { breakAround: true } },
    enlargethispage: { signature: "s", renderInfo: { breakAround: true } },
    pagebreak: { signature: "o", renderInfo: { breakAround: true } },
    nopagebreak: { signature: "o", renderInfo: { breakAround: true } },
    // Boxes
    newsavebox: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    sbox: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    savebox: {
      signature: "m o o m",
      renderInfo: { breakAround: true }
    },
    mbox: { signature: "m" },
    makebox: { signature: "d() o o m", renderInfo: { breakAround: true } },
    fbox: { signature: "m" },
    framebox: { signature: "o o m", renderInfo: { breakAround: true } },
    frame: { signature: "m", renderInfo: { breakAround: true } },
    parbox: { signature: "o o o m m", renderInfo: { breakAround: true } },
    raisebox: { signature: "m o o m" },
    marginpar: { signature: "o m", renderInfo: { breakAround: true } },
    colorbox: { signature: "o m m", renderInfo: { breakAround: true } },
    fcolorbox: { signature: "o m m", renderInfo: { breakAround: true } },
    rotatebox: { signature: "o m m" },
    scalebox: { signature: "m o m" },
    reflectbox: { signature: "m" },
    resizebox: { signature: "s m m m" },
    // Define environments
    newenvironment: {
      signature: "s m o o m m",
      renderInfo: { breakAround: true }
    },
    renewenvironment: {
      signature: "s m o o m m",
      renderInfo: { breakAround: true }
    },
    newtheorem: {
      signature: "s m o m o",
      renderInfo: { breakAround: true }
    },
    newfont: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    // Counters
    alph: { signature: "m" },
    Alph: { signature: "m" },
    arabic: { signature: "m" },
    roman: { signature: "m" },
    Roman: { signature: "m" },
    fnsymbol: { signature: "m" },
    // Other
    documentclass: {
      signature: "o m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    usepackage: {
      signature: "o m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    item: {
      signature: "o",
      renderInfo: { hangingIndent: true, namedArguments: ["label"] }
    },
    value: { signature: "m" },
    centering: { renderInfo: { breakAround: true } },
    input: { signature: "m", renderInfo: { breakAround: true } },
    include: { signature: "m", renderInfo: { breakAround: true } },
    includeonly: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    discretionary: { signature: "m m m" },
    hyphenation: { signature: "m" },
    footnote: { signature: "o m", renderInfo: { inParMode: true } },
    footnotemark: { signature: "o" },
    footnotetext: { signature: "o m", renderInfo: { inParMode: true } },
    caption: {
      signature: "o m",
      renderInfo: { inParMode: true, breakAround: true }
    },
    // Math Commands
    sqrt: { signature: "o m", renderInfo: { inMathMode: true } },
    frac: { signature: "m m", renderInfo: { inMathMode: true } },
    stackrel: { signature: "m m" },
    ensuremath: { signature: "m", renderInfo: { inMathMode: true } },
    // Layout commands
    abstract: {
      signature: "m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    maketitle: { renderInfo: { breakAround: true } },
    doublespacing: { renderInfo: { breakAround: true } },
    singlespacing: { renderInfo: { breakAround: true } },
    date: { signature: "o m", renderInfo: { breakAround: true } },
    thanks: {
      signature: "m",
      renderInfo: { breakAround: true, inParMode: true }
    },
    pagenumbering: { signature: "m", renderInfo: { breakAround: true } },
    pagestyle: { signature: "m", renderInfo: { breakAround: true } },
    thispagestyle: { signature: "m", renderInfo: { breakAround: true } },
    // Colors
    definecolor: { signature: "m m m", renderInfo: { breakAround: true } },
    pagecolor: { signature: "o m", renderInfo: { breakAround: true } },
    nopagecolor: { renderInfo: { breakAround: true } },
    multicolumn: { signature: "m m m" },
    // Graphics
    includegraphics: {
      signature: "s o o m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    rule: { signature: "o m m" },
    // Sectioning
    part: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    chapter: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    section: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    subsection: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    subsubsection: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    paragraph: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    subparagraph: {
      signature: "s o m",
      renderInfo: {
        breakAround: true,
        inParMode: true,
        namedArguments: ["starred", "tocTitle", "title"]
      }
    },
    appendix: { renderInfo: { breakAround: true, inParMode: true } },
    frontmatter: { renderInfo: { breakAround: true, inParMode: true } },
    mainmatter: { renderInfo: { breakAround: true, inParMode: true } },
    backmatter: { renderInfo: { breakAround: true, inParMode: true } },
    // Citing and references
    bibitem: { signature: "o m", renderInfo: { hangingIndent: true } },
    cite: { signature: "o m" },
    // Fonts
    textrm: { signature: "m", renderInfo: { inParMode: true } },
    textit: { signature: "m", renderInfo: { inParMode: true } },
    textmd: { signature: "m", renderInfo: { inParMode: true } },
    textbf: { signature: "m", renderInfo: { inParMode: true } },
    textup: { signature: "m", renderInfo: { inParMode: true } },
    textsl: { signature: "m", renderInfo: { inParMode: true } },
    textsf: { signature: "m", renderInfo: { inParMode: true } },
    textsc: { signature: "m", renderInfo: { inParMode: true } },
    texttt: { signature: "m", renderInfo: { inParMode: true } },
    underline: { signature: "m", renderInfo: { inParMode: true } },
    emph: { signature: "m", renderInfo: { inParMode: true } },
    textnormal: { signature: "m", renderInfo: { inParMode: true } },
    uppercase: { signature: "m", renderInfo: { inParMode: true } },
    mathbf: { signature: "m" },
    mathsf: { signature: "m" },
    mathtt: { signature: "m" },
    mathit: { signature: "m" },
    mathnormal: { signature: "m" },
    mathcal: { signature: "m" },
    mathrm: { signature: "m" },
    // Other
    setlength: { signature: "m m", renderInfo: { breakAround: true } },
    ref: { signature: "s m" },
    label: { signature: "o m" },
    // cleveref changes \label to have this signature
    printbibliography: { renderInfo: { breakAround: true } },
    addtocontents: { signature: "m m", renderInfo: { breakAround: true } },
    addcontentsline: { signature: "m m m", renderInfo: { breakAround: true } },
    contentsline: { signature: "m m m", renderInfo: { breakAround: true } },
    bibliography: { signature: "m", renderInfo: { breakAround: true } },
    bibliographystyle: { signature: "m", renderInfo: { breakAround: true } }
  };
  const environments$a = {
    document: {
      processContent: (nodes) => {
        trim(nodes);
        return nodes;
      }
    },
    array: { signature: "o m", renderInfo: { alignContent: true } },
    description: { signature: "o", processContent: cleanEnumerateBody },
    enumerate: {
      signature: "o",
      processContent: cleanEnumerateBody,
      renderInfo: { pgfkeysArgs: true }
    },
    itemize: { signature: "o", processContent: cleanEnumerateBody },
    trivlist: { signature: "o", processContent: cleanEnumerateBody },
    list: { signature: "m m", processContent: cleanEnumerateBody },
    figure: { signature: "o" },
    "figure*": { signature: "o" },
    filecontents: { signature: "o m" },
    "filecontents*": { signature: "o m" },
    minipage: { signature: "o o o m" },
    picture: { signature: "r() d()" },
    tabbing: { renderInfo: { alignContent: true } },
    table: { signature: "o" },
    tabular: { signature: "o m", renderInfo: { alignContent: true } },
    "tabular*": { signature: "m o m", renderInfo: { alignContent: true } },
    thebibliography: {
      signature: "m",
      processContent: (nodes) => cleanEnumerateBody(nodes, "bibitem")
    },
    // Math
    math: { renderInfo: { inMathMode: true } }
  };
  const argSpecM$1 = parse$6("m")[0];
  const argSpecO$1 = parse$6("o")[0];
  const argSpecRDelim$1 = {};
  const argumentParser$1 = (nodes, startPos) => {
    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecO$1, startPos);
    let codeArg = null;
    let codeArgNodesRemoved = 0;
    const nextNode = nodes[startPos];
    if (match.group(nextNode)) {
      const mandatoryArg = gobbleSingleArgument(nodes, argSpecM$1, startPos);
      codeArg = mandatoryArg.argument;
      codeArgNodesRemoved = mandatoryArg.nodesRemoved;
    } else if (match.string(nextNode) && nextNode.content.length === 1) {
      const delim = nextNode.content;
      argSpecRDelim$1[delim] = argSpecRDelim$1[delim] || parse$6(`r${delim}${delim}`)[0];
      const delimArg = gobbleSingleArgument(
        nodes,
        argSpecRDelim$1[delim],
        startPos
      );
      codeArg = delimArg.argument;
      codeArgNodesRemoved = delimArg.nodesRemoved;
    }
    return {
      args: [optionalArg || arg(null), codeArg || arg(null)],
      nodesRemoved: optionalArgNodesRemoved + codeArgNodesRemoved
    };
  };
  const macros$9 = {
    lstset: { signature: "m" },
    lstinline: { argumentParser: argumentParser$1 },
    lstinputlisting: { signature: "o m" },
    lstdefinestyle: { signature: "m m" },
    lstnewenvironment: { signature: "m o o m m" },
    lstMakeShortInline: { signature: "o m" },
    lstDeleteShortInline: { signature: "m" },
    lstdefineformat: { signature: "m m" },
    lstdefinelanguage: { signature: "o m o m o" },
    lstalias: { signature: "o m o m" },
    lstloadlanguages: { signature: "m" }
  };
  const environments$9 = {};
  const macros$8 = {
    see: { signature: "m m" },
    seealso: { signature: "m m" },
    seename: { signature: "m" },
    alsoname: { signature: "m" },
    index: { signature: "m" }
  };
  const environments$8 = {};
  const macros$7 = {
    mathtoolsset: {
      signature: "m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    mathllap: {
      signature: "o m"
    },
    mathrlap: {
      signature: "o m"
    },
    mathclap: {
      signature: "o m"
    },
    clap: {
      signature: "m"
    },
    mathmbox: {
      signature: "m"
    },
    mathmakebox: {
      signature: "o o m"
    },
    cramped: {
      signature: "o m"
    },
    crampedllap: {
      signature: "o m"
    },
    crampedrlap: {
      signature: "o m"
    },
    crampedclap: {
      signature: "o m"
    },
    crampedsubstack: {
      signature: "o m"
    },
    smashoperator: {
      signature: "o m"
    },
    newtagform: {
      signature: "m o m m"
    },
    renewtagform: {
      signature: "m o m m"
    },
    usetagform: {
      signature: "m"
    },
    xleftrightarrow: { signature: "o m" },
    xLeftarrow: { signature: "o m" },
    xhookleftarrow: { signature: "o m" },
    xmapsto: { signature: "o m" },
    xRightarrow: { signature: "o m" },
    xLeftrightarrow: { signature: "o m" },
    xhookrightarrow: { signature: "o m" },
    underbracket: { signature: "o o m" },
    overbracket: { signature: "o o m" },
    underbrace: { signature: "m" },
    overbrace: { signature: "m" },
    shoveleft: { signature: "o m" },
    shoveright: { signature: "o m" },
    ArrowBetweenLines: { signature: "s o" },
    vdotswithin: { signature: "m" },
    shortdotswithin: { signature: "s m" },
    DeclarePairedDelimiter: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    DeclarePairedDelimiterX: {
      signature: "m o m m m",
      renderInfo: { breakAround: true }
    },
    DeclarePairedDelimiterXPP: {
      signature: "m o m m m m m",
      renderInfo: { breakAround: true }
    },
    prescript: { signature: "m m m" },
    DeclareMathSizes: { signature: "m m m m" },
    newgathered: { signature: "m m m m" },
    renewgathered: { signature: "m m m m" },
    splitfrac: { signature: "m m" },
    splitdfrac: { signature: "m m" },
    xmathstrut: { signature: "o m" },
    // amsthm
    newtheorem: { signature: "s m o m o", renderInfo: { breakAround: true } },
    theoremstyle: { signature: "m", renderInfo: { breakAround: true } },
    newtheoremstyle: {
      signature: "m m m m m m m m m",
      renderInfo: { breakAround: true }
    },
    // amsmath
    text: { signature: "m", renderInfo: { inMathMode: false } },
    // amsfonts
    mathbb: { signature: "m" },
    mathscr: { signature: "m" },
    mathfrak: { signature: "m" },
    frak: { signature: "m" },
    Bdd: { signature: "m" },
    bold: { signature: "m" },
    // amsopn
    operatorname: { signature: "s m" },
    DeclareMathOperator: {
      signature: "s m m",
      renderInfo: { breakAround: true }
    }
  };
  const environments$7 = {
    crampedsubarray: {
      signature: "m",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    matrix: { renderInfo: { alignContent: true, inMathMode: true } },
    bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
    "matrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "bmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "pmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "vmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "Bmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "Vmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "smallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "psmallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "bsmallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "vsmallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "Bsmallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    "Vsmallmatrix*": {
      signature: "o",
      renderInfo: { alignContent: true, inMathMode: true }
    },
    multilined: { signature: "o o", renderInfo: { inMathMode: true } },
    cases: { renderInfo: { alignContent: true, inMathMode: true } },
    "cases*": { renderInfo: { alignContent: true, inMathMode: true } },
    dcases: { renderInfo: { alignContent: true, inMathMode: true } },
    "dcases*": { renderInfo: { alignContent: true, inMathMode: true } },
    rcases: { renderInfo: { alignContent: true, inMathMode: true } },
    "rcases*": { renderInfo: { alignContent: true, inMathMode: true } },
    drcases: { renderInfo: { alignContent: true, inMathMode: true } },
    "drcases*": { renderInfo: { alignContent: true, inMathMode: true } },
    spreadlines: { signature: "m", renderInfo: { inMathMode: true } },
    lgathered: { signature: "o", renderInfo: { inMathMode: true } },
    rgathered: { signature: "o", renderInfo: { inMathMode: true } },
    // amsmath
    "align*": { renderInfo: { inMathMode: true, alignContent: true } },
    align: { renderInfo: { inMathMode: true, alignContent: true } },
    aligned: { renderInfo: { inMathMode: true, alignContent: true } },
    "alignat*": { renderInfo: { inMathMode: true, alignContent: true } },
    alignat: { renderInfo: { inMathMode: true, alignContent: true } },
    "equation*": { renderInfo: { inMathMode: true } },
    equation: { renderInfo: { inMathMode: true } },
    "gather*": { renderInfo: { inMathMode: true } },
    gather: { renderInfo: { inMathMode: true } },
    "multline*": { renderInfo: { inMathMode: true } },
    multline: { renderInfo: { inMathMode: true } },
    "flalign*": { renderInfo: { inMathMode: true, alignContent: true } },
    flalign: { renderInfo: { inMathMode: true, alignContent: true } },
    split: { renderInfo: { inMathMode: true } },
    // Math environments
    displaymath: { renderInfo: { inMathMode: true } },
    // Typical amsthm environments
    theorem: { signature: "o" },
    lemma: { signature: "o" },
    definition: { signature: "o" },
    proposition: { signature: "o" },
    corollary: { signature: "o" },
    remark: { signature: "!o" },
    example: { signature: "!o" },
    proof: { signature: "o" }
  };
  const argSpecM = parse$6("m")[0];
  const argSpecO = parse$6("o")[0];
  const argSpecRDelim = {};
  const argumentParser = (nodes, startPos) => {
    const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecO, startPos);
    const { argument: languageArg, nodesRemoved: languageArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecM, startPos);
    let codeArg = null;
    let codeArgNodesRemoved = 0;
    const nextNode = nodes[startPos];
    if (match.group(nextNode)) {
      const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);
      codeArg = mandatoryArg.argument;
      codeArgNodesRemoved = mandatoryArg.nodesRemoved;
    } else if (match.string(nextNode) && nextNode.content.length === 1) {
      const delim = nextNode.content;
      argSpecRDelim[delim] = argSpecRDelim[delim] || parse$6(`r${delim}${delim}`)[0];
      const delimArg = gobbleSingleArgument(
        nodes,
        argSpecRDelim[delim],
        startPos
      );
      codeArg = delimArg.argument;
      codeArgNodesRemoved = delimArg.nodesRemoved;
    }
    return {
      args: [
        optionalArg || arg(null),
        languageArg || arg(null),
        codeArg || arg(null)
      ],
      nodesRemoved: optionalArgNodesRemoved + languageArgNodesRemoved + codeArgNodesRemoved
    };
  };
  const macros$6 = {
    mint: { argumentParser },
    mintinline: { argumentParser },
    inputminted: { argumentParser },
    usemintedstyle: { signature: "m" },
    setminted: { signature: "o m" },
    setmintedinline: { signature: "o m" },
    newmint: { signature: "o m m" },
    newminted: { signature: "o m m" },
    newmintinline: { signature: "o m m" },
    newmintedfile: { signature: "o m m" }
  };
  const environments$6 = {
    minted: { signature: "o m" }
  };
  const macros$5 = {
    NiceMatrixOptions: {
      signature: "m",
      renderInfo: { pgfkeysArgs: true, breakAround: true }
    }
  };
  const environments$5 = {
    NiceTabular: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    NiceMatrixBlock: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    NiceArrayWithDelims: {
      signature: "m m o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    NiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    pNiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    bNiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    BNiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    vNiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    VNiceArray: {
      signature: "o m !o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    NiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    pNiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    bNiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    BNiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    vNiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    },
    VNiceMatrix: {
      signature: "!o",
      renderInfo: { pgfkeysArgs: true, alignContent: true }
    }
  };
  const macros$4 = {
    systeme: {
      signature: "s o o m",
      renderInfo: { inMathMode: true }
    },
    sysdelim: {
      signature: "m m"
    },
    syseqsep: { signature: "m" },
    sysalign: { signature: "m" },
    syssignspace: { signature: "m" },
    syseqspace: { signature: "m" },
    syslineskipcoeff: { signature: "m" },
    syseqivsign: { signature: "m" },
    sysaddeqsign: { signature: "m" },
    sysremoveeqsign: { signature: "m" },
    sysextracolonsign: { signature: "m" },
    syscodeextracol: { signature: "m" },
    sysautonum: { signature: "m" },
    syssubstitute: { signature: "m" }
  };
  const environments$4 = {};
  (function() {
    if (typeof globalThis === "object") {
      return;
    }
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
      // This makes it possible to `delete` the getter later.
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  })();
  const clone$1 = typeof globalThis.structuredClone === "function" ? globalThis.structuredClone : (obj) => JSON.parse(JSON.stringify(obj));
  function structuredClone$3(obj) {
    return clone$1(obj);
  }
  function deleteComments(ast2) {
    return replaceNode(ast2, (node2) => {
      if (!match.comment(node2)) {
        return;
      }
      if (node2.leadingWhitespace) {
        return { type: "whitespace" };
      }
      return null;
    });
  }
  var colorString$1 = { exports: {} };
  var colorName$1 = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  var simpleSwizzle = { exports: {} };
  var isArrayish$1 = function isArrayish2(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
  var isArrayish = isArrayish$1;
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle$1 = simpleSwizzle.exports = function swizzle2(args) {
    var results = [];
    for (var i = 0, len = args.length; i < len; i++) {
      var arg2 = args[i];
      if (isArrayish(arg2)) {
        results = concat.call(results, slice.call(arg2));
      } else {
        results.push(arg2);
      }
    }
    return results;
  };
  swizzle$1.wrap = function(fn) {
    return function() {
      return fn(swizzle$1(arguments));
    };
  };
  var simpleSwizzleExports = simpleSwizzle.exports;
  var colorNames = colorName$1;
  var swizzle = simpleSwizzleExports;
  var hasOwnProperty$1 = Object.hasOwnProperty;
  var reverseNames = /* @__PURE__ */ Object.create(null);
  for (var name$1 in colorNames) {
    if (hasOwnProperty$1.call(colorNames, name$1)) {
      reverseNames[colorNames[name$1]] = name$1;
    }
  }
  var cs = colorString$1.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string2) {
    var prefix2 = string2.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix2) {
      case "hsl":
        val = cs.get.hsl(string2);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string2);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string2);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string2) {
    if (!string2) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match2;
    var i;
    var hexAlpha;
    if (match2 = string2.match(hex2)) {
      hexAlpha = match2[2];
      match2 = match2[1];
      for (i = 0; i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match2.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match2 = string2.match(abbr)) {
      match2 = match2[1];
      hexAlpha = match2[3];
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match2[i] + match2[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match2 = string2.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match2[i + 1], 0);
      }
      if (match2[4]) {
        if (match2[5]) {
          rgb[3] = parseFloat(match2[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match2[4]);
        }
      }
    } else if (match2 = string2.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match2[i + 1]) * 2.55);
      }
      if (match2[4]) {
        if (match2[5]) {
          rgb[3] = parseFloat(match2[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match2[4]);
        }
      }
    } else if (match2 = string2.match(keyword)) {
      if (match2[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty$1.call(colorNames, match2[1])) {
        return null;
      }
      rgb = colorNames[match2[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string2) {
    if (!string2) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match2 = string2.match(hsl);
    if (match2) {
      var alpha = parseFloat(match2[4]);
      var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
      var s2 = clamp(parseFloat(match2[2]), 0, 100);
      var l = clamp(parseFloat(match2[3]), 0, 100);
      var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h2, s2, l, a2];
    }
    return null;
  };
  cs.get.hwb = function(string2) {
    if (!string2) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match2 = string2.match(hwb);
    if (match2) {
      var alpha = parseFloat(match2[4]);
      var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match2[2]), 0, 100);
      var b = clamp(parseFloat(match2[3]), 0, 100);
      var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h2, w, b, a2];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a2 = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a2 = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }
  var colorStringExports = colorString$1.exports;
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  const cssKeywords = colorName;
  const reverseKeywords = {};
  for (const key2 of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key2]] = key2;
  }
  const convert$7 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var conversions$2 = convert$7;
  for (const model of Object.keys(convert$7)) {
    if (!("channels" in convert$7[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$7[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$7[model].labels.length !== convert$7[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert$7[model];
    delete convert$7[model].channels;
    delete convert$7[model].labels;
    Object.defineProperty(convert$7[model], "channels", { value: channels });
    Object.defineProperty(convert$7[model], "labels", { value: labels });
  }
  convert$7.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h2;
    let s2;
    if (max === min) {
      h2 = 0;
    } else if (r === max) {
      h2 = (g - b) / delta;
    } else if (g === max) {
      h2 = 2 + (b - r) / delta;
    } else if (b === max) {
      h2 = 4 + (r - g) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert$7.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c2) {
      return (v - c2) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert$7.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h2 = convert$7.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h2, w * 100, b * 100];
  };
  convert$7.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c2 = (1 - r - k) / (1 - k) || 0;
    const m2 = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c2 * 100, m2 * 100, y * 100, k * 100];
  };
  function comparativeDistance(x2, y) {
    return (x2[0] - y[0]) ** 2 + (x2[1] - y[1]) ** 2 + (x2[2] - y[2]) ** 2;
  }
  convert$7.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value2 = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value2);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert$7.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert$7.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x2 = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x2 * 100, y * 100, z * 100];
  };
  convert$7.rgb.lab = function(rgb) {
    const xyz = convert$7.rgb.xyz(rgb);
    let x2 = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x2 /= 95.047;
    y /= 100;
    z /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a2 = 500 * (x2 - y);
    const b = 200 * (y - z);
    return [l, a2, b];
  };
  convert$7.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h2 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert$7.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s2) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert$7.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f = h2 - Math.floor(h2);
    const p2 = 255 * v * (1 - s2);
    const q2 = 255 * v * (1 - s2 * f);
    const t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p2];
      case 1:
        return [q2, v, p2];
      case 2:
        return [p2, v, t];
      case 3:
        return [p2, q2, v];
      case 4:
        return [t, p2, v];
      case 5:
        return [v, p2, q2];
    }
  };
  convert$7.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s2) * v;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h2, sl * 100, l * 100];
  };
  convert$7.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h2);
    const v = 1 - bl;
    f = 6 * h2 - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert$7.cmyk.rgb = function(cmyk) {
    const c2 = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c2 * (1 - k) + k);
    const g = 1 - Math.min(1, m2 * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert$7.xyz.rgb = function(xyz) {
    const x2 = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x2 * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x2 * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x2 * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert$7.xyz.lab = function(xyz) {
    let x2 = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x2 /= 95.047;
    y /= 100;
    z /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a2 = 500 * (x2 - y);
    const b = 200 * (y - z);
    return [l, a2, b];
  };
  convert$7.lab.xyz = function(lab) {
    const l = lab[0];
    const a2 = lab[1];
    const b = lab[2];
    let x2;
    let y;
    let z;
    y = (l + 16) / 116;
    x2 = a2 / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x22 = x2 ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x2 *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x2, y, z];
  };
  convert$7.lab.lch = function(lab) {
    const l = lab[0];
    const a2 = lab[1];
    const b = lab[2];
    let h2;
    const hr2 = Math.atan2(b, a2);
    h2 = hr2 * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c2 = Math.sqrt(a2 * a2 + b * b);
    return [l, c2, h2];
  };
  convert$7.lch.lab = function(lch) {
    const l = lch[0];
    const c2 = lch[1];
    const h2 = lch[2];
    const hr2 = h2 / 360 * 2 * Math.PI;
    const a2 = c2 * Math.cos(hr2);
    const b = c2 * Math.sin(hr2);
    return [l, a2, b];
  };
  convert$7.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value2 = saturation === null ? convert$7.rgb.hsv(args)[2] : saturation;
    value2 = Math.round(value2 / 50);
    if (value2 === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value2 === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert$7.hsv.ansi16 = function(args) {
    return convert$7.rgb.ansi16(convert$7.hsv.rgb(args), args[2]);
  };
  convert$7.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert$7.ansi16.rgb = function(args) {
    let color2 = args % 10;
    if (color2 === 0 || color2 === 7) {
      if (args > 50) {
        color2 += 3.5;
      }
      color2 = color2 / 10.5 * 255;
      return [color2, color2, color2];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color2 & 1) * mult * 255;
    const g = (color2 >> 1 & 1) * mult * 255;
    const b = (color2 >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert$7.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c2 = (args - 232) * 10 + 8;
      return [c2, c2, c2];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert$7.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert$7.hex.rgb = function(args) {
    const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match2) {
      return [0, 0, 0];
    }
    let colorString2 = match2[0];
    if (match2[0].length === 3) {
      colorString2 = colorString2.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString2, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert$7.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert$7.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c2 = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
    let f = 0;
    if (c2 < 1) {
      f = (l - 0.5 * c2) / (1 - c2);
    }
    return [hsl[0], c2 * 100, f * 100];
  };
  convert$7.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c2 = s2 * v;
    let f = 0;
    if (c2 < 1) {
      f = (v - c2) / (1 - c2);
    }
    return [hsv[0], c2 * 100, f * 100];
  };
  convert$7.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c2 = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c2 === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg2 = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg2 = (1 - c2) * g;
    return [
      (c2 * pure[0] + mg2) * 255,
      (c2 * pure[1] + mg2) * 255,
      (c2 * pure[2] + mg2) * 255
    ];
  };
  convert$7.hcg.hsv = function(hcg) {
    const c2 = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c2 + g * (1 - c2);
    let f = 0;
    if (v > 0) {
      f = c2 / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert$7.hcg.hsl = function(hcg) {
    const c2 = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c2) + 0.5 * c2;
    let s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c2 / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c2 / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert$7.hcg.hwb = function(hcg) {
    const c2 = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c2 + g * (1 - c2);
    return [hcg[0], (v - c2) * 100, (1 - v) * 100];
  };
  convert$7.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c2 = v - w;
    let g = 0;
    if (c2 < 1) {
      g = (v - c2) / (1 - c2);
    }
    return [hwb[0], c2 * 100, g * 100];
  };
  convert$7.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert$7.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert$7.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert$7.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert$7.gray.hsv = convert$7.gray.hsl;
  convert$7.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert$7.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert$7.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert$7.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert$7.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions$1);
    for (let len = models2.length, i = 0; i < len; i++) {
      graph[models2[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions$1[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link$2(from, to2) {
    return function(args) {
      return to2(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions$1[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link$2(conversions$1[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  var route$1 = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for (let len = models2.length, i = 0; i < len; i++) {
      const toModel = models2[i];
      const node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  const conversions = conversions$2;
  const route = route$1;
  const convert$6 = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert$6[fromModel] = {};
    Object.defineProperty(convert$6[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert$6[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert$6[fromModel][toModel] = wrapRounded(fn);
      convert$6[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert$6;
  const colorString = colorStringExports;
  const convert$5 = colorConvert;
  const skippedModels = [
    // To be honest, I don't really feel like keyword belongs in color convert, but eh.
    "keyword",
    // Gray conflicts with some method names, and has its own method defined.
    "gray",
    // Shouldn't really be in color-convert either...
    "hex"
  ];
  const hashedModelKeys = {};
  for (const model of Object.keys(convert$5)) {
    hashedModelKeys[[...convert$5[model].labels].sort().join("")] = model;
  }
  const limiters = {};
  function Color(object2, model) {
    if (!(this instanceof Color)) {
      return new Color(object2, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert$5)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object2 == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object2 instanceof Color) {
      this.model = object2.model;
      this.color = [...object2.color];
      this.valpha = object2.valpha;
    } else if (typeof object2 === "string") {
      const result = colorString.get(object2);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object2);
      }
      this.model = result.model;
      channels = convert$5[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object2.length > 0) {
      this.model = model || "rgb";
      channels = convert$5[this.model].channels;
      const newArray = Array.prototype.slice.call(object2, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object2[channels] === "number" ? object2[channels] : 1;
    } else if (typeof object2 === "number") {
      this.model = "rgb";
      this.color = [
        object2 >> 16 & 255,
        object2 >> 8 & 255,
        object2 & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys2 = Object.keys(object2);
      if ("alpha" in object2) {
        keys2.splice(keys2.indexOf("alpha"), 1);
        this.valpha = typeof object2.alpha === "number" ? object2.alpha : 0;
      }
      const hashedKeys = keys2.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object2));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = convert$5[this.model];
      const color2 = [];
      for (i = 0; i < labels.length; i++) {
        color2.push(object2[labels[i]]);
      }
      this.color = zeroArray(color2);
    }
    if (limiters[this.model]) {
      channels = convert$5[this.model].channels;
      for (i = 0; i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to[self2.model](args);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = convert$5[this.model];
      const { labels } = convert$5[this.model];
      for (let i = 0; i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value2) {
      if (value2 !== void 0) {
        return new Color([...this.color, Math.max(0, Math.min(1, value2))], this.model);
      }
      return this.valpha;
    },
    // Rgb
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value2) => (value2 % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value2) {
      if (value2 !== void 0) {
        return new Color(value2);
      }
      return convert$5[this.model].keyword(this.color);
    },
    hex(value2) {
      if (value2 !== void 0) {
        return new Color(value2);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value2) {
      if (value2 !== void 0) {
        return new Color(value2);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element2] of rgb.entries()) {
        const chan = element2 / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0; i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value2 = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value2, value2, value2);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p2 = weight === void 0 ? 0.5 : weight;
      const w = 2 * p2 - 1;
      const a2 = color1.alpha() - color2.alpha();
      const w1 = ((w * a2 === -1 ? w : (w + a2) / (1 + w * a2)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(
        w1 * color1.red() + w2 * color2.red(),
        w1 * color1.green() + w2 * color2.green(),
        w1 * color1.blue() + w2 * color2.blue(),
        color1.alpha() * p2 + color2.alpha() * (1 - p2)
      );
    }
  };
  for (const model of Object.keys(convert$5)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = convert$5[model];
    Color.prototype[model] = function(...args) {
      if (this.model === model) {
        return new Color(this);
      }
      if (args.length > 0) {
        return new Color(args, model);
      }
      return new Color([...assertArray(convert$5[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color[model] = function(...args) {
      let color2 = args[0];
      if (typeof color2 === "number") {
        color2 = zeroArray(args, channels);
      }
      return new Color(color2, model);
    };
  }
  function roundTo(number2, places) {
    return Number(number2.toFixed(places));
  }
  function roundToPlace(places) {
    return function(number2) {
      return roundTo(number2, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m2 of model) {
      (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
    }
    model = model[0];
    return function(value2) {
      let result;
      if (value2 !== void 0) {
        if (modifier) {
          value2 = modifier(value2);
        }
        result = this[model]();
        result.color[channel] = value2;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value2) {
    return Array.isArray(value2) ? value2 : [value2];
  }
  function zeroArray(array, length) {
    for (let i = 0; i < length; i++) {
      if (typeof array[i] !== "number") {
        array[i] = 0;
      }
    }
    return array;
  }
  var color$2 = Color;
  var Color$1 = /* @__PURE__ */ getDefaultExportFromCjs(color$2);
  const macros$3 = {
    substitutecolormodel: {
      signature: "m m",
      renderInfo: { breakAround: true }
    },
    selectcolormodel: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    definecolor: {
      signature: "o m m m",
      renderInfo: { breakAround: true }
    },
    providecolor: {
      signature: "o m m m",
      renderInfo: { breakAround: true }
    },
    colorlet: {
      signature: "o m o m",
      renderInfo: { breakAround: true }
    },
    definecolorset: {
      signature: "o m m m",
      renderInfo: { breakAround: true }
    },
    providecolorset: {
      signature: "o m m m m",
      renderInfo: { breakAround: true }
    },
    preparecolor: {
      signature: "o m m m",
      renderInfo: { breakAround: true }
    },
    preparecolorset: {
      signature: "o m m m m",
      renderInfo: { breakAround: true }
    },
    DefineNamedColor: {
      signature: "m m m m",
      renderInfo: { breakAround: true }
    },
    definecolors: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    providecolors: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    color: { signature: "o m", renderInfo: { breakAround: true } },
    textcolor: { signature: "o m m", renderInfo: { inParMode: true } },
    pagecolor: { signature: "o m" },
    colorbox: { signature: "o m m" },
    fcolorbox: { signature: "o m o m m" },
    boxframe: { signature: "o m" },
    testcolor: { signature: "o m" },
    blendcolors: { signature: "s m" },
    maskcolors: { signature: "o m" },
    definecolorseries: {
      signature: "m m m o m o m",
      renderInfo: { breakAround: true }
    },
    resetcolorseries: {
      signature: "o m",
      renderInfo: { breakAround: true }
    },
    rowcolors: { signature: "s o m m m" },
    extractcolorspec: { signature: "m m" },
    extractcolorspecs: { signature: "m m m" },
    convertcolorspec: { signature: "m m m m" }
  };
  const environments$3 = {
    testcolors: { signature: "o", renderInfo: { pgfkeysArgs: true } }
  };
  const fromRgb = ([r, g, b]) => Color$1([r * 255, g * 255, b * 255], "rgb");
  const DVI_PS_NAMES = {
    Apricot: Color$1("#FBB982"),
    Aquamarine: Color$1("#00B5BE"),
    Bittersweet: Color$1("#C04F17"),
    Black: Color$1("#221E1F"),
    Blue: Color$1("#2D2F92"),
    BlueGreen: Color$1("#00B3B8"),
    BlueViolet: Color$1("#473992"),
    BrickRed: Color$1("#B6321C"),
    Brown: Color$1("#792500"),
    BurntOrange: Color$1("#F7921D"),
    CadetBlue: Color$1("#74729A"),
    CarnationPink: Color$1("#F282B4"),
    Cerulean: Color$1("#00A2E3"),
    CornflowerBlue: Color$1("#41B0E4"),
    Cyan: Color$1("#00AEEF"),
    Dandelion: Color$1("#FDBC42"),
    DarkOrchid: Color$1("#A4538A"),
    Emerald: Color$1("#00A99D"),
    ForestGreen: Color$1("#009B55"),
    Fuchsia: Color$1("#8C368C"),
    Goldenrod: Color$1("#FFDF42"),
    Gray: Color$1("#949698"),
    Green: Color$1("#00A64F"),
    GreenYellow: Color$1("#DFE674"),
    JungleGreen: Color$1("#00A99A"),
    Lavender: Color$1("#F49EC4"),
    LimeGreen: Color$1("#8DC73E"),
    Magenta: Color$1("#EC008C"),
    Mahogany: Color$1("#A9341F"),
    Maroon: Color$1("#AF3235"),
    Melon: Color$1("#F89E7B"),
    MidnightBlue: Color$1("#006795"),
    Mulberry: Color$1("#A93C93"),
    NavyBlue: Color$1("#006EB8"),
    OliveGreen: Color$1("#3C8031"),
    Orange: Color$1("#F58137"),
    OrangeRed: Color$1("#ED135A"),
    Orchid: Color$1("#AF72B0"),
    Peach: Color$1("#F7965A"),
    Periwinkle: Color$1("#7977B8"),
    PineGreen: Color$1("#008B72"),
    Plum: Color$1("#92268F"),
    ProcessBlue: Color$1("#00B0F0"),
    Purple: Color$1("#99479B"),
    RawSienna: Color$1("#974006"),
    Red: Color$1("#ED1B23"),
    RedOrange: Color$1("#F26035"),
    RedViolet: Color$1("#A1246B"),
    Rhodamine: Color$1("#EF559F"),
    RoyalBlue: Color$1("#0071BC"),
    RoyalPurple: Color$1("#613F99"),
    RubineRed: Color$1("#ED017D"),
    Salmon: Color$1("#F69289"),
    SeaGreen: Color$1("#3FBC9D"),
    Sepia: Color$1("#671800"),
    SkyBlue: Color$1("#46C5DD"),
    SpringGreen: Color$1("#C6DC67"),
    Tan: Color$1("#DA9D76"),
    TealBlue: Color$1("#00AEB3"),
    Thistle: Color$1("#D883B7"),
    Turquoise: Color$1("#00B4CE"),
    Violet: Color$1("#58429B"),
    VioletRed: Color$1("#EF58A0"),
    White: Color$1("#FFFFFF"),
    WildStrawberry: Color$1("#EE2967"),
    Yellow: Color$1("#FFF200"),
    YellowGreen: Color$1("#98CC70"),
    YellowOrange: Color$1("#FAA21A")
  };
  const SVG_NAMES = {
    AliceBlue: fromRgb([0.94, 0.972, 1]),
    AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),
    Aqua: fromRgb([0, 1, 1]),
    Aquamarine: fromRgb([0.498, 1, 0.83]),
    Azure: fromRgb([0.94, 1, 1]),
    Beige: fromRgb([0.96, 0.96, 0.864]),
    Bisque: fromRgb([1, 0.894, 0.77]),
    Black: fromRgb([0, 0, 0]),
    BlanchedAlmond: fromRgb([1, 0.92, 0.804]),
    Blue: fromRgb([0, 0, 1]),
    BlueViolet: fromRgb([0.54, 0.17, 0.888]),
    Brown: fromRgb([0.648, 0.165, 0.165]),
    BurlyWood: fromRgb([0.87, 0.72, 0.53]),
    CadetBlue: fromRgb([0.372, 0.62, 0.628]),
    Chartreuse: fromRgb([0.498, 1, 0]),
    Chocolate: fromRgb([0.824, 0.41, 0.116]),
    Coral: fromRgb([1, 0.498, 0.312]),
    CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),
    Cornsilk: fromRgb([1, 0.972, 0.864]),
    Crimson: fromRgb([0.864, 0.08, 0.235]),
    Cyan: fromRgb([0, 1, 1]),
    DarkBlue: fromRgb([0, 0, 0.545]),
    DarkCyan: fromRgb([0, 0.545, 0.545]),
    DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),
    DarkGray: fromRgb([0.664, 0.664, 0.664]),
    DarkGreen: fromRgb([0, 0.392, 0]),
    DarkGrey: fromRgb([0.664, 0.664, 0.664]),
    DarkKhaki: fromRgb([0.74, 0.716, 0.42]),
    DarkMagenta: fromRgb([0.545, 0, 0.545]),
    DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),
    DarkOrange: fromRgb([1, 0.55, 0]),
    DarkOrchid: fromRgb([0.6, 0.196, 0.8]),
    DarkRed: fromRgb([0.545, 0, 0]),
    DarkSalmon: fromRgb([0.912, 0.59, 0.48]),
    DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),
    DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),
    DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),
    DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),
    DarkTurquoise: fromRgb([0, 0.808, 0.82]),
    DarkViolet: fromRgb([0.58, 0, 0.828]),
    DeepPink: fromRgb([1, 0.08, 0.576]),
    DeepSkyBlue: fromRgb([0, 0.75, 1]),
    DimGray: fromRgb([0.41, 0.41, 0.41]),
    DimGrey: fromRgb([0.41, 0.41, 0.41]),
    DodgerBlue: fromRgb([0.116, 0.565, 1]),
    FireBrick: fromRgb([0.698, 0.132, 0.132]),
    FloralWhite: fromRgb([1, 0.98, 0.94]),
    ForestGreen: fromRgb([0.132, 0.545, 0.132]),
    Fuchsia: fromRgb([1, 0, 1]),
    Gainsboro: fromRgb([0.864, 0.864, 0.864]),
    GhostWhite: fromRgb([0.972, 0.972, 1]),
    Gold: fromRgb([1, 0.844, 0]),
    Goldenrod: fromRgb([0.855, 0.648, 0.125]),
    Gray: fromRgb([0.5, 0.5, 0.5]),
    Green: fromRgb([0, 0.5, 0]),
    GreenYellow: fromRgb([0.68, 1, 0.185]),
    Grey: fromRgb([0.5, 0.5, 0.5]),
    Honeydew: fromRgb([0.94, 1, 0.94]),
    HotPink: fromRgb([1, 0.41, 0.705]),
    IndianRed: fromRgb([0.804, 0.36, 0.36]),
    Indigo: fromRgb([0.294, 0, 0.51]),
    Ivory: fromRgb([1, 1, 0.94]),
    Khaki: fromRgb([0.94, 0.9, 0.55]),
    Lavender: fromRgb([0.9, 0.9, 0.98]),
    LavenderBlush: fromRgb([1, 0.94, 0.96]),
    LawnGreen: fromRgb([0.488, 0.99, 0]),
    LemonChiffon: fromRgb([1, 0.98, 0.804]),
    LightBlue: fromRgb([0.68, 0.848, 0.9]),
    LightCoral: fromRgb([0.94, 0.5, 0.5]),
    LightCyan: fromRgb([0.88, 1, 1]),
    LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),
    LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),
    LightGray: fromRgb([0.828, 0.828, 0.828]),
    LightGreen: fromRgb([0.565, 0.932, 0.565]),
    LightGrey: fromRgb([0.828, 0.828, 0.828]),
    LightPink: fromRgb([1, 0.712, 0.756]),
    LightSalmon: fromRgb([1, 0.628, 0.48]),
    LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),
    LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),
    LightSlateBlue: fromRgb([0.518, 0.44, 1]),
    LightSlateGray: fromRgb([0.468, 0.532, 0.6]),
    LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),
    LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),
    LightYellow: fromRgb([1, 1, 0.88]),
    Lime: fromRgb([0, 1, 0]),
    LimeGreen: fromRgb([0.196, 0.804, 0.196]),
    Linen: fromRgb([0.98, 0.94, 0.9]),
    Magenta: fromRgb([1, 0, 1]),
    Maroon: fromRgb([0.5, 0, 0]),
    MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),
    MediumBlue: fromRgb([0, 0, 0.804]),
    MediumOrchid: fromRgb([0.73, 0.332, 0.828]),
    MediumPurple: fromRgb([0.576, 0.44, 0.86]),
    MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),
    MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),
    MediumSpringGreen: fromRgb([0, 0.98, 0.604]),
    MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),
    MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),
    MidnightBlue: fromRgb([0.098, 0.098, 0.44]),
    MintCream: fromRgb([0.96, 1, 0.98]),
    MistyRose: fromRgb([1, 0.894, 0.884]),
    Moccasin: fromRgb([1, 0.894, 0.71]),
    NavajoWhite: fromRgb([1, 0.87, 0.68]),
    Navy: fromRgb([0, 0, 0.5]),
    NavyBlue: fromRgb([0, 0, 0.5]),
    OldLace: fromRgb([0.992, 0.96, 0.9]),
    Olive: fromRgb([0.5, 0.5, 0]),
    OliveDrab: fromRgb([0.42, 0.556, 0.136]),
    Orange: fromRgb([1, 0.648, 0]),
    OrangeRed: fromRgb([1, 0.27, 0]),
    Orchid: fromRgb([0.855, 0.44, 0.84]),
    PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),
    PaleGreen: fromRgb([0.596, 0.985, 0.596]),
    PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),
    PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),
    PapayaWhip: fromRgb([1, 0.936, 0.835]),
    PeachPuff: fromRgb([1, 0.855, 0.725]),
    Peru: fromRgb([0.804, 0.52, 0.248]),
    Pink: fromRgb([1, 0.752, 0.796]),
    Plum: fromRgb([0.868, 0.628, 0.868]),
    PowderBlue: fromRgb([0.69, 0.88, 0.9]),
    Purple: fromRgb([0.5, 0, 0.5]),
    Red: fromRgb([1, 0, 0]),
    RosyBrown: fromRgb([0.736, 0.56, 0.56]),
    RoyalBlue: fromRgb([0.255, 0.41, 0.884]),
    SaddleBrown: fromRgb([0.545, 0.27, 0.075]),
    Salmon: fromRgb([0.98, 0.5, 0.448]),
    SandyBrown: fromRgb([0.956, 0.644, 0.376]),
    SeaGreen: fromRgb([0.18, 0.545, 0.34]),
    Seashell: fromRgb([1, 0.96, 0.932]),
    Sienna: fromRgb([0.628, 0.32, 0.176]),
    Silver: fromRgb([0.752, 0.752, 0.752]),
    SkyBlue: fromRgb([0.53, 0.808, 0.92]),
    SlateBlue: fromRgb([0.415, 0.352, 0.804]),
    SlateGray: fromRgb([0.44, 0.5, 0.565]),
    SlateGrey: fromRgb([0.44, 0.5, 0.565]),
    Snow: fromRgb([1, 0.98, 0.98]),
    SpringGreen: fromRgb([0, 1, 0.498]),
    SteelBlue: fromRgb([0.275, 0.51, 0.705]),
    Tan: fromRgb([0.824, 0.705, 0.55]),
    Teal: fromRgb([0, 0.5, 0.5]),
    Thistle: fromRgb([0.848, 0.75, 0.848]),
    Tomato: fromRgb([1, 0.39, 0.28]),
    Turquoise: fromRgb([0.25, 0.88, 0.815]),
    Violet: fromRgb([0.932, 0.51, 0.932]),
    VioletRed: fromRgb([0.816, 0.125, 0.565]),
    Wheat: fromRgb([0.96, 0.87, 0.7]),
    White: fromRgb([1, 1, 1]),
    WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),
    Yellow: fromRgb([1, 1, 0]),
    YellowGreen: fromRgb([0.604, 0.804, 0.196])
  };
  const X11_NAMES = {
    AntiqueWhite1: fromRgb([1, 0.936, 0.86]),
    AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),
    AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),
    AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),
    Aquamarine1: fromRgb([0.498, 1, 0.83]),
    Aquamarine2: fromRgb([0.464, 0.932, 0.776]),
    Aquamarine3: fromRgb([0.4, 0.804, 0.668]),
    Aquamarine4: fromRgb([0.27, 0.545, 0.455]),
    Azure1: fromRgb([0.94, 1, 1]),
    Azure2: fromRgb([0.88, 0.932, 0.932]),
    Azure3: fromRgb([0.756, 0.804, 0.804]),
    Azure4: fromRgb([0.512, 0.545, 0.545]),
    Bisque1: fromRgb([1, 0.894, 0.77]),
    Bisque2: fromRgb([0.932, 0.835, 0.716]),
    Bisque3: fromRgb([0.804, 0.716, 0.62]),
    Bisque4: fromRgb([0.545, 0.49, 0.42]),
    Blue1: fromRgb([0, 0, 1]),
    Blue2: fromRgb([0, 0, 0.932]),
    Blue3: fromRgb([0, 0, 0.804]),
    Blue4: fromRgb([0, 0, 0.545]),
    Brown1: fromRgb([1, 0.25, 0.25]),
    Brown2: fromRgb([0.932, 0.23, 0.23]),
    Brown3: fromRgb([0.804, 0.2, 0.2]),
    Brown4: fromRgb([0.545, 0.136, 0.136]),
    Burlywood1: fromRgb([1, 0.828, 0.608]),
    Burlywood2: fromRgb([0.932, 0.772, 0.57]),
    Burlywood3: fromRgb([0.804, 0.668, 0.49]),
    Burlywood4: fromRgb([0.545, 0.45, 0.332]),
    CadetBlue1: fromRgb([0.596, 0.96, 1]),
    CadetBlue2: fromRgb([0.556, 0.898, 0.932]),
    CadetBlue3: fromRgb([0.48, 0.772, 0.804]),
    CadetBlue4: fromRgb([0.325, 0.525, 0.545]),
    Chartreuse1: fromRgb([0.498, 1, 0]),
    Chartreuse2: fromRgb([0.464, 0.932, 0]),
    Chartreuse3: fromRgb([0.4, 0.804, 0]),
    Chartreuse4: fromRgb([0.27, 0.545, 0]),
    Chocolate1: fromRgb([1, 0.498, 0.14]),
    Chocolate2: fromRgb([0.932, 0.464, 0.13]),
    Chocolate3: fromRgb([0.804, 0.4, 0.112]),
    Chocolate4: fromRgb([0.545, 0.27, 0.075]),
    Coral1: fromRgb([1, 0.448, 0.336]),
    Coral2: fromRgb([0.932, 0.415, 0.312]),
    Coral3: fromRgb([0.804, 0.356, 0.27]),
    Coral4: fromRgb([0.545, 0.244, 0.185]),
    Cornsilk1: fromRgb([1, 0.972, 0.864]),
    Cornsilk2: fromRgb([0.932, 0.91, 0.804]),
    Cornsilk3: fromRgb([0.804, 0.785, 0.694]),
    Cornsilk4: fromRgb([0.545, 0.532, 0.47]),
    Cyan1: fromRgb([0, 1, 1]),
    Cyan2: fromRgb([0, 0.932, 0.932]),
    Cyan3: fromRgb([0, 0.804, 0.804]),
    Cyan4: fromRgb([0, 0.545, 0.545]),
    DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),
    DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),
    DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),
    DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),
    DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),
    DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),
    DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),
    DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),
    DarkOrange1: fromRgb([1, 0.498, 0]),
    DarkOrange2: fromRgb([0.932, 0.464, 0]),
    DarkOrange3: fromRgb([0.804, 0.4, 0]),
    DarkOrange4: fromRgb([0.545, 0.27, 0]),
    DarkOrchid1: fromRgb([0.75, 0.244, 1]),
    DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),
    DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),
    DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),
    DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),
    DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),
    DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),
    DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),
    DarkSlateGray1: fromRgb([0.592, 1, 1]),
    DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),
    DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),
    DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),
    DeepPink1: fromRgb([1, 0.08, 0.576]),
    DeepPink2: fromRgb([0.932, 0.07, 0.536]),
    DeepPink3: fromRgb([0.804, 0.064, 0.464]),
    DeepPink4: fromRgb([0.545, 0.04, 0.312]),
    DeepSkyBlue1: fromRgb([0, 0.75, 1]),
    DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),
    DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),
    DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),
    DodgerBlue1: fromRgb([0.116, 0.565, 1]),
    DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),
    DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),
    DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),
    Firebrick1: fromRgb([1, 0.19, 0.19]),
    Firebrick2: fromRgb([0.932, 0.172, 0.172]),
    Firebrick3: fromRgb([0.804, 0.15, 0.15]),
    Firebrick4: fromRgb([0.545, 0.1, 0.1]),
    Gold1: fromRgb([1, 0.844, 0]),
    Gold2: fromRgb([0.932, 0.79, 0]),
    Gold3: fromRgb([0.804, 0.68, 0]),
    Gold4: fromRgb([0.545, 0.46, 0]),
    Goldenrod1: fromRgb([1, 0.756, 0.145]),
    Goldenrod2: fromRgb([0.932, 0.705, 0.132]),
    Goldenrod3: fromRgb([0.804, 0.608, 0.112]),
    Goldenrod4: fromRgb([0.545, 0.41, 0.08]),
    Green1: fromRgb([0, 1, 0]),
    Green2: fromRgb([0, 0.932, 0]),
    Green3: fromRgb([0, 0.804, 0]),
    Green4: fromRgb([0, 0.545, 0]),
    Honeydew1: fromRgb([0.94, 1, 0.94]),
    Honeydew2: fromRgb([0.88, 0.932, 0.88]),
    Honeydew3: fromRgb([0.756, 0.804, 0.756]),
    Honeydew4: fromRgb([0.512, 0.545, 0.512]),
    HotPink1: fromRgb([1, 0.43, 0.705]),
    HotPink2: fromRgb([0.932, 0.415, 0.655]),
    HotPink3: fromRgb([0.804, 0.376, 0.565]),
    HotPink4: fromRgb([0.545, 0.228, 0.385]),
    IndianRed1: fromRgb([1, 0.415, 0.415]),
    IndianRed2: fromRgb([0.932, 0.39, 0.39]),
    IndianRed3: fromRgb([0.804, 0.332, 0.332]),
    IndianRed4: fromRgb([0.545, 0.228, 0.228]),
    Ivory1: fromRgb([1, 1, 0.94]),
    Ivory2: fromRgb([0.932, 0.932, 0.88]),
    Ivory3: fromRgb([0.804, 0.804, 0.756]),
    Ivory4: fromRgb([0.545, 0.545, 0.512]),
    Khaki1: fromRgb([1, 0.965, 0.56]),
    Khaki2: fromRgb([0.932, 0.9, 0.52]),
    Khaki3: fromRgb([0.804, 0.776, 0.45]),
    Khaki4: fromRgb([0.545, 0.525, 0.305]),
    LavenderBlush1: fromRgb([1, 0.94, 0.96]),
    LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),
    LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),
    LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),
    LemonChiffon1: fromRgb([1, 0.98, 0.804]),
    LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),
    LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),
    LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),
    LightBlue1: fromRgb([0.75, 0.936, 1]),
    LightBlue2: fromRgb([0.698, 0.875, 0.932]),
    LightBlue3: fromRgb([0.604, 0.752, 0.804]),
    LightBlue4: fromRgb([0.408, 0.512, 0.545]),
    LightCyan1: fromRgb([0.88, 1, 1]),
    LightCyan2: fromRgb([0.82, 0.932, 0.932]),
    LightCyan3: fromRgb([0.705, 0.804, 0.804]),
    LightCyan4: fromRgb([0.48, 0.545, 0.545]),
    LightGoldenrod1: fromRgb([1, 0.925, 0.545]),
    LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),
    LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),
    LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),
    LightPink1: fromRgb([1, 0.684, 0.725]),
    LightPink2: fromRgb([0.932, 0.635, 0.68]),
    LightPink3: fromRgb([0.804, 0.55, 0.585]),
    LightPink4: fromRgb([0.545, 0.372, 0.396]),
    LightSalmon1: fromRgb([1, 0.628, 0.48]),
    LightSalmon2: fromRgb([0.932, 0.585, 0.448]),
    LightSalmon3: fromRgb([0.804, 0.505, 0.385]),
    LightSalmon4: fromRgb([0.545, 0.34, 0.26]),
    LightSkyBlue1: fromRgb([0.69, 0.888, 1]),
    LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),
    LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),
    LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),
    LightSteelBlue1: fromRgb([0.792, 0.884, 1]),
    LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),
    LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),
    LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),
    LightYellow1: fromRgb([1, 1, 0.88]),
    LightYellow2: fromRgb([0.932, 0.932, 0.82]),
    LightYellow3: fromRgb([0.804, 0.804, 0.705]),
    LightYellow4: fromRgb([0.545, 0.545, 0.48]),
    Magenta1: fromRgb([1, 0, 1]),
    Magenta2: fromRgb([0.932, 0, 0.932]),
    Magenta3: fromRgb([0.804, 0, 0.804]),
    Magenta4: fromRgb([0.545, 0, 0.545]),
    Maroon1: fromRgb([1, 0.204, 0.7]),
    Maroon2: fromRgb([0.932, 0.19, 0.655]),
    Maroon3: fromRgb([0.804, 0.16, 0.565]),
    Maroon4: fromRgb([0.545, 0.11, 0.385]),
    MediumOrchid1: fromRgb([0.88, 0.4, 1]),
    MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),
    MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),
    MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),
    MediumPurple1: fromRgb([0.67, 0.51, 1]),
    MediumPurple2: fromRgb([0.624, 0.475, 0.932]),
    MediumPurple3: fromRgb([0.536, 0.408, 0.804]),
    MediumPurple4: fromRgb([0.365, 0.28, 0.545]),
    MistyRose1: fromRgb([1, 0.894, 0.884]),
    MistyRose2: fromRgb([0.932, 0.835, 0.824]),
    MistyRose3: fromRgb([0.804, 0.716, 0.71]),
    MistyRose4: fromRgb([0.545, 0.49, 0.484]),
    NavajoWhite1: fromRgb([1, 0.87, 0.68]),
    NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),
    NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),
    NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),
    OliveDrab1: fromRgb([0.752, 1, 0.244]),
    OliveDrab2: fromRgb([0.7, 0.932, 0.228]),
    OliveDrab3: fromRgb([0.604, 0.804, 0.196]),
    OliveDrab4: fromRgb([0.41, 0.545, 0.132]),
    Orange1: fromRgb([1, 0.648, 0]),
    Orange2: fromRgb([0.932, 0.604, 0]),
    Orange3: fromRgb([0.804, 0.52, 0]),
    Orange4: fromRgb([0.545, 0.352, 0]),
    OrangeRed1: fromRgb([1, 0.27, 0]),
    OrangeRed2: fromRgb([0.932, 0.25, 0]),
    OrangeRed3: fromRgb([0.804, 0.215, 0]),
    OrangeRed4: fromRgb([0.545, 0.145, 0]),
    Orchid1: fromRgb([1, 0.512, 0.98]),
    Orchid2: fromRgb([0.932, 0.48, 0.912]),
    Orchid3: fromRgb([0.804, 0.41, 0.79]),
    Orchid4: fromRgb([0.545, 0.28, 0.536]),
    PaleGreen1: fromRgb([0.604, 1, 0.604]),
    PaleGreen2: fromRgb([0.565, 0.932, 0.565]),
    PaleGreen3: fromRgb([0.488, 0.804, 0.488]),
    PaleGreen4: fromRgb([0.33, 0.545, 0.33]),
    PaleTurquoise1: fromRgb([0.732, 1, 1]),
    PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),
    PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),
    PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),
    PaleVioletRed1: fromRgb([1, 0.51, 0.67]),
    PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),
    PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),
    PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),
    PeachPuff1: fromRgb([1, 0.855, 0.725]),
    PeachPuff2: fromRgb([0.932, 0.796, 0.68]),
    PeachPuff3: fromRgb([0.804, 0.688, 0.585]),
    PeachPuff4: fromRgb([0.545, 0.468, 0.396]),
    Pink1: fromRgb([1, 0.71, 0.772]),
    Pink2: fromRgb([0.932, 0.664, 0.72]),
    Pink3: fromRgb([0.804, 0.57, 0.62]),
    Pink4: fromRgb([0.545, 0.39, 0.424]),
    Plum1: fromRgb([1, 0.732, 1]),
    Plum2: fromRgb([0.932, 0.684, 0.932]),
    Plum3: fromRgb([0.804, 0.59, 0.804]),
    Plum4: fromRgb([0.545, 0.4, 0.545]),
    Purple1: fromRgb([0.608, 0.19, 1]),
    Purple2: fromRgb([0.57, 0.172, 0.932]),
    Purple3: fromRgb([0.49, 0.15, 0.804]),
    Purple4: fromRgb([0.332, 0.1, 0.545]),
    Red1: fromRgb([1, 0, 0]),
    Red2: fromRgb([0.932, 0, 0]),
    Red3: fromRgb([0.804, 0, 0]),
    Red4: fromRgb([0.545, 0, 0]),
    RosyBrown1: fromRgb([1, 0.756, 0.756]),
    RosyBrown2: fromRgb([0.932, 0.705, 0.705]),
    RosyBrown3: fromRgb([0.804, 0.608, 0.608]),
    RosyBrown4: fromRgb([0.545, 0.41, 0.41]),
    RoyalBlue1: fromRgb([0.284, 0.464, 1]),
    RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),
    RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),
    RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),
    Salmon1: fromRgb([1, 0.55, 0.41]),
    Salmon2: fromRgb([0.932, 0.51, 0.385]),
    Salmon3: fromRgb([0.804, 0.44, 0.33]),
    Salmon4: fromRgb([0.545, 0.298, 0.224]),
    SeaGreen1: fromRgb([0.33, 1, 0.624]),
    SeaGreen2: fromRgb([0.305, 0.932, 0.58]),
    SeaGreen3: fromRgb([0.264, 0.804, 0.5]),
    SeaGreen4: fromRgb([0.18, 0.545, 0.34]),
    Seashell1: fromRgb([1, 0.96, 0.932]),
    Seashell2: fromRgb([0.932, 0.898, 0.87]),
    Seashell3: fromRgb([0.804, 0.772, 0.75]),
    Seashell4: fromRgb([0.545, 0.525, 0.51]),
    Sienna1: fromRgb([1, 0.51, 0.28]),
    Sienna2: fromRgb([0.932, 0.475, 0.26]),
    Sienna3: fromRgb([0.804, 0.408, 0.224]),
    Sienna4: fromRgb([0.545, 0.28, 0.15]),
    SkyBlue1: fromRgb([0.53, 0.808, 1]),
    SkyBlue2: fromRgb([0.494, 0.752, 0.932]),
    SkyBlue3: fromRgb([0.424, 0.65, 0.804]),
    SkyBlue4: fromRgb([0.29, 0.44, 0.545]),
    SlateBlue1: fromRgb([0.512, 0.435, 1]),
    SlateBlue2: fromRgb([0.48, 0.404, 0.932]),
    SlateBlue3: fromRgb([0.41, 0.35, 0.804]),
    SlateBlue4: fromRgb([0.28, 0.235, 0.545]),
    SlateGray1: fromRgb([0.776, 0.888, 1]),
    SlateGray2: fromRgb([0.725, 0.828, 0.932]),
    SlateGray3: fromRgb([0.624, 0.712, 0.804]),
    SlateGray4: fromRgb([0.424, 0.484, 0.545]),
    Snow1: fromRgb([1, 0.98, 0.98]),
    Snow2: fromRgb([0.932, 0.912, 0.912]),
    Snow3: fromRgb([0.804, 0.79, 0.79]),
    Snow4: fromRgb([0.545, 0.536, 0.536]),
    SpringGreen1: fromRgb([0, 1, 0.498]),
    SpringGreen2: fromRgb([0, 0.932, 0.464]),
    SpringGreen3: fromRgb([0, 0.804, 0.4]),
    SpringGreen4: fromRgb([0, 0.545, 0.27]),
    SteelBlue1: fromRgb([0.39, 0.72, 1]),
    SteelBlue2: fromRgb([0.36, 0.675, 0.932]),
    SteelBlue3: fromRgb([0.31, 0.58, 0.804]),
    SteelBlue4: fromRgb([0.21, 0.392, 0.545]),
    Tan1: fromRgb([1, 0.648, 0.31]),
    Tan2: fromRgb([0.932, 0.604, 0.288]),
    Tan3: fromRgb([0.804, 0.52, 0.248]),
    Tan4: fromRgb([0.545, 0.352, 0.17]),
    Thistle1: fromRgb([1, 0.884, 1]),
    Thistle2: fromRgb([0.932, 0.824, 0.932]),
    Thistle3: fromRgb([0.804, 0.71, 0.804]),
    Thistle4: fromRgb([0.545, 0.484, 0.545]),
    Tomato1: fromRgb([1, 0.39, 0.28]),
    Tomato2: fromRgb([0.932, 0.36, 0.26]),
    Tomato3: fromRgb([0.804, 0.31, 0.224]),
    Tomato4: fromRgb([0.545, 0.21, 0.15]),
    Turquoise1: fromRgb([0, 0.96, 1]),
    Turquoise2: fromRgb([0, 0.898, 0.932]),
    Turquoise3: fromRgb([0, 0.772, 0.804]),
    Turquoise4: fromRgb([0, 0.525, 0.545]),
    VioletRed1: fromRgb([1, 0.244, 0.59]),
    VioletRed2: fromRgb([0.932, 0.228, 0.55]),
    VioletRed3: fromRgb([0.804, 0.196, 0.47]),
    VioletRed4: fromRgb([0.545, 0.132, 0.32]),
    Wheat1: fromRgb([1, 0.905, 0.73]),
    Wheat2: fromRgb([0.932, 0.848, 0.684]),
    Wheat3: fromRgb([0.804, 0.73, 0.59]),
    Wheat4: fromRgb([0.545, 0.494, 0.4]),
    Yellow1: fromRgb([1, 1, 0]),
    Yellow2: fromRgb([0.932, 0.932, 0]),
    Yellow3: fromRgb([0.804, 0.804, 0]),
    Yellow4: fromRgb([0.545, 0.545, 0]),
    Gray0: fromRgb([0.745, 0.745, 0.745]),
    Green0: fromRgb([0, 1, 0]),
    Grey0: fromRgb([0.745, 0.745, 0.745]),
    Maroon0: fromRgb([0.69, 0.19, 0.376]),
    Purple0: fromRgb([0.628, 0.125, 0.94])
  };
  const parseCache$1 = {};
  function parse$4(str = "") {
    parseCache$1[str] = parseCache$1[str] || XColorPegParser.parse(str);
    return parseCache$1[str];
  }
  const CORE_MODELS = /* @__PURE__ */ new Set(["rgb", "cmy", "cmyk", "hsb", "gray"]);
  const XColorCoreModelToColor = {
    rgb: ([r, g, b]) => Color$1([r * 255, g * 255, b * 255], "rgb"),
    cmy: ([c2, m2, y]) => XColorCoreModelToColor.rgb([1 - c2, 1 - m2, 1 - y]),
    cmyk: ([c2, m2, y, k]) => Color$1([c2 * 255, m2 * 255, y * 255, k * 100], "cmyk"),
    hsb: ([h2, s2, b]) => Color$1([h2 * 360, s2 * 100, b * 100], "hsv"),
    gray: ([v]) => Color$1([v * 255, v * 255, v * 255], "rgb")
  };
  const XColorModelToColor = {
    wave: ([lambda]) => {
      const gamma = 0.8;
      let baseRgb = [0, 0, 0];
      if (380 <= lambda && lambda < 440) {
        baseRgb = [(440 - lambda) / (440 - 380), 0, 1];
      }
      if (440 <= lambda && lambda < 490) {
        baseRgb = [0, (lambda - 440) / (490 - 440), 1];
      }
      if (490 <= lambda && lambda < 510) {
        baseRgb = [0, 1, (510 - lambda) / (510 - 490)];
      }
      if (510 <= lambda && lambda < 580) {
        baseRgb = [(lambda - 510) / (580 - 510), 1, 0];
      }
      if (580 <= lambda && lambda < 6450) {
        baseRgb = [1, (645 - lambda) / (645 - 580), 0];
      }
      if (645 <= lambda && lambda <= 780) {
        baseRgb = [1, 0, 0];
      }
      let f = 1;
      if (380 <= lambda && 420 < lambda) {
        f = 0.3 + 0.7 * (lambda - 380) / (420 - 380);
      }
      if (700 < lambda && lambda <= 780) {
        f = 0.3 + 0.7 * (780 - lambda) / (780 - 700);
      }
      const rgb = [
        Math.pow(baseRgb[0] * f, gamma),
        Math.pow(baseRgb[1] * f, gamma),
        Math.pow(baseRgb[2] * f, gamma)
      ];
      return Color$1([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], "rgb");
    },
    Hsb: ([h2, s2, b]) => XColorCoreModelToColor.hsb([h2 / 360, s2, b]),
    HSB: ([h2, s2, b]) => XColorCoreModelToColor.hsb([h2 / 240, s2 / 240, b / 240]),
    HTML: ([v]) => v.startsWith("#") ? Color$1(v) : Color$1(`#${v}`),
    RGB: ([r, g, b]) => Color$1([r, g, b], "rgb"),
    Gray: ([v]) => XColorCoreModelToColor.gray([v / 15]),
    ...XColorCoreModelToColor
  };
  const ColorToXColorModel = {
    rgb: (color2) => color2.rgb().array().map((v) => v / 255),
    cmy: (color2) => [255 - color2.red(), 255 - color2.green(), 255 - color2.blue()].map(
      (v) => v / 255
    ),
    cmyk: (color2) => color2.cmyk().array().map((v, i) => i === 3 ? v / 100 : v / 255),
    hsb: (color2) => [
      color2.hue() / 360,
      color2.saturationv() / 100,
      color2.value() / 100
    ],
    gray: (color2) => [color2.gray() / 100]
  };
  const PREDEFINED_XCOLOR_COLORS = {
    // Core colors
    red: XColorCoreModelToColor.rgb([1, 0, 0]),
    green: XColorCoreModelToColor.rgb([0, 1, 0]),
    blue: XColorCoreModelToColor.rgb([0, 0, 1]),
    brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),
    lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),
    orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),
    pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),
    purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),
    teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),
    violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),
    cyan: XColorCoreModelToColor.rgb([0, 1, 1]),
    magenta: XColorCoreModelToColor.rgb([1, 0, 1]),
    yellow: XColorCoreModelToColor.rgb([1, 1, 0]),
    olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),
    black: XColorCoreModelToColor.rgb([0, 0, 0]),
    darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),
    gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),
    lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),
    white: XColorCoreModelToColor.rgb([1, 1, 1]),
    ...DVI_PS_NAMES,
    ...SVG_NAMES,
    ...X11_NAMES
  };
  function scalarMul(scalar, vec) {
    return vec.map((v) => scalar * v);
  }
  function addVectors(...vecs) {
    return vecs.reduce((prev, current) => prev.map((v, i) => v + current[i]));
  }
  function mixInModel(model, colorsAndCoefficients) {
    if (!CORE_MODELS.has(model)) {
      throw new Error(
        `Cannot mix colors in model "${model}"; only core modes ${Array.from(
          CORE_MODELS
        ).join(", ")} are supported`
      );
    }
    const toModel = ColorToXColorModel[model];
    const fromModel = XColorCoreModelToColor[model];
    const mixed = addVectors(
      ...colorsAndCoefficients.map(([v, color2]) => {
        const colorInModel = toModel(color2);
        return scalarMul(v, colorInModel);
      })
    );
    return fromModel(mixed);
  }
  function computeColor(expr, predefinedColors = {}) {
    if (expr.type !== "color") {
      throw new Error(
        `Can only compute the color of a "color" expression, not one of type ${expr.type}`
      );
    }
    const knownColors = { ...PREDEFINED_XCOLOR_COLORS, ...predefinedColors };
    function getColor(name2) {
      if (!knownColors[name2]) {
        throw new Error(`Unknown color "${name2}"`);
      }
      return knownColors[name2];
    }
    const color2 = expr.color;
    let computedColor = Color$1("#000000");
    if (color2.type === "expr") {
      let base2 = getColor(color2.name);
      for (const mix of color2.mix_expr) {
        if (mix.type === "complete_mix") {
          const mixColor = getColor(mix.name);
          base2 = base2.mix(mixColor, 1 - mix.mix_percent / 100);
        } else if (mix.type === "partial_mix") {
          base2 = base2.mix(Color$1("#FFFFFF"), 1 - mix.mix_percent / 100);
        }
      }
      if (color2.prefix && color2.prefix.length % 2 === 1) {
        base2 = base2.rotate(180);
      }
      computedColor = base2;
    }
    if (color2.type === "extended_expr") {
      const model = color2.core_model;
      const div = color2.div || color2.expressions.reduce((a2, expr2) => a2 + expr2.weight, 0);
      if (div <= 0) {
        throw new Error(
          `Cannot mix color with ratios that have a denominator of ${div}`
        );
      }
      const colorsToMix = color2.expressions.map(
        (expr2) => [
          expr2.weight / div,
          computeColor({
            type: "color",
            color: expr2.color,
            functions: []
          })
        ]
      );
      computedColor = mixInModel(model, colorsToMix);
    }
    for (const func of expr.functions) {
      if (func.name === "wheel") {
        const angle = func.args[0];
        const circ = func.args[1] || 360;
        computedColor = computedColor.rotate(angle / circ * 360);
      }
      if (func.name === "twheel") {
        const angle = func.args[0];
        const circ = func.args[1] || 360;
        computedColor = computedColor.rotate(angle / circ * 360 + 60);
      }
    }
    return computedColor;
  }
  function xcolorColorToHex(color2, model, options2 = { predefinedColors: {} }) {
    const { predefinedColors = {} } = options2;
    const parsed = parse$4(color2);
    if (model && model !== "default" && parsed.type !== "color") {
      if (!(model in XColorModelToColor)) {
        throw new Error(
          `Unknown color model "${model}"; known models are ${Object.keys(
            XColorModelToColor
          ).join(", ")}`
        );
      }
      if (parsed.type !== "hex_spec" && parsed.type !== "num_spec") {
        throw new Error(
          `Cannot use model ${model} to compute the color "${color2}"`
        );
      }
      if (model === "HTML" && parsed.type === "hex_spec") {
        return XColorModelToColor.HTML(parsed.content).hex();
      } else if (parsed.type === "num_spec") {
        return XColorModelToColor[model](parsed.content).hex();
      }
      throw new Error(
        `Don't know how to process color "${color2}" in model "${model}"`
      );
    }
    if (Array.isArray(parsed) || parsed.type !== "color") {
      throw new Error(
        `Cannot the color "${color2}" is not a valid color string`
      );
    }
    let computed = null;
    try {
      computed = computeColor(parsed, predefinedColors);
    } catch (e) {
    }
    return computed && computed.hex();
  }
  const macros$2 = {
    NewDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    RenewDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    ProvideDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    DeclareDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    NewDocumentEnvironment: {
      signature: "m m m m",
      renderInfo: { breakAround: true }
    },
    RenewDocumentEnvironment: {
      signature: "m m m m",
      renderInfo: { breakAround: true }
    },
    ProvideDocumentEnvironment: {
      signature: "m m m m",
      renderInfo: { breakAround: true }
    },
    DeclareDocumentEnvironment: {
      signature: "m m m m",
      renderInfo: { breakAround: true }
    },
    NewExpandableDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    RenewExpandableDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    ProvideExpandableDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    DeclareExpandableDocumentCommand: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    RequirePackage: {
      signature: "o m",
      renderInfo: { pgfkeysArgs: true, breakAround: true }
    },
    DeclareOption: { signature: "m m", renderInfo: { breakAround: true } }
  };
  const environments$2 = {};
  const macros$1 = {
    mode: { signature: "s d<> d{}", renderInfo: { breakAround: true } },
    insertnavigation: { signature: "m", renderInfo: { breakAround: true } },
    insertsectionnavigation: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    insertsectionnavigationhorizontal: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    insertauthor: { signature: "o", renderInfo: { breakAround: true } },
    insertshortauthor: { signature: "o", renderInfo: { breakAround: true } },
    insertshortdate: { signature: "o", renderInfo: { breakAround: true } },
    insertshortinstitute: { signature: "o", renderInfo: { breakAround: true } },
    insertshortpart: { signature: "o", renderInfo: { breakAround: true } },
    insertshorttitle: { signature: "o", renderInfo: { breakAround: true } },
    insertsubsectionnavigation: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    insertsubsectionnavigationhorizontal: {
      signature: "m m m",
      renderInfo: { breakAround: true }
    },
    insertverticalnavigation: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    usebeamercolor: { signature: "s m", renderInfo: { breakAround: true } },
    usebeamertemplate: { signature: "s m", renderInfo: { breakAround: true } },
    setbeamercolor: {
      signature: "m m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    setbeamersize: {
      signature: "m o o",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    setbeamertemplate: {
      signature: "m o o d{}",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    newcommand: {
      signature: "s d<> +m o +o +m",
      renderInfo: {
        breakAround: true,
        namedArguments: [
          "starred",
          null,
          "name",
          "numArgs",
          "default",
          "body"
        ]
      }
    },
    renewcommand: {
      signature: "s d<> +m o +o +m",
      renderInfo: {
        breakAround: true,
        namedArguments: [
          "starred",
          null,
          "name",
          "numArgs",
          "default",
          "body"
        ]
      }
    },
    newenvironment: {
      signature: "s d<> m o o m m",
      renderInfo: { breakAround: true }
    },
    renewenvironment: {
      signature: "s d<> m o o m m",
      renderInfo: { breakAround: true }
    },
    resetcounteronoverlays: {
      signature: "m",
      renderInfo: { breakAround: true }
    },
    resetcountonoverlays: { signature: "m", renderInfo: { breakAround: true } },
    logo: { signature: "m", renderInfo: { breakAround: true } },
    frametitle: { signature: "d<> o m", renderInfo: { breakAround: true } },
    framesubtitle: { signature: "d<> m", renderInfo: { breakAround: true } },
    pause: { signature: "o" },
    onslide: { signature: "t+ t* d<> d{}" },
    only: { signature: "d<> m d<>" },
    uncover: { signature: "d<> m" },
    visible: { signature: "d<> m" },
    invisible: { signature: "d<> m" },
    alt: { signature: "d<> m m d<>" },
    temporal: { signature: "r<> m m m" },
    item: {
      signature: "d<> o d<>",
      renderInfo: {
        hangingIndent: true,
        namedArguments: [null, "label", null]
      }
    },
    label: { signature: "d<> o m" },
    // cleveref adds an optional argument to label; this gives maximum compatibility.
    action: { signature: "d<> m" },
    beamerdefaultoverlayspecification: { signature: "m" },
    titlegraphic: { signature: "m", renderInfo: { breakAround: true } },
    subject: { signature: "m", renderInfo: { breakAround: true } },
    keywords: { signature: "m", renderInfo: { breakAround: true } },
    lecture: { signature: "o m m", renderInfo: { breakAround: true } },
    partpage: { renderInfo: { breakAround: true } },
    sectionpage: { renderInfo: { breakAround: true } },
    subsectionpage: { renderInfo: { breakAround: true } },
    AtBeginLecture: { signature: "m", renderInfo: { breakAround: true } },
    AtBeginPart: { signature: "m", renderInfo: { breakAround: true } },
    tableofcontents: {
      signature: "o",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    againframe: { signature: "d<> o o m", renderInfo: { breakAround: true } },
    framezoom: {
      signature: "r<> r<> o r() r()",
      renderInfo: { breakAround: true }
    },
    column: { signature: "d<> o m", renderInfo: { breakAround: true } },
    animate: { signature: "r<>", renderInfo: { breakAround: true } },
    animatevalue: { signature: "r<> m m m", renderInfo: { breakAround: true } },
    sound: {
      signature: "o m m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    hyperlinksound: {
      signature: "o m m",
      renderInfo: { breakAround: true, pgfkeysArgs: true }
    },
    hyperlinkmute: { signature: "m", renderInfo: { breakAround: true } },
    // These signatures conflict with the default signatures.
    // Care must be taken when processing an AST.
    section: {
      signature: "s d<> o m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", null, "tocTitle", "title"]
      }
    },
    subsection: {
      signature: "s d<> o m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", null, "tocTitle", "title"]
      }
    },
    subsubsection: {
      signature: "s d<> o m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", null, "tocTitle", "title"]
      }
    },
    part: {
      signature: "s d<> o m",
      renderInfo: {
        breakAround: true,
        namedArguments: ["starred", null, "tocTitle", "title"]
      }
    },
    bibitem: {
      signature: "s d<> o m",
      renderInfo: {
        hangingIndent: true,
        namedArguments: ["starred", null, "tocTitle", "title"]
      }
    }
  };
  const environments$1 = {
    frame: {
      signature: "!d<> !o !o !d{} !d{}"
    },
    block: {
      signature: "!d<> !d{} !d<>"
    },
    alertblock: {
      signature: "!d<> !d{} !d<>"
    },
    exampleblock: {
      signature: "!d<> !d{} !d<>"
    },
    onlyenv: {
      signature: "!d<>"
    },
    altenv: {
      signature: "!d<> m m m m !d<>"
    },
    overlayarea: { signature: "m m" },
    overprint: { signature: "o" },
    actionenv: { signature: "!d<>" },
    columns: { signature: "d<> o" },
    column: { signature: "d<> o m" }
  };
  const macros = {
    columnbreak: { renderInfo: { breakAround: true } }
  };
  const environments = {
    multicols: {
      signature: "m o o"
    },
    "multicols*": {
      signature: "m o o"
    }
  };
  const macroInfo = {
    amsart: macros$f,
    cleveref: macros$e,
    exam: macros$d,
    geometry: macros$c,
    hyperref: macros$b,
    latex2e: macros$a,
    listings: macros$9,
    makeidx: macros$8,
    mathtools: macros$7,
    minted: macros$6,
    nicematrix: macros$5,
    systeme: macros$4,
    tikz: macros$g,
    xcolor: macros$3,
    xparse: macros$2,
    beamer: macros$1,
    multicol: macros
  };
  const environmentInfo = {
    amsart: environments$f,
    cleveref: environments$e,
    exam: environments$d,
    geometry: environments$c,
    hyperref: environments$b,
    latex2e: environments$a,
    listings: environments$9,
    makeidx: environments$8,
    mathtools: environments$7,
    minted: environments$6,
    nicematrix: environments$5,
    systeme: environments$4,
    tikz: environments$g,
    xcolor: environments$3,
    xparse: environments$2,
    beamer: environments$1,
    multicol: environments
  };
  function processEnvironment(envNode, envInfo) {
    if (envInfo.signature && envNode.args == null) {
      const { args } = gobbleArguments(envNode.content, envInfo.signature);
      envNode.args = args;
    }
    updateRenderInfo(envNode, envInfo.renderInfo);
    if (typeof envInfo.processContent === "function") {
      envNode.content = envInfo.processContent(envNode.content);
    }
  }
  function findRegionInArray(tree, start, end2) {
    const ret = [];
    let currRegion = { start: void 0, end: tree.length };
    for (let i = 0; i < tree.length; i++) {
      const node2 = tree[i];
      if (start(node2)) {
        currRegion.start = i;
      }
      if (end2(node2)) {
        currRegion.end = i + 1;
        ret.push(currRegion);
        currRegion = { start: void 0, end: tree.length };
      }
    }
    if (currRegion.start != null) {
      ret.push(currRegion);
    }
    return ret;
  }
  function refineRegions(regions) {
    const _regions = [...regions];
    _regions.sort((a2, b) => a2.start - b.start);
    const cutPointsSet = new Set(_regions.flatMap((r) => [r.start, r.end]));
    const cutPoints = Array.from(cutPointsSet);
    cutPoints.sort((a2, b) => a2 - b);
    const retRegions = [];
    const retRegionsContainedIn = [];
    let seekIndex = 0;
    for (let i = 0; i < cutPoints.length - 1; i++) {
      const start = cutPoints[i];
      const end2 = cutPoints[i + 1];
      const region = { start, end: end2 };
      const regionContainedIn = /* @__PURE__ */ new Set();
      let encounteredEndPastStart = false;
      for (let j = seekIndex; j < _regions.length; j++) {
        const superRegion = _regions[j];
        if (superRegion.end >= region.start) {
          encounteredEndPastStart = true;
        }
        if (!encounteredEndPastStart && superRegion.end < region.start) {
          seekIndex = j + 1;
          continue;
        }
        if (superRegion.start > end2) {
          break;
        }
        if (superRegion.start <= region.start && superRegion.end >= region.end) {
          encounteredEndPastStart = true;
          regionContainedIn.add(superRegion);
        }
      }
      if (regionContainedIn.size > 0) {
        retRegions.push(region);
        retRegionsContainedIn.push(regionContainedIn);
      }
    }
    return { regions: retRegions, regionsContainedIn: retRegionsContainedIn };
  }
  function splitByRegions(array, regionsRecord) {
    const ret = [];
    const indices = [0, array.length];
    const reverseMap = {};
    for (const [key2, records] of Object.entries(regionsRecord)) {
      indices.push(
        ...records.flatMap((r) => {
          reverseMap["" + [r.start, r.end]] = key2;
          return [r.start, r.end];
        })
      );
    }
    indices.sort((a2, b) => a2 - b);
    for (let i = 0; i < indices.length - 1; i++) {
      const start = indices[i];
      const end2 = indices[i + 1];
      if (start === end2) {
        continue;
      }
      const regionKey = reverseMap["" + [start, end2]];
      ret.push([regionKey || null, array.slice(start, end2)]);
    }
    return ret;
  }
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function buildWordRegex(allowedSet) {
    const regexpStr = `^(${["\\p{L}"].concat(Array.from(allowedSet).map(escapeRegExp)).join("|")})*`;
    return new RegExp(regexpStr, "u");
  }
  function hasReparsableMacroNamesInArray(tree, allowedTokens) {
    for (let i = 0; i < tree.length; i++) {
      const macro2 = tree[i];
      const string2 = tree[i + 1];
      if (match.anyMacro(macro2) && match.anyString(string2)) {
        if (allowedTokens.has(
          macro2.content.charAt(macro2.content.length - 1)
        ) || allowedTokens.has(string2.content.charAt(0))) {
          return true;
        }
      }
    }
    return false;
  }
  function hasReparsableMacroNames(tree, allowedTokens) {
    if (typeof allowedTokens === "string") {
      allowedTokens = new Set(allowedTokens.split(""));
    }
    const _allowedTokens = allowedTokens;
    for (const v of _allowedTokens) {
      if (v.length > 1) {
        throw new Error(
          `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`
        );
      }
    }
    let ret = false;
    visit$3(
      tree,
      (nodes) => {
        if (hasReparsableMacroNamesInArray(nodes, _allowedTokens)) {
          ret = true;
          return EXIT$2;
        }
      },
      { includeArrays: true, test: Array.isArray }
    );
    return ret;
  }
  function reparseMacroNamesInArray(tree, allowedTokens) {
    var _a3, _b, _c;
    const regex = buildWordRegex(allowedTokens);
    let i = 0;
    while (i < tree.length) {
      const macro2 = tree[i];
      const string2 = tree[i + 1];
      if (match.anyMacro(macro2) && // The _^ macros in math mode should not be extended no-matter what;
      // So we check to make sure that the macro we're dealing with has the default escape token.
      (macro2.escapeToken == null || macro2.escapeToken === "\\") && match.anyString(string2) && // There are two options. Either the macro ends with the special character,
      // e.g. `\@foo` or the special character starts the next string, e.g. `\foo@`.
      (allowedTokens.has(
        macro2.content.charAt(macro2.content.length - 1)
      ) || allowedTokens.has(string2.content.charAt(0)))) {
        const match2 = string2.content.match(regex);
        const takeable = match2 ? match2[0] : "";
        if (takeable.length > 0) {
          if (takeable.length === string2.content.length) {
            macro2.content += string2.content;
            tree.splice(i + 1, 1);
            if (macro2.position && ((_a3 = string2.position) == null ? void 0 : _a3.end)) {
              macro2.position.end = string2.position.end;
            }
          } else {
            macro2.content += takeable;
            string2.content = string2.content.slice(takeable.length);
            if ((_b = macro2.position) == null ? void 0 : _b.end) {
              macro2.position.end.offset += takeable.length;
              macro2.position.end.column += takeable.length;
            }
            if ((_c = string2.position) == null ? void 0 : _c.start) {
              string2.position.start.offset += takeable.length;
              string2.position.start.column += takeable.length;
            }
          }
        } else {
          i++;
        }
      } else {
        ++i;
      }
    }
  }
  function reparseMacroNames(tree, allowedTokens) {
    if (typeof allowedTokens === "string") {
      allowedTokens = new Set(allowedTokens.split(""));
    }
    const _allowedTokens = allowedTokens;
    for (const v of _allowedTokens) {
      if (v.length > 1) {
        throw new Error(
          `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`
        );
      }
    }
    visit$3(
      tree,
      (nodes) => {
        reparseMacroNamesInArray(nodes, _allowedTokens);
      },
      { includeArrays: true, test: Array.isArray }
    );
  }
  const expl3Find = {
    start: match.createMacroMatcher(["ExplSyntaxOn"]),
    end: match.createMacroMatcher(["ExplSyntaxOff"])
  };
  const atLetterFind = {
    start: match.createMacroMatcher(["makeatletter"]),
    end: match.createMacroMatcher(["makeatother"])
  };
  function findExpl3AndAtLetterRegionsInArray(tree) {
    const expl3 = findRegionInArray(tree, expl3Find.start, expl3Find.end);
    const atLetter = findRegionInArray(
      tree,
      atLetterFind.start,
      atLetterFind.end
    );
    const regionMap = new Map([
      ...expl3.map((x2) => [x2, "expl"]),
      ...atLetter.map((x2) => [x2, "atLetter"])
    ]);
    const all2 = refineRegions([...expl3, ...atLetter]);
    const ret = {
      explOnly: [],
      atLetterOnly: [],
      both: []
    };
    for (let i = 0; i < all2.regions.length; i++) {
      const region = all2.regions[i];
      const containedIn = all2.regionsContainedIn[i];
      if (containedIn.size === 2) {
        ret.both.push(region);
        continue;
      }
      for (const v of containedIn.values()) {
        if (regionMap.get(v) === "expl") {
          ret.explOnly.push(region);
        }
        if (regionMap.get(v) === "atLetter") {
          ret.atLetterOnly.push(region);
        }
      }
    }
    ret.explOnly = ret.explOnly.filter((r) => r.end - r.start > 1);
    ret.atLetterOnly = ret.atLetterOnly.filter((r) => r.end - r.start > 1);
    ret.both = ret.both.filter((r) => r.end - r.start > 1);
    return ret;
  }
  const atLetterSet = /* @__PURE__ */ new Set(["@"]);
  const explSet = /* @__PURE__ */ new Set(["_", ":"]);
  const bothSet = /* @__PURE__ */ new Set(["_", ":", "@"]);
  function reparseExpl3AndAtLetterRegions(tree) {
    visit$3(
      tree,
      {
        leave: (nodes) => {
          const regions = findExpl3AndAtLetterRegionsInArray(nodes);
          const totalNumRegions = regions.both.length + regions.atLetterOnly.length + regions.explOnly.length;
          if (totalNumRegions === 0) {
            return;
          }
          const splits = splitByRegions(nodes, regions);
          const processed = [];
          for (const [key2, slice2] of splits) {
            switch (key2) {
              case null:
                processed.push(...slice2);
                continue;
              case "atLetterOnly":
                reparseMacroNames(slice2, atLetterSet);
                processed.push(...slice2);
                continue;
              case "explOnly":
                reparseMacroNames(slice2, explSet);
                processed.push(...slice2);
                continue;
              case "both":
                reparseMacroNames(slice2, bothSet);
                processed.push(...slice2);
                continue;
              default:
                throw new Error(
                  `Unexpected case when splitting ${key2}`
                );
            }
          }
          nodes.length = 0;
          nodes.push(...processed);
          return SKIP$2;
        }
      },
      { includeArrays: true, test: Array.isArray }
    );
  }
  const unifiedLatexAstComplier = function unifiedLatexAstComplier2() {
    Object.assign(this, { Compiler: (x2) => x2 });
  };
  function parseMinimal(str) {
    return LatexPegParser.parse(str);
  }
  function parseMathMinimal(str) {
    return LatexPegParser.parse(str, { startRule: "math" });
  }
  const unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options2) {
    const parser2 = (str) => {
      if ((options2 == null ? void 0 : options2.mode) === "math") {
        return {
          type: "root",
          content: parseMathMinimal(str),
          _renderInfo: { inMathMode: true }
        };
      }
      return parseMinimal(str);
    };
    Object.assign(this, { Parser: parser2 });
  };
  function unifiedLatexReparseMathConstructPlugin({
    mathEnvs,
    mathMacros
  }) {
    const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);
    const isMathMacro = match.createMacroMatcher(mathMacros);
    return (tree) => {
      visit$3(
        tree,
        (node2) => {
          if (match.anyMacro(node2)) {
            for (const arg2 of node2.args || []) {
              if (arg2.content.length > 0 && !wasParsedInMathMode(arg2.content)) {
                arg2.content = parseMathMinimal(
                  printRaw(arg2.content)
                );
              }
            }
          }
          if (match.anyEnvironment(node2)) {
            if (!wasParsedInMathMode(node2.content)) {
              node2.content = parseMathMinimal(printRaw(node2.content));
            }
          }
        },
        {
          test: (node2) => isMathEnvironment(node2) || isMathMacro(node2)
        }
      );
    };
  }
  function wasParsedInMathMode(nodes) {
    return !nodes.some(
      (node2) => (
        // If there are multi-char strings or ^ and _ have been parsed as strings, we know
        // that we were not parsed in math mode.
        match.anyString(node2) && node2.content.length > 1 || match.string(node2, "^") || match.string(node2, "_")
      )
    );
  }
  const unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse2(options2) {
    const { environments: environments2 = {}, macros: macros2 = {} } = options2 || {};
    const mathMacros = Object.fromEntries(
      Object.entries(macros2).filter(
        ([_, info]) => {
          var _a3;
          return ((_a3 = info.renderInfo) == null ? void 0 : _a3.inMathMode) === true;
        }
      )
    );
    const mathEnvs = Object.fromEntries(
      Object.entries(environments2).filter(
        ([_, info]) => {
          var _a3;
          return ((_a3 = info.renderInfo) == null ? void 0 : _a3.inMathMode) === true;
        }
      )
    );
    const mathReparser = unifiedLatexReparseMathConstructPlugin({
      mathEnvs: Object.keys(mathEnvs),
      mathMacros: Object.keys(mathMacros)
    });
    const isRelevantEnvironment = match.createEnvironmentMatcher(environments2);
    const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);
    return (tree) => {
      visit$3(
        tree,
        {
          enter: (nodes) => {
            if (!Array.isArray(nodes)) {
              return;
            }
            attachMacroArgsInArray(nodes, mathMacros);
          },
          leave: (node2) => {
            if (!isRelevantMathEnvironment(node2)) {
              return;
            }
            const envName = printRaw(node2.env);
            const envInfo = environments2[envName];
            if (!envInfo) {
              throw new Error(
                `Could not find environment info for environment "${envName}"`
              );
            }
            processEnvironment(node2, envInfo);
          }
        },
        { includeArrays: true }
      );
      mathReparser(tree);
      visit$3(
        tree,
        {
          enter: (nodes) => {
            if (!Array.isArray(nodes)) {
              return;
            }
            attachMacroArgsInArray(nodes, macros2);
          },
          leave: (node2) => {
            if (!isRelevantEnvironment(node2)) {
              return;
            }
            const envName = printRaw(node2.env);
            const envInfo = environments2[envName];
            if (!envInfo) {
              throw new Error(
                `Could not find environment info for environment "${envName}"`
              );
            }
            processEnvironment(node2, envInfo);
          }
        },
        { includeArrays: true }
      );
    };
  };
  const unifiedLatexProcessAtLetterAndExplMacros = function unifiedLatexProcessAtLetterAndExplMacros2(options2) {
    let {
      atLetter = false,
      expl3 = false,
      autodetectExpl3AndAtLetter = false
    } = options2 || {};
    return (tree) => {
      reparseExpl3AndAtLetterRegions(tree);
      if (atLetter || expl3) {
        autodetectExpl3AndAtLetter = false;
      }
      if (autodetectExpl3AndAtLetter) {
        atLetter = hasReparsableMacroNames(tree, "@");
        expl3 = hasReparsableMacroNames(tree, "_");
      }
      const charSet = /* @__PURE__ */ new Set();
      if (atLetter) {
        charSet.add("@");
      }
      if (expl3) {
        charSet.add(":");
        charSet.add("_");
      }
      if (charSet.size > 0) {
        reparseMacroNames(tree, charSet);
      }
    };
  };
  const unifiedLatexFromString = function unifiedLatexFromString2(options2) {
    const {
      mode = "regular",
      macros: macros2 = {},
      environments: environments2 = {},
      flags: {
        atLetter = false,
        expl3 = false,
        autodetectExpl3AndAtLetter = false
      } = {}
    } = options2 || {};
    const allMacroInfo = Object.assign(
      {},
      ...Object.values(macroInfo),
      macros2
    );
    const allEnvInfo = Object.assign(
      {},
      ...Object.values(environmentInfo),
      environments2
    );
    const fullParser = unified().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessAtLetterAndExplMacros, {
      atLetter,
      expl3,
      autodetectExpl3AndAtLetter
    }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {
      macros: allMacroInfo,
      environments: allEnvInfo
    }).use(unifiedLatexTrimEnvironmentContents).use(unifiedLatexTrimRoot).use(unifiedLatexAstComplier);
    const parser2 = (str) => {
      const file = fullParser.processSync({ value: str });
      return file.result;
    };
    Object.assign(this, { Parser: parser2 });
  };
  let parser$2 = unified().use(unifiedLatexFromString).freeze();
  function parse$3(str) {
    return parser$2.parse(str);
  }
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
  var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
  var _path, _print;
  function formatEnvSurround(node2) {
    const env2 = printRaw(node2.env);
    return {
      envName: env2,
      start: ESCAPE + "begin{" + env2 + "}",
      end: ESCAPE + "end{" + env2 + "}"
    };
  }
  function isLineType(elm) {
    if (elm == null || typeof elm === "string") {
      return false;
    }
    if (Array.isArray(elm)) {
      return isLineType(elm[0]);
    }
    if (elm.type === "concat") {
      return isLineType(elm.parts);
    }
    return elm.type === "line";
  }
  function joinWithSoftline(arr) {
    if (arr.length === 0 || arr.length === 1) {
      return arr;
    }
    const ret = [arr[0]];
    for (let i = 1; i < arr.length; i++) {
      const prevNode = arr[i - 1];
      const nextNode = arr[i];
      if (!isLineType(prevNode) && !isLineType(nextNode)) {
        ret.push(softline);
      }
      ret.push(nextNode);
    }
    return ret;
  }
  function getNodeInfo(node2, options2) {
    if (!node2) {
      return { renderInfo: {} };
    }
    const renderInfo = node2._renderInfo || {};
    const previousNode = options2.referenceMap && options2.referenceMap.getPreviousNode(node2);
    const nextNode = options2.referenceMap && options2.referenceMap.getNextNode(node2);
    const renderCache = options2.referenceMap && options2.referenceMap.getRenderCache(node2);
    return {
      renderInfo,
      renderCache,
      previousNode,
      nextNode,
      referenceMap: options2.referenceMap
    };
  }
  const ESCAPE = "\\";
  const {
    group,
    fill,
    ifBreak,
    line,
    softline,
    hardline,
    lineSuffix,
    lineSuffixBoundary,
    breakParent,
    indent,
    markAsRoot,
    join: join$3
  } = builders;
  function formatDocArray(nodes, docArray, options2) {
    const ret = [];
    for (let i = 0; i < nodes.length; i++) {
      const rawNode = nodes[i];
      const printedNode = docArray[i];
      const { renderInfo, referenceMap, previousNode, nextNode } = getNodeInfo(rawNode, options2);
      const renderCache = referenceMap && referenceMap.getRenderCache(rawNode);
      switch (rawNode.type) {
        case "comment":
          if (!rawNode.sameline && previousNode && !match.comment(previousNode) && !match.parbreak(previousNode)) {
            ret.push(hardline);
          }
          ret.push(printedNode);
          if (nextNode && !rawNode.suffixParbreak) {
            ret.push(hardline);
          }
          break;
        case "environment":
        case "displaymath":
        case "mathenv":
          if (previousNode && (previousNode == null ? void 0 : previousNode.type) !== "parbreak") {
            if (ret[ret.length - 1] === line) {
              ret.pop();
            }
            if (ret[ret.length - 1] !== hardline) {
              ret.push(hardline);
            }
          }
          ret.push(printedNode);
          if ((nextNode == null ? void 0 : nextNode.type) === "whitespace") {
            ret.push(hardline);
            i++;
          }
          break;
        case "macro":
          if (renderInfo.breakBefore || renderInfo.breakAround) {
            if (previousNode) {
              if (ret[ret.length - 1] === line || ret[ret.length - 1] === hardline) {
                ret.pop();
                ret.push(hardline);
              } else if (!match.comment(previousNode) && !match.parbreak(previousNode)) {
                ret.push(hardline);
              }
            }
          }
          if (renderInfo.inParMode && !renderInfo.hangingIndent && renderCache) {
            ret.push(
              renderCache.content,
              ...renderCache.rawArgs || []
            );
          } else {
            ret.push(printedNode);
          }
          if (renderInfo.breakAfter || renderInfo.breakAround) {
            if (nextNode) {
              if (match.whitespace(nextNode)) {
                ret.push(hardline);
                i++;
              } else if (match.parbreak(nextNode))
                ;
              else if (!match.comment(nextNode)) {
                ret.push(hardline);
              }
            }
          }
          break;
        case "parbreak":
          ret.push(hardline, hardline);
          break;
        default:
          ret.push(printedNode);
          break;
      }
    }
    return ret;
  }
  function zip(array1, array2) {
    const ret = [];
    const len = Math.min(array1.length, array2.length);
    for (let i = 0; i < len; i++) {
      ret.push([array1[i], array2[i]]);
    }
    return ret;
  }
  function printMacro(path2, print, options2) {
    const node2 = path2.getNode();
    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(
      node2,
      options2
    );
    const content2 = (node2.escapeToken != null ? node2.escapeToken : ESCAPE) + node2.content;
    const args = node2.args ? path2.map(print, "args") : [];
    const rawArgs = [];
    for (const [arg2, printedArg] of zip(node2.args || [], args)) {
      const renderCache = referenceMap && referenceMap.getRenderCache(arg2);
      if (renderInfo.inParMode && renderCache) {
        rawArgs.push(...renderCache);
      } else {
        rawArgs.push(printedArg);
      }
    }
    if (referenceMap) {
      referenceMap.setRenderCache(node2, { rawArgs, content: content2 });
    }
    if (renderInfo.hangingIndent) {
      return indent(fill([content2, ...rawArgs]));
    }
    return group([content2, ...rawArgs]);
  }
  function printArgumentPgfkeys(nodes, options2) {
    const { allowParenGroups = false } = options2;
    const parsed = parsePgfkeys(nodes, { allowParenGroups });
    const content2 = [];
    for (const part of parsed) {
      const isLastItem = part === parsed[parsed.length - 1];
      if (part.itemParts) {
        const parts2 = part.itemParts.map(
          (node2) => printRaw(node2, { asArray: true }).map(
            (token) => token === linebreak ? hardline : token
          )
        );
        const row2 = join$3("=", parts2);
        content2.push(row2);
        if (part.trailingComma) {
          content2.push(",");
        }
      }
      if (part.trailingComment) {
        const leadingContent = part.itemParts ? [" "] : [];
        if (part.leadingParbreak) {
          leadingContent.push(hardline);
        }
        content2.push(
          ...leadingContent,
          // We're carefully and manually controlling the newlines,
          // so print the comment directly without any newlines
          "%",
          part.trailingComment.content,
          breakParent
        );
      }
      if (!isLastItem) {
        content2.push(line);
      }
    }
    let leadingComment = [""];
    if (options2.leadingComment) {
      if (options2.leadingComment.leadingWhitespace) {
        leadingComment.push(" ");
      }
      leadingComment.push("%" + options2.leadingComment.content, breakParent);
    }
    return group([
      options2.openMark,
      ...leadingComment,
      // If there is no content, we don't want to push an extra `softline`.
      // This matters because the braces group could still be broken by `leadingComment`
      content2.length > 0 ? indent([softline, ...content2]) : "",
      softline,
      options2.closeMark
    ]);
  }
  function printTikzArgument(path2, print, options2) {
    const node2 = path2.getNode();
    getNodeInfo(
      node2,
      options2
    );
    const content2 = [];
    const nodes = [...node2.content];
    trim(nodes);
    try {
      const tikzAst = parse$5(nodes);
      if (tikzAst.content.length === 0) {
        content2.push(";");
        return content2;
      }
      const printer2 = new TikzArgumentPrinter(tikzAst, path2, print);
      return printer2.toDoc();
    } catch (e) {
      console.warn("Encountered error when trying to parse tikz argument", e);
    }
    content2.push(";");
    return content2;
  }
  function printFragment(fragment2, path2, print) {
    const tmpKey = Symbol();
    const currNode = path2.getNode();
    if (!currNode) {
      throw new Error(
        "tried to print a fragment, but the current node is `null`"
      );
    }
    currNode[tmpKey] = fragment2;
    const ret = print(tmpKey);
    delete currNode[tmpKey];
    return ret;
  }
  function printTikzPathSpecNode(node2, path2, print) {
    switch (node2.type) {
      case "comment":
        return printFragment(node2, path2, print);
      case "unknown":
        return printFragment(node2.content, path2, print);
      case "coordinate":
        return [printRaw(node2.prefix), "(", printRaw(node2.content), ")"];
      case "line_to":
        return node2.command;
      case "square_brace_group":
        return printOptionalArgs(node2.content);
      case "operation":
        return node2.content.content;
      case "svg_operation": {
        const comments = node2.comments.map(
          (n) => printTikzPathSpecNode(n, path2, print)
        );
        const options2 = node2.options ? printOptionalArgs(node2.options) : [];
        const rest = node2.options ? [group(indent([line, printRaw(node2.content)]))] : [" ", printRaw(node2.content)];
        return [...comments, "svg", options2, ...rest];
      }
      case "curve_to": {
        const comments = node2.comments.map(
          (n) => printTikzPathSpecNode(n, path2, print)
        );
        const printedControls = node2.controls.length > 1 ? [
          printTikzPathSpecNode(node2.controls[0], path2, print),
          " ",
          "and",
          line,
          printTikzPathSpecNode(node2.controls[1], path2, print)
        ] : [printTikzPathSpecNode(node2.controls[0], path2, print)];
        return [
          ...comments,
          "..",
          " ",
          group(
            indent(["controls", line, ...printedControls, " ", ".."])
          )
        ];
      }
      case "animation": {
        const comments = node2.comments.map(
          (n) => printTikzPathSpecNode(n, path2, print)
        );
        return [
          ...comments,
          ":",
          node2.attribute,
          " ",
          "=",
          " ",
          group(
            indent([
              printArgumentPgfkeys(node2.content, {
                openMark: "{",
                closeMark: "}"
              })
            ])
          )
        ];
      }
      case "foreach": {
        const comments = node2.comments.map(
          (n) => printTikzPathSpecNode(n, path2, print)
        );
        const variables = [...node2.variables];
        trim(variables);
        const list2 = node2.list.type === "macro" ? printFragment(node2.list, path2, print) : printArgumentPgfkeys(node2.list.content, {
          openMark: "{",
          closeMark: "}",
          allowParenGroups: true
        });
        const doc = [
          ...comments,
          printRaw(node2.start),
          " ",
          printRaw(variables)
        ];
        if (node2.options) {
          doc.push(" ", indent(printOptionalArgs(node2.options)));
        }
        doc.push(" ", "in", " ", group(indent(list2)));
        const commandType = node2.command.type;
        switch (commandType) {
          case "foreach":
            doc.push(
              indent([
                line,
                printTikzPathSpecNode(node2.command, path2, print)
              ])
            );
            break;
          case "macro":
            doc.push(
              indent([line, printFragment(node2.command, path2, print)])
            );
            break;
          case "group": {
            const groupContent = [...node2.command.content];
            trim(groupContent);
            doc.push(
              " ",
              indent(
                group([
                  "{",
                  indent([
                    softline,
                    ...groupContent.map(
                      (n) => printFragment(n, path2, print)
                    )
                  ]),
                  softline,
                  "}"
                ])
              )
            );
            break;
          }
          default:
            const invalidType = commandType;
            console.warn(
              `Unhandled command type when printing "foreach": ${invalidType}`
            );
        }
        return indent(doc);
      }
    }
    console.warn(
      `Encountered unknown type when trying to print tikz PathSpec: "${node2.type}"`
    );
    return [];
  }
  function printOptionalArgs(nodes) {
    return printArgumentPgfkeys(nodes, {
      openMark: "[",
      closeMark: "]"
    });
  }
  class TikzArgumentPrinter {
    constructor(spec, path2, print) {
      __privateAdd(this, _path);
      __privateAdd(this, _print);
      __privateSet(this, _path, path2);
      __privateSet(this, _print, print);
      this.nodes = [...spec.content];
    }
    nodeToDoc(node2) {
      return printTikzPathSpecNode(node2, __privateGet(this, _path), __privateGet(this, _print));
    }
    toDoc() {
      const doc = [];
      const startArg = this.eatOptionalArg();
      if (startArg.optionalArg) {
        doc.push(
          ...startArg.comments.map(
            (c2) => printFragment(c2, __privateGet(this, _path), __privateGet(this, _print))
          )
        );
        doc.push(printOptionalArgs(startArg.optionalArg.content));
      }
      const innerDoc = [];
      doc.push(group([indent(innerDoc), ";"]));
      let cycle = -1;
      while (this.nodes.length > 0) {
        cycle++;
        const firstSep = cycle === 0 && !startArg.optionalArg ? " " : line;
        const comingUp = this.peek();
        switch (comingUp) {
          case "short_path": {
            const [n0, n1, n2] = this.nodes.splice(0, 3);
            innerDoc.push(
              firstSep,
              this.nodeToDoc(n0),
              " ",
              this.nodeToDoc(n1),
              " ",
              this.nodeToDoc(n2)
            );
            continue;
          }
          case "long_path": {
            const [n0, n1] = this.nodes.splice(0, 2);
            if (n1.type === "operation") {
              this.nodes.unshift(n1);
              innerDoc.push(
                firstSep,
                this.nodeToDoc(n0),
                " ",
                this.eatOperation()
              );
            } else {
              innerDoc.push(
                firstSep,
                this.nodeToDoc(n0),
                " ",
                this.nodeToDoc(n1)
              );
            }
            continue;
          }
          case "node":
            {
              const eatenNode = this.eatNode();
              if (eatenNode) {
                innerDoc.push(line, ...eatenNode);
                continue;
              }
              console.warn(
                "Expected to print a tikz `node` PathSpec but couldn't find the text `node`"
              );
            }
            continue;
          case "operation":
            innerDoc.push(firstSep, this.eatOperation());
            continue;
          case "unknown": {
            const node2 = this.nodes.shift();
            innerDoc.push(firstSep, this.nodeToDoc(node2));
            continue;
          }
        }
        this.nodes.shift();
      }
      return doc;
    }
    /**
     * Look at the current node and the nodes that follow. Return what
     * "type" is recognized.
     */
    peek() {
      const [n0, n1, n2, n3] = [
        this.nodes[0],
        this.nodes[1],
        this.nodes[2],
        this.nodes[3]
      ];
      if ((n0 == null ? void 0 : n0.type) === "coordinate" && isPathJoinOperation(n1)) {
        if ((n2 == null ? void 0 : n2.type) === "coordinate" && !((n3 == null ? void 0 : n3.type) === "coordinate" || isPathJoinOperation(n3))) {
          return "short_path";
        }
        return "long_path";
      }
      if ((n0 == null ? void 0 : n0.type) === "operation") {
        if (n0.content.content === "node") {
          return "node";
        }
        return "operation";
      }
      return "unknown";
    }
    /**
     * Eat comments and an optional arg if present. If no optional
     * arg is present, do nothing.
     */
    eatOptionalArg() {
      let i = 0;
      const comments = [];
      let optionalArg = null;
      for (; i < this.nodes.length; i++) {
        const node2 = this.nodes[i];
        if (node2.type === "square_brace_group") {
          optionalArg = node2;
          i++;
          break;
        }
        if (node2.type === "comment") {
          comments.push(node2);
          continue;
        }
        break;
      }
      if (optionalArg) {
        this.nodes.splice(0, i);
      }
      return { optionalArg, comments };
    }
    /**
     * Eat a `type === "operation"` node whose contents is `"node"`. I.e.,
     * the type of thing that shows up in `\path node at (1,1) {foo};`
     */
    eatNode() {
      const firstNode = this.nodes[0];
      if ((firstNode == null ? void 0 : firstNode.type) === "operation" && firstNode.content.content === "node") {
        this.nodes.shift();
      } else {
        return null;
      }
      const innerDoc = [];
      const commentBlock = [];
      const doc = [commentBlock, "node", group(indent(innerDoc))];
      let hasNodeArgument = false;
      let shouldBail = false;
      let i = 0;
      const comments = [];
      const options2 = [];
      const name2 = [];
      const atLocations = [];
      const animations = [];
      let content2 = [];
      for (; i < this.nodes.length && !shouldBail; i++) {
        const node2 = this.nodes[i];
        switch (node2.type) {
          case "animation":
            animations.push(this.nodeToDoc(node2));
            continue;
          case "comment": {
            const comment2 = {
              ...node2,
              leadingWhitespace: false
            };
            comments.push(this.nodeToDoc(comment2));
            continue;
          }
          case "square_brace_group":
            options2.push(printOptionalArgs(node2.content));
            continue;
          case "coordinate":
            name2.push(this.nodeToDoc(node2));
            continue;
          case "operation": {
            if (node2.content.content === "at") {
              const nextNode = this.nodes[i + 1];
              if (!nextNode || !(nextNode.type === "coordinate" || nextNode.type === "unknown" && match.anyMacro(nextNode.content))) {
                shouldBail = true;
                continue;
              }
              atLocations.push(["at", " ", this.nodeToDoc(nextNode)]);
              i++;
              continue;
            }
            shouldBail = true;
            continue;
          }
          case "unknown": {
            if (match.group(node2.content)) {
              hasNodeArgument = true;
              content2 = this.nodeToDoc(node2);
            }
          }
        }
        break;
      }
      if (!hasNodeArgument) {
        return innerDoc;
      }
      this.nodes.splice(0, i + 1);
      let isFirstElement = true;
      let isNamed = !(Array.isArray(name2) && name2.length === 0);
      for (const comment2 of comments) {
        commentBlock.push(comment2, hardline);
      }
      if (options2.length > 0) {
        innerDoc.push(join$3(" ", options2));
        isFirstElement = false;
      }
      if (animations.length > 0) {
        innerDoc.push(isFirstElement ? " " : line);
        innerDoc.push(join$3(line, animations));
        isFirstElement = false;
      }
      if (isNamed) {
        innerDoc.push(isFirstElement ? " " : line);
        innerDoc.push(name2);
        isFirstElement = false;
      }
      if (atLocations.length > 0) {
        innerDoc.push(isFirstElement || isNamed ? " " : line);
        innerDoc.push(join$3(line, atLocations));
        isFirstElement = false;
      }
      innerDoc.push(line, content2);
      return doc;
    }
    /**
     * Eat a `type === "operation"` node, including its optional arguments.
     */
    eatOperation() {
      const node2 = this.nodes[0];
      if ((node2 == null ? void 0 : node2.type) === "operation") {
        this.nodes.shift();
      } else {
        return [];
      }
      const doc = [];
      if ((node2 == null ? void 0 : node2.type) !== "operation") {
        throw new Error("Expecting `operation` node.");
      }
      const options2 = this.eatOptionalArg();
      doc.push(
        ...options2.comments.map(
          (c2) => printFragment(c2, __privateGet(this, _path), __privateGet(this, _print))
        ),
        node2.content.content
      );
      if (options2.optionalArg) {
        doc.push(indent(printOptionalArgs(options2.optionalArg.content)));
      }
      return doc;
    }
  }
  _path = /* @__PURE__ */ new WeakMap();
  _print = /* @__PURE__ */ new WeakMap();
  const PATH_JOIN_OPERATIONS = /* @__PURE__ */ new Set(["rectangle", "grid", "sin", "cos", "to"]);
  function isPathJoinOperation(node2) {
    if (!node2) {
      return false;
    }
    switch (node2.type) {
      case "line_to":
      case "curve_to":
        return true;
      case "operation":
        return PATH_JOIN_OPERATIONS.has(node2.content.content);
    }
    return false;
  }
  function printArgument(path2, print, options2) {
    const node2 = path2.getNode();
    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(
      node2,
      options2
    );
    if (node2.openMark === "" && node2.closeMark === "" && node2.content.length === 0) {
      return [];
    }
    const parentNode = path2.getParentNode();
    const { renderInfo: parentRenderInfo } = getNodeInfo(parentNode, options2);
    if (parentRenderInfo.pgfkeysArgs) {
      const leadingComment = node2.content.length > 0 && match.comment(node2.content[0]) && node2.content[0].sameline ? node2.content[0] : null;
      const content22 = leadingComment ? node2.content.slice(1) : node2.content;
      trim(content22);
      return printArgumentPgfkeys(content22, {
        openMark: node2.openMark,
        closeMark: node2.closeMark,
        leadingComment
      });
    }
    if (parentRenderInfo.tikzPathCommand) {
      return printTikzArgument(path2, print, options2);
    }
    const openMark = node2.openMark;
    const closeMark = node2.closeMark;
    let content2 = path2.map(print, "content");
    content2 = formatDocArray(node2.content, content2, options2);
    if (match.comment(node2.content[node2.content.length - 1])) {
      content2.push(hardline);
    }
    let rawRet = [openMark, fill(content2), closeMark];
    if (renderInfo.inParMode) {
      rawRet = [openMark, ...content2, closeMark];
    }
    if (referenceMap) {
      referenceMap.setRenderCache(node2, rawRet);
    }
    return rawRet;
  }
  function hasPreambleCode(nodes) {
    return nodes.some((node2) => match.macro(node2, "documentclass"));
  }
  function printRoot(path2, print, options2) {
    const node2 = path2.getNode();
    getNodeInfo(
      node2,
      options2
    );
    const content2 = path2.map(print, "content");
    const rawContent = formatDocArray(node2.content, content2, options2);
    const concatFunction = hasPreambleCode(node2.content) ? (x2) => x2 : fill;
    return concatFunction(rawContent);
  }
  function printComment(path2, _print2, _options) {
    const node2 = path2.getNode();
    let leadingWhitespace = "";
    if (node2.leadingWhitespace && node2.sameline) {
      leadingWhitespace = " ";
    }
    const content2 = [leadingWhitespace, "%" + printRaw(node2.content)];
    return content2;
  }
  function printInlineMath(path2, print, options2) {
    const node2 = path2.getNode();
    if (node2.content.length === 0) {
      return ["$", " ", "$"];
    }
    let content2 = path2.map(print, "content");
    content2 = formatDocArray(node2.content, content2, options2);
    content2 = joinWithSoftline(content2);
    if (node2.content[node2.content.length - 1].type === "comment") {
      content2.push(hardline);
    }
    return fill(["$", ...content2, "$"]);
  }
  function printDisplayMath(path2, print, options2) {
    const node2 = path2.getNode();
    let content2 = path2.map(print, "content");
    content2 = formatDocArray(node2.content, content2, options2);
    content2 = joinWithSoftline(content2);
    const bodyStartToken = [hardline];
    if (node2.content.length === 0 || node2.content[0].type === "comment" && node2.content[0].sameline) {
      bodyStartToken.pop();
    }
    return [
      ESCAPE + "[",
      indent(fill(bodyStartToken.concat(content2))),
      hardline,
      ESCAPE + "]"
    ];
  }
  function printVerbatimEnvironment(path2, print, options2) {
    const node2 = path2.getNode();
    const env2 = formatEnvSurround(node2);
    return [env2.start, node2.content, env2.end];
  }
  function printEnvironment(path2, print, options2) {
    const node2 = path2.getNode();
    const { renderInfo, previousNode, nextNode, referenceMap } = getNodeInfo(
      node2,
      options2
    );
    const args = node2.args ? path2.map(print, "args") : [];
    const env2 = formatEnvSurround(node2);
    let content2 = path2.map(print, "content");
    content2 = formatDocArray(node2.content, content2, options2);
    if (renderInfo.inMathMode) {
      content2 = joinWithSoftline(content2);
    }
    let bodyStartToken = [hardline];
    if (node2.content.length === 0 || node2.content[0].type === "comment" && node2.content[0].sameline) {
      bodyStartToken.pop();
    }
    return [
      env2.start,
      ...args,
      indent(fill(bodyStartToken.concat(content2))),
      hardline,
      env2.end
    ];
  }
  function printAlignedEnvironment(path2, print, options2) {
    const node2 = path2.getNode();
    getNodeInfo(
      node2,
      options2
    );
    const args = node2.args ? path2.map(print, "args") : [];
    const env2 = formatEnvSurround(node2);
    const leadingComment = node2.content[0] && node2.content[0].type === "comment" && node2.content[0].sameline ? node2.content[0] : null;
    const { rows, rowSeps, trailingComments } = formatAlignedContent(
      leadingComment ? node2.content.slice(1) : node2.content
    );
    const content2 = [];
    for (let i = 0; i < rows.length; i++) {
      const row2 = rows[i];
      const rowSep = rowSeps[i];
      const trailingComment = trailingComments[i];
      content2.push(row2);
      if (rowSep) {
        content2.push(printRaw(rowSep));
      }
      if (rowSep && trailingComment) {
        content2.push(" ");
      }
      if (trailingComment) {
        content2.push(["%", printRaw(trailingComment.content)]);
      }
      if (rowSep || trailingComment) {
        content2.push(hardline);
      }
    }
    if (content2[content2.length - 1] === hardline) {
      content2.pop();
    }
    if (leadingComment) {
      content2.unshift(
        leadingComment.leadingWhitespace ? " " : "",
        "%" + printRaw(leadingComment.content),
        hardline
      );
      return [env2.start, ...args, indent(content2), hardline, env2.end];
    }
    return [
      env2.start,
      ...args,
      indent([hardline, ...content2]),
      hardline,
      env2.end
    ];
  }
  function formatAlignedContent(nodes) {
    function getSpace(len = 1) {
      return " ".repeat(len);
    }
    const rows = parseAlignEnvironment(nodes);
    const numCols = Math.max(...rows.map((r) => r.cells.length));
    const rowSeps = rows.map(({ rowSep }) => printRaw(rowSep || []));
    const trailingComments = rows.map(({ trailingComment }) => trailingComment);
    const renderedRows = rows.map(({ cells: cells2, colSeps }) => ({
      cells: cells2.map((nodes2) => {
        trim(nodes2);
        return printRaw(nodes2);
      }),
      seps: colSeps.map((nodes2) => printRaw(nodes2))
    }));
    const colWidths = [];
    for (let i = 0; i < numCols; i++) {
      colWidths.push(
        Math.max(
          ...renderedRows.map(
            ({ cells: cells2, seps }) => ((cells2[i] || "") + (seps[i] || "")).length
          )
        )
      );
    }
    const joinedRows = renderedRows.map(({ cells: cells2, seps }) => {
      if (cells2.length === 1 && cells2[0] === "") {
        return "";
      }
      let ret = "";
      for (let i = 0; i < cells2.length; i++) {
        const width = colWidths[i] - (seps[i] || "").length;
        ret += (i === 0 ? "" : " ") + cells2[i] + getSpace(width - cells2[i].length + 1) + (seps[i] || "");
      }
      return ret;
    });
    return { rows: joinedRows, rowSeps, trailingComments };
  }
  class ReferenceMap {
    constructor(ast2) {
      this.ast = ast2;
      this.map = /* @__PURE__ */ new Map();
      visit$3(
        this.ast,
        (nodeList) => {
          for (let i = 0; i < nodeList.length; i++) {
            this.map.set(nodeList[i], {
              previous: nodeList[i - 1],
              next: nodeList[i + 1]
            });
          }
        },
        { includeArrays: true, test: Array.isArray }
      );
    }
    /**
     * Associate render-specific data with this node. This data
     * will be overwritten if `setRenderCache` is called twice.
     *
     * @param {Ast.Ast} node
     * @param {*} data
     * @memberof ReferenceMap
     */
    setRenderCache(node2, data) {
      const currData = this.map.get(node2) || {};
      this.map.set(node2, { ...currData, renderCache: data });
    }
    /**
     * Retrieve data associated with `node` via `setRenderCache`
     *
     * @param {Ast.Ast} node
     * @returns {(object | undefined)}
     * @memberof ReferenceMap
     */
    getRenderCache(node2) {
      var _a3;
      return (_a3 = this.map.get(node2)) == null ? void 0 : _a3.renderCache;
    }
    getPreviousNode(node2) {
      return (this.map.get(node2) || {}).previous;
    }
    getNextNode(node2) {
      return (this.map.get(node2) || {}).next;
    }
  }
  function printLatexAst(path2, options2, print) {
    const node2 = path2.getValue();
    const { renderInfo } = getNodeInfo(node2, options2);
    if (node2 == null) {
      return node2;
    }
    if (typeof node2 === "string") {
      return node2;
    }
    switch (node2.type) {
      case "root":
        if (options2.referenceMap) {
          console.warn(
            "Processing root node, but ReferenceMap already exists. Are there multiple nodes of type 'root'?"
          );
        }
        options2.referenceMap = new ReferenceMap(node2);
        return printRoot(path2, print, options2);
      case "argument":
        return printArgument(path2, print, options2);
      case "comment":
        return printComment(path2);
      case "environment":
      case "mathenv":
        if (renderInfo.alignContent) {
          return printAlignedEnvironment(path2, print, options2);
        }
        return printEnvironment(path2, print, options2);
      case "displaymath":
        return printDisplayMath(path2, print, options2);
      case "group":
        const content2 = printRaw(node2.content, {
          asArray: true
        }).map((token) => token === linebreak ? hardline : token);
        return ["{", ...content2, "}"];
      case "inlinemath":
        return printInlineMath(path2, print, options2);
      case "macro":
        return printMacro(path2, print, options2);
      case "parbreak":
        return [hardline, hardline];
      case "string":
        return node2.content;
      case "verb":
        return [
          ESCAPE,
          node2.env,
          node2.escape,
          printRaw(node2.content),
          node2.escape
        ];
      case "verbatim":
        return printVerbatimEnvironment(path2);
      case "whitespace":
        return line;
      default:
        console.warn(`Printing unknown type ${readableType(node2)}`, node2);
        return printRaw(node2);
    }
  }
  function readableType(obj) {
    if (obj == null) {
      return "null";
    }
    if (Array.isArray(obj)) {
      return "array";
    }
    return typeof obj;
  }
  const languages = [
    {
      name: "latex",
      extensions: [".tex"],
      parsers: ["latex-parser"]
    }
  ];
  const parsers = {
    "latex-parser": {
      parse: parse$3,
      astFormat: "latex-ast",
      locStart: (node2) => node2.position ? node2.position.start.offset : 0,
      locEnd: (node2) => node2.position ? node2.position.end.offset : 1
    }
  };
  const printers = {
    "latex-ast": {
      print: printLatexAst
    }
  };
  const prettierPluginLatex = { languages, parsers, printers };
  var unicode$3 = {};
  const UNDEFINED_CODE_POINTS = [
    65534,
    65535,
    131070,
    131071,
    196606,
    196607,
    262142,
    262143,
    327678,
    327679,
    393214,
    393215,
    458750,
    458751,
    524286,
    524287,
    589822,
    589823,
    655358,
    655359,
    720894,
    720895,
    786430,
    786431,
    851966,
    851967,
    917502,
    917503,
    983038,
    983039,
    1048574,
    1048575,
    1114110,
    1114111
  ];
  unicode$3.REPLACEMENT_CHARACTER = "ï¿½";
  unicode$3.CODE_POINTS = {
    EOF: -1,
    NULL: 0,
    TABULATION: 9,
    CARRIAGE_RETURN: 13,
    LINE_FEED: 10,
    FORM_FEED: 12,
    SPACE: 32,
    EXCLAMATION_MARK: 33,
    QUOTATION_MARK: 34,
    NUMBER_SIGN: 35,
    AMPERSAND: 38,
    APOSTROPHE: 39,
    HYPHEN_MINUS: 45,
    SOLIDUS: 47,
    DIGIT_0: 48,
    DIGIT_9: 57,
    SEMICOLON: 59,
    LESS_THAN_SIGN: 60,
    EQUALS_SIGN: 61,
    GREATER_THAN_SIGN: 62,
    QUESTION_MARK: 63,
    LATIN_CAPITAL_A: 65,
    LATIN_CAPITAL_F: 70,
    LATIN_CAPITAL_X: 88,
    LATIN_CAPITAL_Z: 90,
    RIGHT_SQUARE_BRACKET: 93,
    GRAVE_ACCENT: 96,
    LATIN_SMALL_A: 97,
    LATIN_SMALL_F: 102,
    LATIN_SMALL_X: 120,
    LATIN_SMALL_Z: 122,
    REPLACEMENT_CHARACTER: 65533
  };
  unicode$3.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [45, 45],
    //--
    DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
    //DOCTYPE
    CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
    //[CDATA[
    SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
    //script
    PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
    //PUBLIC
    SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
    //SYSTEM
  };
  unicode$3.isSurrogate = function(cp) {
    return cp >= 55296 && cp <= 57343;
  };
  unicode$3.isSurrogatePair = function(cp) {
    return cp >= 56320 && cp <= 57343;
  };
  unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  };
  unicode$3.isControlCodePoint = function(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  };
  unicode$3.isUndefinedCodePoint = function(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
  };
  var errorCodes = {
    controlCharacterInInputStream: "control-character-in-input-stream",
    noncharacterInInputStream: "noncharacter-in-input-stream",
    surrogateInInputStream: "surrogate-in-input-stream",
    nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
    endTagWithAttributes: "end-tag-with-attributes",
    endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
    unexpectedSolidusInTag: "unexpected-solidus-in-tag",
    unexpectedNullCharacter: "unexpected-null-character",
    unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
    invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
    unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
    missingEndTagName: "missing-end-tag-name",
    unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
    unknownNamedCharacterReference: "unknown-named-character-reference",
    missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
    unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
    unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
    eofBeforeTagName: "eof-before-tag-name",
    eofInTag: "eof-in-tag",
    missingAttributeValue: "missing-attribute-value",
    missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
    missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
    missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
    missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
    missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
    missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
    missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
    abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
    abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
    cdataInHtmlContent: "cdata-in-html-content",
    incorrectlyOpenedComment: "incorrectly-opened-comment",
    eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
    eofInDoctype: "eof-in-doctype",
    nestedComment: "nested-comment",
    abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
    eofInComment: "eof-in-comment",
    incorrectlyClosedComment: "incorrectly-closed-comment",
    eofInCdata: "eof-in-cdata",
    absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
    nullCharacterReference: "null-character-reference",
    surrogateCharacterReference: "surrogate-character-reference",
    characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
    controlCharacterReference: "control-character-reference",
    noncharacterCharacterReference: "noncharacter-character-reference",
    missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
    missingDoctypeName: "missing-doctype-name",
    invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
    duplicateAttribute: "duplicate-attribute",
    nonConformingDoctype: "non-conforming-doctype",
    missingDoctype: "missing-doctype",
    misplacedDoctype: "misplaced-doctype",
    endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
    closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
    disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
    openElementsLeftAfterEof: "open-elements-left-after-eof",
    abandonedHeadElementChild: "abandoned-head-element-child",
    misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
    nestedNoscriptInHead: "nested-noscript-in-head",
    eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
  };
  const unicode$2 = unicode$3;
  const ERR$2 = errorCodes;
  const $$6 = unicode$2.CODE_POINTS;
  const DEFAULT_BUFFER_WATERLINE = 1 << 16;
  let Preprocessor$1 = class Preprocessor {
    constructor() {
      this.html = null;
      this.pos = -1;
      this.lastGapPos = -1;
      this.lastCharPos = -1;
      this.gapStack = [];
      this.skipNextNewLine = false;
      this.lastChunkWritten = false;
      this.endOfChunkHit = false;
      this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    }
    _err() {
    }
    _addGap() {
      this.gapStack.push(this.lastGapPos);
      this.lastGapPos = this.pos;
    }
    _processSurrogate(cp) {
      if (this.pos !== this.lastCharPos) {
        const nextCp = this.html.charCodeAt(this.pos + 1);
        if (unicode$2.isSurrogatePair(nextCp)) {
          this.pos++;
          this._addGap();
          return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
        }
      } else if (!this.lastChunkWritten) {
        this.endOfChunkHit = true;
        return $$6.EOF;
      }
      this._err(ERR$2.surrogateInInputStream);
      return cp;
    }
    dropParsedChunk() {
      if (this.pos > this.bufferWaterline) {
        this.lastCharPos -= this.pos;
        this.html = this.html.substring(this.pos);
        this.pos = 0;
        this.lastGapPos = -1;
        this.gapStack = [];
      }
    }
    write(chunk, isLastChunk) {
      if (this.html) {
        this.html += chunk;
      } else {
        this.html = chunk;
      }
      this.lastCharPos = this.html.length - 1;
      this.endOfChunkHit = false;
      this.lastChunkWritten = isLastChunk;
    }
    insertHtmlAtCurrentPos(chunk) {
      this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
      this.lastCharPos = this.html.length - 1;
      this.endOfChunkHit = false;
    }
    advance() {
      this.pos++;
      if (this.pos > this.lastCharPos) {
        this.endOfChunkHit = !this.lastChunkWritten;
        return $$6.EOF;
      }
      let cp = this.html.charCodeAt(this.pos);
      if (this.skipNextNewLine && cp === $$6.LINE_FEED) {
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
      if (cp === $$6.CARRIAGE_RETURN) {
        this.skipNextNewLine = true;
        return $$6.LINE_FEED;
      }
      this.skipNextNewLine = false;
      if (unicode$2.isSurrogate(cp)) {
        cp = this._processSurrogate(cp);
      }
      const isCommonValidRange = cp > 31 && cp < 127 || cp === $$6.LINE_FEED || cp === $$6.CARRIAGE_RETURN || cp > 159 && cp < 64976;
      if (!isCommonValidRange) {
        this._checkForProblematicCharacters(cp);
      }
      return cp;
    }
    _checkForProblematicCharacters(cp) {
      if (unicode$2.isControlCodePoint(cp)) {
        this._err(ERR$2.controlCharacterInInputStream);
      } else if (unicode$2.isUndefinedCodePoint(cp)) {
        this._err(ERR$2.noncharacterInInputStream);
      }
    }
    retreat() {
      if (this.pos === this.lastGapPos) {
        this.lastGapPos = this.gapStack.pop();
        this.pos--;
      }
      this.pos--;
    }
  };
  var preprocessor = Preprocessor$1;
  var namedEntityData = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
  const Preprocessor = preprocessor;
  const unicode$1 = unicode$3;
  const neTree = namedEntityData;
  const ERR$1 = errorCodes;
  const $$5 = unicode$1.CODE_POINTS;
  const $$ = unicode$1.CODE_POINT_SEQUENCES;
  const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
  };
  const HAS_DATA_FLAG = 1 << 0;
  const DATA_DUPLET_FLAG = 1 << 1;
  const HAS_BRANCHES_FLAG = 1 << 2;
  const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
  const DATA_STATE = "DATA_STATE";
  const RCDATA_STATE = "RCDATA_STATE";
  const RAWTEXT_STATE = "RAWTEXT_STATE";
  const SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE";
  const PLAINTEXT_STATE = "PLAINTEXT_STATE";
  const TAG_OPEN_STATE = "TAG_OPEN_STATE";
  const END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE";
  const TAG_NAME_STATE = "TAG_NAME_STATE";
  const RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE";
  const RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE";
  const RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE";
  const RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE";
  const RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE";
  const RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE";
  const SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE";
  const SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE";
  const SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE";
  const SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE";
  const SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE";
  const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE";
  const BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE";
  const ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE";
  const AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE";
  const BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE";
  const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE";
  const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE";
  const ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE";
  const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE";
  const SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE";
  const BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE";
  const MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE";
  const COMMENT_START_STATE = "COMMENT_START_STATE";
  const COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE";
  const COMMENT_STATE = "COMMENT_STATE";
  const COMMENT_LESS_THAN_SIGN_STATE = "COMMENT_LESS_THAN_SIGN_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_STATE = "COMMENT_LESS_THAN_SIGN_BANG_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE";
  const COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE";
  const COMMENT_END_STATE = "COMMENT_END_STATE";
  const COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE";
  const DOCTYPE_STATE = "DOCTYPE_STATE";
  const BEFORE_DOCTYPE_NAME_STATE = "BEFORE_DOCTYPE_NAME_STATE";
  const DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE";
  const AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE";
  const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE";
  const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
  const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE";
  const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE";
  const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
  const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE";
  const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE";
  const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
  const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE";
  const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE";
  const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
  const BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE";
  const CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
  const CDATA_SECTION_BRACKET_STATE = "CDATA_SECTION_BRACKET_STATE";
  const CDATA_SECTION_END_STATE = "CDATA_SECTION_END_STATE";
  const CHARACTER_REFERENCE_STATE = "CHARACTER_REFERENCE_STATE";
  const NAMED_CHARACTER_REFERENCE_STATE = "NAMED_CHARACTER_REFERENCE_STATE";
  const AMBIGUOUS_AMPERSAND_STATE = "AMBIGUOS_AMPERSAND_STATE";
  const NUMERIC_CHARACTER_REFERENCE_STATE = "NUMERIC_CHARACTER_REFERENCE_STATE";
  const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE";
  const DECIMAL_CHARACTER_REFERENCE_START_STATE = "DECIMAL_CHARACTER_REFERENCE_START_STATE";
  const HEXADEMICAL_CHARACTER_REFERENCE_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_STATE";
  const DECIMAL_CHARACTER_REFERENCE_STATE = "DECIMAL_CHARACTER_REFERENCE_STATE";
  const NUMERIC_CHARACTER_REFERENCE_END_STATE = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
  function isWhitespace(cp) {
    return cp === $$5.SPACE || cp === $$5.LINE_FEED || cp === $$5.TABULATION || cp === $$5.FORM_FEED;
  }
  function isAsciiDigit(cp) {
    return cp >= $$5.DIGIT_0 && cp <= $$5.DIGIT_9;
  }
  function isAsciiUpper(cp) {
    return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_Z;
  }
  function isAsciiLower(cp) {
    return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_Z;
  }
  function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
  }
  function isAsciiAlphaNumeric(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
  }
  function isAsciiUpperHexDigit(cp) {
    return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_F;
  }
  function isAsciiLowerHexDigit(cp) {
    return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_F;
  }
  function isAsciiHexDigit(cp) {
    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
  }
  function toAsciiLowerCodePoint(cp) {
    return cp + 32;
  }
  function toChar(cp) {
    if (cp <= 65535) {
      return String.fromCharCode(cp);
    }
    cp -= 65536;
    return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
  }
  function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
  }
  function findNamedEntityTreeBranch(nodeIx, cp) {
    const branchCount = neTree[++nodeIx];
    let lo2 = ++nodeIx;
    let hi = lo2 + branchCount - 1;
    while (lo2 <= hi) {
      const mid = lo2 + hi >>> 1;
      const midCp = neTree[mid];
      if (midCp < cp) {
        lo2 = mid + 1;
      } else if (midCp > cp) {
        hi = mid - 1;
      } else {
        return neTree[mid + branchCount];
      }
    }
    return -1;
  }
  let Tokenizer$4 = class Tokenizer2 {
    constructor() {
      this.preprocessor = new Preprocessor();
      this.tokenQueue = [];
      this.allowCDATA = false;
      this.state = DATA_STATE;
      this.returnState = "";
      this.charRefCode = -1;
      this.tempBuff = [];
      this.lastStartTagName = "";
      this.consumedAfterSnapshot = -1;
      this.active = false;
      this.currentCharacterToken = null;
      this.currentToken = null;
      this.currentAttr = null;
    }
    //Errors
    _err() {
    }
    _errOnNextCodePoint(err) {
      this._consume();
      this._err(err);
      this._unconsume();
    }
    //API
    getNextToken() {
      while (!this.tokenQueue.length && this.active) {
        this.consumedAfterSnapshot = 0;
        const cp = this._consume();
        if (!this._ensureHibernation()) {
          this[this.state](cp);
        }
      }
      return this.tokenQueue.shift();
    }
    write(chunk, isLastChunk) {
      this.active = true;
      this.preprocessor.write(chunk, isLastChunk);
    }
    insertHtmlAtCurrentPos(chunk) {
      this.active = true;
      this.preprocessor.insertHtmlAtCurrentPos(chunk);
    }
    //Hibernation
    _ensureHibernation() {
      if (this.preprocessor.endOfChunkHit) {
        for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
          this.preprocessor.retreat();
        }
        this.active = false;
        this.tokenQueue.push({ type: Tokenizer2.HIBERNATION_TOKEN });
        return true;
      }
      return false;
    }
    //Consumption
    _consume() {
      this.consumedAfterSnapshot++;
      return this.preprocessor.advance();
    }
    _unconsume() {
      this.consumedAfterSnapshot--;
      this.preprocessor.retreat();
    }
    _reconsumeInState(state) {
      this.state = state;
      this._unconsume();
    }
    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
      let consumedCount = 0;
      let isMatch = true;
      const patternLength = pattern.length;
      let patternPos = 0;
      let cp = startCp;
      let patternCp = void 0;
      for (; patternPos < patternLength; patternPos++) {
        if (patternPos > 0) {
          cp = this._consume();
          consumedCount++;
        }
        if (cp === $$5.EOF) {
          isMatch = false;
          break;
        }
        patternCp = pattern[patternPos];
        if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
          isMatch = false;
          break;
        }
      }
      if (!isMatch) {
        while (consumedCount--) {
          this._unconsume();
        }
      }
      return isMatch;
    }
    //Temp buffer
    _isTempBufferEqualToScriptString() {
      if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
        return false;
      }
      for (let i = 0; i < this.tempBuff.length; i++) {
        if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
          return false;
        }
      }
      return true;
    }
    //Token creation
    _createStartTagToken() {
      this.currentToken = {
        type: Tokenizer2.START_TAG_TOKEN,
        tagName: "",
        selfClosing: false,
        ackSelfClosing: false,
        attrs: []
      };
    }
    _createEndTagToken() {
      this.currentToken = {
        type: Tokenizer2.END_TAG_TOKEN,
        tagName: "",
        selfClosing: false,
        attrs: []
      };
    }
    _createCommentToken() {
      this.currentToken = {
        type: Tokenizer2.COMMENT_TOKEN,
        data: ""
      };
    }
    _createDoctypeToken(initialName) {
      this.currentToken = {
        type: Tokenizer2.DOCTYPE_TOKEN,
        name: initialName,
        forceQuirks: false,
        publicId: null,
        systemId: null
      };
    }
    _createCharacterToken(type, ch) {
      this.currentCharacterToken = {
        type,
        chars: ch
      };
    }
    _createEOFToken() {
      this.currentToken = { type: Tokenizer2.EOF_TOKEN };
    }
    //Tag attributes
    _createAttr(attrNameFirstCh) {
      this.currentAttr = {
        name: attrNameFirstCh,
        value: ""
      };
    }
    _leaveAttrName(toState) {
      if (Tokenizer2.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
        this.currentToken.attrs.push(this.currentAttr);
      } else {
        this._err(ERR$1.duplicateAttribute);
      }
      this.state = toState;
    }
    _leaveAttrValue(toState) {
      this.state = toState;
    }
    //Token emission
    _emitCurrentToken() {
      this._emitCurrentCharacterToken();
      const ct2 = this.currentToken;
      this.currentToken = null;
      if (ct2.type === Tokenizer2.START_TAG_TOKEN) {
        this.lastStartTagName = ct2.tagName;
      } else if (ct2.type === Tokenizer2.END_TAG_TOKEN) {
        if (ct2.attrs.length > 0) {
          this._err(ERR$1.endTagWithAttributes);
        }
        if (ct2.selfClosing) {
          this._err(ERR$1.endTagWithTrailingSolidus);
        }
      }
      this.tokenQueue.push(ct2);
    }
    _emitCurrentCharacterToken() {
      if (this.currentCharacterToken) {
        this.tokenQueue.push(this.currentCharacterToken);
        this.currentCharacterToken = null;
      }
    }
    _emitEOFToken() {
      this._createEOFToken();
      this._emitCurrentToken();
    }
    //Characters emission
    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
    //If we have a sequence of characters that belong to the same group, parser can process it
    //as a single solid character token.
    //So, there are 3 types of character tokens in parse5:
    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
    _appendCharToCurrentCharacterToken(type, ch) {
      if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
        this._emitCurrentCharacterToken();
      }
      if (this.currentCharacterToken) {
        this.currentCharacterToken.chars += ch;
      } else {
        this._createCharacterToken(type, ch);
      }
    }
    _emitCodePoint(cp) {
      let type = Tokenizer2.CHARACTER_TOKEN;
      if (isWhitespace(cp)) {
        type = Tokenizer2.WHITESPACE_CHARACTER_TOKEN;
      } else if (cp === $$5.NULL) {
        type = Tokenizer2.NULL_CHARACTER_TOKEN;
      }
      this._appendCharToCurrentCharacterToken(type, toChar(cp));
    }
    _emitSeveralCodePoints(codePoints) {
      for (let i = 0; i < codePoints.length; i++) {
        this._emitCodePoint(codePoints[i]);
      }
    }
    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
    //So we can avoid additional checks here.
    _emitChars(ch) {
      this._appendCharToCurrentCharacterToken(Tokenizer2.CHARACTER_TOKEN, ch);
    }
    // Character reference helpers
    _matchNamedCharacterReference(startCp) {
      let result = null;
      let excess = 1;
      let i = findNamedEntityTreeBranch(0, startCp);
      this.tempBuff.push(startCp);
      while (i > -1) {
        const current = neTree[i];
        const inNode = current < MAX_BRANCH_MARKER_VALUE;
        const nodeWithData = inNode && current & HAS_DATA_FLAG;
        if (nodeWithData) {
          result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
          excess = 0;
        }
        const cp = this._consume();
        this.tempBuff.push(cp);
        excess++;
        if (cp === $$5.EOF) {
          break;
        }
        if (inNode) {
          i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
        } else {
          i = cp === current ? ++i : -1;
        }
      }
      while (excess--) {
        this.tempBuff.pop();
        this._unconsume();
      }
      return result;
    }
    _isCharacterReferenceInAttribute() {
      return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
    }
    _isCharacterReferenceAttributeQuirk(withSemicolon) {
      if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
        const nextCp = this._consume();
        this._unconsume();
        return nextCp === $$5.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
      }
      return false;
    }
    _flushCodePointsConsumedAsCharacterReference() {
      if (this._isCharacterReferenceInAttribute()) {
        for (let i = 0; i < this.tempBuff.length; i++) {
          this.currentAttr.value += toChar(this.tempBuff[i]);
        }
      } else {
        this._emitSeveralCodePoints(this.tempBuff);
      }
      this.tempBuff = [];
    }
    // State machine
    // Data state
    //------------------------------------------------------------------
    [DATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = TAG_OPEN_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = DATA_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitCodePoint(cp);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    //  RCDATA state
    //------------------------------------------------------------------
    [RCDATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.AMPERSAND) {
        this.returnState = RCDATA_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = RCDATA_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // RAWTEXT state
    //------------------------------------------------------------------
    [RAWTEXT_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data state
    //------------------------------------------------------------------
    [SCRIPT_DATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // PLAINTEXT state
    //------------------------------------------------------------------
    [PLAINTEXT_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Tag open state
    //------------------------------------------------------------------
    [TAG_OPEN_STATE](cp) {
      if (cp === $$5.EXCLAMATION_MARK) {
        this.state = MARKUP_DECLARATION_OPEN_STATE;
      } else if (cp === $$5.SOLIDUS) {
        this.state = END_TAG_OPEN_STATE;
      } else if (isAsciiLetter(cp)) {
        this._createStartTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
      } else if (cp === $$5.QUESTION_MARK) {
        this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofBeforeTagName);
        this._emitChars("<");
        this._emitEOFToken();
      } else {
        this._err(ERR$1.invalidFirstCharacterOfTagName);
        this._emitChars("<");
        this._reconsumeInState(DATA_STATE);
      }
    }
    // End tag open state
    //------------------------------------------------------------------
    [END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingEndTagName);
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofBeforeTagName);
        this._emitChars("</");
        this._emitEOFToken();
      } else {
        this._err(ERR$1.invalidFirstCharacterOfTagName);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      }
    }
    // Tag name state
    //------------------------------------------------------------------
    [TAG_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
      } else if (cp === $$5.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentToken.tagName += toChar(cp);
      }
    }
    // RCDATA less-than sign state
    //------------------------------------------------------------------
    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = RCDATA_END_TAG_OPEN_STATE;
      } else {
        this._emitChars("<");
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RCDATA end tag open state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RCDATA end tag name state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RAWTEXT less-than sign state
    //------------------------------------------------------------------
    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = RAWTEXT_END_TAG_OPEN_STATE;
      } else {
        this._emitChars("<");
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // RAWTEXT end tag open state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // RAWTEXT end tag name state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // Script data less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
      } else if (cp === $$5.EXCLAMATION_MARK) {
        this.state = SCRIPT_DATA_ESCAPE_START_STATE;
        this._emitChars("<!");
      } else {
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          } else if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          } else if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
        this._emitChars("-");
      } else {
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escape start dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else {
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChars(">");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
      } else if (isAsciiLetter(cp)) {
        this.tempBuff = [];
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
      } else {
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data escaped end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data escaped end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data double escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      } else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
      } else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
      } else {
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data double escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChars(">");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
        this._emitChars("/");
      } else {
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
      }
    }
    // Script data double escape end state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      } else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
      } else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
      } else {
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
      }
    }
    // Before attribute name state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
        this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.EQUALS_SIGN) {
        this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = ATTRIBUTE_NAME_STATE;
      } else {
        this._createAttr("");
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
      }
    }
    // Attribute name state
    //------------------------------------------------------------------
    [ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
        this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
        this._unconsume();
      } else if (cp === $$5.EQUALS_SIGN) {
        this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
      } else if (isAsciiUpper(cp)) {
        this.currentAttr.name += toAsciiLowerChar(cp);
      } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN) {
        this._err(ERR$1.unexpectedCharacterInAttributeName);
        this.currentAttr.name += toChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
      } else {
        this.currentAttr.name += toChar(cp);
      }
    }
    // After attribute name state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
      } else if (cp === $$5.EQUALS_SIGN) {
        this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._createAttr("");
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
      }
    }
    // Before attribute value state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingAttributeValue);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else {
        this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
      }
    }
    // Attribute value (double-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // Attribute value (single-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // Attribute value (unquoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
      if (isWhitespace(cp)) {
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN || cp === $$5.EQUALS_SIGN || cp === $$5.GRAVE_ACCENT) {
        this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += toChar(cp);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // After attribute value (quoted) state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
      if (isWhitespace(cp)) {
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.SOLIDUS) {
        this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingWhitespaceBetweenAttributes);
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
      }
    }
    // Self-closing start tag state
    //------------------------------------------------------------------
    [SELF_CLOSING_START_TAG_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.currentToken.selfClosing = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._err(ERR$1.unexpectedSolidusInTag);
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
      }
    }
    // Bogus comment state
    //------------------------------------------------------------------
    [BOGUS_COMMENT_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._emitCurrentToken();
        this._emitEOFToken();
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
      } else {
        this.currentToken.data += toChar(cp);
      }
    }
    // Markup declaration open state
    //------------------------------------------------------------------
    [MARKUP_DECLARATION_OPEN_STATE](cp) {
      if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
        this._createCommentToken();
        this.state = COMMENT_START_STATE;
      } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
        this.state = DOCTYPE_STATE;
      } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
        if (this.allowCDATA) {
          this.state = CDATA_SECTION_STATE;
        } else {
          this._err(ERR$1.cdataInHtmlContent);
          this._createCommentToken();
          this.currentToken.data = "[CDATA[";
          this.state = BOGUS_COMMENT_STATE;
        }
      } else if (!this._ensureHibernation()) {
        this._err(ERR$1.incorrectlyOpenedComment);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      }
    }
    // Comment start state
    //------------------------------------------------------------------
    [COMMENT_START_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_START_DASH_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptClosingOfEmptyComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment start dash state
    //------------------------------------------------------------------
    [COMMENT_START_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptClosingOfEmptyComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "-";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment state
    //------------------------------------------------------------------
    [COMMENT_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_DASH_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.currentToken.data += "<";
        this.state = COMMENT_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += toChar(cp);
      }
    }
    // Comment less-than sign state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.EXCLAMATION_MARK) {
        this.currentToken.data += "!";
        this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.currentToken.data += "!";
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment less-than sign bang state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment less-than sign bang dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
      } else {
        this._reconsumeInState(COMMENT_END_DASH_STATE);
      }
    }
    // Comment less-than sign bang dash dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
      if (cp !== $$5.GREATER_THAN_SIGN && cp !== $$5.EOF) {
        this._err(ERR$1.nestedComment);
      }
      this._reconsumeInState(COMMENT_END_STATE);
    }
    // Comment end dash state
    //------------------------------------------------------------------
    [COMMENT_END_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "-";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment end state
    //------------------------------------------------------------------
    [COMMENT_END_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EXCLAMATION_MARK) {
        this.state = COMMENT_END_BANG_STATE;
      } else if (cp === $$5.HYPHEN_MINUS) {
        this.currentToken.data += "-";
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "--";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment end bang state
    //------------------------------------------------------------------
    [COMMENT_END_BANG_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.currentToken.data += "--!";
        this.state = COMMENT_END_DASH_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.incorrectlyClosedComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "--!";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // DOCTYPE state
    //------------------------------------------------------------------
    [DOCTYPE_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
      }
    }
    // Before DOCTYPE name state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (isAsciiUpper(cp)) {
        this._createDoctypeToken(toAsciiLowerChar(cp));
        this.state = DOCTYPE_NAME_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
        this.state = DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeName);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._createDoctypeToken(toChar(cp));
        this.state = DOCTYPE_NAME_STATE;
      }
    }
    // DOCTYPE name state
    //------------------------------------------------------------------
    [DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = AFTER_DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (isAsciiUpper(cp)) {
        this.currentToken.name += toAsciiLowerChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.name += toChar(cp);
      }
    }
    // After DOCTYPE name state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
        this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
      } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
        this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
      } else if (!this._ensureHibernation()) {
        this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // After DOCTYPE public keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Before DOCTYPE public identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // DOCTYPE public identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.publicId += toChar(cp);
      }
    }
    // DOCTYPE public identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.publicId += toChar(cp);
      }
    }
    // After DOCTYPE public identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Between DOCTYPE public and system identifiers state
    //------------------------------------------------------------------
    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // After DOCTYPE system keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Before DOCTYPE system identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // DOCTYPE system identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.systemId += toChar(cp);
      }
    }
    // DOCTYPE system identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.systemId += toChar(cp);
      }
    }
    // After DOCTYPE system identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Bogus DOCTYPE state
    //------------------------------------------------------------------
    [BOGUS_DOCTYPE_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
      } else if (cp === $$5.EOF) {
        this._emitCurrentToken();
        this._emitEOFToken();
      }
    }
    // CDATA section state
    //------------------------------------------------------------------
    [CDATA_SECTION_STATE](cp) {
      if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this.state = CDATA_SECTION_BRACKET_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInCdata);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // CDATA section bracket state
    //------------------------------------------------------------------
    [CDATA_SECTION_BRACKET_STATE](cp) {
      if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this.state = CDATA_SECTION_END_STATE;
      } else {
        this._emitChars("]");
        this._reconsumeInState(CDATA_SECTION_STATE);
      }
    }
    // CDATA section end state
    //------------------------------------------------------------------
    [CDATA_SECTION_END_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
      } else if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this._emitChars("]");
      } else {
        this._emitChars("]]");
        this._reconsumeInState(CDATA_SECTION_STATE);
      }
    }
    // Character reference state
    //------------------------------------------------------------------
    [CHARACTER_REFERENCE_STATE](cp) {
      this.tempBuff = [$$5.AMPERSAND];
      if (cp === $$5.NUMBER_SIGN) {
        this.tempBuff.push(cp);
        this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
      } else if (isAsciiAlphaNumeric(cp)) {
        this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
      } else {
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Named character reference state
    //------------------------------------------------------------------
    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
      const matchResult = this._matchNamedCharacterReference(cp);
      if (this._ensureHibernation()) {
        this.tempBuff = [$$5.AMPERSAND];
      } else if (matchResult) {
        const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$5.SEMICOLON;
        if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
          if (!withSemicolon) {
            this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
          }
          this.tempBuff = matchResult;
        }
        this._flushCodePointsConsumedAsCharacterReference();
        this.state = this.returnState;
      } else {
        this._flushCodePointsConsumedAsCharacterReference();
        this.state = AMBIGUOUS_AMPERSAND_STATE;
      }
    }
    // Ambiguos ampersand state
    //------------------------------------------------------------------
    [AMBIGUOUS_AMPERSAND_STATE](cp) {
      if (isAsciiAlphaNumeric(cp)) {
        if (this._isCharacterReferenceInAttribute()) {
          this.currentAttr.value += toChar(cp);
        } else {
          this._emitCodePoint(cp);
        }
      } else {
        if (cp === $$5.SEMICOLON) {
          this._err(ERR$1.unknownNamedCharacterReference);
        }
        this._reconsumeInState(this.returnState);
      }
    }
    // Numeric character reference state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
      this.charRefCode = 0;
      if (cp === $$5.LATIN_SMALL_X || cp === $$5.LATIN_CAPITAL_X) {
        this.tempBuff.push(cp);
        this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
      } else {
        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
      }
    }
    // Hexademical character reference start state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
      if (isAsciiHexDigit(cp)) {
        this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
      } else {
        this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Decimal character reference start state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
      if (isAsciiDigit(cp)) {
        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
      } else {
        this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Hexademical character reference state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
      if (isAsciiUpperHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 55;
      } else if (isAsciiLowerHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 87;
      } else if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 48;
      } else if (cp === $$5.SEMICOLON) {
        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
      } else {
        this._err(ERR$1.missingSemicolonAfterCharacterReference);
        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
      }
    }
    // Decimal character reference state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
      if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 10 + cp - 48;
      } else if (cp === $$5.SEMICOLON) {
        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
      } else {
        this._err(ERR$1.missingSemicolonAfterCharacterReference);
        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
      }
    }
    // Numeric character reference end state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
      if (this.charRefCode === $$5.NULL) {
        this._err(ERR$1.nullCharacterReference);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (this.charRefCode > 1114111) {
        this._err(ERR$1.characterReferenceOutsideUnicodeRange);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (unicode$1.isSurrogate(this.charRefCode)) {
        this._err(ERR$1.surrogateCharacterReference);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
        this._err(ERR$1.noncharacterCharacterReference);
      } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$5.CARRIAGE_RETURN) {
        this._err(ERR$1.controlCharacterReference);
        const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
        if (replacement) {
          this.charRefCode = replacement;
        }
      }
      this.tempBuff = [this.charRefCode];
      this._flushCodePointsConsumedAsCharacterReference();
      this._reconsumeInState(this.returnState);
    }
  };
  Tokenizer$4.CHARACTER_TOKEN = "CHARACTER_TOKEN";
  Tokenizer$4.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
  Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
  Tokenizer$4.START_TAG_TOKEN = "START_TAG_TOKEN";
  Tokenizer$4.END_TAG_TOKEN = "END_TAG_TOKEN";
  Tokenizer$4.COMMENT_TOKEN = "COMMENT_TOKEN";
  Tokenizer$4.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
  Tokenizer$4.EOF_TOKEN = "EOF_TOKEN";
  Tokenizer$4.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
  Tokenizer$4.MODE = {
    DATA: DATA_STATE,
    RCDATA: RCDATA_STATE,
    RAWTEXT: RAWTEXT_STATE,
    SCRIPT_DATA: SCRIPT_DATA_STATE,
    PLAINTEXT: PLAINTEXT_STATE
  };
  Tokenizer$4.getTokenAttr = function(token, attrName) {
    for (let i = token.attrs.length - 1; i >= 0; i--) {
      if (token.attrs[i].name === attrName) {
        return token.attrs[i].value;
      }
    }
    return null;
  };
  var tokenizer = Tokenizer$4;
  var html$6 = {};
  const NS$3 = html$6.NAMESPACES = {
    HTML: "http://www.w3.org/1999/xhtml",
    MATHML: "http://www.w3.org/1998/Math/MathML",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/"
  };
  html$6.ATTRS = {
    TYPE: "type",
    ACTION: "action",
    ENCODING: "encoding",
    PROMPT: "prompt",
    NAME: "name",
    COLOR: "color",
    FACE: "face",
    SIZE: "size"
  };
  html$6.DOCUMENT_MODE = {
    NO_QUIRKS: "no-quirks",
    QUIRKS: "quirks",
    LIMITED_QUIRKS: "limited-quirks"
  };
  const $$4 = html$6.TAG_NAMES = {
    A: "a",
    ADDRESS: "address",
    ANNOTATION_XML: "annotation-xml",
    APPLET: "applet",
    AREA: "area",
    ARTICLE: "article",
    ASIDE: "aside",
    B: "b",
    BASE: "base",
    BASEFONT: "basefont",
    BGSOUND: "bgsound",
    BIG: "big",
    BLOCKQUOTE: "blockquote",
    BODY: "body",
    BR: "br",
    BUTTON: "button",
    CAPTION: "caption",
    CENTER: "center",
    CODE: "code",
    COL: "col",
    COLGROUP: "colgroup",
    DD: "dd",
    DESC: "desc",
    DETAILS: "details",
    DIALOG: "dialog",
    DIR: "dir",
    DIV: "div",
    DL: "dl",
    DT: "dt",
    EM: "em",
    EMBED: "embed",
    FIELDSET: "fieldset",
    FIGCAPTION: "figcaption",
    FIGURE: "figure",
    FONT: "font",
    FOOTER: "footer",
    FOREIGN_OBJECT: "foreignObject",
    FORM: "form",
    FRAME: "frame",
    FRAMESET: "frameset",
    H1: "h1",
    H2: "h2",
    H3: "h3",
    H4: "h4",
    H5: "h5",
    H6: "h6",
    HEAD: "head",
    HEADER: "header",
    HGROUP: "hgroup",
    HR: "hr",
    HTML: "html",
    I: "i",
    IMG: "img",
    IMAGE: "image",
    INPUT: "input",
    IFRAME: "iframe",
    KEYGEN: "keygen",
    LABEL: "label",
    LI: "li",
    LINK: "link",
    LISTING: "listing",
    MAIN: "main",
    MALIGNMARK: "malignmark",
    MARQUEE: "marquee",
    MATH: "math",
    MENU: "menu",
    META: "meta",
    MGLYPH: "mglyph",
    MI: "mi",
    MO: "mo",
    MN: "mn",
    MS: "ms",
    MTEXT: "mtext",
    NAV: "nav",
    NOBR: "nobr",
    NOFRAMES: "noframes",
    NOEMBED: "noembed",
    NOSCRIPT: "noscript",
    OBJECT: "object",
    OL: "ol",
    OPTGROUP: "optgroup",
    OPTION: "option",
    P: "p",
    PARAM: "param",
    PLAINTEXT: "plaintext",
    PRE: "pre",
    RB: "rb",
    RP: "rp",
    RT: "rt",
    RTC: "rtc",
    RUBY: "ruby",
    S: "s",
    SCRIPT: "script",
    SECTION: "section",
    SELECT: "select",
    SOURCE: "source",
    SMALL: "small",
    SPAN: "span",
    STRIKE: "strike",
    STRONG: "strong",
    STYLE: "style",
    SUB: "sub",
    SUMMARY: "summary",
    SUP: "sup",
    TABLE: "table",
    TBODY: "tbody",
    TEMPLATE: "template",
    TEXTAREA: "textarea",
    TFOOT: "tfoot",
    TD: "td",
    TH: "th",
    THEAD: "thead",
    TITLE: "title",
    TR: "tr",
    TRACK: "track",
    TT: "tt",
    U: "u",
    UL: "ul",
    SVG: "svg",
    VAR: "var",
    WBR: "wbr",
    XMP: "xmp"
  };
  html$6.SPECIAL_ELEMENTS = {
    [NS$3.HTML]: {
      [$$4.ADDRESS]: true,
      [$$4.APPLET]: true,
      [$$4.AREA]: true,
      [$$4.ARTICLE]: true,
      [$$4.ASIDE]: true,
      [$$4.BASE]: true,
      [$$4.BASEFONT]: true,
      [$$4.BGSOUND]: true,
      [$$4.BLOCKQUOTE]: true,
      [$$4.BODY]: true,
      [$$4.BR]: true,
      [$$4.BUTTON]: true,
      [$$4.CAPTION]: true,
      [$$4.CENTER]: true,
      [$$4.COL]: true,
      [$$4.COLGROUP]: true,
      [$$4.DD]: true,
      [$$4.DETAILS]: true,
      [$$4.DIR]: true,
      [$$4.DIV]: true,
      [$$4.DL]: true,
      [$$4.DT]: true,
      [$$4.EMBED]: true,
      [$$4.FIELDSET]: true,
      [$$4.FIGCAPTION]: true,
      [$$4.FIGURE]: true,
      [$$4.FOOTER]: true,
      [$$4.FORM]: true,
      [$$4.FRAME]: true,
      [$$4.FRAMESET]: true,
      [$$4.H1]: true,
      [$$4.H2]: true,
      [$$4.H3]: true,
      [$$4.H4]: true,
      [$$4.H5]: true,
      [$$4.H6]: true,
      [$$4.HEAD]: true,
      [$$4.HEADER]: true,
      [$$4.HGROUP]: true,
      [$$4.HR]: true,
      [$$4.HTML]: true,
      [$$4.IFRAME]: true,
      [$$4.IMG]: true,
      [$$4.INPUT]: true,
      [$$4.LI]: true,
      [$$4.LINK]: true,
      [$$4.LISTING]: true,
      [$$4.MAIN]: true,
      [$$4.MARQUEE]: true,
      [$$4.MENU]: true,
      [$$4.META]: true,
      [$$4.NAV]: true,
      [$$4.NOEMBED]: true,
      [$$4.NOFRAMES]: true,
      [$$4.NOSCRIPT]: true,
      [$$4.OBJECT]: true,
      [$$4.OL]: true,
      [$$4.P]: true,
      [$$4.PARAM]: true,
      [$$4.PLAINTEXT]: true,
      [$$4.PRE]: true,
      [$$4.SCRIPT]: true,
      [$$4.SECTION]: true,
      [$$4.SELECT]: true,
      [$$4.SOURCE]: true,
      [$$4.STYLE]: true,
      [$$4.SUMMARY]: true,
      [$$4.TABLE]: true,
      [$$4.TBODY]: true,
      [$$4.TD]: true,
      [$$4.TEMPLATE]: true,
      [$$4.TEXTAREA]: true,
      [$$4.TFOOT]: true,
      [$$4.TH]: true,
      [$$4.THEAD]: true,
      [$$4.TITLE]: true,
      [$$4.TR]: true,
      [$$4.TRACK]: true,
      [$$4.UL]: true,
      [$$4.WBR]: true,
      [$$4.XMP]: true
    },
    [NS$3.MATHML]: {
      [$$4.MI]: true,
      [$$4.MO]: true,
      [$$4.MN]: true,
      [$$4.MS]: true,
      [$$4.MTEXT]: true,
      [$$4.ANNOTATION_XML]: true
    },
    [NS$3.SVG]: {
      [$$4.TITLE]: true,
      [$$4.FOREIGN_OBJECT]: true,
      [$$4.DESC]: true
    }
  };
  const HTML$3 = html$6;
  const $$3 = HTML$3.TAG_NAMES;
  const NS$2 = HTML$3.NAMESPACES;
  function isImpliedEndTagRequired(tn2) {
    switch (tn2.length) {
      case 1:
        return tn2 === $$3.P;
      case 2:
        return tn2 === $$3.RB || tn2 === $$3.RP || tn2 === $$3.RT || tn2 === $$3.DD || tn2 === $$3.DT || tn2 === $$3.LI;
      case 3:
        return tn2 === $$3.RTC;
      case 6:
        return tn2 === $$3.OPTION;
      case 8:
        return tn2 === $$3.OPTGROUP;
    }
    return false;
  }
  function isImpliedEndTagRequiredThoroughly(tn2) {
    switch (tn2.length) {
      case 1:
        return tn2 === $$3.P;
      case 2:
        return tn2 === $$3.RB || tn2 === $$3.RP || tn2 === $$3.RT || tn2 === $$3.DD || tn2 === $$3.DT || tn2 === $$3.LI || tn2 === $$3.TD || tn2 === $$3.TH || tn2 === $$3.TR;
      case 3:
        return tn2 === $$3.RTC;
      case 5:
        return tn2 === $$3.TBODY || tn2 === $$3.TFOOT || tn2 === $$3.THEAD;
      case 6:
        return tn2 === $$3.OPTION;
      case 7:
        return tn2 === $$3.CAPTION;
      case 8:
        return tn2 === $$3.OPTGROUP || tn2 === $$3.COLGROUP;
    }
    return false;
  }
  function isScopingElement(tn2, ns) {
    switch (tn2.length) {
      case 2:
        if (tn2 === $$3.TD || tn2 === $$3.TH) {
          return ns === NS$2.HTML;
        } else if (tn2 === $$3.MI || tn2 === $$3.MO || tn2 === $$3.MN || tn2 === $$3.MS) {
          return ns === NS$2.MATHML;
        }
        break;
      case 4:
        if (tn2 === $$3.HTML) {
          return ns === NS$2.HTML;
        } else if (tn2 === $$3.DESC) {
          return ns === NS$2.SVG;
        }
        break;
      case 5:
        if (tn2 === $$3.TABLE) {
          return ns === NS$2.HTML;
        } else if (tn2 === $$3.MTEXT) {
          return ns === NS$2.MATHML;
        } else if (tn2 === $$3.TITLE) {
          return ns === NS$2.SVG;
        }
        break;
      case 6:
        return (tn2 === $$3.APPLET || tn2 === $$3.OBJECT) && ns === NS$2.HTML;
      case 7:
        return (tn2 === $$3.CAPTION || tn2 === $$3.MARQUEE) && ns === NS$2.HTML;
      case 8:
        return tn2 === $$3.TEMPLATE && ns === NS$2.HTML;
      case 13:
        return tn2 === $$3.FOREIGN_OBJECT && ns === NS$2.SVG;
      case 14:
        return tn2 === $$3.ANNOTATION_XML && ns === NS$2.MATHML;
    }
    return false;
  }
  let OpenElementStack$1 = class OpenElementStack {
    constructor(document2, treeAdapter) {
      this.stackTop = -1;
      this.items = [];
      this.current = document2;
      this.currentTagName = null;
      this.currentTmplContent = null;
      this.tmplCount = 0;
      this.treeAdapter = treeAdapter;
    }
    //Index of element
    _indexOf(element2) {
      let idx = -1;
      for (let i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element2) {
          idx = i;
          break;
        }
      }
      return idx;
    }
    //Update current element
    _isInTemplate() {
      return this.currentTagName === $$3.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$2.HTML;
    }
    _updateCurrentElement() {
      this.current = this.items[this.stackTop];
      this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
      this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
    }
    //Mutations
    push(element2) {
      this.items[++this.stackTop] = element2;
      this._updateCurrentElement();
      if (this._isInTemplate()) {
        this.tmplCount++;
      }
    }
    pop() {
      this.stackTop--;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount--;
      }
      this._updateCurrentElement();
    }
    replace(oldElement, newElement) {
      const idx = this._indexOf(oldElement);
      this.items[idx] = newElement;
      if (idx === this.stackTop) {
        this._updateCurrentElement();
      }
    }
    insertAfter(referenceElement, newElement) {
      const insertionIdx = this._indexOf(referenceElement) + 1;
      this.items.splice(insertionIdx, 0, newElement);
      if (insertionIdx === ++this.stackTop) {
        this._updateCurrentElement();
      }
    }
    popUntilTagNamePopped(tagName2) {
      while (this.stackTop > -1) {
        const tn2 = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn2 === tagName2 && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popUntilElementPopped(element2) {
      while (this.stackTop > -1) {
        const poppedElement = this.current;
        this.pop();
        if (poppedElement === element2) {
          break;
        }
      }
    }
    popUntilNumberedHeaderPopped() {
      while (this.stackTop > -1) {
        const tn2 = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn2 === $$3.H1 || tn2 === $$3.H2 || tn2 === $$3.H3 || tn2 === $$3.H4 || tn2 === $$3.H5 || tn2 === $$3.H6 && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popUntilTableCellPopped() {
      while (this.stackTop > -1) {
        const tn2 = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn2 === $$3.TD || tn2 === $$3.TH && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popAllUpToHtmlElement() {
      this.stackTop = 0;
      this._updateCurrentElement();
    }
    clearBackToTableContext() {
      while (this.currentTagName !== $$3.TABLE && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    clearBackToTableBodyContext() {
      while (this.currentTagName !== $$3.TBODY && this.currentTagName !== $$3.TFOOT && this.currentTagName !== $$3.THEAD && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    clearBackToTableRowContext() {
      while (this.currentTagName !== $$3.TR && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    remove(element2) {
      for (let i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element2) {
          this.items.splice(i, 1);
          this.stackTop--;
          this._updateCurrentElement();
          break;
        }
      }
    }
    //Search
    tryPeekProperlyNestedBodyElement() {
      const element2 = this.items[1];
      return element2 && this.treeAdapter.getTagName(element2) === $$3.BODY ? element2 : null;
    }
    contains(element2) {
      return this._indexOf(element2) > -1;
    }
    getCommonAncestor(element2) {
      let elementIdx = this._indexOf(element2);
      return --elementIdx >= 0 ? this.items[elementIdx] : null;
    }
    isRootHtmlElementCurrent() {
      return this.stackTop === 0 && this.currentTagName === $$3.HTML;
    }
    //Element in scope
    hasInScope(tagName2) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn2 === tagName2 && ns === NS$2.HTML) {
          return true;
        }
        if (isScopingElement(tn2, ns)) {
          return false;
        }
      }
      return true;
    }
    hasNumberedHeaderInScope() {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if ((tn2 === $$3.H1 || tn2 === $$3.H2 || tn2 === $$3.H3 || tn2 === $$3.H4 || tn2 === $$3.H5 || tn2 === $$3.H6) && ns === NS$2.HTML) {
          return true;
        }
        if (isScopingElement(tn2, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInListItemScope(tagName2) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn2 === tagName2 && ns === NS$2.HTML) {
          return true;
        }
        if ((tn2 === $$3.UL || tn2 === $$3.OL) && ns === NS$2.HTML || isScopingElement(tn2, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInButtonScope(tagName2) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (tn2 === tagName2 && ns === NS$2.HTML) {
          return true;
        }
        if (tn2 === $$3.BUTTON && ns === NS$2.HTML || isScopingElement(tn2, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInTableScope(tagName2) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn2 === tagName2) {
          return true;
        }
        if (tn2 === $$3.TABLE || tn2 === $$3.TEMPLATE || tn2 === $$3.HTML) {
          return false;
        }
      }
      return true;
    }
    hasTableBodyContextInTableScope() {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn2 === $$3.TBODY || tn2 === $$3.THEAD || tn2 === $$3.TFOOT) {
          return true;
        }
        if (tn2 === $$3.TABLE || tn2 === $$3.HTML) {
          return false;
        }
      }
      return true;
    }
    hasInSelectScope(tagName2) {
      for (let i = this.stackTop; i >= 0; i--) {
        const tn2 = this.treeAdapter.getTagName(this.items[i]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn2 === tagName2) {
          return true;
        }
        if (tn2 !== $$3.OPTION && tn2 !== $$3.OPTGROUP) {
          return false;
        }
      }
      return true;
    }
    //Implied end tags
    generateImpliedEndTags() {
      while (isImpliedEndTagRequired(this.currentTagName)) {
        this.pop();
      }
    }
    generateImpliedEndTagsThoroughly() {
      while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
        this.pop();
      }
    }
    generateImpliedEndTagsWithExclusion(exclusionTagName) {
      while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
        this.pop();
      }
    }
  };
  var openElementStack = OpenElementStack$1;
  const NOAH_ARK_CAPACITY = 3;
  let FormattingElementList$1 = class FormattingElementList2 {
    constructor(treeAdapter) {
      this.length = 0;
      this.entries = [];
      this.treeAdapter = treeAdapter;
      this.bookmark = null;
    }
    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement) {
      const candidates = [];
      if (this.length >= NOAH_ARK_CAPACITY) {
        const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
        const neTagName = this.treeAdapter.getTagName(newElement);
        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
        for (let i = this.length - 1; i >= 0; i--) {
          const entry = this.entries[i];
          if (entry.type === FormattingElementList2.MARKER_ENTRY) {
            break;
          }
          const element2 = entry.element;
          const elementAttrs = this.treeAdapter.getAttrList(element2);
          const isCandidate = this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI && elementAttrs.length === neAttrsLength;
          if (isCandidate) {
            candidates.push({ idx: i, attrs: elementAttrs });
          }
        }
      }
      return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
    }
    _ensureNoahArkCondition(newElement) {
      const candidates = this._getNoahArkConditionCandidates(newElement);
      let cLength = candidates.length;
      if (cLength) {
        const neAttrs = this.treeAdapter.getAttrList(newElement);
        const neAttrsLength = neAttrs.length;
        const neAttrsMap = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < neAttrsLength; i++) {
          const neAttr = neAttrs[i];
          neAttrsMap[neAttr.name] = neAttr.value;
        }
        for (let i = 0; i < neAttrsLength; i++) {
          for (let j = 0; j < cLength; j++) {
            const cAttr = candidates[j].attrs[i];
            if (neAttrsMap[cAttr.name] !== cAttr.value) {
              candidates.splice(j, 1);
              cLength--;
            }
            if (candidates.length < NOAH_ARK_CAPACITY) {
              return;
            }
          }
        }
        for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
          this.entries.splice(candidates[i].idx, 1);
          this.length--;
        }
      }
    }
    //Mutations
    insertMarker() {
      this.entries.push({ type: FormattingElementList2.MARKER_ENTRY });
      this.length++;
    }
    pushElement(element2, token) {
      this._ensureNoahArkCondition(element2);
      this.entries.push({
        type: FormattingElementList2.ELEMENT_ENTRY,
        element: element2,
        token
      });
      this.length++;
    }
    insertElementAfterBookmark(element2, token) {
      let bookmarkIdx = this.length - 1;
      for (; bookmarkIdx >= 0; bookmarkIdx--) {
        if (this.entries[bookmarkIdx] === this.bookmark) {
          break;
        }
      }
      this.entries.splice(bookmarkIdx + 1, 0, {
        type: FormattingElementList2.ELEMENT_ENTRY,
        element: element2,
        token
      });
      this.length++;
    }
    removeEntry(entry) {
      for (let i = this.length - 1; i >= 0; i--) {
        if (this.entries[i] === entry) {
          this.entries.splice(i, 1);
          this.length--;
          break;
        }
      }
    }
    clearToLastMarker() {
      while (this.length) {
        const entry = this.entries.pop();
        this.length--;
        if (entry.type === FormattingElementList2.MARKER_ENTRY) {
          break;
        }
      }
    }
    //Search
    getElementEntryInScopeWithTagName(tagName2) {
      for (let i = this.length - 1; i >= 0; i--) {
        const entry = this.entries[i];
        if (entry.type === FormattingElementList2.MARKER_ENTRY) {
          return null;
        }
        if (this.treeAdapter.getTagName(entry.element) === tagName2) {
          return entry;
        }
      }
      return null;
    }
    getElementEntry(element2) {
      for (let i = this.length - 1; i >= 0; i--) {
        const entry = this.entries[i];
        if (entry.type === FormattingElementList2.ELEMENT_ENTRY && entry.element === element2) {
          return entry;
        }
      }
      return null;
    }
  };
  FormattingElementList$1.MARKER_ENTRY = "MARKER_ENTRY";
  FormattingElementList$1.ELEMENT_ENTRY = "ELEMENT_ENTRY";
  var formattingElementList = FormattingElementList$1;
  let Mixin$9 = class Mixin {
    constructor(host) {
      const originalMethods = {};
      const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
      for (const key2 of Object.keys(overriddenMethods)) {
        if (typeof overriddenMethods[key2] === "function") {
          originalMethods[key2] = host[key2];
          host[key2] = overriddenMethods[key2];
        }
      }
    }
    _getOverriddenMethods() {
      throw new Error("Not implemented");
    }
  };
  Mixin$9.install = function(host, Ctor, opts) {
    if (!host.__mixins) {
      host.__mixins = [];
    }
    for (let i = 0; i < host.__mixins.length; i++) {
      if (host.__mixins[i].constructor === Ctor) {
        return host.__mixins[i];
      }
    }
    const mixin2 = new Ctor(host, opts);
    host.__mixins.push(mixin2);
    return mixin2;
  };
  var mixin = Mixin$9;
  const Mixin$8 = mixin;
  let PositionTrackingPreprocessorMixin$2 = class PositionTrackingPreprocessorMixin extends Mixin$8 {
    constructor(preprocessor2) {
      super(preprocessor2);
      this.preprocessor = preprocessor2;
      this.isEol = false;
      this.lineStartPos = 0;
      this.droppedBufferSize = 0;
      this.offset = 0;
      this.col = 0;
      this.line = 1;
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        advance() {
          const pos = this.pos + 1;
          const ch = this.html[pos];
          if (mxn.isEol) {
            mxn.isEol = false;
            mxn.line++;
            mxn.lineStartPos = pos;
          }
          if (ch === "\n" || ch === "\r" && this.html[pos + 1] !== "\n") {
            mxn.isEol = true;
          }
          mxn.col = pos - mxn.lineStartPos + 1;
          mxn.offset = mxn.droppedBufferSize + pos;
          return orig.advance.call(this);
        },
        retreat() {
          orig.retreat.call(this);
          mxn.isEol = false;
          mxn.col = this.pos - mxn.lineStartPos + 1;
        },
        dropParsedChunk() {
          const prevPos = this.pos;
          orig.dropParsedChunk.call(this);
          const reduction = prevPos - this.pos;
          mxn.lineStartPos -= reduction;
          mxn.droppedBufferSize += reduction;
          mxn.offset = mxn.droppedBufferSize + this.pos;
        }
      };
    }
  };
  var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;
  const Mixin$7 = mixin;
  const Tokenizer$3 = tokenizer;
  const PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;
  let LocationInfoTokenizerMixin$2 = class LocationInfoTokenizerMixin extends Mixin$7 {
    constructor(tokenizer2) {
      super(tokenizer2);
      this.tokenizer = tokenizer2;
      this.posTracker = Mixin$7.install(tokenizer2.preprocessor, PositionTrackingPreprocessorMixin$1);
      this.currentAttrLocation = null;
      this.ctLoc = null;
    }
    _getCurrentLocation() {
      return {
        startLine: this.posTracker.line,
        startCol: this.posTracker.col,
        startOffset: this.posTracker.offset,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
    }
    _attachCurrentAttrLocationInfo() {
      this.currentAttrLocation.endLine = this.posTracker.line;
      this.currentAttrLocation.endCol = this.posTracker.col;
      this.currentAttrLocation.endOffset = this.posTracker.offset;
      const currentToken = this.tokenizer.currentToken;
      const currentAttr = this.tokenizer.currentAttr;
      if (!currentToken.location.attrs) {
        currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
      }
      currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
    }
    _getOverriddenMethods(mxn, orig) {
      const methods = {
        _createStartTagToken() {
          orig._createStartTagToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createEndTagToken() {
          orig._createEndTagToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createCommentToken() {
          orig._createCommentToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createDoctypeToken(initialName) {
          orig._createDoctypeToken.call(this, initialName);
          this.currentToken.location = mxn.ctLoc;
        },
        _createCharacterToken(type, ch) {
          orig._createCharacterToken.call(this, type, ch);
          this.currentCharacterToken.location = mxn.ctLoc;
        },
        _createEOFToken() {
          orig._createEOFToken.call(this);
          this.currentToken.location = mxn._getCurrentLocation();
        },
        _createAttr(attrNameFirstCh) {
          orig._createAttr.call(this, attrNameFirstCh);
          mxn.currentAttrLocation = mxn._getCurrentLocation();
        },
        _leaveAttrName(toState) {
          orig._leaveAttrName.call(this, toState);
          mxn._attachCurrentAttrLocationInfo();
        },
        _leaveAttrValue(toState) {
          orig._leaveAttrValue.call(this, toState);
          mxn._attachCurrentAttrLocationInfo();
        },
        _emitCurrentToken() {
          const ctLoc = this.currentToken.location;
          if (this.currentCharacterToken) {
            this.currentCharacterToken.location.endLine = ctLoc.startLine;
            this.currentCharacterToken.location.endCol = ctLoc.startCol;
            this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
          }
          if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
            ctLoc.endLine = ctLoc.startLine;
            ctLoc.endCol = ctLoc.startCol;
            ctLoc.endOffset = ctLoc.startOffset;
          } else {
            ctLoc.endLine = mxn.posTracker.line;
            ctLoc.endCol = mxn.posTracker.col + 1;
            ctLoc.endOffset = mxn.posTracker.offset + 1;
          }
          orig._emitCurrentToken.call(this);
        },
        _emitCurrentCharacterToken() {
          const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
          if (ctLoc && ctLoc.endOffset === -1) {
            ctLoc.endLine = mxn.posTracker.line;
            ctLoc.endCol = mxn.posTracker.col;
            ctLoc.endOffset = mxn.posTracker.offset;
          }
          orig._emitCurrentCharacterToken.call(this);
        }
      };
      Object.keys(Tokenizer$3.MODE).forEach((modeName) => {
        const state = Tokenizer$3.MODE[modeName];
        methods[state] = function(cp) {
          mxn.ctLoc = mxn._getCurrentLocation();
          orig[state].call(this, cp);
        };
      });
      return methods;
    }
  };
  var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;
  const Mixin$6 = mixin;
  let LocationInfoOpenElementStackMixin$1 = class LocationInfoOpenElementStackMixin extends Mixin$6 {
    constructor(stack2, opts) {
      super(stack2);
      this.onItemPop = opts.onItemPop;
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        pop() {
          mxn.onItemPop(this.current);
          orig.pop.call(this);
        },
        popAllUpToHtmlElement() {
          for (let i = this.stackTop; i > 0; i--) {
            mxn.onItemPop(this.items[i]);
          }
          orig.popAllUpToHtmlElement.call(this);
        },
        remove(element2) {
          mxn.onItemPop(this.current);
          orig.remove.call(this, element2);
        }
      };
    }
  };
  var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
  const Mixin$5 = mixin;
  const Tokenizer$2 = tokenizer;
  const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
  const LocationInfoOpenElementStackMixin = openElementStackMixin;
  const HTML$2 = html$6;
  const $$2 = HTML$2.TAG_NAMES;
  let LocationInfoParserMixin$1 = class LocationInfoParserMixin extends Mixin$5 {
    constructor(parser2) {
      super(parser2);
      this.parser = parser2;
      this.treeAdapter = this.parser.treeAdapter;
      this.posTracker = null;
      this.lastStartTagToken = null;
      this.lastFosterParentingLocation = null;
      this.currentToken = null;
    }
    _setStartLocation(element2) {
      let loc = null;
      if (this.lastStartTagToken) {
        loc = Object.assign({}, this.lastStartTagToken.location);
        loc.startTag = this.lastStartTagToken.location;
      }
      this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
    }
    _setEndLocation(element2, closingToken) {
      const loc = this.treeAdapter.getNodeSourceCodeLocation(element2);
      if (loc) {
        if (closingToken.location) {
          const ctLoc = closingToken.location;
          const tn2 = this.treeAdapter.getTagName(element2);
          const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn2 === closingToken.tagName;
          const endLoc = {};
          if (isClosingEndTag) {
            endLoc.endTag = Object.assign({}, ctLoc);
            endLoc.endLine = ctLoc.endLine;
            endLoc.endCol = ctLoc.endCol;
            endLoc.endOffset = ctLoc.endOffset;
          } else {
            endLoc.endLine = ctLoc.startLine;
            endLoc.endCol = ctLoc.startCol;
            endLoc.endOffset = ctLoc.startOffset;
          }
          this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
        }
      }
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        _bootstrap(document2, fragmentContext) {
          orig._bootstrap.call(this, document2, fragmentContext);
          mxn.lastStartTagToken = null;
          mxn.lastFosterParentingLocation = null;
          mxn.currentToken = null;
          const tokenizerMixin2 = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);
          mxn.posTracker = tokenizerMixin2.posTracker;
          Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
            onItemPop: function(element2) {
              mxn._setEndLocation(element2, mxn.currentToken);
            }
          });
        },
        _runParsingLoop(scriptHandler) {
          orig._runParsingLoop.call(this, scriptHandler);
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
          }
        },
        //Token processing
        _processTokenInForeignContent(token) {
          mxn.currentToken = token;
          orig._processTokenInForeignContent.call(this, token);
        },
        _processToken(token) {
          mxn.currentToken = token;
          orig._processToken.call(this, token);
          const requireExplicitUpdate = token.type === Tokenizer$2.END_TAG_TOKEN && (token.tagName === $$2.HTML || token.tagName === $$2.BODY && this.openElements.hasInScope($$2.BODY));
          if (requireExplicitUpdate) {
            for (let i = this.openElements.stackTop; i >= 0; i--) {
              const element2 = this.openElements.items[i];
              if (this.treeAdapter.getTagName(element2) === token.tagName) {
                mxn._setEndLocation(element2, token);
                break;
              }
            }
          }
        },
        //Doctype
        _setDocumentType(token) {
          orig._setDocumentType.call(this, token);
          const documentChildren = this.treeAdapter.getChildNodes(this.document);
          const cnLength = documentChildren.length;
          for (let i = 0; i < cnLength; i++) {
            const node2 = documentChildren[i];
            if (this.treeAdapter.isDocumentTypeNode(node2)) {
              this.treeAdapter.setNodeSourceCodeLocation(node2, token.location);
              break;
            }
          }
        },
        //Elements
        _attachElementToTree(element2) {
          mxn._setStartLocation(element2);
          mxn.lastStartTagToken = null;
          orig._attachElementToTree.call(this, element2);
        },
        _appendElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;
          orig._appendElement.call(this, token, namespaceURI);
        },
        _insertElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;
          orig._insertElement.call(this, token, namespaceURI);
        },
        _insertTemplate(token) {
          mxn.lastStartTagToken = token;
          orig._insertTemplate.call(this, token);
          const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
        },
        _insertFakeRootElement() {
          orig._insertFakeRootElement.call(this);
          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
        },
        //Comments
        _appendCommentNode(token, parent) {
          orig._appendCommentNode.call(this, token, parent);
          const children = this.treeAdapter.getChildNodes(parent);
          const commentNode = children[children.length - 1];
          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
        },
        //Text
        _findFosterParentingLocation() {
          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
          return mxn.lastFosterParentingLocation;
        },
        _insertCharacters(token) {
          orig._insertCharacters.call(this, token);
          const hasFosterParent = this._shouldFosterParentOnInsertion();
          const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
          const siblings2 = this.treeAdapter.getChildNodes(parent);
          const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings2.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings2.length - 1;
          const textNode = siblings2[textNodeIdx];
          const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
          if (tnLoc) {
            const { endLine, endCol, endOffset } = token.location;
            this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
          } else {
            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
          }
        }
      };
    }
  };
  var parserMixin$1 = LocationInfoParserMixin$1;
  const Mixin$4 = mixin;
  let ErrorReportingMixinBase$3 = class ErrorReportingMixinBase extends Mixin$4 {
    constructor(host, opts) {
      super(host);
      this.posTracker = null;
      this.onParseError = opts.onParseError;
    }
    _setErrorLocation(err) {
      err.startLine = err.endLine = this.posTracker.line;
      err.startCol = err.endCol = this.posTracker.col;
      err.startOffset = err.endOffset = this.posTracker.offset;
    }
    _reportError(code2) {
      const err = {
        code: code2,
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
      this._setErrorLocation(err);
      this.onParseError(err);
    }
    _getOverriddenMethods(mxn) {
      return {
        _err(code2) {
          mxn._reportError(code2);
        }
      };
    }
  };
  var mixinBase = ErrorReportingMixinBase$3;
  const ErrorReportingMixinBase$2 = mixinBase;
  const PositionTrackingPreprocessorMixin = preprocessorMixin$1;
  const Mixin$3 = mixin;
  let ErrorReportingPreprocessorMixin$1 = class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase$2 {
    constructor(preprocessor2, opts) {
      super(preprocessor2, opts);
      this.posTracker = Mixin$3.install(preprocessor2, PositionTrackingPreprocessorMixin);
      this.lastErrOffset = -1;
    }
    _reportError(code2) {
      if (this.lastErrOffset !== this.posTracker.offset) {
        this.lastErrOffset = this.posTracker.offset;
        super._reportError(code2);
      }
    }
  };
  var preprocessorMixin = ErrorReportingPreprocessorMixin$1;
  const ErrorReportingMixinBase$1 = mixinBase;
  const ErrorReportingPreprocessorMixin = preprocessorMixin;
  const Mixin$2 = mixin;
  let ErrorReportingTokenizerMixin$1 = class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase$1 {
    constructor(tokenizer2, opts) {
      super(tokenizer2, opts);
      const preprocessorMixin2 = Mixin$2.install(tokenizer2.preprocessor, ErrorReportingPreprocessorMixin, opts);
      this.posTracker = preprocessorMixin2.posTracker;
    }
  };
  var tokenizerMixin = ErrorReportingTokenizerMixin$1;
  const ErrorReportingMixinBase = mixinBase;
  const ErrorReportingTokenizerMixin = tokenizerMixin;
  const LocationInfoTokenizerMixin = tokenizerMixin$1;
  const Mixin$1 = mixin;
  let ErrorReportingParserMixin$1 = class ErrorReportingParserMixin extends ErrorReportingMixinBase {
    constructor(parser2, opts) {
      super(parser2, opts);
      this.opts = opts;
      this.ctLoc = null;
      this.locBeforeToken = false;
    }
    _setErrorLocation(err) {
      if (this.ctLoc) {
        err.startLine = this.ctLoc.startLine;
        err.startCol = this.ctLoc.startCol;
        err.startOffset = this.ctLoc.startOffset;
        err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
        err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
        err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
      }
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        _bootstrap(document2, fragmentContext) {
          orig._bootstrap.call(this, document2, fragmentContext);
          Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
          Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
        },
        _processInputToken(token) {
          mxn.ctLoc = token.location;
          orig._processInputToken.call(this, token);
        },
        _err(code2, options2) {
          mxn.locBeforeToken = options2 && options2.beforeToken;
          mxn._reportError(code2);
        }
      };
    }
  };
  var parserMixin = ErrorReportingParserMixin$1;
  var _default = {};
  const { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html$6;
  _default.createDocument = function() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE$1.NO_QUIRKS,
      childNodes: []
    };
  };
  _default.createDocumentFragment = function() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  };
  _default.createElement = function(tagName2, namespaceURI, attrs) {
    return {
      nodeName: tagName2,
      tagName: tagName2,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  };
  _default.createCommentNode = function(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null
    };
  };
  const createTextNode = function(value2) {
    return {
      nodeName: "#text",
      value: value2,
      parentNode: null
    };
  };
  const appendChild = _default.appendChild = function(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  };
  const insertBefore = _default.insertBefore = function(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  };
  _default.setTemplateContent = function(templateElement, contentElement) {
    templateElement.content = contentElement;
  };
  _default.getTemplateContent = function(templateElement) {
    return templateElement.content;
  };
  _default.setDocumentType = function(document2, name2, publicId, systemId) {
    let doctypeNode = null;
    for (let i = 0; i < document2.childNodes.length; i++) {
      if (document2.childNodes[i].nodeName === "#documentType") {
        doctypeNode = document2.childNodes[i];
        break;
      }
    }
    if (doctypeNode) {
      doctypeNode.name = name2;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      appendChild(document2, {
        nodeName: "#documentType",
        name: name2,
        publicId,
        systemId
      });
    }
  };
  _default.setDocumentMode = function(document2, mode) {
    document2.mode = mode;
  };
  _default.getDocumentMode = function(document2) {
    return document2.mode;
  };
  _default.detachNode = function(node2) {
    if (node2.parentNode) {
      const idx = node2.parentNode.childNodes.indexOf(node2);
      node2.parentNode.childNodes.splice(idx, 1);
      node2.parentNode = null;
    }
  };
  _default.insertText = function(parentNode, text2) {
    if (parentNode.childNodes.length) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (prevNode.nodeName === "#text") {
        prevNode.value += text2;
        return;
      }
    }
    appendChild(parentNode, createTextNode(text2));
  };
  _default.insertTextBefore = function(parentNode, text2, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && prevNode.nodeName === "#text") {
      prevNode.value += text2;
    } else {
      insertBefore(parentNode, createTextNode(text2), referenceNode);
    }
  };
  _default.adoptAttributes = function(recipient, attrs) {
    const recipientAttrsMap = [];
    for (let i = 0; i < recipient.attrs.length; i++) {
      recipientAttrsMap.push(recipient.attrs[i].name);
    }
    for (let j = 0; j < attrs.length; j++) {
      if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
        recipient.attrs.push(attrs[j]);
      }
    }
  };
  _default.getFirstChild = function(node2) {
    return node2.childNodes[0];
  };
  _default.getChildNodes = function(node2) {
    return node2.childNodes;
  };
  _default.getParentNode = function(node2) {
    return node2.parentNode;
  };
  _default.getAttrList = function(element2) {
    return element2.attrs;
  };
  _default.getTagName = function(element2) {
    return element2.tagName;
  };
  _default.getNamespaceURI = function(element2) {
    return element2.namespaceURI;
  };
  _default.getTextNodeContent = function(textNode) {
    return textNode.value;
  };
  _default.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
  };
  _default.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode.name;
  };
  _default.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode.publicId;
  };
  _default.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode.systemId;
  };
  _default.isTextNode = function(node2) {
    return node2.nodeName === "#text";
  };
  _default.isCommentNode = function(node2) {
    return node2.nodeName === "#comment";
  };
  _default.isDocumentTypeNode = function(node2) {
    return node2.nodeName === "#documentType";
  };
  _default.isElementNode = function(node2) {
    return !!node2.tagName;
  };
  _default.setNodeSourceCodeLocation = function(node2, location2) {
    node2.sourceCodeLocation = location2;
  };
  _default.getNodeSourceCodeLocation = function(node2) {
    return node2.sourceCodeLocation;
  };
  _default.updateNodeSourceCodeLocation = function(node2, endLocation) {
    node2.sourceCodeLocation = Object.assign(node2.sourceCodeLocation, endLocation);
  };
  var mergeOptions$1 = function mergeOptions2(defaults2, options2) {
    options2 = options2 || /* @__PURE__ */ Object.create(null);
    return [defaults2, options2].reduce((merged, optObj) => {
      Object.keys(optObj).forEach((key2) => {
        merged[key2] = optObj[key2];
      });
      return merged;
    }, /* @__PURE__ */ Object.create(null));
  };
  var doctype$4 = {};
  const { DOCUMENT_MODE } = html$6;
  const VALID_DOCTYPE_NAME = "html";
  const VALID_SYSTEM_ID = "about:legacy-compat";
  const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
  const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
    "+//silmaril//dtd html pro v0r11 19970101//",
    "-//as//dtd html 3.0 aswedit + extensions//",
    "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
    "-//ietf//dtd html 2.0 level 1//",
    "-//ietf//dtd html 2.0 level 2//",
    "-//ietf//dtd html 2.0 strict level 1//",
    "-//ietf//dtd html 2.0 strict level 2//",
    "-//ietf//dtd html 2.0 strict//",
    "-//ietf//dtd html 2.0//",
    "-//ietf//dtd html 2.1e//",
    "-//ietf//dtd html 3.0//",
    "-//ietf//dtd html 3.2 final//",
    "-//ietf//dtd html 3.2//",
    "-//ietf//dtd html 3//",
    "-//ietf//dtd html level 0//",
    "-//ietf//dtd html level 1//",
    "-//ietf//dtd html level 2//",
    "-//ietf//dtd html level 3//",
    "-//ietf//dtd html strict level 0//",
    "-//ietf//dtd html strict level 1//",
    "-//ietf//dtd html strict level 2//",
    "-//ietf//dtd html strict level 3//",
    "-//ietf//dtd html strict//",
    "-//ietf//dtd html//",
    "-//metrius//dtd metrius presentational//",
    "-//microsoft//dtd internet explorer 2.0 html strict//",
    "-//microsoft//dtd internet explorer 2.0 html//",
    "-//microsoft//dtd internet explorer 2.0 tables//",
    "-//microsoft//dtd internet explorer 3.0 html strict//",
    "-//microsoft//dtd internet explorer 3.0 html//",
    "-//microsoft//dtd internet explorer 3.0 tables//",
    "-//netscape comm. corp.//dtd html//",
    "-//netscape comm. corp.//dtd strict html//",
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    "-//sq//dtd html 2.0 hotmetal + extensions//",
    "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
    "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
    "-//spyglass//dtd html 2.0 extended//",
    "-//sun microsystems corp.//dtd hotjava html//",
    "-//sun microsystems corp.//dtd hotjava strict html//",
    "-//w3c//dtd html 3 1995-03-24//",
    "-//w3c//dtd html 3.2 draft//",
    "-//w3c//dtd html 3.2 final//",
    "-//w3c//dtd html 3.2//",
    "-//w3c//dtd html 3.2s draft//",
    "-//w3c//dtd html 4.0 frameset//",
    "-//w3c//dtd html 4.0 transitional//",
    "-//w3c//dtd html experimental 19960712//",
    "-//w3c//dtd html experimental 970421//",
    "-//w3c//dtd w3 html//",
    "-//w3o//dtd w3 html 3.0//",
    "-//webtechs//dtd mozilla html 2.0//",
    "-//webtechs//dtd mozilla html//"
  ];
  const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ]);
  const QUIRKS_MODE_PUBLIC_IDS = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"];
  const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
  const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ]);
  function enquoteDoctypeId(id2) {
    const quote = id2.indexOf('"') !== -1 ? "'" : '"';
    return quote + id2 + quote;
  }
  function hasPrefix(publicId, prefixes) {
    for (let i = 0; i < prefixes.length; i++) {
      if (publicId.indexOf(prefixes[i]) === 0) {
        return true;
      }
    }
    return false;
  }
  doctype$4.isConforming = function(token) {
    return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
  };
  doctype$4.getDocumentMode = function(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
      return DOCUMENT_MODE.QUIRKS;
    }
    const systemId = token.systemId;
    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let publicId = token.publicId;
    if (publicId !== null) {
      publicId = publicId.toLowerCase();
      if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.LIMITED_QUIRKS;
      }
    }
    return DOCUMENT_MODE.NO_QUIRKS;
  };
  doctype$4.serializeContent = function(name2, publicId, systemId) {
    let str = "!DOCTYPE ";
    if (name2) {
      str += name2;
    }
    if (publicId) {
      str += " PUBLIC " + enquoteDoctypeId(publicId);
    } else if (systemId) {
      str += " SYSTEM";
    }
    if (systemId !== null) {
      str += " " + enquoteDoctypeId(systemId);
    }
    return str;
  };
  var foreignContent$1 = {};
  const Tokenizer$1 = tokenizer;
  const HTML$1 = html$6;
  const $$1 = HTML$1.TAG_NAMES;
  const NS$1 = HTML$1.NAMESPACES;
  const ATTRS$1 = HTML$1.ATTRS;
  const MIME_TYPES = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
  };
  const DEFINITION_URL_ATTR = "definitionurl";
  const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
  const SVG_ATTRS_ADJUSTMENT_MAP = {
    attributename: "attributeName",
    attributetype: "attributeType",
    basefrequency: "baseFrequency",
    baseprofile: "baseProfile",
    calcmode: "calcMode",
    clippathunits: "clipPathUnits",
    diffuseconstant: "diffuseConstant",
    edgemode: "edgeMode",
    filterunits: "filterUnits",
    glyphref: "glyphRef",
    gradienttransform: "gradientTransform",
    gradientunits: "gradientUnits",
    kernelmatrix: "kernelMatrix",
    kernelunitlength: "kernelUnitLength",
    keypoints: "keyPoints",
    keysplines: "keySplines",
    keytimes: "keyTimes",
    lengthadjust: "lengthAdjust",
    limitingconeangle: "limitingConeAngle",
    markerheight: "markerHeight",
    markerunits: "markerUnits",
    markerwidth: "markerWidth",
    maskcontentunits: "maskContentUnits",
    maskunits: "maskUnits",
    numoctaves: "numOctaves",
    pathlength: "pathLength",
    patterncontentunits: "patternContentUnits",
    patterntransform: "patternTransform",
    patternunits: "patternUnits",
    pointsatx: "pointsAtX",
    pointsaty: "pointsAtY",
    pointsatz: "pointsAtZ",
    preservealpha: "preserveAlpha",
    preserveaspectratio: "preserveAspectRatio",
    primitiveunits: "primitiveUnits",
    refx: "refX",
    refy: "refY",
    repeatcount: "repeatCount",
    repeatdur: "repeatDur",
    requiredextensions: "requiredExtensions",
    requiredfeatures: "requiredFeatures",
    specularconstant: "specularConstant",
    specularexponent: "specularExponent",
    spreadmethod: "spreadMethod",
    startoffset: "startOffset",
    stddeviation: "stdDeviation",
    stitchtiles: "stitchTiles",
    surfacescale: "surfaceScale",
    systemlanguage: "systemLanguage",
    tablevalues: "tableValues",
    targetx: "targetX",
    targety: "targetY",
    textlength: "textLength",
    viewbox: "viewBox",
    viewtarget: "viewTarget",
    xchannelselector: "xChannelSelector",
    ychannelselector: "yChannelSelector",
    zoomandpan: "zoomAndPan"
  };
  const XML_ATTRS_ADJUSTMENT_MAP = {
    "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS$1.XLINK },
    "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS$1.XLINK },
    "xlink:href": { prefix: "xlink", name: "href", namespace: NS$1.XLINK },
    "xlink:role": { prefix: "xlink", name: "role", namespace: NS$1.XLINK },
    "xlink:show": { prefix: "xlink", name: "show", namespace: NS$1.XLINK },
    "xlink:title": { prefix: "xlink", name: "title", namespace: NS$1.XLINK },
    "xlink:type": { prefix: "xlink", name: "type", namespace: NS$1.XLINK },
    "xml:base": { prefix: "xml", name: "base", namespace: NS$1.XML },
    "xml:lang": { prefix: "xml", name: "lang", namespace: NS$1.XML },
    "xml:space": { prefix: "xml", name: "space", namespace: NS$1.XML },
    xmlns: { prefix: "", name: "xmlns", namespace: NS$1.XMLNS },
    "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS$1.XMLNS }
  };
  const SVG_TAG_NAMES_ADJUSTMENT_MAP = foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    altglyph: "altGlyph",
    altglyphdef: "altGlyphDef",
    altglyphitem: "altGlyphItem",
    animatecolor: "animateColor",
    animatemotion: "animateMotion",
    animatetransform: "animateTransform",
    clippath: "clipPath",
    feblend: "feBlend",
    fecolormatrix: "feColorMatrix",
    fecomponenttransfer: "feComponentTransfer",
    fecomposite: "feComposite",
    feconvolvematrix: "feConvolveMatrix",
    fediffuselighting: "feDiffuseLighting",
    fedisplacementmap: "feDisplacementMap",
    fedistantlight: "feDistantLight",
    feflood: "feFlood",
    fefunca: "feFuncA",
    fefuncb: "feFuncB",
    fefuncg: "feFuncG",
    fefuncr: "feFuncR",
    fegaussianblur: "feGaussianBlur",
    feimage: "feImage",
    femerge: "feMerge",
    femergenode: "feMergeNode",
    femorphology: "feMorphology",
    feoffset: "feOffset",
    fepointlight: "fePointLight",
    fespecularlighting: "feSpecularLighting",
    fespotlight: "feSpotLight",
    fetile: "feTile",
    feturbulence: "feTurbulence",
    foreignobject: "foreignObject",
    glyphref: "glyphRef",
    lineargradient: "linearGradient",
    radialgradient: "radialGradient",
    textpath: "textPath"
  };
  const EXITS_FOREIGN_CONTENT = {
    [$$1.B]: true,
    [$$1.BIG]: true,
    [$$1.BLOCKQUOTE]: true,
    [$$1.BODY]: true,
    [$$1.BR]: true,
    [$$1.CENTER]: true,
    [$$1.CODE]: true,
    [$$1.DD]: true,
    [$$1.DIV]: true,
    [$$1.DL]: true,
    [$$1.DT]: true,
    [$$1.EM]: true,
    [$$1.EMBED]: true,
    [$$1.H1]: true,
    [$$1.H2]: true,
    [$$1.H3]: true,
    [$$1.H4]: true,
    [$$1.H5]: true,
    [$$1.H6]: true,
    [$$1.HEAD]: true,
    [$$1.HR]: true,
    [$$1.I]: true,
    [$$1.IMG]: true,
    [$$1.LI]: true,
    [$$1.LISTING]: true,
    [$$1.MENU]: true,
    [$$1.META]: true,
    [$$1.NOBR]: true,
    [$$1.OL]: true,
    [$$1.P]: true,
    [$$1.PRE]: true,
    [$$1.RUBY]: true,
    [$$1.S]: true,
    [$$1.SMALL]: true,
    [$$1.SPAN]: true,
    [$$1.STRONG]: true,
    [$$1.STRIKE]: true,
    [$$1.SUB]: true,
    [$$1.SUP]: true,
    [$$1.TABLE]: true,
    [$$1.TT]: true,
    [$$1.U]: true,
    [$$1.UL]: true,
    [$$1.VAR]: true
  };
  foreignContent$1.causesExit = function(startTagToken2) {
    const tn2 = startTagToken2.tagName;
    const isFontWithAttrs = tn2 === $$1.FONT && (Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.COLOR) !== null || Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.SIZE) !== null || Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.FACE) !== null);
    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn2];
  };
  foreignContent$1.adjustTokenMathMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      if (token.attrs[i].name === DEFINITION_URL_ATTR) {
        token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  };
  foreignContent$1.adjustTokenSVGAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
      if (adjustedAttrName) {
        token.attrs[i].name = adjustedAttrName;
      }
    }
  };
  foreignContent$1.adjustTokenXMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
      if (adjustedAttrEntry) {
        token.attrs[i].prefix = adjustedAttrEntry.prefix;
        token.attrs[i].name = adjustedAttrEntry.name;
        token.attrs[i].namespace = adjustedAttrEntry.namespace;
      }
    }
  };
  foreignContent$1.adjustTokenSVGTagName = function(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
    if (adjustedTagName) {
      token.tagName = adjustedTagName;
    }
  };
  function isMathMLTextIntegrationPoint(tn2, ns) {
    return ns === NS$1.MATHML && (tn2 === $$1.MI || tn2 === $$1.MO || tn2 === $$1.MN || tn2 === $$1.MS || tn2 === $$1.MTEXT);
  }
  function isHtmlIntegrationPoint(tn2, ns, attrs) {
    if (ns === NS$1.MATHML && tn2 === $$1.ANNOTATION_XML) {
      for (let i = 0; i < attrs.length; i++) {
        if (attrs[i].name === ATTRS$1.ENCODING) {
          const value2 = attrs[i].value.toLowerCase();
          return value2 === MIME_TYPES.TEXT_HTML || value2 === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns === NS$1.SVG && (tn2 === $$1.FOREIGN_OBJECT || tn2 === $$1.DESC || tn2 === $$1.TITLE);
  }
  foreignContent$1.isIntegrationPoint = function(tn2, ns, attrs, foreignNS) {
    if ((!foreignNS || foreignNS === NS$1.HTML) && isHtmlIntegrationPoint(tn2, ns, attrs)) {
      return true;
    }
    if ((!foreignNS || foreignNS === NS$1.MATHML) && isMathMLTextIntegrationPoint(tn2, ns)) {
      return true;
    }
    return false;
  };
  const Tokenizer = tokenizer;
  const OpenElementStack = openElementStack;
  const FormattingElementList = formattingElementList;
  const LocationInfoParserMixin = parserMixin$1;
  const ErrorReportingParserMixin = parserMixin;
  const Mixin = mixin;
  const defaultTreeAdapter = _default;
  const mergeOptions = mergeOptions$1;
  const doctype$3 = doctype$4;
  const foreignContent = foreignContent$1;
  const ERR = errorCodes;
  const unicode = unicode$3;
  const HTML = html$6;
  const $ = HTML.TAG_NAMES;
  const NS = HTML.NAMESPACES;
  const ATTRS = HTML.ATTRS;
  const DEFAULT_OPTIONS = {
    scriptingEnabled: true,
    sourceCodeLocationInfo: false,
    onParseError: null,
    treeAdapter: defaultTreeAdapter
  };
  const HIDDEN_INPUT_TYPE = "hidden";
  const AA_OUTER_LOOP_ITER = 8;
  const AA_INNER_LOOP_ITER = 3;
  const INITIAL_MODE = "INITIAL_MODE";
  const BEFORE_HTML_MODE = "BEFORE_HTML_MODE";
  const BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE";
  const IN_HEAD_MODE = "IN_HEAD_MODE";
  const IN_HEAD_NO_SCRIPT_MODE = "IN_HEAD_NO_SCRIPT_MODE";
  const AFTER_HEAD_MODE = "AFTER_HEAD_MODE";
  const IN_BODY_MODE = "IN_BODY_MODE";
  const TEXT_MODE = "TEXT_MODE";
  const IN_TABLE_MODE = "IN_TABLE_MODE";
  const IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE";
  const IN_CAPTION_MODE = "IN_CAPTION_MODE";
  const IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE";
  const IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE";
  const IN_ROW_MODE = "IN_ROW_MODE";
  const IN_CELL_MODE = "IN_CELL_MODE";
  const IN_SELECT_MODE = "IN_SELECT_MODE";
  const IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE";
  const IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE";
  const AFTER_BODY_MODE = "AFTER_BODY_MODE";
  const IN_FRAMESET_MODE = "IN_FRAMESET_MODE";
  const AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE";
  const AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE";
  const AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
  const INSERTION_MODE_RESET_MAP = {
    [$.TR]: IN_ROW_MODE,
    [$.TBODY]: IN_TABLE_BODY_MODE,
    [$.THEAD]: IN_TABLE_BODY_MODE,
    [$.TFOOT]: IN_TABLE_BODY_MODE,
    [$.CAPTION]: IN_CAPTION_MODE,
    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
    [$.TABLE]: IN_TABLE_MODE,
    [$.BODY]: IN_BODY_MODE,
    [$.FRAMESET]: IN_FRAMESET_MODE
  };
  const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
    [$.CAPTION]: IN_TABLE_MODE,
    [$.COLGROUP]: IN_TABLE_MODE,
    [$.TBODY]: IN_TABLE_MODE,
    [$.TFOOT]: IN_TABLE_MODE,
    [$.THEAD]: IN_TABLE_MODE,
    [$.COL]: IN_COLUMN_GROUP_MODE,
    [$.TR]: IN_TABLE_BODY_MODE,
    [$.TD]: IN_ROW_MODE,
    [$.TH]: IN_ROW_MODE
  };
  const TOKEN_HANDLERS = {
    [INITIAL_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
      [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
      [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
      [Tokenizer.EOF_TOKEN]: tokenInInitialMode
    },
    [BEFORE_HTML_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
      [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
      [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
    },
    [BEFORE_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
      [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
      [Tokenizer.EOF_TOKEN]: tokenBeforeHead
    },
    [IN_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagInHead,
      [Tokenizer.END_TAG_TOKEN]: endTagInHead,
      [Tokenizer.EOF_TOKEN]: tokenInHead
    },
    [IN_HEAD_NO_SCRIPT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
      [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
      [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
    },
    [AFTER_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
      [Tokenizer.EOF_TOKEN]: tokenAfterHead
    },
    [IN_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInBody,
      [Tokenizer.END_TAG_TOKEN]: endTagInBody,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [TEXT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: ignoreToken,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: ignoreToken,
      [Tokenizer.END_TAG_TOKEN]: endTagInText,
      [Tokenizer.EOF_TOKEN]: eofInText
    },
    [IN_TABLE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTable,
      [Tokenizer.END_TAG_TOKEN]: endTagInTable,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_TEXT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
      [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
      [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
      [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
      [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
      [Tokenizer.EOF_TOKEN]: tokenInTableText
    },
    [IN_CAPTION_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
      [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_COLUMN_GROUP_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
      [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
      [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_ROW_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInRow,
      [Tokenizer.END_TAG_TOKEN]: endTagInRow,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_CELL_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInCell,
      [Tokenizer.END_TAG_TOKEN]: endTagInCell,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
      [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_IN_TABLE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
      [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TEMPLATE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
      [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
      [Tokenizer.EOF_TOKEN]: eofInTemplate
    },
    [AFTER_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [IN_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
      [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
      [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
      [Tokenizer.END_TAG_TOKEN]: ignoreToken,
      [Tokenizer.EOF_TOKEN]: stopParsing
    }
  };
  class Parser {
    constructor(options2) {
      this.options = mergeOptions(DEFAULT_OPTIONS, options2);
      this.treeAdapter = this.options.treeAdapter;
      this.pendingScript = null;
      if (this.options.sourceCodeLocationInfo) {
        Mixin.install(this, LocationInfoParserMixin);
      }
      if (this.options.onParseError) {
        Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
      }
    }
    // API
    parse(html2) {
      const document2 = this.treeAdapter.createDocument();
      this._bootstrap(document2, null);
      this.tokenizer.write(html2, true);
      this._runParsingLoop(null);
      return document2;
    }
    parseFragment(html2, fragmentContext) {
      if (!fragmentContext) {
        fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
      }
      const documentMock = this.treeAdapter.createElement("documentmock", NS.HTML, []);
      this._bootstrap(documentMock, fragmentContext);
      if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
        this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
      }
      this._initTokenizerForFragmentParsing();
      this._insertFakeRootElement();
      this._resetInsertionMode();
      this._findFormInFragmentContext();
      this.tokenizer.write(html2, true);
      this._runParsingLoop(null);
      const rootElement = this.treeAdapter.getFirstChild(documentMock);
      const fragment2 = this.treeAdapter.createDocumentFragment();
      this._adoptNodes(rootElement, fragment2);
      return fragment2;
    }
    //Bootstrap parser
    _bootstrap(document2, fragmentContext) {
      this.tokenizer = new Tokenizer(this.options);
      this.stopped = false;
      this.insertionMode = INITIAL_MODE;
      this.originalInsertionMode = "";
      this.document = document2;
      this.fragmentContext = fragmentContext;
      this.headElement = null;
      this.formElement = null;
      this.openElements = new OpenElementStack(this.document, this.treeAdapter);
      this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
      this.tmplInsertionModeStack = [];
      this.tmplInsertionModeStackTop = -1;
      this.currentTmplInsertionMode = null;
      this.pendingCharacterTokens = [];
      this.hasNonWhitespacePendingCharacterToken = false;
      this.framesetOk = true;
      this.skipNextNewLine = false;
      this.fosterParentingEnabled = false;
    }
    //Errors
    _err() {
    }
    //Parsing loop
    _runParsingLoop(scriptHandler) {
      while (!this.stopped) {
        this._setupTokenizerCDATAMode();
        const token = this.tokenizer.getNextToken();
        if (token.type === Tokenizer.HIBERNATION_TOKEN) {
          break;
        }
        if (this.skipNextNewLine) {
          this.skipNextNewLine = false;
          if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
            if (token.chars.length === 1) {
              continue;
            }
            token.chars = token.chars.substr(1);
          }
        }
        this._processInputToken(token);
        if (scriptHandler && this.pendingScript) {
          break;
        }
      }
    }
    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
      this._runParsingLoop(scriptHandler);
      if (scriptHandler && this.pendingScript) {
        const script = this.pendingScript;
        this.pendingScript = null;
        scriptHandler(script);
        return;
      }
      if (writeCallback) {
        writeCallback();
      }
    }
    //Text parsing
    _setupTokenizerCDATAMode() {
      const current = this._getAdjustedCurrentElement();
      this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
    }
    _switchToTextParsing(currentToken, nextTokenizerState) {
      this._insertElement(currentToken, NS.HTML);
      this.tokenizer.state = nextTokenizerState;
      this.originalInsertionMode = this.insertionMode;
      this.insertionMode = TEXT_MODE;
    }
    switchToPlaintextParsing() {
      this.insertionMode = TEXT_MODE;
      this.originalInsertionMode = IN_BODY_MODE;
      this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }
    //Fragment parsing
    _getAdjustedCurrentElement() {
      return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
    }
    _findFormInFragmentContext() {
      let node2 = this.fragmentContext;
      do {
        if (this.treeAdapter.getTagName(node2) === $.FORM) {
          this.formElement = node2;
          break;
        }
        node2 = this.treeAdapter.getParentNode(node2);
      } while (node2);
    }
    _initTokenizerForFragmentParsing() {
      if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
        const tn2 = this.treeAdapter.getTagName(this.fragmentContext);
        if (tn2 === $.TITLE || tn2 === $.TEXTAREA) {
          this.tokenizer.state = Tokenizer.MODE.RCDATA;
        } else if (tn2 === $.STYLE || tn2 === $.XMP || tn2 === $.IFRAME || tn2 === $.NOEMBED || tn2 === $.NOFRAMES || tn2 === $.NOSCRIPT) {
          this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
        } else if (tn2 === $.SCRIPT) {
          this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
        } else if (tn2 === $.PLAINTEXT) {
          this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
        }
      }
    }
    //Tree mutation
    _setDocumentType(token) {
      const name2 = token.name || "";
      const publicId = token.publicId || "";
      const systemId = token.systemId || "";
      this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    }
    _attachElementToTree(element2) {
      if (this._shouldFosterParentOnInsertion()) {
        this._fosterParentElement(element2);
      } else {
        const parent = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.appendChild(parent, element2);
      }
    }
    _appendElement(token, namespaceURI) {
      const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element2);
    }
    _insertElement(token, namespaceURI) {
      const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element2);
      this.openElements.push(element2);
    }
    _insertFakeElement(tagName2) {
      const element2 = this.treeAdapter.createElement(tagName2, NS.HTML, []);
      this._attachElementToTree(element2);
      this.openElements.push(element2);
    }
    _insertTemplate(token) {
      const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
      const content2 = this.treeAdapter.createDocumentFragment();
      this.treeAdapter.setTemplateContent(tmpl, content2);
      this._attachElementToTree(tmpl);
      this.openElements.push(tmpl);
    }
    _insertFakeRootElement() {
      const element2 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
      this.treeAdapter.appendChild(this.openElements.current, element2);
      this.openElements.push(element2);
    }
    _appendCommentNode(token, parent) {
      const commentNode = this.treeAdapter.createCommentNode(token.data);
      this.treeAdapter.appendChild(parent, commentNode);
    }
    _insertCharacters(token) {
      if (this._shouldFosterParentOnInsertion()) {
        this._fosterParentText(token.chars);
      } else {
        const parent = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.insertText(parent, token.chars);
      }
    }
    _adoptNodes(donor, recipient) {
      for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
        this.treeAdapter.detachNode(child);
        this.treeAdapter.appendChild(recipient, child);
      }
    }
    //Token processing
    _shouldProcessTokenInForeignContent(token) {
      const current = this._getAdjustedCurrentElement();
      if (!current || current === this.document) {
        return false;
      }
      const ns = this.treeAdapter.getNamespaceURI(current);
      if (ns === NS.HTML) {
        return false;
      }
      if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
        return false;
      }
      const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
      const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;
      if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
        return false;
      }
      if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {
        return false;
      }
      return token.type !== Tokenizer.EOF_TOKEN;
    }
    _processToken(token) {
      TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
    }
    _processTokenInBodyMode(token) {
      TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
    }
    _processTokenInForeignContent(token) {
      if (token.type === Tokenizer.CHARACTER_TOKEN) {
        characterInForeignContent(this, token);
      } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
        nullCharacterInForeignContent(this, token);
      } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
        insertCharacters(this, token);
      } else if (token.type === Tokenizer.COMMENT_TOKEN) {
        appendComment(this, token);
      } else if (token.type === Tokenizer.START_TAG_TOKEN) {
        startTagInForeignContent(this, token);
      } else if (token.type === Tokenizer.END_TAG_TOKEN) {
        endTagInForeignContent(this, token);
      }
    }
    _processInputToken(token) {
      if (this._shouldProcessTokenInForeignContent(token)) {
        this._processTokenInForeignContent(token);
      } else {
        this._processToken(token);
      }
      if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
        this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
      }
    }
    //Integration points
    _isIntegrationPoint(element2, foreignNS) {
      const tn2 = this.treeAdapter.getTagName(element2);
      const ns = this.treeAdapter.getNamespaceURI(element2);
      const attrs = this.treeAdapter.getAttrList(element2);
      return foreignContent.isIntegrationPoint(tn2, ns, attrs, foreignNS);
    }
    //Active formatting elements reconstruction
    _reconstructActiveFormattingElements() {
      const listLength = this.activeFormattingElements.length;
      if (listLength) {
        let unopenIdx = listLength;
        let entry = null;
        do {
          unopenIdx--;
          entry = this.activeFormattingElements.entries[unopenIdx];
          if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
            unopenIdx++;
            break;
          }
        } while (unopenIdx > 0);
        for (let i = unopenIdx; i < listLength; i++) {
          entry = this.activeFormattingElements.entries[i];
          this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
          entry.element = this.openElements.current;
        }
      }
    }
    //Close elements
    _closeTableCell() {
      this.openElements.generateImpliedEndTags();
      this.openElements.popUntilTableCellPopped();
      this.activeFormattingElements.clearToLastMarker();
      this.insertionMode = IN_ROW_MODE;
    }
    _closePElement() {
      this.openElements.generateImpliedEndTagsWithExclusion($.P);
      this.openElements.popUntilTagNamePopped($.P);
    }
    //Insertion modes
    _resetInsertionMode() {
      for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
        let element2 = this.openElements.items[i];
        if (i === 0) {
          last = true;
          if (this.fragmentContext) {
            element2 = this.fragmentContext;
          }
        }
        const tn2 = this.treeAdapter.getTagName(element2);
        const newInsertionMode = INSERTION_MODE_RESET_MAP[tn2];
        if (newInsertionMode) {
          this.insertionMode = newInsertionMode;
          break;
        } else if (!last && (tn2 === $.TD || tn2 === $.TH)) {
          this.insertionMode = IN_CELL_MODE;
          break;
        } else if (!last && tn2 === $.HEAD) {
          this.insertionMode = IN_HEAD_MODE;
          break;
        } else if (tn2 === $.SELECT) {
          this._resetInsertionModeForSelect(i);
          break;
        } else if (tn2 === $.TEMPLATE) {
          this.insertionMode = this.currentTmplInsertionMode;
          break;
        } else if (tn2 === $.HTML) {
          this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
          break;
        } else if (last) {
          this.insertionMode = IN_BODY_MODE;
          break;
        }
      }
    }
    _resetInsertionModeForSelect(selectIdx) {
      if (selectIdx > 0) {
        for (let i = selectIdx - 1; i > 0; i--) {
          const ancestor = this.openElements.items[i];
          const tn2 = this.treeAdapter.getTagName(ancestor);
          if (tn2 === $.TEMPLATE) {
            break;
          } else if (tn2 === $.TABLE) {
            this.insertionMode = IN_SELECT_IN_TABLE_MODE;
            return;
          }
        }
      }
      this.insertionMode = IN_SELECT_MODE;
    }
    _pushTmplInsertionMode(mode) {
      this.tmplInsertionModeStack.push(mode);
      this.tmplInsertionModeStackTop++;
      this.currentTmplInsertionMode = mode;
    }
    _popTmplInsertionMode() {
      this.tmplInsertionModeStack.pop();
      this.tmplInsertionModeStackTop--;
      this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
    }
    //Foster parenting
    _isElementCausesFosterParenting(element2) {
      const tn2 = this.treeAdapter.getTagName(element2);
      return tn2 === $.TABLE || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD || tn2 === $.TR;
    }
    _shouldFosterParentOnInsertion() {
      return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
    }
    _findFosterParentingLocation() {
      const location2 = {
        parent: null,
        beforeElement: null
      };
      for (let i = this.openElements.stackTop; i >= 0; i--) {
        const openElement = this.openElements.items[i];
        const tn2 = this.treeAdapter.getTagName(openElement);
        const ns = this.treeAdapter.getNamespaceURI(openElement);
        if (tn2 === $.TEMPLATE && ns === NS.HTML) {
          location2.parent = this.treeAdapter.getTemplateContent(openElement);
          break;
        } else if (tn2 === $.TABLE) {
          location2.parent = this.treeAdapter.getParentNode(openElement);
          if (location2.parent) {
            location2.beforeElement = openElement;
          } else {
            location2.parent = this.openElements.items[i - 1];
          }
          break;
        }
      }
      if (!location2.parent) {
        location2.parent = this.openElements.items[0];
      }
      return location2;
    }
    _fosterParentElement(element2) {
      const location2 = this._findFosterParentingLocation();
      if (location2.beforeElement) {
        this.treeAdapter.insertBefore(location2.parent, element2, location2.beforeElement);
      } else {
        this.treeAdapter.appendChild(location2.parent, element2);
      }
    }
    _fosterParentText(chars) {
      const location2 = this._findFosterParentingLocation();
      if (location2.beforeElement) {
        this.treeAdapter.insertTextBefore(location2.parent, chars, location2.beforeElement);
      } else {
        this.treeAdapter.insertText(location2.parent, chars);
      }
    }
    //Special elements
    _isSpecialElement(element2) {
      const tn2 = this.treeAdapter.getTagName(element2);
      const ns = this.treeAdapter.getNamespaceURI(element2);
      return HTML.SPECIAL_ELEMENTS[ns][tn2];
    }
  }
  var parser$1 = Parser;
  function aaObtainFormattingElementEntry(p2, token) {
    let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
    if (formattingElementEntry) {
      if (!p2.openElements.contains(formattingElementEntry.element)) {
        p2.activeFormattingElements.removeEntry(formattingElementEntry);
        formattingElementEntry = null;
      } else if (!p2.openElements.hasInScope(token.tagName)) {
        formattingElementEntry = null;
      }
    } else {
      genericEndTagInBody(p2, token);
    }
    return formattingElementEntry;
  }
  function aaObtainFurthestBlock(p2, formattingElementEntry) {
    let furthestBlock = null;
    for (let i = p2.openElements.stackTop; i >= 0; i--) {
      const element2 = p2.openElements.items[i];
      if (element2 === formattingElementEntry.element) {
        break;
      }
      if (p2._isSpecialElement(element2)) {
        furthestBlock = element2;
      }
    }
    if (!furthestBlock) {
      p2.openElements.popUntilElementPopped(formattingElementEntry.element);
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
    }
    return furthestBlock;
  }
  function aaInnerLoop(p2, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
    for (let i = 0, element2 = nextElement; element2 !== formattingElement; i++, element2 = nextElement) {
      nextElement = p2.openElements.getCommonAncestor(element2);
      const elementEntry = p2.activeFormattingElements.getElementEntry(element2);
      const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
      const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
      if (shouldRemoveFromOpenElements) {
        if (counterOverflow) {
          p2.activeFormattingElements.removeEntry(elementEntry);
        }
        p2.openElements.remove(element2);
      } else {
        element2 = aaRecreateElementFromEntry(p2, elementEntry);
        if (lastElement === furthestBlock) {
          p2.activeFormattingElements.bookmark = elementEntry;
        }
        p2.treeAdapter.detachNode(lastElement);
        p2.treeAdapter.appendChild(element2, lastElement);
        lastElement = element2;
      }
    }
    return lastElement;
  }
  function aaRecreateElementFromEntry(p2, elementEntry) {
    const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
    p2.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;
    return newElement;
  }
  function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
    if (p2._isElementCausesFosterParenting(commonAncestor)) {
      p2._fosterParentElement(lastElement);
    } else {
      const tn2 = p2.treeAdapter.getTagName(commonAncestor);
      const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
      if (tn2 === $.TEMPLATE && ns === NS.HTML) {
        commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
      }
      p2.treeAdapter.appendChild(commonAncestor, lastElement);
    }
  }
  function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
    const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const token = formattingElementEntry.token;
    const newElement = p2.treeAdapter.createElement(token.tagName, ns, token.attrs);
    p2._adoptNodes(furthestBlock, newElement);
    p2.treeAdapter.appendChild(furthestBlock, newElement);
    p2.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p2.activeFormattingElements.removeEntry(formattingElementEntry);
    p2.openElements.remove(formattingElementEntry.element);
    p2.openElements.insertAfter(furthestBlock, newElement);
  }
  function callAdoptionAgency(p2, token) {
    let formattingElementEntry;
    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
      formattingElementEntry = aaObtainFormattingElementEntry(p2, token);
      if (!formattingElementEntry) {
        break;
      }
      const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
      if (!furthestBlock) {
        break;
      }
      p2.activeFormattingElements.bookmark = formattingElementEntry;
      const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
      const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
      p2.treeAdapter.detachNode(lastElement);
      aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
      aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
    }
  }
  function ignoreToken() {
  }
  function misplacedDoctype(p2) {
    p2._err(ERR.misplacedDoctype);
  }
  function appendComment(p2, token) {
    p2._appendCommentNode(token, p2.openElements.currentTmplContent || p2.openElements.current);
  }
  function appendCommentToRootHtmlElement(p2, token) {
    p2._appendCommentNode(token, p2.openElements.items[0]);
  }
  function appendCommentToDocument(p2, token) {
    p2._appendCommentNode(token, p2.document);
  }
  function insertCharacters(p2, token) {
    p2._insertCharacters(token);
  }
  function stopParsing(p2) {
    p2.stopped = true;
  }
  function doctypeInInitialMode(p2, token) {
    p2._setDocumentType(token);
    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype$3.getDocumentMode(token);
    if (!doctype$3.isConforming(token)) {
      p2._err(ERR.nonConformingDoctype);
    }
    p2.treeAdapter.setDocumentMode(p2.document, mode);
    p2.insertionMode = BEFORE_HTML_MODE;
  }
  function tokenInInitialMode(p2, token) {
    p2._err(ERR.missingDoctype, { beforeToken: true });
    p2.treeAdapter.setDocumentMode(p2.document, HTML.DOCUMENT_MODE.QUIRKS);
    p2.insertionMode = BEFORE_HTML_MODE;
    p2._processToken(token);
  }
  function startTagBeforeHtml(p2, token) {
    if (token.tagName === $.HTML) {
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = BEFORE_HEAD_MODE;
    } else {
      tokenBeforeHtml(p2, token);
    }
  }
  function endTagBeforeHtml(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML || tn2 === $.HEAD || tn2 === $.BODY || tn2 === $.BR) {
      tokenBeforeHtml(p2, token);
    }
  }
  function tokenBeforeHtml(p2, token) {
    p2._insertFakeRootElement();
    p2.insertionMode = BEFORE_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagBeforeHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.HEAD) {
      p2._insertElement(token, NS.HTML);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = IN_HEAD_MODE;
    } else {
      tokenBeforeHead(p2, token);
    }
  }
  function endTagBeforeHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HEAD || tn2 === $.BODY || tn2 === $.HTML || tn2 === $.BR) {
      tokenBeforeHead(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenBeforeHead(p2, token) {
    p2._insertFakeElement($.HEAD);
    p2.headElement = p2.openElements.current;
    p2.insertionMode = IN_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagInHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.BASE || tn2 === $.BASEFONT || tn2 === $.BGSOUND || tn2 === $.LINK || tn2 === $.META) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn2 === $.TITLE) {
      p2._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
    } else if (tn2 === $.NOSCRIPT) {
      if (p2.options.scriptingEnabled) {
        p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
      } else {
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
      }
    } else if (tn2 === $.NOFRAMES || tn2 === $.STYLE) {
      p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    } else if (tn2 === $.SCRIPT) {
      p2._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
    } else if (tn2 === $.TEMPLATE) {
      p2._insertTemplate(token, NS.HTML);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
      p2.insertionMode = IN_TEMPLATE_MODE;
      p2._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    } else if (tn2 === $.HEAD) {
      p2._err(ERR.misplacedStartTagForHeadElement);
    } else {
      tokenInHead(p2, token);
    }
  }
  function endTagInHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HEAD) {
      p2.openElements.pop();
      p2.insertionMode = AFTER_HEAD_MODE;
    } else if (tn2 === $.BODY || tn2 === $.BR || tn2 === $.HTML) {
      tokenInHead(p2, token);
    } else if (tn2 === $.TEMPLATE) {
      if (p2.openElements.tmplCount > 0) {
        p2.openElements.generateImpliedEndTagsThoroughly();
        if (p2.openElements.currentTagName !== $.TEMPLATE) {
          p2._err(ERR.closingOfElementWithOpenChildElements);
        }
        p2.openElements.popUntilTagNamePopped($.TEMPLATE);
        p2.activeFormattingElements.clearToLastMarker();
        p2._popTmplInsertionMode();
        p2._resetInsertionMode();
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHead(p2, token) {
    p2.openElements.pop();
    p2.insertionMode = AFTER_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagInHeadNoScript(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.BASEFONT || tn2 === $.BGSOUND || tn2 === $.HEAD || tn2 === $.LINK || tn2 === $.META || tn2 === $.NOFRAMES || tn2 === $.STYLE) {
      startTagInHead(p2, token);
    } else if (tn2 === $.NOSCRIPT) {
      p2._err(ERR.nestedNoscriptInHead);
    } else {
      tokenInHeadNoScript(p2, token);
    }
  }
  function endTagInHeadNoScript(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.NOSCRIPT) {
      p2.openElements.pop();
      p2.insertionMode = IN_HEAD_MODE;
    } else if (tn2 === $.BR) {
      tokenInHeadNoScript(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHeadNoScript(p2, token) {
    const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
    p2._err(errCode);
    p2.openElements.pop();
    p2.insertionMode = IN_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagAfterHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.BODY) {
      p2._insertElement(token, NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = IN_BODY_MODE;
    } else if (tn2 === $.FRAMESET) {
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_FRAMESET_MODE;
    } else if (tn2 === $.BASE || tn2 === $.BASEFONT || tn2 === $.BGSOUND || tn2 === $.LINK || tn2 === $.META || tn2 === $.NOFRAMES || tn2 === $.SCRIPT || tn2 === $.STYLE || tn2 === $.TEMPLATE || tn2 === $.TITLE) {
      p2._err(ERR.abandonedHeadElementChild);
      p2.openElements.push(p2.headElement);
      startTagInHead(p2, token);
      p2.openElements.remove(p2.headElement);
    } else if (tn2 === $.HEAD) {
      p2._err(ERR.misplacedStartTagForHeadElement);
    } else {
      tokenAfterHead(p2, token);
    }
  }
  function endTagAfterHead(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.BODY || tn2 === $.HTML || tn2 === $.BR) {
      tokenAfterHead(p2, token);
    } else if (tn2 === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenAfterHead(p2, token) {
    p2._insertFakeElement($.BODY);
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function whitespaceCharacterInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertCharacters(token);
  }
  function characterInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertCharacters(token);
    p2.framesetOk = false;
  }
  function htmlStartTagInBody(p2, token) {
    if (p2.openElements.tmplCount === 0) {
      p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token.attrs);
    }
  }
  function bodyStartTagInBody(p2, token) {
    const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
    if (bodyElement && p2.openElements.tmplCount === 0) {
      p2.framesetOk = false;
      p2.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
  }
  function framesetStartTagInBody(p2, token) {
    const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
    if (p2.framesetOk && bodyElement) {
      p2.treeAdapter.detachNode(bodyElement);
      p2.openElements.popAllUpToHtmlElement();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_FRAMESET_MODE;
    }
  }
  function addressStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function numberedHeaderStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    const tn2 = p2.openElements.currentTagName;
    if (tn2 === $.H1 || tn2 === $.H2 || tn2 === $.H3 || tn2 === $.H4 || tn2 === $.H5 || tn2 === $.H6) {
      p2.openElements.pop();
    }
    p2._insertElement(token, NS.HTML);
  }
  function preStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.skipNextNewLine = true;
    p2.framesetOk = false;
  }
  function formStartTagInBody(p2, token) {
    const inTemplate = p2.openElements.tmplCount > 0;
    if (!p2.formElement || inTemplate) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
      if (!inTemplate) {
        p2.formElement = p2.openElements.current;
      }
    }
  }
  function listItemStartTagInBody(p2, token) {
    p2.framesetOk = false;
    const tn2 = token.tagName;
    for (let i = p2.openElements.stackTop; i >= 0; i--) {
      const element2 = p2.openElements.items[i];
      const elementTn = p2.treeAdapter.getTagName(element2);
      let closeTn = null;
      if (tn2 === $.LI && elementTn === $.LI) {
        closeTn = $.LI;
      } else if ((tn2 === $.DD || tn2 === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
        closeTn = elementTn;
      }
      if (closeTn) {
        p2.openElements.generateImpliedEndTagsWithExclusion(closeTn);
        p2.openElements.popUntilTagNamePopped(closeTn);
        break;
      }
      if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p2._isSpecialElement(element2)) {
        break;
      }
    }
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function plaintextStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
  }
  function buttonStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.BUTTON)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped($.BUTTON);
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
  }
  function aStartTagInBody(p2, token) {
    const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
    if (activeElementEntry) {
      callAdoptionAgency(p2, token);
      p2.openElements.remove(activeElementEntry.element);
      p2.activeFormattingElements.removeEntry(activeElementEntry);
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function bStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function nobrStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    if (p2.openElements.hasInScope($.NOBR)) {
      callAdoptionAgency(p2, token);
      p2._reconstructActiveFormattingElements();
    }
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function appletStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.insertMarker();
    p2.framesetOk = false;
  }
  function tableStartTagInBody(p2, token) {
    if (p2.treeAdapter.getDocumentMode(p2.document) !== HTML.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
    p2.insertionMode = IN_TABLE_MODE;
  }
  function areaStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._appendElement(token, NS.HTML);
    p2.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function inputStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._appendElement(token, NS.HTML);
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
      p2.framesetOk = false;
    }
    token.ackSelfClosing = true;
  }
  function paramStartTagInBody(p2, token) {
    p2._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  }
  function hrStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._appendElement(token, NS.HTML);
    p2.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function imageStartTagInBody(p2, token) {
    token.tagName = $.IMG;
    areaStartTagInBody(p2, token);
  }
  function textareaStartTagInBody(p2, token) {
    p2._insertElement(token, NS.HTML);
    p2.skipNextNewLine = true;
    p2.tokenizer.state = Tokenizer.MODE.RCDATA;
    p2.originalInsertionMode = p2.insertionMode;
    p2.framesetOk = false;
    p2.insertionMode = TEXT_MODE;
  }
  function xmpStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._reconstructActiveFormattingElements();
    p2.framesetOk = false;
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function iframeStartTagInBody(p2, token) {
    p2.framesetOk = false;
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function noembedStartTagInBody(p2, token) {
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function selectStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
    if (p2.insertionMode === IN_TABLE_MODE || p2.insertionMode === IN_CAPTION_MODE || p2.insertionMode === IN_TABLE_BODY_MODE || p2.insertionMode === IN_ROW_MODE || p2.insertionMode === IN_CELL_MODE) {
      p2.insertionMode = IN_SELECT_IN_TABLE_MODE;
    } else {
      p2.insertionMode = IN_SELECT_MODE;
    }
  }
  function optgroupStartTagInBody(p2, token) {
    if (p2.openElements.currentTagName === $.OPTION) {
      p2.openElements.pop();
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
  }
  function rbStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.RUBY)) {
      p2.openElements.generateImpliedEndTags();
    }
    p2._insertElement(token, NS.HTML);
  }
  function rtStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.RUBY)) {
      p2.openElements.generateImpliedEndTagsWithExclusion($.RTC);
    }
    p2._insertElement(token, NS.HTML);
  }
  function menuStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function mathStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    foreignContent.adjustTokenMathMLAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p2._appendElement(token, NS.MATHML);
    } else {
      p2._insertElement(token, NS.MATHML);
    }
    token.ackSelfClosing = true;
  }
  function svgStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    foreignContent.adjustTokenSVGAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p2._appendElement(token, NS.SVG);
    } else {
      p2._insertElement(token, NS.SVG);
    }
    token.ackSelfClosing = true;
  }
  function genericStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
  }
  function startTagInBody(p2, token) {
    const tn2 = token.tagName;
    switch (tn2.length) {
      case 1:
        if (tn2 === $.I || tn2 === $.S || tn2 === $.B || tn2 === $.U) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.P) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.A) {
          aStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 2:
        if (tn2 === $.DL || tn2 === $.OL || tn2 === $.UL) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.H1 || tn2 === $.H2 || tn2 === $.H3 || tn2 === $.H4 || tn2 === $.H5 || tn2 === $.H6) {
          numberedHeaderStartTagInBody(p2, token);
        } else if (tn2 === $.LI || tn2 === $.DD || tn2 === $.DT) {
          listItemStartTagInBody(p2, token);
        } else if (tn2 === $.EM || tn2 === $.TT) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.BR) {
          areaStartTagInBody(p2, token);
        } else if (tn2 === $.HR) {
          hrStartTagInBody(p2, token);
        } else if (tn2 === $.RB) {
          rbStartTagInBody(p2, token);
        } else if (tn2 === $.RT || tn2 === $.RP) {
          rtStartTagInBody(p2, token);
        } else if (tn2 !== $.TH && tn2 !== $.TD && tn2 !== $.TR) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 3:
        if (tn2 === $.DIV || tn2 === $.DIR || tn2 === $.NAV) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.PRE) {
          preStartTagInBody(p2, token);
        } else if (tn2 === $.BIG) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.IMG || tn2 === $.WBR) {
          areaStartTagInBody(p2, token);
        } else if (tn2 === $.XMP) {
          xmpStartTagInBody(p2, token);
        } else if (tn2 === $.SVG) {
          svgStartTagInBody(p2, token);
        } else if (tn2 === $.RTC) {
          rbStartTagInBody(p2, token);
        } else if (tn2 !== $.COL) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 4:
        if (tn2 === $.HTML) {
          htmlStartTagInBody(p2, token);
        } else if (tn2 === $.BASE || tn2 === $.LINK || tn2 === $.META) {
          startTagInHead(p2, token);
        } else if (tn2 === $.BODY) {
          bodyStartTagInBody(p2, token);
        } else if (tn2 === $.MAIN || tn2 === $.MENU) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.FORM) {
          formStartTagInBody(p2, token);
        } else if (tn2 === $.CODE || tn2 === $.FONT) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.NOBR) {
          nobrStartTagInBody(p2, token);
        } else if (tn2 === $.AREA) {
          areaStartTagInBody(p2, token);
        } else if (tn2 === $.MATH) {
          mathStartTagInBody(p2, token);
        } else if (tn2 === $.MENU) {
          menuStartTagInBody(p2, token);
        } else if (tn2 !== $.HEAD) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 5:
        if (tn2 === $.STYLE || tn2 === $.TITLE) {
          startTagInHead(p2, token);
        } else if (tn2 === $.ASIDE) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.SMALL) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.TABLE) {
          tableStartTagInBody(p2, token);
        } else if (tn2 === $.EMBED) {
          areaStartTagInBody(p2, token);
        } else if (tn2 === $.INPUT) {
          inputStartTagInBody(p2, token);
        } else if (tn2 === $.PARAM || tn2 === $.TRACK) {
          paramStartTagInBody(p2, token);
        } else if (tn2 === $.IMAGE) {
          imageStartTagInBody(p2, token);
        } else if (tn2 !== $.FRAME && tn2 !== $.TBODY && tn2 !== $.TFOOT && tn2 !== $.THEAD) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 6:
        if (tn2 === $.SCRIPT) {
          startTagInHead(p2, token);
        } else if (tn2 === $.CENTER || tn2 === $.FIGURE || tn2 === $.FOOTER || tn2 === $.HEADER || tn2 === $.HGROUP || tn2 === $.DIALOG) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.BUTTON) {
          buttonStartTagInBody(p2, token);
        } else if (tn2 === $.STRIKE || tn2 === $.STRONG) {
          bStartTagInBody(p2, token);
        } else if (tn2 === $.APPLET || tn2 === $.OBJECT) {
          appletStartTagInBody(p2, token);
        } else if (tn2 === $.KEYGEN) {
          areaStartTagInBody(p2, token);
        } else if (tn2 === $.SOURCE) {
          paramStartTagInBody(p2, token);
        } else if (tn2 === $.IFRAME) {
          iframeStartTagInBody(p2, token);
        } else if (tn2 === $.SELECT) {
          selectStartTagInBody(p2, token);
        } else if (tn2 === $.OPTION) {
          optgroupStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 7:
        if (tn2 === $.BGSOUND) {
          startTagInHead(p2, token);
        } else if (tn2 === $.DETAILS || tn2 === $.ADDRESS || tn2 === $.ARTICLE || tn2 === $.SECTION || tn2 === $.SUMMARY) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.LISTING) {
          preStartTagInBody(p2, token);
        } else if (tn2 === $.MARQUEE) {
          appletStartTagInBody(p2, token);
        } else if (tn2 === $.NOEMBED) {
          noembedStartTagInBody(p2, token);
        } else if (tn2 !== $.CAPTION) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 8:
        if (tn2 === $.BASEFONT) {
          startTagInHead(p2, token);
        } else if (tn2 === $.FRAMESET) {
          framesetStartTagInBody(p2, token);
        } else if (tn2 === $.FIELDSET) {
          addressStartTagInBody(p2, token);
        } else if (tn2 === $.TEXTAREA) {
          textareaStartTagInBody(p2, token);
        } else if (tn2 === $.TEMPLATE) {
          startTagInHead(p2, token);
        } else if (tn2 === $.NOSCRIPT) {
          if (p2.options.scriptingEnabled) {
            noembedStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
        } else if (tn2 === $.OPTGROUP) {
          optgroupStartTagInBody(p2, token);
        } else if (tn2 !== $.COLGROUP) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 9:
        if (tn2 === $.PLAINTEXT) {
          plaintextStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 10:
        if (tn2 === $.BLOCKQUOTE || tn2 === $.FIGCAPTION) {
          addressStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      default:
        genericStartTagInBody(p2, token);
    }
  }
  function bodyEndTagInBody(p2) {
    if (p2.openElements.hasInScope($.BODY)) {
      p2.insertionMode = AFTER_BODY_MODE;
    }
  }
  function htmlEndTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.BODY)) {
      p2.insertionMode = AFTER_BODY_MODE;
      p2._processToken(token);
    }
  }
  function addressEndTagInBody(p2, token) {
    const tn2 = token.tagName;
    if (p2.openElements.hasInScope(tn2)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(tn2);
    }
  }
  function formEndTagInBody(p2) {
    const inTemplate = p2.openElements.tmplCount > 0;
    const formElement = p2.formElement;
    if (!inTemplate) {
      p2.formElement = null;
    }
    if ((formElement || inTemplate) && p2.openElements.hasInScope($.FORM)) {
      p2.openElements.generateImpliedEndTags();
      if (inTemplate) {
        p2.openElements.popUntilTagNamePopped($.FORM);
      } else {
        p2.openElements.remove(formElement);
      }
    }
  }
  function pEndTagInBody(p2) {
    if (!p2.openElements.hasInButtonScope($.P)) {
      p2._insertFakeElement($.P);
    }
    p2._closePElement();
  }
  function liEndTagInBody(p2) {
    if (p2.openElements.hasInListItemScope($.LI)) {
      p2.openElements.generateImpliedEndTagsWithExclusion($.LI);
      p2.openElements.popUntilTagNamePopped($.LI);
    }
  }
  function ddEndTagInBody(p2, token) {
    const tn2 = token.tagName;
    if (p2.openElements.hasInScope(tn2)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(tn2);
      p2.openElements.popUntilTagNamePopped(tn2);
    }
  }
  function numberedHeaderEndTagInBody(p2) {
    if (p2.openElements.hasNumberedHeaderInScope()) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilNumberedHeaderPopped();
    }
  }
  function appletEndTagInBody(p2, token) {
    const tn2 = token.tagName;
    if (p2.openElements.hasInScope(tn2)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(tn2);
      p2.activeFormattingElements.clearToLastMarker();
    }
  }
  function brEndTagInBody(p2) {
    p2._reconstructActiveFormattingElements();
    p2._insertFakeElement($.BR);
    p2.openElements.pop();
    p2.framesetOk = false;
  }
  function genericEndTagInBody(p2, token) {
    const tn2 = token.tagName;
    for (let i = p2.openElements.stackTop; i > 0; i--) {
      const element2 = p2.openElements.items[i];
      if (p2.treeAdapter.getTagName(element2) === tn2) {
        p2.openElements.generateImpliedEndTagsWithExclusion(tn2);
        p2.openElements.popUntilElementPopped(element2);
        break;
      }
      if (p2._isSpecialElement(element2)) {
        break;
      }
    }
  }
  function endTagInBody(p2, token) {
    const tn2 = token.tagName;
    switch (tn2.length) {
      case 1:
        if (tn2 === $.A || tn2 === $.B || tn2 === $.I || tn2 === $.S || tn2 === $.U) {
          callAdoptionAgency(p2, token);
        } else if (tn2 === $.P) {
          pEndTagInBody(p2);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 2:
        if (tn2 === $.DL || tn2 === $.UL || tn2 === $.OL) {
          addressEndTagInBody(p2, token);
        } else if (tn2 === $.LI) {
          liEndTagInBody(p2);
        } else if (tn2 === $.DD || tn2 === $.DT) {
          ddEndTagInBody(p2, token);
        } else if (tn2 === $.H1 || tn2 === $.H2 || tn2 === $.H3 || tn2 === $.H4 || tn2 === $.H5 || tn2 === $.H6) {
          numberedHeaderEndTagInBody(p2);
        } else if (tn2 === $.BR) {
          brEndTagInBody(p2);
        } else if (tn2 === $.EM || tn2 === $.TT) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 3:
        if (tn2 === $.BIG) {
          callAdoptionAgency(p2, token);
        } else if (tn2 === $.DIR || tn2 === $.DIV || tn2 === $.NAV || tn2 === $.PRE) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 4:
        if (tn2 === $.BODY) {
          bodyEndTagInBody(p2);
        } else if (tn2 === $.HTML) {
          htmlEndTagInBody(p2, token);
        } else if (tn2 === $.FORM) {
          formEndTagInBody(p2);
        } else if (tn2 === $.CODE || tn2 === $.FONT || tn2 === $.NOBR) {
          callAdoptionAgency(p2, token);
        } else if (tn2 === $.MAIN || tn2 === $.MENU) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 5:
        if (tn2 === $.ASIDE) {
          addressEndTagInBody(p2, token);
        } else if (tn2 === $.SMALL) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 6:
        if (tn2 === $.CENTER || tn2 === $.FIGURE || tn2 === $.FOOTER || tn2 === $.HEADER || tn2 === $.HGROUP || tn2 === $.DIALOG) {
          addressEndTagInBody(p2, token);
        } else if (tn2 === $.APPLET || tn2 === $.OBJECT) {
          appletEndTagInBody(p2, token);
        } else if (tn2 === $.STRIKE || tn2 === $.STRONG) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 7:
        if (tn2 === $.ADDRESS || tn2 === $.ARTICLE || tn2 === $.DETAILS || tn2 === $.SECTION || tn2 === $.SUMMARY || tn2 === $.LISTING) {
          addressEndTagInBody(p2, token);
        } else if (tn2 === $.MARQUEE) {
          appletEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 8:
        if (tn2 === $.FIELDSET) {
          addressEndTagInBody(p2, token);
        } else if (tn2 === $.TEMPLATE) {
          endTagInHead(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 10:
        if (tn2 === $.BLOCKQUOTE || tn2 === $.FIGCAPTION) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      default:
        genericEndTagInBody(p2, token);
    }
  }
  function eofInBody(p2, token) {
    if (p2.tmplInsertionModeStackTop > -1) {
      eofInTemplate(p2, token);
    } else {
      p2.stopped = true;
    }
  }
  function endTagInText(p2, token) {
    if (token.tagName === $.SCRIPT) {
      p2.pendingScript = p2.openElements.current;
    }
    p2.openElements.pop();
    p2.insertionMode = p2.originalInsertionMode;
  }
  function eofInText(p2, token) {
    p2._err(ERR.eofInElementThatCanContainOnlyText);
    p2.openElements.pop();
    p2.insertionMode = p2.originalInsertionMode;
    p2._processToken(token);
  }
  function characterInTable(p2, token) {
    const curTn = p2.openElements.currentTagName;
    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
      p2.pendingCharacterTokens = [];
      p2.hasNonWhitespacePendingCharacterToken = false;
      p2.originalInsertionMode = p2.insertionMode;
      p2.insertionMode = IN_TABLE_TEXT_MODE;
      p2._processToken(token);
    } else {
      tokenInTable(p2, token);
    }
  }
  function captionStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2.activeFormattingElements.insertMarker();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_CAPTION_MODE;
  }
  function colgroupStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_COLUMN_GROUP_MODE;
  }
  function colStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertFakeElement($.COLGROUP);
    p2.insertionMode = IN_COLUMN_GROUP_MODE;
    p2._processToken(token);
  }
  function tbodyStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_TABLE_BODY_MODE;
  }
  function tdStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertFakeElement($.TBODY);
    p2.insertionMode = IN_TABLE_BODY_MODE;
    p2._processToken(token);
  }
  function tableStartTagInTable(p2, token) {
    if (p2.openElements.hasInTableScope($.TABLE)) {
      p2.openElements.popUntilTagNamePopped($.TABLE);
      p2._resetInsertionMode();
      p2._processToken(token);
    }
  }
  function inputStartTagInTable(p2, token) {
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
      p2._appendElement(token, NS.HTML);
    } else {
      tokenInTable(p2, token);
    }
    token.ackSelfClosing = true;
  }
  function formStartTagInTable(p2, token) {
    if (!p2.formElement && p2.openElements.tmplCount === 0) {
      p2._insertElement(token, NS.HTML);
      p2.formElement = p2.openElements.current;
      p2.openElements.pop();
    }
  }
  function startTagInTable(p2, token) {
    const tn2 = token.tagName;
    switch (tn2.length) {
      case 2:
        if (tn2 === $.TD || tn2 === $.TH || tn2 === $.TR) {
          tdStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 3:
        if (tn2 === $.COL) {
          colStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 4:
        if (tn2 === $.FORM) {
          formStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 5:
        if (tn2 === $.TABLE) {
          tableStartTagInTable(p2, token);
        } else if (tn2 === $.STYLE) {
          startTagInHead(p2, token);
        } else if (tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD) {
          tbodyStartTagInTable(p2, token);
        } else if (tn2 === $.INPUT) {
          inputStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 6:
        if (tn2 === $.SCRIPT) {
          startTagInHead(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 7:
        if (tn2 === $.CAPTION) {
          captionStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 8:
        if (tn2 === $.COLGROUP) {
          colgroupStartTagInTable(p2, token);
        } else if (tn2 === $.TEMPLATE) {
          startTagInHead(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      default:
        tokenInTable(p2, token);
    }
  }
  function endTagInTable(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TABLE) {
      if (p2.openElements.hasInTableScope($.TABLE)) {
        p2.openElements.popUntilTagNamePopped($.TABLE);
        p2._resetInsertionMode();
      }
    } else if (tn2 === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else if (tn2 !== $.BODY && tn2 !== $.CAPTION && tn2 !== $.COL && tn2 !== $.COLGROUP && tn2 !== $.HTML && tn2 !== $.TBODY && tn2 !== $.TD && tn2 !== $.TFOOT && tn2 !== $.TH && tn2 !== $.THEAD && tn2 !== $.TR) {
      tokenInTable(p2, token);
    }
  }
  function tokenInTable(p2, token) {
    const savedFosterParentingState = p2.fosterParentingEnabled;
    p2.fosterParentingEnabled = true;
    p2._processTokenInBodyMode(token);
    p2.fosterParentingEnabled = savedFosterParentingState;
  }
  function whitespaceCharacterInTableText(p2, token) {
    p2.pendingCharacterTokens.push(token);
  }
  function characterInTableText(p2, token) {
    p2.pendingCharacterTokens.push(token);
    p2.hasNonWhitespacePendingCharacterToken = true;
  }
  function tokenInTableText(p2, token) {
    let i = 0;
    if (p2.hasNonWhitespacePendingCharacterToken) {
      for (; i < p2.pendingCharacterTokens.length; i++) {
        tokenInTable(p2, p2.pendingCharacterTokens[i]);
      }
    } else {
      for (; i < p2.pendingCharacterTokens.length; i++) {
        p2._insertCharacters(p2.pendingCharacterTokens[i]);
      }
    }
    p2.insertionMode = p2.originalInsertionMode;
    p2._processToken(token);
  }
  function startTagInCaption(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.CAPTION || tn2 === $.COL || tn2 === $.COLGROUP || tn2 === $.TBODY || tn2 === $.TD || tn2 === $.TFOOT || tn2 === $.TH || tn2 === $.THEAD || tn2 === $.TR) {
      if (p2.openElements.hasInTableScope($.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInBody(p2, token);
    }
  }
  function endTagInCaption(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.CAPTION || tn2 === $.TABLE) {
      if (p2.openElements.hasInTableScope($.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_TABLE_MODE;
        if (tn2 === $.TABLE) {
          p2._processToken(token);
        }
      }
    } else if (tn2 !== $.BODY && tn2 !== $.COL && tn2 !== $.COLGROUP && tn2 !== $.HTML && tn2 !== $.TBODY && tn2 !== $.TD && tn2 !== $.TFOOT && tn2 !== $.TH && tn2 !== $.THEAD && tn2 !== $.TR) {
      endTagInBody(p2, token);
    }
  }
  function startTagInColumnGroup(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.COL) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn2 === $.TEMPLATE) {
      startTagInHead(p2, token);
    } else {
      tokenInColumnGroup(p2, token);
    }
  }
  function endTagInColumnGroup(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.COLGROUP) {
      if (p2.openElements.currentTagName === $.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
      }
    } else if (tn2 === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else if (tn2 !== $.COL) {
      tokenInColumnGroup(p2, token);
    }
  }
  function tokenInColumnGroup(p2, token) {
    if (p2.openElements.currentTagName === $.COLGROUP) {
      p2.openElements.pop();
      p2.insertionMode = IN_TABLE_MODE;
      p2._processToken(token);
    }
  }
  function startTagInTableBody(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TR) {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_ROW_MODE;
    } else if (tn2 === $.TH || tn2 === $.TD) {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertFakeElement($.TR);
      p2.insertionMode = IN_ROW_MODE;
      p2._processToken(token);
    } else if (tn2 === $.CAPTION || tn2 === $.COL || tn2 === $.COLGROUP || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD) {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInTable(p2, token);
    }
  }
  function endTagInTableBody(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD) {
      if (p2.openElements.hasInTableScope(tn2)) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
      }
    } else if (tn2 === $.TABLE) {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else if (tn2 !== $.BODY && tn2 !== $.CAPTION && tn2 !== $.COL && tn2 !== $.COLGROUP || tn2 !== $.HTML && tn2 !== $.TD && tn2 !== $.TH && tn2 !== $.TR) {
      endTagInTable(p2, token);
    }
  }
  function startTagInRow(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TH || tn2 === $.TD) {
      p2.openElements.clearBackToTableRowContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_CELL_MODE;
      p2.activeFormattingElements.insertMarker();
    } else if (tn2 === $.CAPTION || tn2 === $.COL || tn2 === $.COLGROUP || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD || tn2 === $.TR) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInTable(p2, token);
    }
  }
  function endTagInRow(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TR) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
      }
    } else if (tn2 === $.TABLE) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else if (tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD) {
      if (p2.openElements.hasInTableScope(tn2) || p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else if (tn2 !== $.BODY && tn2 !== $.CAPTION && tn2 !== $.COL && tn2 !== $.COLGROUP || tn2 !== $.HTML && tn2 !== $.TD && tn2 !== $.TH) {
      endTagInTable(p2, token);
    }
  }
  function startTagInCell(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.CAPTION || tn2 === $.COL || tn2 === $.COLGROUP || tn2 === $.TBODY || tn2 === $.TD || tn2 === $.TFOOT || tn2 === $.TH || tn2 === $.THEAD || tn2 === $.TR) {
      if (p2.openElements.hasInTableScope($.TD) || p2.openElements.hasInTableScope($.TH)) {
        p2._closeTableCell();
        p2._processToken(token);
      }
    } else {
      startTagInBody(p2, token);
    }
  }
  function endTagInCell(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.TD || tn2 === $.TH) {
      if (p2.openElements.hasInTableScope(tn2)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn2);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_ROW_MODE;
      }
    } else if (tn2 === $.TABLE || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD || tn2 === $.TR) {
      if (p2.openElements.hasInTableScope(tn2)) {
        p2._closeTableCell();
        p2._processToken(token);
      }
    } else if (tn2 !== $.BODY && tn2 !== $.CAPTION && tn2 !== $.COL && tn2 !== $.COLGROUP && tn2 !== $.HTML) {
      endTagInBody(p2, token);
    }
  }
  function startTagInSelect(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.OPTION) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      p2._insertElement(token, NS.HTML);
    } else if (tn2 === $.OPTGROUP) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagName === $.OPTGROUP) {
        p2.openElements.pop();
      }
      p2._insertElement(token, NS.HTML);
    } else if (tn2 === $.INPUT || tn2 === $.KEYGEN || tn2 === $.TEXTAREA || tn2 === $.SELECT) {
      if (p2.openElements.hasInSelectScope($.SELECT)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        if (tn2 !== $.SELECT) {
          p2._processToken(token);
        }
      }
    } else if (tn2 === $.SCRIPT || tn2 === $.TEMPLATE) {
      startTagInHead(p2, token);
    }
  }
  function endTagInSelect(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.OPTGROUP) {
      const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
      const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
      if (p2.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagName === $.OPTGROUP) {
        p2.openElements.pop();
      }
    } else if (tn2 === $.OPTION) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
    } else if (tn2 === $.SELECT && p2.openElements.hasInSelectScope($.SELECT)) {
      p2.openElements.popUntilTagNamePopped($.SELECT);
      p2._resetInsertionMode();
    } else if (tn2 === $.TEMPLATE) {
      endTagInHead(p2, token);
    }
  }
  function startTagInSelectInTable(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.CAPTION || tn2 === $.TABLE || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD || tn2 === $.TR || tn2 === $.TD || tn2 === $.TH) {
      p2.openElements.popUntilTagNamePopped($.SELECT);
      p2._resetInsertionMode();
      p2._processToken(token);
    } else {
      startTagInSelect(p2, token);
    }
  }
  function endTagInSelectInTable(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.CAPTION || tn2 === $.TABLE || tn2 === $.TBODY || tn2 === $.TFOOT || tn2 === $.THEAD || tn2 === $.TR || tn2 === $.TD || tn2 === $.TH) {
      if (p2.openElements.hasInTableScope(tn2)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        p2._processToken(token);
      }
    } else {
      endTagInSelect(p2, token);
    }
  }
  function startTagInTemplate(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.BASE || tn2 === $.BASEFONT || tn2 === $.BGSOUND || tn2 === $.LINK || tn2 === $.META || tn2 === $.NOFRAMES || tn2 === $.SCRIPT || tn2 === $.STYLE || tn2 === $.TEMPLATE || tn2 === $.TITLE) {
      startTagInHead(p2, token);
    } else {
      const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn2] || IN_BODY_MODE;
      p2._popTmplInsertionMode();
      p2._pushTmplInsertionMode(newInsertionMode);
      p2.insertionMode = newInsertionMode;
      p2._processToken(token);
    }
  }
  function endTagInTemplate(p2, token) {
    if (token.tagName === $.TEMPLATE) {
      endTagInHead(p2, token);
    }
  }
  function eofInTemplate(p2, token) {
    if (p2.openElements.tmplCount > 0) {
      p2.openElements.popUntilTagNamePopped($.TEMPLATE);
      p2.activeFormattingElements.clearToLastMarker();
      p2._popTmplInsertionMode();
      p2._resetInsertionMode();
      p2._processToken(token);
    } else {
      p2.stopped = true;
    }
  }
  function startTagAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      startTagInBody(p2, token);
    } else {
      tokenAfterBody(p2, token);
    }
  }
  function endTagAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      if (!p2.fragmentContext) {
        p2.insertionMode = AFTER_AFTER_BODY_MODE;
      }
    } else {
      tokenAfterBody(p2, token);
    }
  }
  function tokenAfterBody(p2, token) {
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function startTagInFrameset(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.FRAMESET) {
      p2._insertElement(token, NS.HTML);
    } else if (tn2 === $.FRAME) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn2 === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function endTagInFrameset(p2, token) {
    if (token.tagName === $.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
      p2.openElements.pop();
      if (!p2.fragmentContext && p2.openElements.currentTagName !== $.FRAMESET) {
        p2.insertionMode = AFTER_FRAMESET_MODE;
      }
    }
  }
  function startTagAfterFrameset(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function endTagAfterFrameset(p2, token) {
    if (token.tagName === $.HTML) {
      p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
    }
  }
  function startTagAfterAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      startTagInBody(p2, token);
    } else {
      tokenAfterAfterBody(p2, token);
    }
  }
  function tokenAfterAfterBody(p2, token) {
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function startTagAfterAfterFrameset(p2, token) {
    const tn2 = token.tagName;
    if (tn2 === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn2 === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function nullCharacterInForeignContent(p2, token) {
    token.chars = unicode.REPLACEMENT_CHARACTER;
    p2._insertCharacters(token);
  }
  function characterInForeignContent(p2, token) {
    p2._insertCharacters(token);
    p2.framesetOk = false;
  }
  function startTagInForeignContent(p2, token) {
    if (foreignContent.causesExit(token) && !p2.fragmentContext) {
      while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
        p2.openElements.pop();
      }
      p2._processToken(token);
    } else {
      const current = p2._getAdjustedCurrentElement();
      const currentNs = p2.treeAdapter.getNamespaceURI(current);
      if (currentNs === NS.MATHML) {
        foreignContent.adjustTokenMathMLAttrs(token);
      } else if (currentNs === NS.SVG) {
        foreignContent.adjustTokenSVGTagName(token);
        foreignContent.adjustTokenSVGAttrs(token);
      }
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p2._appendElement(token, currentNs);
      } else {
        p2._insertElement(token, currentNs);
      }
      token.ackSelfClosing = true;
    }
  }
  function endTagInForeignContent(p2, token) {
    for (let i = p2.openElements.stackTop; i > 0; i--) {
      const element2 = p2.openElements.items[i];
      if (p2.treeAdapter.getNamespaceURI(element2) === NS.HTML) {
        p2._processToken(token);
        break;
      }
      if (p2.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
        p2.openElements.popUntilElementPopped(element2);
        break;
      }
    }
  }
  var Parser$1 = /* @__PURE__ */ getDefaultExportFromCjs(parser$1);
  const pointStart$1 = point$3("start");
  const pointEnd$1 = point$3("end");
  function point$3(type) {
    return point2;
    function point2(node2) {
      const point3 = node2 && node2.position && node2.position[type] || {};
      return {
        // @ts-expect-error: in practice, null is allowed.
        line: point3.line || null,
        // @ts-expect-error: in practice, null is allowed.
        column: point3.column || null,
        // @ts-expect-error: in practice, null is allowed.
        offset: point3.offset > -1 ? point3.offset : null
      };
    }
  }
  const convert$4 = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok$4;
      }
      if (typeof test === "string") {
        return typeFactory$4(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$5(test) : propsFactory$4(test);
      }
      if (typeof test === "function") {
        return castFactory$5(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$5(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$4(tests[index2]);
    }
    return castFactory$5(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$4(check) {
    return castFactory$5(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$4(check) {
    return castFactory$5(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$5(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok$4() {
    return true;
  }
  function color$1(d) {
    return d;
  }
  const CONTINUE$1 = true;
  const EXIT$1 = false;
  const SKIP$1 = "skip";
  const visitParents$1 = (
    /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function(tree, test, visitor2, reverse) {
      if (typeof test === "function" && typeof visitor2 !== "function") {
        reverse = visitor2;
        visitor2 = test;
        test = null;
      }
      const is = convert$4(test);
      const step = reverse ? -1 : 1;
      factory3(tree, void 0, [])();
      function factory3(node2, index2, parents) {
        const value2 = node2 && typeof node2 === "object" ? node2 : {};
        if (typeof value2.type === "string") {
          const name2 = (
            // `hast`
            typeof value2.tagName === "string" ? value2.tagName : (
              // `xast`
              typeof value2.name === "string" ? value2.name : void 0
            )
          );
          Object.defineProperty(visit2, "name", {
            value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
          });
        }
        return visit2;
        function visit2() {
          let result = [];
          let subresult;
          let offset;
          let grandparents;
          if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult$1(visitor2(node2, parents));
            if (result[0] === EXIT$1) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP$1) {
            offset = (reverse ? node2.children.length : -1) + step;
            grandparents = parents.concat(node2);
            while (offset > -1 && offset < node2.children.length) {
              subresult = factory3(node2.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT$1) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
  );
  function toResult$1(value2) {
    if (Array.isArray(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      return [CONTINUE$1, value2];
    }
    return [value2];
  }
  const visit$2 = (
    /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function(tree, test, visitor2, reverse) {
      if (typeof test === "function" && typeof visitor2 !== "function") {
        reverse = visitor2;
        visitor2 = test;
        test = null;
      }
      visitParents$1(tree, test, overload, reverse);
      function overload(node2, parents) {
        const parent = parents[parents.length - 1];
        return visitor2(
          node2,
          parent ? parent.children.indexOf(node2) : null,
          parent
        );
      }
    }
  );
  class Schema {
    /**
     * @constructor
     * @param {Properties} property
     * @param {Normal} normal
     * @param {string} [space]
     */
    constructor(property, normal, space) {
      this.property = property;
      this.normal = normal;
      if (space) {
        this.space = space;
      }
    }
  }
  Schema.prototype.property = {};
  Schema.prototype.normal = {};
  Schema.prototype.space = null;
  function merge$1(definitions, space) {
    const property = {};
    const normal = {};
    let index2 = -1;
    while (++index2 < definitions.length) {
      Object.assign(property, definitions[index2].property);
      Object.assign(normal, definitions[index2].normal);
    }
    return new Schema(property, normal, space);
  }
  function normalize$1(value2) {
    return value2.toLowerCase();
  }
  class Info {
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     */
    constructor(property, attribute) {
      this.property = property;
      this.attribute = attribute;
    }
  }
  Info.prototype.space = null;
  Info.prototype.boolean = false;
  Info.prototype.booleanish = false;
  Info.prototype.overloadedBoolean = false;
  Info.prototype.number = false;
  Info.prototype.commaSeparated = false;
  Info.prototype.spaceSeparated = false;
  Info.prototype.commaOrSpaceSeparated = false;
  Info.prototype.mustUseProperty = false;
  Info.prototype.defined = false;
  let powers = 0;
  const boolean = increment();
  const booleanish = increment();
  const overloadedBoolean = increment();
  const number = increment();
  const spaceSeparated = increment();
  const commaSeparated = increment();
  const commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }
  var types = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    boolean,
    booleanish,
    commaOrSpaceSeparated,
    commaSeparated,
    number,
    overloadedBoolean,
    spaceSeparated
  });
  const checks = Object.keys(types);
  class DefinedInfo extends Info {
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     * @param {number|null} [mask]
     * @param {string} [space]
     */
    constructor(property, attribute, mask, space) {
      let index2 = -1;
      super(property, attribute);
      mark(this, "space", space);
      if (typeof mask === "number") {
        while (++index2 < checks.length) {
          const check = checks[index2];
          mark(this, checks[index2], (mask & types[check]) === types[check]);
        }
      }
    }
  }
  DefinedInfo.prototype.defined = true;
  function mark(values, key2, value2) {
    if (value2) {
      values[key2] = value2;
    }
  }
  const own$c = {}.hasOwnProperty;
  function create$3(definition2) {
    const property = {};
    const normal = {};
    let prop;
    for (prop in definition2.properties) {
      if (own$c.call(definition2.properties, prop)) {
        const value2 = definition2.properties[prop];
        const info = new DefinedInfo(
          prop,
          definition2.transform(definition2.attributes || {}, prop),
          value2,
          definition2.space
        );
        if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
          info.mustUseProperty = true;
        }
        property[prop] = info;
        normal[normalize$1(prop)] = prop;
        normal[normalize$1(info.attribute)] = prop;
      }
    }
    return new Schema(property, normal, definition2.space);
  }
  const xlink = create$3({
    space: "xlink",
    transform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    },
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  });
  const xml = create$3({
    space: "xml",
    transform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    },
    properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
  });
  function caseSensitiveTransform(attributes2, attribute) {
    return attribute in attributes2 ? attributes2[attribute] : attribute;
  }
  function caseInsensitiveTransform(attributes2, property) {
    return caseSensitiveTransform(attributes2, property.toLowerCase());
  }
  const xmlns = create$3({
    space: "xmlns",
    attributes: { xmlnsxlink: "xmlns:xlink" },
    transform: caseInsensitiveTransform,
    properties: { xmlns: null, xmlnsXLink: null }
  });
  const aria = create$3({
    transform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    },
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number,
      ariaColIndex: number,
      ariaColSpan: number,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number,
      ariaRowIndex: number,
      ariaRowSpan: number,
      ariaSelected: booleanish,
      ariaSetSize: number,
      ariaSort: null,
      ariaValueMax: number,
      ariaValueMin: number,
      ariaValueNow: number,
      ariaValueText: null,
      role: null
    }
  });
  const html$5 = create$3({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: boolean,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number,
      hidden: boolean,
      high: number,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number,
      manifest: null,
      max: null,
      maxLength: number,
      media: null,
      method: null,
      min: null,
      minLength: number,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number,
      rowSpan: number,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shape: null,
      size: number,
      sizes: null,
      slot: null,
      span: number,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number,
      step: null,
      style: null,
      tabIndex: number,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number,
      wrap: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number,
      // `<img>` and `<object>`
      leftMargin: number,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number,
      // `<body>`
      marginWidth: number,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number,
      security: null,
      unselectable: null
    }
  });
  const svg$1 = create$3({
    space: "svg",
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    transform: caseSensitiveTransform,
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number,
      amplitude: number,
      arabicForm: null,
      ascent: number,
      attributeName: null,
      attributeType: null,
      azimuth: number,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number,
      by: null,
      calcMode: null,
      capHeight: number,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number,
      diffuseConstant: number,
      direction: null,
      display: null,
      dur: null,
      divisor: number,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number,
      horizOriginX: number,
      horizOriginY: number,
      id: null,
      ideographic: number,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number,
      k: number,
      k1: number,
      k2: number,
      k3: number,
      k4: number,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number,
      overlineThickness: number,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number,
      pointsAtY: number,
      pointsAtZ: number,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number,
      specularExponent: number,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number,
      strikethroughThickness: number,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number,
      strokeOpacity: number,
      strokeWidth: null,
      style: null,
      surfaceScale: number,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number,
      tableValues: null,
      target: null,
      targetX: number,
      targetY: number,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number,
      underlineThickness: number,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number,
      values: null,
      vAlphabetic: number,
      vMathematical: number,
      vectorEffect: null,
      vHanging: number,
      vIdeographic: number,
      version: null,
      vertAdvY: number,
      vertOriginX: number,
      vertOriginY: number,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    }
  });
  const valid = /^data[-\w.:]+$/i;
  const dash = /-[a-z]/g;
  const cap = /[A-Z]/g;
  function find(schema, value2) {
    const normal = normalize$1(value2);
    let prop = value2;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value2)) {
      if (value2.charAt(4) === "-") {
        const rest = value2.slice(5).replace(dash, camelcase);
        prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value2.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value2 = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(prop, value2);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  const html$4 = merge$1([xml, xlink, xmlns, aria, html$5], "html");
  const svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
  const search = /[#.]/g;
  function parseSelector(selector, defaultTagName) {
    const value2 = selector || "";
    const props = {};
    let start = 0;
    let previous;
    let tagName2;
    while (start < value2.length) {
      search.lastIndex = start;
      const match2 = search.exec(value2);
      const subvalue = value2.slice(start, match2 ? match2.index : value2.length);
      if (subvalue) {
        if (!previous) {
          tagName2 = subvalue;
        } else if (previous === "#") {
          props.id = subvalue;
        } else if (Array.isArray(props.className)) {
          props.className.push(subvalue);
        } else {
          props.className = [subvalue];
        }
        start += subvalue.length;
      }
      if (match2) {
        previous = match2[0];
        start++;
      }
    }
    return {
      type: "element",
      // @ts-expect-error: fine.
      tagName: tagName2 || defaultTagName || "div",
      properties: props,
      children: []
    };
  }
  function parse$2(value2) {
    const input2 = String(value2 || "").trim();
    return input2 ? input2.split(/[ \t\n\r\f]+/g) : [];
  }
  function stringify$1(values) {
    return values.join(" ").trim();
  }
  function parse$1(value2) {
    const tokens = [];
    const input2 = String(value2 || "");
    let index2 = input2.indexOf(",");
    let start = 0;
    let end2 = false;
    while (!end2) {
      if (index2 === -1) {
        index2 = input2.length;
        end2 = true;
      }
      const token = input2.slice(start, index2).trim();
      if (token || !end2) {
        tokens.push(token);
      }
      start = index2 + 1;
      index2 = input2.indexOf(",", start);
    }
    return tokens;
  }
  function stringify(values, options2) {
    const settings = options2 || {};
    const input2 = values[values.length - 1] === "" ? [...values, ""] : values;
    return input2.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }
  const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
  const own$b = {}.hasOwnProperty;
  function core$1(schema, defaultTagName, caseSensitive) {
    const adjust = caseSensitive && createAdjustMap(caseSensitive);
    const h2 = (
      /**
       * @type {{
       *   (): Root
       *   (selector: null | undefined, ...children: Array<HChild>): Root
       *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
       *   (selector: string, ...children: Array<HChild>): Element
       * }}
       */
      /**
       * Hyperscript compatible DSL for creating virtual hast trees.
       *
       * @param {string | null} [selector]
       * @param {HProperties | HChild} [properties]
       * @param {Array<HChild>} children
       * @returns {HResult}
       */
      function(selector, properties, ...children) {
        let index2 = -1;
        let node2;
        if (selector === void 0 || selector === null) {
          node2 = { type: "root", children: [] };
          children.unshift(properties);
        } else {
          node2 = parseSelector(selector, defaultTagName);
          node2.tagName = node2.tagName.toLowerCase();
          if (adjust && own$b.call(adjust, node2.tagName)) {
            node2.tagName = adjust[node2.tagName];
          }
          if (isProperties(properties, node2.tagName)) {
            let key2;
            for (key2 in properties) {
              if (own$b.call(properties, key2)) {
                addProperty(schema, node2.properties, key2, properties[key2]);
              }
            }
          } else {
            children.unshift(properties);
          }
        }
        while (++index2 < children.length) {
          addChild$1(node2.children, children[index2]);
        }
        if (node2.type === "element" && node2.tagName === "template") {
          node2.content = { type: "root", children: node2.children };
          node2.children = [];
        }
        return node2;
      }
    );
    return h2;
  }
  function isProperties(value2, name2) {
    if (value2 === null || value2 === void 0 || typeof value2 !== "object" || Array.isArray(value2)) {
      return false;
    }
    if (name2 === "input" || !value2.type || typeof value2.type !== "string") {
      return true;
    }
    if ("children" in value2 && Array.isArray(value2.children)) {
      return false;
    }
    if (name2 === "button") {
      return buttonTypes.has(value2.type.toLowerCase());
    }
    return !("value" in value2);
  }
  function addProperty(schema, properties, key2, value2) {
    const info = find(schema, key2);
    let index2 = -1;
    let result;
    if (value2 === void 0 || value2 === null)
      return;
    if (typeof value2 === "number") {
      if (Number.isNaN(value2))
        return;
      result = value2;
    } else if (typeof value2 === "boolean") {
      result = value2;
    } else if (typeof value2 === "string") {
      if (info.spaceSeparated) {
        result = parse$2(value2);
      } else if (info.commaSeparated) {
        result = parse$1(value2);
      } else if (info.commaOrSpaceSeparated) {
        result = parse$2(parse$1(value2).join(" "));
      } else {
        result = parsePrimitive(info, info.property, value2);
      }
    } else if (Array.isArray(value2)) {
      result = value2.concat();
    } else {
      result = info.property === "style" ? style(value2) : String(value2);
    }
    if (Array.isArray(result)) {
      const finalResult = [];
      while (++index2 < result.length) {
        finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
      }
      result = finalResult;
    }
    if (info.property === "className" && Array.isArray(properties.className)) {
      result = properties.className.concat(result);
    }
    properties[info.property] = result;
  }
  function addChild$1(nodes, value2) {
    let index2 = -1;
    if (value2 === void 0 || value2 === null)
      ;
    else if (typeof value2 === "string" || typeof value2 === "number") {
      nodes.push({ type: "text", value: String(value2) });
    } else if (Array.isArray(value2)) {
      while (++index2 < value2.length) {
        addChild$1(nodes, value2[index2]);
      }
    } else if (typeof value2 === "object" && "type" in value2) {
      if (value2.type === "root") {
        addChild$1(nodes, value2.children);
      } else {
        nodes.push(value2);
      }
    } else {
      throw new Error("Expected node, nodes, or string, got `" + value2 + "`");
    }
  }
  function parsePrimitive(info, name2, value2) {
    if (typeof value2 === "string") {
      if (info.number && value2 && !Number.isNaN(Number(value2))) {
        return Number(value2);
      }
      if ((info.boolean || info.overloadedBoolean) && (value2 === "" || normalize$1(value2) === normalize$1(name2))) {
        return true;
      }
    }
    return value2;
  }
  function style(value2) {
    const result = [];
    let key2;
    for (key2 in value2) {
      if (own$b.call(value2, key2)) {
        result.push([key2, value2[key2]].join(": "));
      }
    }
    return result.join("; ");
  }
  function createAdjustMap(values) {
    const result = {};
    let index2 = -1;
    while (++index2 < values.length) {
      result[values[index2].toLowerCase()] = values[index2];
    }
    return result;
  }
  const h = core$1(html$4, "div");
  const svgCaseSensitiveTagNames = [
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "solidColor",
    "textArea",
    "textPath"
  ];
  const s = core$1(svg, "g", svgCaseSensitiveTagNames);
  function location(file) {
    const value2 = String(file);
    const indices = [];
    const search2 = /\r?\n|\r/g;
    while (search2.test(value2)) {
      indices.push(search2.lastIndex);
    }
    indices.push(value2.length + 1);
    return { toPoint, toOffset };
    function toPoint(offset) {
      let index2 = -1;
      if (typeof offset === "number" && offset > -1 && offset < indices[indices.length - 1]) {
        while (++index2 < indices.length) {
          if (indices[index2] > offset) {
            return {
              line: index2 + 1,
              column: offset - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
              offset
            };
          }
        }
      }
      return { line: void 0, column: void 0, offset: void 0 };
    }
    function toOffset(point2) {
      const line2 = point2 && point2.line;
      const column = point2 && point2.column;
      if (typeof line2 === "number" && typeof column === "number" && !Number.isNaN(line2) && !Number.isNaN(column) && line2 - 1 in indices) {
        const offset = (indices[line2 - 2] || 0) + column - 1 || 0;
        if (offset > -1 && offset < indices[indices.length - 1]) {
          return offset;
        }
      }
      return -1;
    }
  }
  const webNamespaces = {
    html: "http://www.w3.org/1999/xhtml",
    mathml: "http://www.w3.org/1998/Math/MathML",
    svg: "http://www.w3.org/2000/svg",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  const own$a = {}.hasOwnProperty;
  const proto = Object.prototype;
  function fromParse5(tree, options2) {
    const options_ = options2 || {};
    let settings;
    let file;
    if (isFile(options_)) {
      file = options_;
      settings = {};
    } else {
      file = options_.file || void 0;
      settings = options_;
    }
    return one$7(
      {
        schema: settings.space === "svg" ? svg : html$4,
        file,
        verbose: settings.verbose,
        location: false
      },
      tree
    );
  }
  function one$7(state, node2) {
    let result;
    switch (node2.nodeName) {
      case "#comment": {
        const reference = (
          /** @type {P5Comment} */
          node2
        );
        result = { type: "comment", value: reference.data };
        patch$2(state, reference, result);
        return result;
      }
      case "#document":
      case "#document-fragment": {
        const reference = (
          /** @type {P5Document | P5DocumentFragment} */
          node2
        );
        const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
        result = {
          type: "root",
          children: all$9(state, node2.childNodes),
          data: { quirksMode }
        };
        if (state.file && state.location) {
          const doc = String(state.file);
          const loc = location(doc);
          const start = loc.toPoint(0);
          const end2 = loc.toPoint(doc.length);
          result.position = { start, end: end2 };
        }
        return result;
      }
      case "#documentType": {
        const reference = (
          /** @type {P5DocumentType} */
          node2
        );
        result = { type: "doctype" };
        patch$2(state, reference, result);
        return result;
      }
      case "#text": {
        const reference = (
          /** @type {P5Text} */
          node2
        );
        result = { type: "text", value: reference.value };
        patch$2(state, reference, result);
        return result;
      }
      default: {
        const reference = (
          /** @type {P5Element} */
          node2
        );
        result = element$4(state, reference);
        return result;
      }
    }
  }
  function all$9(state, nodes) {
    let index2 = -1;
    const result = [];
    while (++index2 < nodes.length) {
      result[index2] = one$7(state, nodes[index2]);
    }
    return result;
  }
  function element$4(state, node2) {
    const schema = state.schema;
    state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$4;
    let index2 = -1;
    const props = {};
    while (++index2 < node2.attrs.length) {
      const attribute = node2.attrs[index2];
      const name2 = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
      if (!own$a.call(proto, name2)) {
        props[name2] = attribute.value;
      }
    }
    const fn = state.schema.space === "svg" ? s : h;
    const result = fn(node2.tagName, props, all$9(state, node2.childNodes));
    patch$2(state, node2, result);
    if (result.tagName === "template") {
      const reference = (
        /** @type {P5Template} */
        node2
      );
      const pos = reference.sourceCodeLocation;
      const startTag2 = pos && pos.startTag && position$2(pos.startTag);
      const endTag2 = pos && pos.endTag && position$2(pos.endTag);
      const content2 = one$7(state, reference.content);
      if (startTag2 && endTag2 && state.file) {
        content2.position = { start: startTag2.end, end: endTag2.start };
      }
      result.content = content2;
    }
    state.schema = schema;
    return result;
  }
  function patch$2(state, from, to2) {
    if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
      const position2 = createLocation(state, to2, from.sourceCodeLocation);
      if (position2) {
        state.location = true;
        to2.position = position2;
      }
    }
  }
  function createLocation(state, node2, location2) {
    const result = position$2(location2);
    if (node2.type === "element") {
      const tail = node2.children[node2.children.length - 1];
      if (result && !location2.endTag && tail && tail.position && tail.position.end) {
        result.end = Object.assign({}, tail.position.end);
      }
      if (state.verbose) {
        const props = {};
        let key2;
        if (location2.attrs) {
          for (key2 in location2.attrs) {
            if (own$a.call(location2.attrs, key2)) {
              props[find(state.schema, key2).property] = position$2(
                location2.attrs[key2]
              );
            }
          }
        }
        node2.data = {
          position: {
            // @ts-expect-error: assume not `undefined`.
            opening: position$2(location2.startTag),
            closing: location2.endTag ? position$2(location2.endTag) : null,
            properties: props
          }
        };
      }
    }
    return result;
  }
  function position$2(loc) {
    const start = point$2({
      line: loc.startLine,
      column: loc.startCol,
      offset: loc.startOffset
    });
    const end2 = point$2({
      line: loc.endLine,
      column: loc.endCol,
      offset: loc.endOffset
    });
    return start || end2 ? { start, end: end2 } : void 0;
  }
  function point$2(point2) {
    return point2.line && point2.column ? point2 : void 0;
  }
  function isFile(value2) {
    return "messages" in value2;
  }
  const own$9 = {}.hasOwnProperty;
  function zwitch(key2, options2) {
    const settings = options2 || {};
    function one2(value2, ...parameters) {
      let fn = one2.invalid;
      const handlers2 = one2.handlers;
      if (value2 && own$9.call(value2, key2)) {
        const id2 = String(value2[key2]);
        fn = own$9.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
      }
      if (fn) {
        return fn.call(this, value2, ...parameters);
      }
    }
    one2.handlers = settings.handlers || {};
    one2.invalid = settings.invalid;
    one2.unknown = settings.unknown;
    return one2;
  }
  const own$8 = {}.hasOwnProperty;
  const one$6 = zwitch("type", { handlers: { root: root$4, element: element$3, text: text$5, comment: comment$3, doctype: doctype$2 } });
  function toParse5(tree, options2) {
    const space = options2 && typeof options2 === "object" ? options2.space : options2;
    return one$6(tree, space === "svg" ? svg : html$4);
  }
  function root$4(node2, schema) {
    const result = {
      nodeName: "#document",
      // @ts-expect-error: `parse5` uses enums, which are actually strings.
      mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
      childNodes: []
    };
    result.childNodes = all$8(node2.children, result, schema);
    patch$1(node2, result);
    return result;
  }
  function fragment(node2, schema) {
    const result = { nodeName: "#document-fragment", childNodes: [] };
    result.childNodes = all$8(node2.children, result, schema);
    patch$1(node2, result);
    return result;
  }
  function doctype$2(node2) {
    const result = {
      nodeName: "#documentType",
      name: "html",
      publicId: "",
      systemId: "",
      // @ts-expect-error: change to `null` in a major?
      parentNode: void 0
    };
    patch$1(node2, result);
    return result;
  }
  function text$5(node2) {
    const result = {
      nodeName: "#text",
      value: node2.value,
      // @ts-expect-error: no `parentNode`
      parentNode: void 0
    };
    patch$1(node2, result);
    return result;
  }
  function comment$3(node2) {
    const result = {
      nodeName: "#comment",
      data: node2.value,
      // @ts-expect-error: no `parentNode`
      parentNode: void 0
    };
    patch$1(node2, result);
    return result;
  }
  function element$3(node2, schema) {
    const parentSchema = schema;
    let currentSchema = parentSchema;
    if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
      currentSchema = svg;
    }
    const attrs = [];
    let prop;
    if (node2.properties) {
      for (prop in node2.properties) {
        if (prop !== "children" && own$8.call(node2.properties, prop)) {
          const result2 = createProperty(
            currentSchema,
            prop,
            node2.properties[prop]
          );
          if (result2) {
            attrs.push(result2);
          }
        }
      }
    }
    const result = {
      nodeName: node2.tagName,
      tagName: node2.tagName,
      attrs,
      // @ts-expect-error: html and svg both have a space.
      namespaceURI: webNamespaces[currentSchema.space],
      childNodes: [],
      // @ts-expect-error: no `parentNode`
      parentNode: void 0
    };
    result.childNodes = all$8(node2.children, result, currentSchema);
    patch$1(node2, result);
    if (node2.tagName === "template" && node2.content) {
      result.content = fragment(node2.content, currentSchema);
    }
    return result;
  }
  function createProperty(schema, prop, value2) {
    const info = find(schema, prop);
    if (value2 === void 0 || value2 === null || value2 === false || typeof value2 === "number" && Number.isNaN(value2) || !value2 && info.boolean) {
      return;
    }
    if (Array.isArray(value2)) {
      value2 = info.commaSeparated ? stringify(value2) : stringify$1(value2);
    }
    const attribute = {
      name: info.attribute,
      value: value2 === true ? "" : String(value2)
    };
    if (info.space && info.space !== "html" && info.space !== "svg") {
      const index2 = attribute.name.indexOf(":");
      if (index2 < 0) {
        attribute.prefix = "";
      } else {
        attribute.name = attribute.name.slice(index2 + 1);
        attribute.prefix = info.attribute.slice(0, index2);
      }
      attribute.namespace = webNamespaces[info.space];
    }
    return attribute;
  }
  function all$8(children, parentNode, schema) {
    let index2 = -1;
    const results = [];
    if (children) {
      while (++index2 < children.length) {
        const child = one$6(children[index2], schema);
        child.parentNode = parentNode;
        results.push(child);
      }
    }
    return results;
  }
  function patch$1(from, to2) {
    const position2 = from.position;
    if (position2 && position2.start && position2.end) {
      to2.sourceCodeLocation = {
        startLine: position2.start.line,
        startCol: position2.start.column,
        // @ts-expect-error assume this is set.
        startOffset: position2.start.offset,
        endLine: position2.end.line,
        endCol: position2.end.column,
        // @ts-expect-error assume this is set.
        endOffset: position2.end.offset
      };
    }
  }
  const htmlVoidElements = [
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
  ];
  const inTemplateMode = "IN_TEMPLATE_MODE";
  const dataState = "DATA_STATE";
  const characterToken = "CHARACTER_TOKEN";
  const startTagToken = "START_TAG_TOKEN";
  const endTagToken = "END_TAG_TOKEN";
  const commentToken = "COMMENT_TOKEN";
  const doctypeToken = "DOCTYPE_TOKEN";
  const parseOptions = { sourceCodeLocationInfo: true, scriptingEnabled: false };
  const raw$2 = (
    /**
     * @type {(
     *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &
     *   ((tree: Node, options?: Options) => Node)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {VFile} [file]
     * @param {Options} [options]
     */
    function(tree, file, options2) {
      let index2 = -1;
      const parser2 = new Parser$1(parseOptions);
      const one2 = zwitch("type", {
        handlers: { root: root2, element: element2, text: text2, comment: comment2, doctype: doctype2, raw: handleRaw },
        // @ts-expect-error: hush.
        unknown: unknown$3
      });
      let stitches;
      let tokenizer2;
      let preprocessor2;
      let posTracker;
      let locationTracker;
      if (isOptions(file)) {
        options2 = file;
        file = void 0;
      }
      if (options2 && options2.passThrough) {
        while (++index2 < options2.passThrough.length) {
          one2.handlers[options2.passThrough[index2]] = stitch;
        }
      }
      const result = fromParse5(
        documentMode(tree) ? document2() : fragment2(),
        file
      );
      if (stitches) {
        visit$2(result, "comment", (node2, index3, parent) => {
          const stitch2 = (
            /** @type {Stitch} */
            /** @type {unknown} */
            node2
          );
          if (stitch2.value.stitch && parent !== null && index3 !== null) {
            parent.children[index3] = stitch2.value.stitch;
            return index3;
          }
        });
      }
      if (tree.type !== "root" && result.type === "root" && result.children.length === 1) {
        return result.children[0];
      }
      return result;
      function fragment2() {
        const context = {
          nodeName: "template",
          tagName: "template",
          attrs: [],
          namespaceURI: webNamespaces.html,
          childNodes: []
        };
        const mock = {
          nodeName: "documentmock",
          tagName: "documentmock",
          attrs: [],
          namespaceURI: webNamespaces.html,
          childNodes: []
        };
        const doc = { nodeName: "#document-fragment", childNodes: [] };
        parser2._bootstrap(mock, context);
        parser2._pushTmplInsertionMode(inTemplateMode);
        parser2._initTokenizerForFragmentParsing();
        parser2._insertFakeRootElement();
        parser2._resetInsertionMode();
        parser2._findFormInFragmentContext();
        tokenizer2 = parser2.tokenizer;
        if (!tokenizer2)
          throw new Error("Expected `tokenizer`");
        preprocessor2 = tokenizer2.preprocessor;
        locationTracker = tokenizer2.__mixins[0];
        posTracker = locationTracker.posTracker;
        one2(tree);
        resetTokenizer();
        parser2._adoptNodes(mock.childNodes[0], doc);
        return doc;
      }
      function document2() {
        const doc = parser2.treeAdapter.createDocument();
        parser2._bootstrap(doc, void 0);
        tokenizer2 = parser2.tokenizer;
        if (!tokenizer2)
          throw new Error("Expected `tokenizer`");
        preprocessor2 = tokenizer2.preprocessor;
        locationTracker = tokenizer2.__mixins[0];
        posTracker = locationTracker.posTracker;
        one2(tree);
        resetTokenizer();
        return doc;
      }
      function all2(nodes) {
        let index3 = -1;
        if (nodes) {
          while (++index3 < nodes.length) {
            one2(nodes[index3]);
          }
        }
      }
      function root2(node2) {
        all2(node2.children);
      }
      function element2(node2) {
        resetTokenizer();
        parser2._processInputToken(startTag(node2));
        all2(node2.children);
        if (!htmlVoidElements.includes(node2.tagName)) {
          resetTokenizer();
          parser2._processInputToken(endTag(node2));
        }
      }
      function text2(node2) {
        resetTokenizer();
        parser2._processInputToken({
          type: characterToken,
          chars: node2.value,
          location: createParse5Location(node2)
        });
      }
      function doctype2(node2) {
        resetTokenizer();
        parser2._processInputToken({
          type: doctypeToken,
          name: "html",
          forceQuirks: false,
          publicId: "",
          systemId: "",
          location: createParse5Location(node2)
        });
      }
      function comment2(node2) {
        resetTokenizer();
        parser2._processInputToken({
          type: commentToken,
          data: node2.value,
          location: createParse5Location(node2)
        });
      }
      function handleRaw(node2) {
        const start = pointStart$1(node2);
        const line2 = start.line || 1;
        const column = start.column || 1;
        const offset = start.offset || 0;
        if (!preprocessor2)
          throw new Error("Expected `preprocessor`");
        if (!tokenizer2)
          throw new Error("Expected `tokenizer`");
        if (!posTracker)
          throw new Error("Expected `posTracker`");
        if (!locationTracker)
          throw new Error("Expected `locationTracker`");
        preprocessor2.html = void 0;
        preprocessor2.pos = -1;
        preprocessor2.lastGapPos = -1;
        preprocessor2.lastCharPos = -1;
        preprocessor2.gapStack = [];
        preprocessor2.skipNextNewLine = false;
        preprocessor2.lastChunkWritten = false;
        preprocessor2.endOfChunkHit = false;
        posTracker.isEol = false;
        posTracker.lineStartPos = -column + 1;
        posTracker.droppedBufferSize = offset;
        posTracker.offset = 0;
        posTracker.col = 1;
        posTracker.line = line2;
        locationTracker.currentAttrLocation = void 0;
        locationTracker.ctLoc = createParse5Location(node2);
        tokenizer2.write(node2.value);
        parser2._runParsingLoop(null);
        if (tokenizer2.state === "NAMED_CHARACTER_REFERENCE_STATE" || tokenizer2.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") {
          preprocessor2.lastChunkWritten = true;
          tokenizer2[tokenizer2.state](tokenizer2._consume());
        }
      }
      function stitch(node2) {
        stitches = true;
        let clone2;
        if ("children" in node2) {
          clone2 = {
            ...node2,
            children: raw$2(
              { type: "root", children: node2.children },
              file,
              options2
              // @ts-expect-error Assume a given parent yields a parent.
            ).children
          };
        } else {
          clone2 = { ...node2 };
        }
        comment2({ type: "comment", value: { stitch: clone2 } });
      }
      function resetTokenizer() {
        if (!tokenizer2)
          throw new Error("Expected `tokenizer`");
        if (!posTracker)
          throw new Error("Expected `posTracker`");
        const token = tokenizer2.currentCharacterToken;
        if (token) {
          token.location.endLine = posTracker.line;
          token.location.endCol = posTracker.col + 1;
          token.location.endOffset = posTracker.offset + 1;
          parser2._processInputToken(token);
        }
        tokenizer2.tokenQueue = [];
        tokenizer2.state = dataState;
        tokenizer2.returnState = "";
        tokenizer2.charRefCode = -1;
        tokenizer2.tempBuff = [];
        tokenizer2.lastStartTagName = "";
        tokenizer2.consumedAfterSnapshot = -1;
        tokenizer2.active = false;
        tokenizer2.currentCharacterToken = void 0;
        tokenizer2.currentToken = void 0;
        tokenizer2.currentAttr = void 0;
      }
    }
  );
  function startTag(node2) {
    const location2 = Object.assign(createParse5Location(node2));
    location2.startTag = Object.assign({}, location2);
    return {
      type: startTagToken,
      tagName: node2.tagName,
      selfClosing: false,
      attrs: attributes(node2),
      location: location2
    };
  }
  function attributes(node2) {
    return toParse5({
      tagName: node2.tagName,
      type: "element",
      properties: node2.properties,
      children: []
      // @ts-expect-error Assume element.
    }).attrs;
  }
  function endTag(node2) {
    const location2 = Object.assign(createParse5Location(node2));
    location2.startTag = Object.assign({}, location2);
    return {
      type: endTagToken,
      tagName: node2.tagName,
      attrs: [],
      location: location2
    };
  }
  function unknown$3(node2) {
    throw new Error("Cannot compile `" + node2.type + "` node");
  }
  function documentMode(node2) {
    const head2 = node2.type === "root" ? node2.children[0] : node2;
    return Boolean(
      head2 && (head2.type === "doctype" || head2.type === "element" && head2.tagName === "html")
    );
  }
  function createParse5Location(node2) {
    const start = pointStart$1(node2);
    const end2 = pointEnd$1(node2);
    return {
      startLine: start.line,
      startCol: start.column,
      startOffset: start.offset,
      endLine: end2.line,
      endCol: end2.column,
      endOffset: end2.offset
    };
  }
  function isOptions(value2) {
    return Boolean(value2 && !("message" in value2 && "messages" in value2));
  }
  function rehypeRaw(options2 = {}) {
    return (tree, file) => {
      const result = (
        /** @type {Root} */
        raw$2(tree, file, options2)
      );
      return result;
    };
  }
  const unicodeLigatures = /* @__PURE__ */ JSON.parse(`[["\\\\-","Â­"],["\\\\. A","È¦"],["\\\\. a","È§"],["\\\\. B","á¸"],["\\\\. b","á¸"],["\\\\. C","Ä"],["\\\\. c","Ä"],["\\\\. D","á¸"],["\\\\. d","á¸"],["\\\\. E","Ä"],["\\\\. e","Ä"],["\\\\. F","á¸"],["\\\\. f","á¸"],["\\\\. G","Ä "],["\\\\. g","Ä¡"],["\\\\. I","Ä°"],["\\\\. M","á¹"],["\\\\. m","á¹"],["\\\\. O","È®"],["\\\\. o","È¯"],["\\\\. P","á¹"],["\\\\. p","á¹"],["\\\\. S","á¹ "],["\\\\. s","á¹¡"],["\\\\. T","á¹ª"],["\\\\. t","á¹«"],["\\\\. Z","Å»"],["\\\\. z","Å¼"],["\\\\\\" \\\\i","Ã¯"],["\\\\\\" A","Ã"],["\\\\\\" a","Ã¤"],["\\\\\\" E","Ã"],["\\\\\\" e","Ã«"],["\\\\\\" I","Ã"],["\\\\\\" i","Ã¯"],["\\\\\\" O","Ã"],["\\\\\\" o","Ã¶"],["\\\\\\" U","Ã"],["\\\\\\" u","Ã¼"],["\\\\\\" W","áº"],["\\\\\\" w","áº"],["\\\\\\" y","Ã¿"],["\\\\\\" Y","Å¸"],["\\\\' A","Ã"],["\\\\' a","Ã¡"],["\\\\' C","Ä"],["\\\\' c","Ä"],["\\\\' E","Ã"],["\\\\' e","Ã©"],["\\\\' G","Ç´"],["\\\\' g","Çµ"],["\\\\' I","Ã"],["\\\\' i","Ã­"],["\\\\' \\\\i","Ã­"],["\\\\' \\\\j","jÌ"],["\\\\' K","á¸°"],["\\\\' k","á¸±"],["\\\\' L","Ä¹"],["\\\\' \\\\L","ÅÌ"],["\\\\' l","Äº"],["\\\\' \\\\l","ÅÌ"],["\\\\' M","á¸¾"],["\\\\' m","á¸¿"],["\\\\' N","Å"],["\\\\' n","Å"],["\\\\' O","Ã"],["\\\\' \\\\O","Ç¾"],["\\\\' o","Ã³"],["\\\\' \\\\o","Ç¿"],["\\\\' P","á¹"],["\\\\' p","á¹"],["\\\\' R","Å"],["\\\\' r","Å"],["\\\\' S","Å"],["\\\\' s","Å"],["\\\\' U","Ã"],["\\\\' u","Ãº"],["\\\\' W","áº"],["\\\\' w","áº"],["\\\\' Y","Ã"],["\\\\' y","Ã½"],["\\\\' Z","Å¹"],["\\\\' z","Åº"],["\\\\^ \\\\i","Ã®"],["\\\\^ \\\\j","Äµ"],["\\\\^ A","Ã"],["\\\\^ a","Ã¢"],["\\\\^ C","Ä"],["\\\\^ c","Ä"],["\\\\^ E","Ã"],["\\\\^ e","Ãª"],["\\\\^ G","Ä"],["\\\\^ g","Ä"],["\\\\^ H","Ä¤"],["\\\\^ h","Ä¥"],["\\\\^ I","Ã"],["\\\\^ J","Ä´"],["\\\\^ O","Ã"],["\\\\^ o","Ã´"],["\\\\^ S","Å"],["\\\\^ s","Å"],["\\\\^ U","Ã"],["\\\\^ u","Ã»"],["\\\\^ W","Å´"],["\\\\^ w","Åµ"],["\\\\^ Y","Å¶"],["\\\\^ y","Å·"],["\\\\~ \\\\i","Ä©"],["\\\\~ A","Ã"],["\\\\~ a","Ã£"],["\\\\~ I","Ä¨"],["\\\\~ N","Ã"],["\\\\~ n","Ã±"],["\\\\~ O","Ã"],["\\\\~ o","Ãµ"],["\\\\~ U","Å¨"],["\\\\~ u","Å©"],["\\\\AE","Ã"],["\\\\ae","Ã¦"],["\\\\c \\\\ ","Â¸"],["\\\\c C","Ã"],["\\\\c c","Ã§"],["\\\\c E","È¨"],["\\\\c e","È©"],["\\\\c G","Ä¢"],["\\\\c g","Ä£"],["\\\\c K","Ä¶"],["\\\\c k","Ä·"],["\\\\c L","Ä»"],["\\\\c l","Ä¼"],["\\\\c N","Å"],["\\\\c n","Å"],["\\\\c R","Å"],["\\\\c r","Å"],["\\\\c S","Å"],["\\\\c s","Å"],["\\\\c T","Å¢"],["\\\\c t","Å£"],["\\\\CYRA","Ð"],["\\\\cyra","Ð°"],["\\\\CYRABHCH","Ò¼"],["\\\\cyrabhch","Ò½"],["\\\\CYRABHCHDSC","Ò¾"],["\\\\cyrabhchdsc","Ò¿"],["\\\\CYRABHDZE","Ó "],["\\\\cyrabhdze","Ó¡"],["\\\\CYRABHHA","Ò¨"],["\\\\cyrabhha","Ò©"],["\\\\CYRAE","Ó"],["\\\\cyrae","Ó"],["\\\\CYRB","Ð"],["\\\\cyrb","Ð±"],["\\\\CYRBYUS","Ñª"],["\\\\cyrbyus","Ñ«"],["\\\\CYRC","Ð¦"],["\\\\cyrc","Ñ"],["\\\\CYRCH","Ð§"],["\\\\cyrch","Ñ"],["\\\\CYRCHLDSC","Ó"],["\\\\cyrchldsc","Ó"],["\\\\CYRCHRDSC","Ò¶"],["\\\\cyrchrdsc","Ò·"],["\\\\CYRCHVCRS","Ò¸"],["\\\\cyrchvcrs","Ò¹"],["\\\\CYRD","Ð"],["\\\\cyrd","Ð´"],["\\\\CYRDJE","Ð"],["\\\\cyrdje","Ñ"],["\\\\CYRDZE","Ð"],["\\\\cyrdze","Ñ"],["\\\\CYRDZHE","Ð"],["\\\\cyrdzhe","Ñ"],["\\\\CYRE","Ð"],["\\\\cyre","Ðµ"],["\\\\CYREREV","Ð­"],["\\\\cyrerev","Ñ"],["\\\\CYRERY","Ð«"],["\\\\cyrery","Ñ"],["\\\\CYRF","Ð¤"],["\\\\cyrf","Ñ"],["\\\\CYRFITA","Ñ²"],["\\\\cyrfita","Ñ³"],["\\\\CYRG","Ð"],["\\\\cyrg","Ð³"],["\\\\CYRGHCRS","Ò"],["\\\\cyrghcrs","Ò"],["\\\\CYRGHK","Ò"],["\\\\cyrghk","Ò"],["\\\\CYRGUP","Ò"],["\\\\cyrgup","Ò"],["\\\\CYRH","Ð¥"],["\\\\cyrh","Ñ"],["\\\\CYRHDSC","Ò²"],["\\\\cyrhdsc","Ò³"],["\\\\CYRHRDSN","Ðª"],["\\\\cyrhrdsn","Ñ"],["\\\\CYRI","Ð"],["\\\\cyri","Ð¸"],["\\\\CYRIE","Ð"],["\\\\cyrie","Ñ"],["\\\\CYRII","Ð"],["\\\\cyrii","Ñ"],["\\\\CYRISHRT","Ð"],["\\\\cyrishrt","Ð¹"],["\\\\CYRIZH","Ñ´"],["\\\\cyrizh","Ñµ"],["\\\\CYRJE","Ð"],["\\\\cyrje","Ñ"],["\\\\CYRK","Ð"],["\\\\cyrk","Ðº"],["\\\\CYRKBEAK","Ò "],["\\\\cyrkbeak","Ò¡"],["\\\\CYRKDSC","Ò"],["\\\\cyrkdsc","Ò"],["\\\\CYRKHCRS","Ò"],["\\\\cyrkhcrs","Ò"],["\\\\CYRKHK","Ó"],["\\\\cyrkhk","Ó"],["\\\\CYRKVCRS","Ò"],["\\\\cyrkvcrs","Ò"],["\\\\CYRL","Ð"],["\\\\cyrl","Ð»"],["\\\\CYRLDSC","Ó"],["\\\\cyrldsc","Ó"],["\\\\CYRLJE","Ð"],["\\\\cyrlje","Ñ"],["\\\\CYRM","Ð"],["\\\\cyrm","Ð¼"],["\\\\CYRMDSC","Ó"],["\\\\cyrmdsc","Ó"],["\\\\CYRN","Ð"],["\\\\cyrn","Ð½"],["\\\\CYRNDSC","Ò¢"],["\\\\cyrndsc","Ò£"],["\\\\CYRNG","Ò¤"],["\\\\cyrng","Ò¥"],["\\\\CYRNHK","Ó"],["\\\\cyrnhk","Ó"],["\\\\CYRNJE","Ð"],["\\\\cyrnje","Ñ"],["\\\\CYRO","Ð"],["\\\\cyro","Ð¾"],["\\\\CYROTLD","Ó¨"],["\\\\cyrotld","Ó©"],["\\\\CYRP","Ð"],["\\\\cyrp","Ð¿"],["\\\\CYRpalochka","Ó"],["\\\\CYRPHK","Ò¦"],["\\\\cyrphk","Ò§"],["\\\\CYRR","Ð "],["\\\\cyrr","Ñ"],["\\\\CYRRTICK","Ò"],["\\\\cyrrtick","Ò"],["\\\\CYRS","Ð¡"],["\\\\cyrs","Ñ"],["\\\\CYRSCHWA","Ó"],["\\\\cyrschwa","Ó"],["\\\\CYRSDSC","Òª"],["\\\\cyrsdsc","Ò«"],["\\\\CYRSEMISFTSN","Ò"],["\\\\cyrsemisftsn","Ò"],["\\\\CYRSFTSN","Ð¬"],["\\\\cyrsftsn","Ñ"],["\\\\CYRSH","Ð¨"],["\\\\cyrsh","Ñ"],["\\\\CYRSHCH","Ð©"],["\\\\cyrshch","Ñ"],["\\\\CYRSHHA","Òº"],["\\\\cyrshha","Ò»"],["\\\\CYRT","Ð¢"],["\\\\cyrt","Ñ"],["\\\\CYRTDSC","Ò¬"],["\\\\cyrtdsc","Ò­"],["\\\\CYRTETSE","Ò´"],["\\\\cyrtetse","Òµ"],["\\\\CYRTSHE","Ð"],["\\\\cyrtshe","Ñ"],["\\\\CYRU","Ð£"],["\\\\cyru","Ñ"],["\\\\CYRUSHRT","Ð"],["\\\\cyrushrt","Ñ"],["\\\\CYRV","Ð"],["\\\\cyrv","Ð²"],["\\\\CYRY","Ò®"],["\\\\cyry","Ò¯"],["\\\\CYRYA","Ð¯"],["\\\\cyrya","Ñ"],["\\\\CYRYAT","Ñ¢"],["\\\\cyryat","Ñ£"],["\\\\CYRYHCRS","Ò°"],["\\\\cyryhcrs","Ò±"],["\\\\CYRYI","Ð"],["\\\\cyryi","Ñ"],["\\\\CYRYO","Ð"],["\\\\cyryo","Ñ"],["\\\\CYRYU","Ð®"],["\\\\cyryu","Ñ"],["\\\\CYRZ","Ð"],["\\\\cyrz","Ð·"],["\\\\CYRZDSC","Ò"],["\\\\cyrzdsc","Ò"],["\\\\CYRZH","Ð"],["\\\\cyrzh","Ð¶"],["\\\\CYRZHDSC","Ò"],["\\\\cyrzhdsc","Ò"],["\\\\DH","Ã"],["\\\\dh","Ã°"],["\\\\DJ","Ä"],["\\\\dj","Ä"],["\\\\guillemotleft","Â«"],["\\\\guillemotright","Â»"],["\\\\guilsinglleft","â¹"],["\\\\guilsinglright","âº"],["\\\\H O","Å"],["\\\\H o","Å"],["\\\\H U","Å°"],["\\\\H u","Å±"],["\\\\hebalef","×"],["\\\\hebayin","×¢"],["\\\\hebbet","×"],["\\\\hebdalet","×"],["\\\\hebfinalkaf","×"],["\\\\hebfinalmem","×"],["\\\\hebfinalnun","×"],["\\\\hebfinalpe","×£"],["\\\\hebfinaltsadi","×¥"],["\\\\hebgimel","×"],["\\\\hebhe","×"],["\\\\hebhet","×"],["\\\\hebkaf","×"],["\\\\heblamed","×"],["\\\\hebmem","×"],["\\\\hebnun","× "],["\\\\hebpe","×¤"],["\\\\hebqof","×§"],["\\\\hebresh","×¨"],["\\\\hebsamekh","×¡"],["\\\\hebshin","×©"],["\\\\hebtav","×ª"],["\\\\hebtet","×"],["\\\\hebtsadi","×¦"],["\\\\hebvav","×"],["\\\\hebyod","×"],["\\\\hebzayin","×"],["\\\\i","Ä±"],["\\\\IJ","Ä²"],["\\\\ij","Ä³"],["\\\\j","È·"],["\\\\k ","Ë"],["\\\\k A","Ä"],["\\\\k a","Ä"],["\\\\k E","Ä"],["\\\\k e","Ä"],["\\\\k I","Ä®"],["\\\\k i","Ä¯"],["\\\\k U","Å²"],["\\\\k u","Å³"],["\\\\L","Å"],["\\\\l","Å"],["\\\\NG","Å"],["\\\\ng","Å"],["\\\\nobreakspace","Â "],["\\\\O","Ã"],["\\\\o","Ã¸"],["\\\\OE","Å"],["\\\\oe","Å"],["\\\\quotedblbase","â"],["\\\\quotesinglbase","â"],["\\\\r ","Ë"],["\\\\r A","Ã"],["\\\\r a","Ã¥"],["\\\\r U","Å®"],["\\\\r u","Å¯"],["\\\\ss","Ã"],["\\\\textacutedbl","Ë"],["\\\\textalpha","Î±"],["\\\\textapproxequal","â"],["\\\\textasciiacute","Â´"],["\\\\textasciibreve","Ë"],["\\\\textasciicaron","Ë"],["\\\\textasciicircum","Ë"],["\\\\textasciidieresis","Â¨"],["\\\\textasciigrave","Ë"],["\\\\textasciimacron","Â¯"],["\\\\textasciitilde","Ë"],["\\\\textasteriskcentered","â"],["\\\\textbaht","à¸¿"],["\\\\textbardbl","â"],["\\\\textbeta","Î²"],["\\\\textbigcircle","â¯"],["\\\\textblacksquare","â "],["\\\\textblank","â¢"],["\\\\textblock","â"],["\\\\textbrokenbar","Â¦"],["\\\\textbullet","â¢"],["\\\\textbullet","â"],["\\\\textcap","â§"],["\\\\textcelsius","â"],["\\\\textcent","Â¢"],["\\\\textcircledP","â"],["\\\\textcolonmonetary","â¡"],["\\\\textcommabelow S","È"],["\\\\textcommabelow s","È"],["\\\\textcommabelow T","È"],["\\\\textcommabelow t","È"],["\\\\textcompwordmark","â"],["\\\\textcontourintegral","â®"],["\\\\textcopyright","Â©"],["\\\\textcurrency","Â¤"],["\\\\textdagger","â "],["\\\\textdaggerdbl","â¡"],["\\\\textdbllowline","â"],["\\\\textdegree","Â°"],["\\\\textdelta","Î´"],["\\\\textdiscount","â"],["\\\\textdiv","Ã·"],["\\\\textdkshade","â"],["\\\\textdnblock","â"],["\\\\textdong","â«"],["\\\\textdownarrow","â"],["\\\\textelement","â"],["\\\\textellipsis","â¦"],["\\\\textemdash","â"],["\\\\textendash","â"],["\\\\textepsilon","Îµ"],["\\\\textequivalence","â¡"],["\\\\textestimated","â®"],["\\\\texteuro","â¬"],["\\\\textexclamdown","Â¡"],["\\\\textflorin","Æ"],["\\\\textfractionsolidus","â"],["\\\\textGamma","Î"],["\\\\textgreaterequal","â¥"],["\\\\texthorizontalbar","â"],["\\\\textincrement","â"],["\\\\textinfinity","â"],["\\\\textintegral","â«"],["\\\\textinterrobang","â½"],["\\\\textintersection","â©"],["\\\\textkra","Ä¸"],["\\\\textlangle","â©"],["\\\\textleftarrow","â"],["\\\\textlessequal","â¤"],["\\\\textlfblock","â"],["\\\\textlira","â¤"],["\\\\textlnot","Â¬"],["\\\\textlozenge","â"],["\\\\textltshade","â"],["\\\\textmalteseH","Ä¦"],["\\\\textmalteseh","Ä§"],["\\\\textmho","â§"],["\\\\textmu","Âµ"],["\\\\textmusicalnote","âª"],["\\\\textnaira","â¦"],["\\\\textnotequal","â "],["\\\\textnsuperior","â¿"],["\\\\textnumero","â"],["\\\\textohm","â¦"],["\\\\textOmega","Î©"],["\\\\textonehalf","Â½"],["\\\\textonequarter","Â¼"],["\\\\textonesuperior","Â¹"],["\\\\textopenbullet","â¦"],["\\\\textordfeminine","Âª"],["\\\\textordmasculine","Âº"],["\\\\textparagraph","Â¶"],["\\\\textpartial","â"],["\\\\textperiodcentered","Â·"],["\\\\textpertenthousand","â±"],["\\\\textperthousand","â°"],["\\\\textpeseta","â§"],["\\\\textpeso","â±"],["\\\\textPhi","Î¦"],["\\\\textphi","Ï"],["\\\\textpi","Ï"],["\\\\textpm","Â±"],["\\\\textproduct","â"],["\\\\textquestiondown","Â¿"],["\\\\textquotedblleft","â"],["\\\\textquotedblright","â"],["\\\\textquoteleft","â"],["\\\\textquoteright","â"],["\\\\textrangle","âª"],["\\\\textrecipe","â"],["\\\\textreferencemark","â»"],["\\\\textregistered","Â®"],["\\\\textrevlogicalnot","â"],["\\\\textrightarrow","â"],["\\\\textrtblock","â"],["\\\\textsection","Â§"],["\\\\textservicemark","â "],["\\\\textSFi","â"],["\\\\textSFii","â"],["\\\\textSFiii","â"],["\\\\textSFiv","â"],["\\\\textSFix","â¤"],["\\\\textSFl","â"],["\\\\textSFli","â"],["\\\\textSFlii","â"],["\\\\textSFliii","â«"],["\\\\textSFliv","âª"],["\\\\textSFv","â¼"],["\\\\textSFvi","â¬"],["\\\\textSFvii","â´"],["\\\\textSFviii","â"],["\\\\textSFx","â"],["\\\\textSFxi","â"],["\\\\textSFxix","â¡"],["\\\\textSFxl","â©"],["\\\\textSFxli","â¦"],["\\\\textSFxlii","â "],["\\\\textSFxliii","â"],["\\\\textSFxliv","â¬"],["\\\\textSFxlix","â"],["\\\\textSFxlv","â§"],["\\\\textSFxlvi","â¨"],["\\\\textSFxlvii","â¤"],["\\\\textSFxlviii","â¥"],["\\\\textSFxx","â¢"],["\\\\textSFxxi","â"],["\\\\textSFxxii","â"],["\\\\textSFxxiii","â£"],["\\\\textSFxxiv","â"],["\\\\textSFxxv","â"],["\\\\textSFxxvi","â"],["\\\\textSFxxvii","â"],["\\\\textSFxxviii","â"],["\\\\textSFxxxix","â"],["\\\\textSFxxxvi","â"],["\\\\textSFxxxvii","â"],["\\\\textSFxxxviii","â"],["\\\\textshade","â"],["\\\\textSigma","Î£"],["\\\\textsigma","Ï"],["\\\\textsterling","Â£"],["\\\\textsummation","â"],["\\\\textsurd","â"],["\\\\texttau","Ï"],["\\\\textTheta","Î"],["\\\\textthreequarters","Â¾"],["\\\\textthreesuperior","Â³"],["\\\\texttimes","Ã"],["\\\\texttrademark","â¢"],["\\\\textTstroke","Å¦"],["\\\\texttstroke","Å§"],["\\\\texttwosuperior","Â²"],["\\\\textuparrow","â"],["\\\\textupblock","â"],["\\\\textvisiblespace","â£"],["\\\\textwon","â©"],["\\\\textyen","Â¥"],["\\\\TH","Ã"],["\\\\th","Ã¾"],["\\\\u A","Ä"],["\\\\u a","Ä"],["\\\\u G","Ä"],["\\\\u g","Ä"],["\\\\u U","Å¬"],["\\\\u u","Å­"],["\\\\v \\\\i","Ç"],["\\\\v \\\\j","Ç°"],["\\\\v A","Ç"],["\\\\v a","Ç"],["\\\\v C","Ä"],["\\\\v c","Ä"],["\\\\v D","Ä"],["\\\\v d","Ä"],["\\\\v E","Ä"],["\\\\v e","Ä"],["\\\\v G","Ç¦"],["\\\\v g","Ç§"],["\\\\v I","Ç"],["\\\\v K","Ç¨"],["\\\\v k","Ç©"],["\\\\v L","Ä½"],["\\\\v l","Ä¾"],["\\\\v N","Å"],["\\\\v n","Å"],["\\\\v O","Ç"],["\\\\v o","Ç"],["\\\\v R","Å"],["\\\\v r","Å"],["\\\\v S","Å "],["\\\\v s","Å¡"],["\\\\v T","Å¤"],["\\\\v t","Å¥"],["\\\\v U","Ç"],["\\\\v u","Ç"],["\\\\v Z","Å½"],["\\\\v z","Å¾"],["\\\\Â´ i","Ã­"],["\\\\Â´ A","Ã"],["\\\\Â´ a","Ã¡"],["\\\\Â´ C","Ä"],["\\\\Â´ c","Ä"],["\\\\Â´ E","Ã"],["\\\\Â´ e","Ã©"],["\\\\Â´ G","Ç´"],["\\\\Â´ g","Çµ"],["\\\\Â´ I","Ã"],["\\\\Â´ K","á¸°"],["\\\\Â´ k","á¸±"],["\\\\Â´ L","Ä¹"],["\\\\Â´ l","Äº"],["\\\\Â´ M","á¸¾"],["\\\\Â´ m","á¸¿"],["\\\\Â´ N","Å"],["\\\\Â´ n","Å"],["\\\\Â´ O","Ã"],["\\\\Â´ o","Ã³"],["\\\\Â´ P","á¹"],["\\\\Â´ p","á¹"],["\\\\Â´ R","Å"],["\\\\Â´ r","Å"],["\\\\Â´ S","Å"],["\\\\Â´ s","Å"],["\\\\Â´ U","Ã"],["\\\\Â´ u","Ãº"],["\\\\Â´ W","áº"],["\\\\Â´ w","áº"],["\\\\Â´ Y","Ã"],["\\\\Â´ y","Ã½"],["\\\\Â´ Z","Å¹"],["\\\\Â´ z","Åº"],["\\\\\` i","Ã¬"],["\\\\\` A","Ã"],["\\\\\` a","Ã "],["\\\\\` E","Ã"],["\\\\\` e","Ã¨"],["\\\\\` I","Ã"],["\\\\\` N","Ç¸"],["\\\\\` n","Ç¹"],["\\\\\` O","Ã"],["\\\\\` o","Ã²"],["\\\\\` U","Ã"],["\\\\\` u","Ã¹"],["\\\\\` W","áº"],["\\\\\` w","áº"],["\\\\\` Y","á»²"],["\\\\\` y","á»³"]]`);
  function makeString(content2) {
    return { type: "string", content: content2 };
  }
  const mappedLigatures = unicodeLigatures.map(
    ([macro2, str]) => [macro2, makeString(str)]
  );
  const SUBSTITUTION_MAP = new Map([
    // We cannot use the basic lookup to replace a `\ ` macro, since it
    // may be confused with a macro that has no arguments. We will replace this
    // macro manually.
    //["\\ ", makeString(" ")],
    ["\\,", makeString("â")],
    ["\\thinspace", makeString("â")],
    ["\\:", makeString("â")],
    ["\\>", makeString("â")],
    ["\\medspace", makeString("â")],
    // There's no exact unicode versions of `\medspace` or `\thickspace`, so we approximate
    ["\\;", makeString("â")],
    ["\\thickspace", makeString("â")],
    ["\\enspace", makeString("â")],
    ["\\quad", makeString("â")],
    ["\\qquad", makeString("ââ")],
    // Marks the punctuation as ending a sentence; no substitute.
    ["\\@", makeString("")],
    // Italic correction; no substitute
    ["\\/", makeString("")],
    // Non-breaking space
    ["~", makeString("Â ")],
    ["- - -", makeString("â")],
    ["- -", makeString("â")],
    ["` `", makeString("â")],
    ['"', makeString("â")],
    ["' '", makeString("â")],
    ["`", makeString("â")],
    ["'", makeString("â")],
    ["< <", makeString("Â«")],
    ["> >", makeString("Â»")],
    ["\\$", makeString("$")],
    ["\\%", makeString("%")],
    ["\\_", makeString("_")],
    ["\\&", makeString("&")],
    ["\\#", makeString("#")],
    ["\\{", makeString("{")],
    ["\\}", makeString("}")],
    ["\\P", makeString("Â¶")],
    ["\\S", makeString("Â§")],
    ["\\dots", makeString("â¦")],
    ["\\ldots", makeString("â¦")],
    ["\\pounds", makeString("Â£")],
    ["\\copyright", makeString("Â©")],
    ...mappedLigatures
  ]);
  function hashNodes(nodes) {
    return nodes.map((node2) => match.macro(node2) ? `\\${node2.content}` : node2.content).join(" ");
  }
  function isMacroOrStringArray(nodes) {
    return nodes.some((node2) => match.macro(node2) || match.string(node2));
  }
  function ligatureToUnicode(nodes) {
    if (!isMacroOrStringArray(nodes)) {
      return null;
    }
    if (nodes.length === 1 && match.macro(nodes[0], " ") && nodes[0].escapeToken == null) {
      return makeString(" ");
    }
    return SUBSTITUTION_MAP.get(hashNodes(nodes)) || null;
  }
  function createMatchers$4() {
    return {
      isMacro: match.anyMacro,
      isWhitespace: match.whitespace,
      isRecognized: (nodes, whitespaceAllowed = false) => {
        const nodesToTest = [...nodes];
        if (nodes.length === 2 && match.macro(nodes[0])) {
          const arg2 = nodes[1];
          if (match.group(arg2) && arg2.content.length === 1) {
            nodesToTest[1] = arg2.content[0];
          }
          if (nodes[0].content.length === 1 && nodesToTest[1].type === "whitespace") {
            nodesToTest.length = 1;
          }
        }
        return ligatureToUnicode(nodesToTest);
      },
      isSplitable: (node2) => match.anyString(node2) && node2.content.length > 1,
      split: (node2) => [
        { type: "string", content: node2.content.charAt(0) },
        { type: "string", content: node2.content.slice(1) }
      ]
    };
  }
  function parseLigatures(ast2) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = decorateArrayForPegjs([...ast2]);
    return LigaturesPegParser.parse(ast2, createMatchers$4());
  }
  function expandUnicodeLigatures(tree) {
    visit$3(
      tree,
      (nodes, info) => {
        if (info.context.inMathMode || info.context.hasMathModeAncestor) {
          return;
        }
        const parsed = parseLigatures(nodes);
        nodes.length = 0;
        nodes.push(...parsed);
      },
      { includeArrays: true, test: Array.isArray }
    );
  }
  function tagName(tag) {
    return `html-tag:${tag}`;
  }
  function attributeName(attribute) {
    return `html-attr:${attribute}`;
  }
  function getTagNameFromString(tagName2) {
    const match2 = tagName2.match(/:.*/);
    if (match2) {
      return match2[0].slice(1);
    }
    throw new Error(`Could not find tag name in ${tagName2}`);
  }
  function getAttributeNameFromString(tagName2) {
    const match2 = tagName2.match(/:.*/);
    if (match2) {
      return match2[0].slice(1);
    }
    throw new Error(`Could not find attribute name in ${tagName2}`);
  }
  function htmlLike({
    tag,
    content: content2,
    attributes: attributes2
  }) {
    if (!content2) {
      content2 = [];
    }
    if (content2 && !Array.isArray(content2)) {
      content2 = [content2];
    }
    attributes2 = attributes2 || {};
    const attrs = Object.entries(attributes2).map(
      ([name2, value2]) => {
        value2 = JSON.stringify(value2);
        return m(attributeName(name2), arg(value2));
      }
    );
    return m(tagName(tag), arg(attrs.concat(content2)));
  }
  function extractFromHtmlLike(macro2) {
    if (!isHtmlLikeTag(macro2)) {
      throw new Error(
        "Attempting to extract html contents from a node that is not html-like."
      );
    }
    const args = macro2.args || [];
    if (args.length > 1) {
      throw new Error(
        `html-like macros should have 0 or 1 args, but ${args.length} found`
      );
    }
    const argContent = args.length > 0 ? args[0].content : [];
    const tag = getTagNameFromString(macro2.content);
    const attributes2 = {};
    let i = 0;
    for (; i < argContent.length; i++) {
      const node2 = argContent[i];
      if (isHtmlLikeAttribute(node2)) {
        const attrName = getAttributeNameFromString(node2.content);
        let attrValue = true;
        if (node2.args && node2.args.length > 0) {
          attrValue = JSON.parse(printRaw(node2.args[0].content));
        }
        attributes2[attrName] = attrValue;
        continue;
      }
      break;
    }
    return { tag, attributes: attributes2, content: argContent.slice(i) };
  }
  function isHtmlLikeTag(node2) {
    return match.macro(node2) && node2.content.startsWith("html-tag:");
  }
  function isHtmlLikeAttribute(node2) {
    return match.macro(node2) && node2.content.startsWith("html-attr:");
  }
  function lintRule(meta2, rule2) {
    const id2 = typeof meta2 === "string" ? meta2 : meta2.origin;
    const url = typeof meta2 === "string" ? void 0 : meta2.url;
    const parts2 = id2.split(":");
    const source = parts2[1] ? parts2[0] : void 0;
    const ruleId = parts2[1];
    Object.defineProperty(plugin, "name", { value: id2 });
    return plugin;
    function plugin(config2) {
      const [severity, options2] = coerce(ruleId, config2);
      if (!severity)
        return;
      const fatal = severity === 2;
      return (tree, file, next) => {
        let index2 = file.messages.length - 1;
        wrap$1(rule2, (error) => {
          const messages = file.messages;
          if (error && !messages.includes(error)) {
            try {
              file.fail(error);
            } catch {
            }
          }
          while (++index2 < messages.length) {
            Object.assign(messages[index2], { ruleId, source, fatal, url });
          }
          next();
        })(tree, file, options2);
      };
    }
  }
  function coerce(name2, config2) {
    if (!Array.isArray(config2))
      return [1, config2];
    const [severity, ...options2] = config2;
    switch (severity) {
      case false:
      case "off":
      case 0: {
        return [0, ...options2];
      }
      case true:
      case "on":
      case "warn":
      case 1: {
        return [1, ...options2];
      }
      case "error":
      case 2: {
        return [2, ...options2];
      }
      default: {
        if (typeof severity !== "number")
          return [1, config2];
        throw new Error(
          "Incorrect severity `" + severity + "` for `" + name2 + "`, expected 0, 1, or 2"
        );
      }
    }
  }
  const REPLACEMENTS$2 = {
    bf: "bfseries",
    it: "itshape",
    rm: "rmfamily",
    sc: "scshape",
    sf: "sffamily",
    sl: "slshape",
    tt: "ttfamily"
  };
  const isReplaceable$2 = match.createMacroMatcher(REPLACEMENTS$2);
  `## Lint Rule

Avoid using TeX font changing commands like \\bf, \\it, etc. Prefer LaTeX \\bfseries, \\itshape, etc.. 

This rule flags any usage of \`${Object.keys(REPLACEMENTS$2).map((r) => printRaw(m(r))).join("` `")}\`

### See

CTAN l2tabuen Section 2.`;
  const unifiedLatexLintNoTexFontShapingCommands = lintRule(
    { origin: "unified-latex-lint:no-tex-font-shaping-commands" },
    (tree, file, options2) => {
      visit$3(
        tree,
        (node2, info) => {
          const macroName = node2.content;
          file.message(
            `Replace "${printRaw(node2)}" with "${printRaw(
              m(REPLACEMENTS$2[macroName])
            )}"`,
            node2
          );
          if (options2 == null ? void 0 : options2.fix) {
            replaceNodeDuringVisit(m(REPLACEMENTS$2[macroName]), info);
          }
        },
        { test: isReplaceable$2 }
      );
    }
  );
  /*! https://mths.be/cssesc v3.0.0 by @mathias */
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var merge = function merge2(options2, defaults2) {
    if (!options2) {
      return defaults2;
    }
    var result = {};
    for (var key2 in defaults2) {
      result[key2] = hasOwnProperty.call(options2, key2) ? options2[key2] : defaults2[key2];
    }
    return result;
  };
  var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
  var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
  var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
  var cssesc = function cssesc2(string2, options2) {
    options2 = merge(options2, cssesc2.options);
    if (options2.quotes != "single" && options2.quotes != "double") {
      options2.quotes = "single";
    }
    var quote = options2.quotes == "double" ? '"' : "'";
    var isIdentifier = options2.isIdentifier;
    var firstChar = string2.charAt(0);
    var output = "";
    var counter = 0;
    var length = string2.length;
    while (counter < length) {
      var character = string2.charAt(counter++);
      var codePoint = character.charCodeAt();
      var value2 = void 0;
      if (codePoint < 32 || codePoint > 126) {
        if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
          var extra = string2.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
          } else {
            counter--;
          }
        }
        value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else {
        if (options2.escapeEverything) {
          if (regexAnySingleEscape.test(character)) {
            value2 = "\\" + character;
          } else {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          }
        } else if (/[\t\n\f\r\x0B]/.test(character)) {
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
          value2 = "\\" + character;
        } else {
          value2 = character;
        }
      }
      output += value2;
    }
    if (isIdentifier) {
      if (/^-[-\d]/.test(output)) {
        output = "\\-" + output.slice(1);
      } else if (/\d/.test(firstChar)) {
        output = "\\3" + firstChar + " " + output.slice(1);
      }
    }
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
      if ($1 && $1.length % 2) {
        return $0;
      }
      return ($1 || "") + $2;
    });
    if (!isIdentifier && options2.wrap) {
      return quote + output + quote;
    }
    return output;
  };
  cssesc.options = {
    "escapeEverything": false,
    "isIdentifier": false,
    "quotes": "single",
    "wrap": false
  };
  cssesc.version = "3.0.0";
  var cssesc_1 = cssesc;
  var cssesc$1 = /* @__PURE__ */ getDefaultExportFromCjs(cssesc_1);
  function createMatchers$3() {
    return {
      matchChar: (node2, char) => match.string(node2, char),
      isWhitespace: match.whitespace,
      isGroup: match.group
    };
  }
  function parseTabularSpec(ast2) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = splitStringsIntoSingleChars(ast2);
    ast2 = decorateArrayForPegjs([...ast2]);
    return TabularPegParser.parse(ast2, createMatchers$3());
  }
  function createMatchers$2({
    at: at2 = "@",
    equals = "=",
    equationSeparator = ",",
    mathOperations = ["+", "-"],
    whitelistedVariables
  } = {}) {
    let isVar = (node2) => match.anyString(node2) && !!node2.content.match(/[a-zA-Z]/);
    if (whitelistedVariables) {
      whitelistedVariables = whitelistedVariables.map(
        (v) => match.anyString(v) ? v.content : v
      );
      const macros2 = whitelistedVariables.filter(
        (v) => match.anyMacro(v)
      );
      const strings = whitelistedVariables.filter(
        (v) => typeof v === "string"
      );
      const macroHash = Object.fromEntries(macros2.map((v) => [v.content, v]));
      const stringHash = Object.fromEntries(strings.map((s2) => [s2, s2]));
      const macroMatcher = match.createMacroMatcher(macroHash);
      isVar = (node2) => macroMatcher(node2) || match.anyString(node2) && !!stringHash[node2.content];
    }
    return {
      isSep: (node2) => match.string(node2, equationSeparator),
      isVar,
      isOperation: (node2) => mathOperations.some((op2) => match.string(node2, op2)),
      isEquals: (node2) => match.string(node2, equals),
      isAt: (node2) => match.string(node2, at2),
      isSubscript: (node2) => match.macro(node2, "_") && node2.escapeToken === "",
      isWhitespace: match.whitespace,
      isSameLineComment: (node2) => match.comment(node2) && node2.sameline,
      isOwnLineComment: (node2) => match.comment(node2) && !node2.sameline
    };
  }
  function parse(ast2, options2) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = decorateArrayForPegjs([...ast2]);
    return SystemePegParser.parse(
      ast2,
      createMatchers$2(options2 || {})
    );
  }
  const AMP = { type: "string", content: "&" };
  const SEP = { type: "macro", content: "\\" };
  const QUAD = { type: "macro", content: "quad" };
  const PLUS = { type: "string", content: "+" };
  const COLUMN_KERN_ADJUSTMENT = [
    { type: "string", content: "@" },
    {
      type: "group",
      content: [
        { type: "macro", content: "mkern" },
        { type: "string", content: "5mu" }
      ]
    }
  ];
  function sortVariables(vars, whitelistedVariables) {
    const varMap = new Map(vars.map((v) => [v, printRaw(v)]));
    const varNames = Array.from(new Set(varMap.values()));
    varNames.sort();
    const nameToPos = whitelistedVariables ? new Map(whitelistedVariables.map((v, i) => [printRaw(v), i])) : new Map(varNames.map((name2, i) => [name2, i]));
    return new Map(
      Array.from(varMap.entries()).map(([variable, name2]) => {
        return [variable, nameToPos.get(name2) ?? -1];
      })
    );
  }
  function processLine(line2, numVars, varOrder, hasEquals, hasAnnotation) {
    const ret = [];
    if (line2.equation) {
      const nonVarItems = line2.equation.left.filter(
        (item) => item.variable == null
      );
      const varItems = line2.equation.left.filter(
        (item) => item.variable != null
      );
      let nonVarTerm = null;
      if (nonVarItems.length === 1) {
        nonVarTerm = nonVarItems[0];
      } else if (nonVarItems.length > 1) {
        nonVarTerm = {
          ...nonVarItems[0],
          content: nonVarItems[0].content.concat(
            nonVarItems.slice(1).flatMap((item) => {
              if (item.op) {
                return [item.op, ...item.content];
              }
              return [PLUS, ...item.content];
            })
          )
        };
      }
      const allItems = nonVarTerm ? varItems.concat(nonVarTerm) : varItems;
      const indexToItem = new Map(
        allItems.map((item) => {
          if (item.variable == null) {
            return [numVars - 1, item];
          }
          return [varOrder.get(item.variable), item];
        })
      );
      let isFirstItem = true;
      for (let i = 0; i < numVars; i++) {
        const item = indexToItem.get(i);
        if (item) {
          if (isFirstItem && (match.string(item.op, "+") || item.op == null)) {
            ret.push([]);
            ret.push(item.content);
          } else {
            ret.push([item.op || PLUS]);
            ret.push(item.content);
          }
          isFirstItem = false;
        } else {
          ret.push([]);
          ret.push([]);
        }
      }
      if (hasEquals) {
        const equalsPart = (line2.equation.equals ? [line2.equation.equals] : []).concat(line2.equation.right);
        ret.push(equalsPart);
      }
    }
    if (hasAnnotation) {
      ret.push(line2.annotation ? line2.annotation.content : []);
    }
    return ret;
  }
  function arraySpecToSpacedArraySpec(spec, hasAnnotation) {
    const annotationSpec = hasAnnotation ? spec.charAt(spec.length - 1) : "";
    const bodySpec = hasAnnotation ? spec.slice(0, spec.length - 1) : spec;
    const bodyStrings = Array.from(bodySpec).map((x2) => [
      { type: "string", content: x2 }
    ]);
    const body2 = arrayJoin(bodyStrings, COLUMN_KERN_ADJUSTMENT);
    return annotationSpec ? body2.concat({ type: "string", content: annotationSpec }) : body2;
  }
  function extractVariables(nodes) {
    return nodes.flatMap((node2) => {
      if (node2.type === "line" && node2.equation) {
        return extractVariables(node2.equation.left);
      }
      if (node2.type === "equation") {
        return node2.left.flatMap(
          (item) => item.variable ? [item.variable] : []
        );
      }
      if (node2.type === "item") {
        return node2.variable ? [node2.variable] : [];
      }
      return [];
    });
  }
  function normalizeVariableWhitelist(vars) {
    if (!vars) {
      return null;
    }
    const normalized = vars.map(
      (v) => typeof v === "string" ? { type: "string", content: v } : v
    );
    const ret = normalized.filter(
      (v) => (match.anyMacro(v) || match.anyString(v)) && !match.string(v, " ") && !match.whitespace(v)
    );
    return ret;
  }
  function systemeContentsToArray(nodes, options2) {
    nodes = structuredClone$3(nodes);
    deleteComments(nodes);
    const { properSpacing = true, whitelistedVariables } = options2 || {};
    const coercedWhitelistedVariables = normalizeVariableWhitelist(whitelistedVariables);
    const systemeAst = parse(nodes, { whitelistedVariables });
    const vars = extractVariables(systemeAst);
    const varOrder = sortVariables(vars, coercedWhitelistedVariables);
    let numVars = coercedWhitelistedVariables ? coercedWhitelistedVariables.length : Math.max(...Array.from(varOrder.values())) + 1;
    if (systemeAst.some((line2) => {
      if (line2.equation) {
        return line2.equation.left.some((item) => item.variable == null);
      }
    })) {
      numVars += 1;
    }
    const hasEquals = systemeAst.some(
      (line2) => line2.equation && line2.equation.equals
    );
    const hasAnnotation = systemeAst.some((line2) => line2.annotation);
    let rows = systemeAst.map(
      (line2) => processLine(line2, numVars, varOrder, hasEquals, hasAnnotation)
    );
    const noLeadingOperation = rows.every((row2) => row2[0].length === 0);
    let arraySignature = Array.from({ length: numVars }, () => "cr").join("");
    if (noLeadingOperation) {
      arraySignature = arraySignature.slice(1);
      rows = rows.map((row2) => row2.slice(1));
    }
    if (hasEquals) {
      arraySignature += "l";
    }
    if (hasAnnotation) {
      arraySignature += "l";
      rows = rows.map((row2) => {
        if (row2[row2.length - 1].length === 0) {
          return row2;
        }
        return [
          ...row2.slice(0, row2.length - 1),
          [QUAD, { type: "whitespace" }, ...row2[row2.length - 1]]
        ];
      });
    }
    const arraySignatureWithSpacing = properSpacing ? arraySpecToSpacedArraySpec(arraySignature, hasAnnotation) : [{ type: "string", content: arraySignature }];
    const bodyRows = rows.map((row2) => arrayJoin(row2, AMP));
    const body2 = arrayJoin(bodyRows, SEP);
    const ret = {
      type: "environment",
      env: "array",
      args: [
        {
          type: "argument",
          openMark: "{",
          closeMark: "}",
          content: arraySignatureWithSpacing
        }
      ],
      content: body2
    };
    return ret;
  }
  function attachSystemeSettingsAsRenderInfo(ast2) {
    const systemeMatcher = match.createMacroMatcher(["systeme", "sysdelim"]);
    visit$3(
      ast2,
      (nodes, info) => {
        if (!info.context.inMathMode || !nodes.some(systemeMatcher)) {
          return;
        }
        const systemeLocations = nodes.flatMap(
          (node2, i) => match.macro(node2, "systeme") ? i : []
        );
        const sysdelimLocations = nodes.flatMap(
          (node2, i) => match.macro(node2, "sysdelim") ? i : []
        );
        if (systemeLocations.length === 0 || sysdelimLocations.length === 0) {
          return;
        }
        for (const i of systemeLocations) {
          const lastSysdelim = Math.max(
            ...sysdelimLocations.filter((loc) => loc < i)
          );
          if (lastSysdelim >= 0) {
            const node2 = nodes[i];
            const sysdelimMacro = nodes[lastSysdelim];
            if (!match.anyMacro(sysdelimMacro)) {
              throw new Error(
                `Expecting sysdelim macro but found "${printRaw(
                  sysdelimMacro
                )}"`
              );
            }
            const args = getArgsContent(sysdelimMacro);
            updateRenderInfo(node2, { sysdelims: args });
          }
        }
      },
      {
        test: Array.isArray,
        includeArrays: true
      }
    );
  }
  function xcolorMacroToHex(node2) {
    node2 = structuredClone$3(node2);
    deleteComments(node2);
    const args = getArgsContent(node2);
    const model = args[0] && printRaw(args[0]);
    const colorStr = printRaw(args[1] || []);
    let hex2 = null;
    try {
      hex2 = xcolorColorToHex(colorStr, model);
    } catch (e2) {
    }
    const cssVarName = "--" + colorStr.replace(/[^a-zA-Z0-9-_]/g, "-");
    return { hex: hex2, cssVarName };
  }
  function colorToTextcolorMacro(content2, origMacro) {
    if (!Array.isArray(content2)) {
      content2 = [content2];
    }
    const args = (origMacro.args ? origMacro.args : [arg([], { closeMark: "", openMark: "" }), arg([])]).concat(arg(content2));
    return {
      type: "macro",
      content: "textcolor",
      args,
      _renderInfo: { inParMode: true }
    };
  }
  function core(value2, options2) {
    value2 = value2.replace(
      options2.subset ? charactersToExpression(options2.subset) : /["&'<>`]/g,
      basic2
    );
    if (options2.subset || options2.escapeOnly) {
      return value2;
    }
    return value2.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
      // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
      /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
      basic2
    );
    function surrogate(pair, index2, all2) {
      return options2.format(
        (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
        all2.charCodeAt(index2 + 2),
        options2
      );
    }
    function basic2(character, index2, all2) {
      return options2.format(
        character.charCodeAt(0),
        all2.charCodeAt(index2 + 1),
        options2
      );
    }
  }
  function charactersToExpression(subset2) {
    const groups = [];
    let index2 = -1;
    while (++index2 < subset2.length) {
      groups.push(subset2[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
    }
    return new RegExp("(?:" + groups.join("|") + ")", "g");
  }
  function toHexadecimal(code2, next, omit) {
    const value2 = "&#x" + code2.toString(16).toUpperCase();
    return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value2 : value2 + ";";
  }
  function toDecimal(code2, next, omit) {
    const value2 = "&#" + String(code2);
    return omit && next && !/\d/.test(String.fromCharCode(next)) ? value2 : value2 + ";";
  }
  const characterEntitiesLegacy = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml"
  ];
  const characterEntitiesHtml4 = {
    nbsp: "Â ",
    iexcl: "Â¡",
    cent: "Â¢",
    pound: "Â£",
    curren: "Â¤",
    yen: "Â¥",
    brvbar: "Â¦",
    sect: "Â§",
    uml: "Â¨",
    copy: "Â©",
    ordf: "Âª",
    laquo: "Â«",
    not: "Â¬",
    shy: "Â­",
    reg: "Â®",
    macr: "Â¯",
    deg: "Â°",
    plusmn: "Â±",
    sup2: "Â²",
    sup3: "Â³",
    acute: "Â´",
    micro: "Âµ",
    para: "Â¶",
    middot: "Â·",
    cedil: "Â¸",
    sup1: "Â¹",
    ordm: "Âº",
    raquo: "Â»",
    frac14: "Â¼",
    frac12: "Â½",
    frac34: "Â¾",
    iquest: "Â¿",
    Agrave: "Ã",
    Aacute: "Ã",
    Acirc: "Ã",
    Atilde: "Ã",
    Auml: "Ã",
    Aring: "Ã",
    AElig: "Ã",
    Ccedil: "Ã",
    Egrave: "Ã",
    Eacute: "Ã",
    Ecirc: "Ã",
    Euml: "Ã",
    Igrave: "Ã",
    Iacute: "Ã",
    Icirc: "Ã",
    Iuml: "Ã",
    ETH: "Ã",
    Ntilde: "Ã",
    Ograve: "Ã",
    Oacute: "Ã",
    Ocirc: "Ã",
    Otilde: "Ã",
    Ouml: "Ã",
    times: "Ã",
    Oslash: "Ã",
    Ugrave: "Ã",
    Uacute: "Ã",
    Ucirc: "Ã",
    Uuml: "Ã",
    Yacute: "Ã",
    THORN: "Ã",
    szlig: "Ã",
    agrave: "Ã ",
    aacute: "Ã¡",
    acirc: "Ã¢",
    atilde: "Ã£",
    auml: "Ã¤",
    aring: "Ã¥",
    aelig: "Ã¦",
    ccedil: "Ã§",
    egrave: "Ã¨",
    eacute: "Ã©",
    ecirc: "Ãª",
    euml: "Ã«",
    igrave: "Ã¬",
    iacute: "Ã­",
    icirc: "Ã®",
    iuml: "Ã¯",
    eth: "Ã°",
    ntilde: "Ã±",
    ograve: "Ã²",
    oacute: "Ã³",
    ocirc: "Ã´",
    otilde: "Ãµ",
    ouml: "Ã¶",
    divide: "Ã·",
    oslash: "Ã¸",
    ugrave: "Ã¹",
    uacute: "Ãº",
    ucirc: "Ã»",
    uuml: "Ã¼",
    yacute: "Ã½",
    thorn: "Ã¾",
    yuml: "Ã¿",
    fnof: "Æ",
    Alpha: "Î",
    Beta: "Î",
    Gamma: "Î",
    Delta: "Î",
    Epsilon: "Î",
    Zeta: "Î",
    Eta: "Î",
    Theta: "Î",
    Iota: "Î",
    Kappa: "Î",
    Lambda: "Î",
    Mu: "Î",
    Nu: "Î",
    Xi: "Î",
    Omicron: "Î",
    Pi: "Î ",
    Rho: "Î¡",
    Sigma: "Î£",
    Tau: "Î¤",
    Upsilon: "Î¥",
    Phi: "Î¦",
    Chi: "Î§",
    Psi: "Î¨",
    Omega: "Î©",
    alpha: "Î±",
    beta: "Î²",
    gamma: "Î³",
    delta: "Î´",
    epsilon: "Îµ",
    zeta: "Î¶",
    eta: "Î·",
    theta: "Î¸",
    iota: "Î¹",
    kappa: "Îº",
    lambda: "Î»",
    mu: "Î¼",
    nu: "Î½",
    xi: "Î¾",
    omicron: "Î¿",
    pi: "Ï",
    rho: "Ï",
    sigmaf: "Ï",
    sigma: "Ï",
    tau: "Ï",
    upsilon: "Ï",
    phi: "Ï",
    chi: "Ï",
    psi: "Ï",
    omega: "Ï",
    thetasym: "Ï",
    upsih: "Ï",
    piv: "Ï",
    bull: "â¢",
    hellip: "â¦",
    prime: "â²",
    Prime: "â³",
    oline: "â¾",
    frasl: "â",
    weierp: "â",
    image: "â",
    real: "â",
    trade: "â¢",
    alefsym: "âµ",
    larr: "â",
    uarr: "â",
    rarr: "â",
    darr: "â",
    harr: "â",
    crarr: "âµ",
    lArr: "â",
    uArr: "â",
    rArr: "â",
    dArr: "â",
    hArr: "â",
    forall: "â",
    part: "â",
    exist: "â",
    empty: "â",
    nabla: "â",
    isin: "â",
    notin: "â",
    ni: "â",
    prod: "â",
    sum: "â",
    minus: "â",
    lowast: "â",
    radic: "â",
    prop: "â",
    infin: "â",
    ang: "â ",
    and: "â§",
    or: "â¨",
    cap: "â©",
    cup: "âª",
    int: "â«",
    there4: "â´",
    sim: "â¼",
    cong: "â",
    asymp: "â",
    ne: "â ",
    equiv: "â¡",
    le: "â¤",
    ge: "â¥",
    sub: "â",
    sup: "â",
    nsub: "â",
    sube: "â",
    supe: "â",
    oplus: "â",
    otimes: "â",
    perp: "â¥",
    sdot: "â",
    lceil: "â",
    rceil: "â",
    lfloor: "â",
    rfloor: "â",
    lang: "â©",
    rang: "âª",
    loz: "â",
    spades: "â ",
    clubs: "â£",
    hearts: "â¥",
    diams: "â¦",
    quot: '"',
    amp: "&",
    lt: "<",
    gt: ">",
    OElig: "Å",
    oelig: "Å",
    Scaron: "Å ",
    scaron: "Å¡",
    Yuml: "Å¸",
    circ: "Ë",
    tilde: "Ë",
    ensp: "â",
    emsp: "â",
    thinsp: "â",
    zwnj: "â",
    zwj: "â",
    lrm: "â",
    rlm: "â",
    ndash: "â",
    mdash: "â",
    lsquo: "â",
    rsquo: "â",
    sbquo: "â",
    ldquo: "â",
    rdquo: "â",
    bdquo: "â",
    dagger: "â ",
    Dagger: "â¡",
    permil: "â°",
    lsaquo: "â¹",
    rsaquo: "âº",
    euro: "â¬"
  };
  const dangerous = [
    "cent",
    "copy",
    "divide",
    "gt",
    "lt",
    "not",
    "para",
    "times"
  ];
  const own$7 = {}.hasOwnProperty;
  const characters = {};
  let key;
  for (key in characterEntitiesHtml4) {
    if (own$7.call(characterEntitiesHtml4, key)) {
      characters[characterEntitiesHtml4[key]] = key;
    }
  }
  function toNamed(code2, next, omit, attribute) {
    const character = String.fromCharCode(code2);
    if (own$7.call(characters, character)) {
      const name2 = characters[character];
      const value2 = "&" + name2;
      if (omit && characterEntitiesLegacy.includes(name2) && !dangerous.includes(name2) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
        return value2;
      }
      return value2 + ";";
    }
    return "";
  }
  function formatSmart(code2, next, options2) {
    let numeric = toHexadecimal(code2, next, options2.omitOptionalSemicolons);
    let named;
    if (options2.useNamedReferences || options2.useShortestReferences) {
      named = toNamed(
        code2,
        next,
        options2.omitOptionalSemicolons,
        options2.attribute
      );
    }
    if ((options2.useShortestReferences || !named) && options2.useShortestReferences) {
      const decimal = toDecimal(code2, next, options2.omitOptionalSemicolons);
      if (decimal.length < numeric.length) {
        numeric = decimal;
      }
    }
    return named && (!options2.useShortestReferences || named.length < numeric.length) ? named : numeric;
  }
  function formatBasic(code2) {
    return "&#x" + code2.toString(16).toUpperCase() + ";";
  }
  function stringifyEntities(value2, options2) {
    return core(value2, Object.assign({ format: formatSmart }, options2));
  }
  function stringifyEntitiesLight(value2, options2) {
    return core(value2, Object.assign({ format: formatBasic }, options2));
  }
  function comment$2(node2, _1, _2, state) {
    return state.settings.bogusComments ? "<?" + stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, { subset: [">"] })
    ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + "-->";
    function encode($0) {
      return stringifyEntities(
        $0,
        Object.assign({}, state.settings.characterReferences, {
          subset: ["<", ">"]
        })
      );
    }
  }
  function doctype$1(_1, _2, _3, state) {
    return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
  }
  function ccount(value2, character) {
    const source = String(value2);
    if (typeof character !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index2 = source.indexOf(character);
    while (index2 !== -1) {
      count++;
      index2 = source.indexOf(character, index2 + character.length);
    }
    return count;
  }
  function whitespace$2(thing) {
    const value2 = (
      // @ts-expect-error looks like a node.
      thing && typeof thing === "object" && thing.type === "text" ? (
        // @ts-expect-error looks like a text.
        thing.value || ""
      ) : thing
    );
    return typeof value2 === "string" && value2.replace(/[ \t\n\f\r]/g, "") === "";
  }
  const siblingAfter = siblings(1);
  const siblingBefore = siblings(-1);
  function siblings(increment2) {
    return sibling;
    function sibling(parent, index2, includeWhitespace) {
      const siblings2 = parent ? parent.children : [];
      let offset = (index2 || 0) + increment2;
      let next = siblings2 && siblings2[offset];
      if (!includeWhitespace) {
        while (next && whitespace$2(next)) {
          offset += increment2;
          next = siblings2[offset];
        }
      }
      return next;
    }
  }
  const own$6 = {}.hasOwnProperty;
  function omission(handlers2) {
    return omit;
    function omit(node2, index2, parent) {
      return own$6.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
    }
  }
  const closing = omission({
    html: html$3,
    head: headOrColgroupOrCaption,
    body: body$1,
    p: p$2,
    li: li$1,
    dt,
    dd,
    rt: rubyElement,
    rp: rubyElement,
    optgroup,
    option,
    menuitem,
    colgroup: headOrColgroupOrCaption,
    caption: headOrColgroupOrCaption,
    thead,
    tbody: tbody$1,
    tfoot,
    tr,
    td: cells,
    th: cells
  });
  function headOrColgroupOrCaption(_, index2, parent) {
    const next = siblingAfter(parent, index2, true);
    return !next || next.type !== "comment" && !(next.type === "text" && whitespace$2(next.value.charAt(0)));
  }
  function html$3(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function body$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function p$2(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
    !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
  }
  function li$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "li";
  }
  function dt(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
  }
  function dd(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
  }
  function rubyElement(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
  }
  function optgroup(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "optgroup";
  }
  function option(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
  }
  function menuitem(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "menuitem" || next.tagName === "hr" || next.tagName === "menu");
  }
  function thead(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
  }
  function tbody$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
  }
  function tfoot(_, index2, parent) {
    return !siblingAfter(parent, index2);
  }
  function tr(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "tr";
  }
  function cells(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
  }
  const opening = omission({
    html: html$2,
    head,
    body,
    colgroup,
    tbody
  });
  function html$2(node2) {
    const head2 = siblingAfter(node2, -1);
    return !head2 || head2.type !== "comment";
  }
  function head(node2) {
    const children = node2.children;
    const seen = [];
    let index2 = -1;
    while (++index2 < children.length) {
      const child = children[index2];
      if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
        if (seen.includes(child.tagName))
          return false;
        seen.push(child.tagName);
      }
    }
    return children.length > 0;
  }
  function body(node2) {
    const head2 = siblingAfter(node2, -1, true);
    return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace$2(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
  }
  function colgroup(node2, index2, parent) {
    const previous = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1, true);
    if (parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent)) {
      return false;
    }
    return head2 && head2.type === "element" && head2.tagName === "col";
  }
  function tbody(node2, index2, parent) {
    const previous = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1);
    if (parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent)) {
      return false;
    }
    return head2 && head2.type === "element" && head2.tagName === "tr";
  }
  const constants = {
    // See: <https://html.spec.whatwg.org/#attribute-name-state>.
    name: [
      ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
      [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
    unquoted: [
      ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
      ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
    single: [
      ["&'".split(""), "\"&'`".split("")],
      ["\0&'".split(""), "\0\"&'`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
    double: [
      ['"&'.split(""), "\"&'`".split("")],
      ['\0"&'.split(""), "\0\"&'`".split("")]
    ]
  };
  function element$2(node2, index2, parent, state) {
    const schema = state.schema;
    const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
    let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
    const parts2 = [];
    let last;
    if (schema.space === "html" && node2.tagName === "svg") {
      state.schema = svg;
    }
    const attrs = serializeAttributes(state, node2.properties);
    const content2 = state.all(
      schema.space === "html" && node2.tagName === "template" ? node2.content : node2
    );
    state.schema = schema;
    if (content2)
      selfClosing = false;
    if (attrs || !omit || !opening(node2, index2, parent)) {
      parts2.push("<", node2.tagName, attrs ? " " + attrs : "");
      if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
        last = attrs.charAt(attrs.length - 1);
        if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
          parts2.push(" ");
        }
        parts2.push("/");
      }
      parts2.push(">");
    }
    parts2.push(content2);
    if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
      parts2.push("</" + node2.tagName + ">");
    }
    return parts2.join("");
  }
  function serializeAttributes(state, props) {
    const values = [];
    let index2 = -1;
    let key2;
    if (props) {
      for (key2 in props) {
        if (props[key2] !== void 0 && props[key2] !== null) {
          const value2 = serializeAttribute(state, key2, props[key2]);
          if (value2)
            values.push(value2);
        }
      }
    }
    while (++index2 < values.length) {
      const last = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : null;
      if (index2 !== values.length - 1 && last !== '"' && last !== "'") {
        values[index2] += " ";
      }
    }
    return values.join("");
  }
  function serializeAttribute(state, key2, value2) {
    const info = find(state.schema, key2);
    const x2 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
    const y = state.settings.allowDangerousCharacters ? 0 : 1;
    let quote = state.quote;
    let result;
    if (info.overloadedBoolean && (value2 === info.attribute || value2 === "")) {
      value2 = true;
    } else if (info.boolean || info.overloadedBoolean && typeof value2 !== "string") {
      value2 = Boolean(value2);
    }
    if (value2 === void 0 || value2 === null || value2 === false || typeof value2 === "number" && Number.isNaN(value2)) {
      return "";
    }
    const name2 = stringifyEntities(
      info.attribute,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: constants.name[x2][y]
      })
    );
    if (value2 === true)
      return name2;
    value2 = Array.isArray(value2) ? (info.commaSeparated ? stringify : stringify$1)(value2, {
      padLeft: !state.settings.tightCommaSeparatedLists
    }) : String(value2);
    if (state.settings.collapseEmptyAttributes && !value2)
      return name2;
    if (state.settings.preferUnquoted) {
      result = stringifyEntities(
        value2,
        Object.assign({}, state.settings.characterReferences, {
          subset: constants.unquoted[x2][y],
          attribute: true
        })
      );
    }
    if (result !== value2) {
      if (state.settings.quoteSmart && ccount(value2, quote) > ccount(value2, state.alternative)) {
        quote = state.alternative;
      }
      result = quote + stringifyEntities(
        value2,
        Object.assign({}, state.settings.characterReferences, {
          // Always encode without parse errors in non-HTML.
          subset: (quote === "'" ? constants.single : constants.double)[x2][y],
          attribute: true
        })
      ) + quote;
    }
    return name2 + (result ? "=" + result : result);
  }
  function text$4(node2, _, parent, state) {
    return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", "&"]
      })
    );
  }
  function raw$1(node2, index2, parent, state) {
    return state.settings.allowDangerousHtml ? node2.value : text$4(node2, index2, parent, state);
  }
  function root$3(node2, _1, _2, state) {
    return state.all(node2);
  }
  const handle$3 = zwitch("type", {
    invalid: invalid$2,
    unknown: unknown$2,
    handlers: { comment: comment$2, doctype: doctype$1, element: element$2, raw: raw$1, root: root$3, text: text$4 }
  });
  function invalid$2(node2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  function unknown$2(node2) {
    throw new Error("Cannot compile unknown node `" + node2.type + "`");
  }
  function toHtml(tree, options2) {
    const options_ = options2 || {};
    const quote = options_.quote || '"';
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
      throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
    }
    const state = {
      one: one$5,
      all: all$7,
      settings: {
        omitOptionalTags: options_.omitOptionalTags || false,
        allowParseErrors: options_.allowParseErrors || false,
        allowDangerousCharacters: options_.allowDangerousCharacters || false,
        quoteSmart: options_.quoteSmart || false,
        preferUnquoted: options_.preferUnquoted || false,
        tightAttributes: options_.tightAttributes || false,
        upperDoctype: options_.upperDoctype || false,
        tightDoctype: options_.tightDoctype || false,
        bogusComments: options_.bogusComments || false,
        tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
        tightSelfClosing: options_.tightSelfClosing || false,
        collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
        allowDangerousHtml: options_.allowDangerousHtml || false,
        voids: options_.voids || htmlVoidElements,
        characterReferences: options_.characterReferences || options_.entities || {},
        closeSelfClosing: options_.closeSelfClosing || false,
        closeEmptyElements: options_.closeEmptyElements || false
      },
      schema: options_.space === "svg" ? svg : html$4,
      quote,
      alternative
    };
    return state.one(
      Array.isArray(tree) ? { type: "root", children: tree } : tree,
      void 0,
      void 0
    );
  }
  function one$5(node2, index2, parent) {
    return handle$3(node2, index2, parent, this);
  }
  function all$7(parent) {
    const results = [];
    const children = parent && parent.children || [];
    let index2 = -1;
    while (++index2 < children.length) {
      results[index2] = this.one(children[index2], index2, parent);
    }
    return results.join("");
  }
  function rehypeStringify(config2) {
    const processorSettings = (
      /** @type {Options} */
      this.data("settings")
    );
    const settings = Object.assign({}, processorSettings, config2);
    Object.assign(this, { Compiler: compiler2 });
    function compiler2(tree) {
      return toHtml(tree, settings);
    }
  }
  var standalone = { exports: {} };
  (function(module, exports) {
    (function(e) {
      module.exports = e();
    })(function() {
      var xe = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
      var pt2 = xe((r0, pu) => {
        var ir = function(e) {
          return e && e.Math == Math && e;
        };
        pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof commonjsGlobal == "object" && commonjsGlobal) || /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")();
      });
      var Dt2 = xe((n0, fu) => {
        fu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var yt2 = xe((u0, Du) => {
        var Mo = Dt2();
        Du.exports = !Mo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var ar2 = xe((s0, mu) => {
        var Ro = Dt2();
        mu.exports = !Ro(function() {
          var e = (function() {
          }).bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var At2 = xe((i0, du) => {
        var $o = ar2(), or2 = Function.prototype.call;
        du.exports = $o ? or2.bind(or2) : function() {
          return or2.apply(or2, arguments);
        };
      });
      var vu = xe((hu) => {
        var gu2 = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu2.call({ 1: 2 }, 1);
        hu.f = Vo ? function(r) {
          var t = yu(this, r);
          return !!t && t.enumerable;
        } : gu2;
      });
      var lr2 = xe((o0, Cu) => {
        Cu.exports = function(e, r) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
        };
      });
      var mt2 = xe((l0, Au) => {
        var Eu = ar2(), Fu = Function.prototype, Wr2 = Fu.call, Wo = Eu && Fu.bind.bind(Wr2, Wr2);
        Au.exports = Eu ? Wo : function(e) {
          return function() {
            return Wr2.apply(e, arguments);
          };
        };
      });
      var Vt2 = xe((c0, xu) => {
        var Su2 = mt2(), Ho = Su2({}.toString), Go = Su2("".slice);
        xu.exports = function(e) {
          return Go(Ho(e), 8, -1);
        };
      });
      var Tu = xe((p0, bu) => {
        var Uo = mt2(), Jo = Dt2(), zo = Vt2(), Hr = Object, Xo = Uo("".split);
        bu.exports = Jo(function() {
          return !Hr("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return zo(e) == "String" ? Xo(e, "") : Hr(e);
        } : Hr;
      });
      var cr = xe((f0, Bu) => {
        Bu.exports = function(e) {
          return e == null;
        };
      });
      var Gr2 = xe((D0, Nu) => {
        var Ko = cr(), Yo = TypeError;
        Nu.exports = function(e) {
          if (Ko(e))
            throw Yo("Can't call method on " + e);
          return e;
        };
      });
      var pr2 = xe((m0, wu) => {
        var Qo = Tu(), Zo = Gr2();
        wu.exports = function(e) {
          return Qo(Zo(e));
        };
      });
      var Jr2 = xe((d0, _u) => {
        var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
        _u.exports = { all: Ur, IS_HTMLDDA: el };
      });
      var ot2 = xe((g0, Iu) => {
        var Pu = Jr2(), tl = Pu.all;
        Iu.exports = Pu.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === tl;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var St2 = xe((y0, Ou) => {
        var ku = ot2(), Lu = Jr2(), rl = Lu.all;
        Ou.exports = Lu.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : ku(e) || e === rl;
        } : function(e) {
          return typeof e == "object" ? e !== null : ku(e);
        };
      });
      var Wt = xe((h0, ju2) => {
        var zr = pt2(), nl = ot2(), ul = function(e) {
          return nl(e) ? e : void 0;
        };
        ju2.exports = function(e, r) {
          return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r];
        };
      });
      var Xr2 = xe((v0, qu) => {
        var sl = mt2();
        qu.exports = sl({}.isPrototypeOf);
      });
      var Ru = xe((C0, Mu) => {
        var il = Wt();
        Mu.exports = il("navigator", "userAgent") || "";
      });
      var Ju = xe((E0, Uu) => {
        var Gu = pt2(), Kr2 = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu2 = Wu && Wu.v8, dt2, fr2;
        Hu2 && (dt2 = Hu2.split("."), fr2 = dt2[0] > 0 && dt2[0] < 4 ? 1 : +(dt2[0] + dt2[1]));
        !fr2 && Kr2 && (dt2 = Kr2.match(/Edge\/(\d+)/), (!dt2 || dt2[1] >= 74) && (dt2 = Kr2.match(/Chrome\/(\d+)/), dt2 && (fr2 = +dt2[1])));
        Uu.exports = fr2;
      });
      var Yr2 = xe((F0, Xu) => {
        var zu = Ju(), al = Dt2();
        Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
        });
      });
      var Qr = xe((A0, Ku) => {
        var ol = Yr2();
        Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Zr = xe((S0, Yu) => {
        var ll = Wt(), cl = ot2(), pl = Xr2(), fl = Qr(), Dl = Object;
        Yu.exports = fl ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r = ll("Symbol");
          return cl(r) && pl(r.prototype, Dl(e));
        };
      });
      var Dr2 = xe((x0, Qu) => {
        var ml = String;
        Qu.exports = function(e) {
          try {
            return ml(e);
          } catch {
            return "Object";
          }
        };
      });
      var Ht = xe((b0, Zu2) => {
        var dl2 = ot2(), gl = Dr2(), yl = TypeError;
        Zu2.exports = function(e) {
          if (dl2(e))
            return e;
          throw yl(gl(e) + " is not a function");
        };
      });
      var mr2 = xe((T0, es) => {
        var hl = Ht(), vl = cr();
        es.exports = function(e, r) {
          var t = e[r];
          return vl(t) ? void 0 : hl(t);
        };
      });
      var rs = xe((B0, ts2) => {
        var en = At2(), tn2 = ot2(), rn2 = St2(), Cl = TypeError;
        ts2.exports = function(e, r) {
          var t, s2;
          if (r === "string" && tn2(t = e.toString) && !rn2(s2 = en(t, e)) || tn2(t = e.valueOf) && !rn2(s2 = en(t, e)) || r !== "string" && tn2(t = e.toString) && !rn2(s2 = en(t, e)))
            return s2;
          throw Cl("Can't convert object to primitive value");
        };
      });
      var us = xe((N0, ns) => {
        ns.exports = false;
      });
      var dr2 = xe((w0, is) => {
        var ss = pt2(), El = Object.defineProperty;
        is.exports = function(e, r) {
          try {
            El(ss, e, { value: r, configurable: true, writable: true });
          } catch {
            ss[e] = r;
          }
          return r;
        };
      });
      var gr2 = xe((_0, os) => {
        var Fl = pt2(), Al = dr2(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
        os.exports = Sl;
      });
      var nn = xe((P0, cs2) => {
        var xl = us(), ls = gr2();
        (cs2.exports = function(e, r) {
          return ls[e] || (ls[e] = r !== void 0 ? r : {});
        })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var yr = xe((I0, ps) => {
        var bl = Gr2(), Tl = Object;
        ps.exports = function(e) {
          return Tl(bl(e));
        };
      });
      var Ct2 = xe((k0, fs) => {
        var Bl = mt2(), Nl = yr(), wl = Bl({}.hasOwnProperty);
        fs.exports = Object.hasOwn || function(r, t) {
          return wl(Nl(r), t);
        };
      });
      var un2 = xe((L0, Ds) => {
        var _l = mt2(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
        Ds.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
        };
      });
      var bt2 = xe((O0, hs) => {
        var Ll = pt2(), Ol = nn(), ms = Ct2(), jl = un2(), ds = Yr2(), ys = Qr(), It2 = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
        hs.exports = function(e) {
          if (!ms(It2, e) || !(ds || typeof It2[e] == "string")) {
            var r = "Symbol." + e;
            ds && ms(xt, e) ? It2[e] = xt[e] : ys && gs ? It2[e] = gs(r) : It2[e] = ql(r);
          }
          return It2[e];
        };
      });
      var Fs = xe((j0, Es) => {
        var Ml = At2(), vs2 = St2(), Cs = Zr(), Rl = mr2(), $l = rs(), Vl = bt2(), Wl = TypeError, Hl = Vl("toPrimitive");
        Es.exports = function(e, r) {
          if (!vs2(e) || Cs(e))
            return e;
          var t = Rl(e, Hl), s2;
          if (t) {
            if (r === void 0 && (r = "default"), s2 = Ml(t, e, r), !vs2(s2) || Cs(s2))
              return s2;
            throw Wl("Can't convert object to primitive value");
          }
          return r === void 0 && (r = "number"), $l(e, r);
        };
      });
      var hr2 = xe((q0, As2) => {
        var Gl = Fs(), Ul = Zr();
        As2.exports = function(e) {
          var r = Gl(e, "string");
          return Ul(r) ? r : r + "";
        };
      });
      var bs = xe((M0, xs) => {
        var Jl = pt2(), Ss = St2(), sn2 = Jl.document, zl = Ss(sn2) && Ss(sn2.createElement);
        xs.exports = function(e) {
          return zl ? sn2.createElement(e) : {};
        };
      });
      var an = xe((R0, Ts) => {
        var Xl = yt2(), Kl = Dt2(), Yl = bs();
        Ts.exports = !Xl && !Kl(function() {
          return Object.defineProperty(Yl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var on = xe((Ns) => {
        var Ql = yt2(), Zl = At2(), ec = vu(), tc = lr2(), rc = pr2(), nc = hr2(), uc = Ct2(), sc = an(), Bs2 = Object.getOwnPropertyDescriptor;
        Ns.f = Ql ? Bs2 : function(r, t) {
          if (r = rc(r), t = nc(t), sc)
            try {
              return Bs2(r, t);
            } catch {
            }
          if (uc(r, t))
            return tc(!Zl(ec.f, r, t), r[t]);
        };
      });
      var _s = xe((V0, ws) => {
        var ic = yt2(), ac = Dt2();
        ws.exports = ic && ac(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Tt2 = xe((W0, Ps) => {
        var oc = St2(), lc = String, cc = TypeError;
        Ps.exports = function(e) {
          if (oc(e))
            return e;
          throw cc(lc(e) + " is not an object");
        };
      });
      var kt2 = xe((ks) => {
        var pc = yt2(), fc = an(), Dc = _s(), vr = Tt2(), Is = hr2(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn2 = "configurable", fn = "writable";
        ks.f = pc ? Dc ? function(r, t, s2) {
          if (vr(r), t = Is(t), vr(s2), typeof r == "function" && t === "prototype" && "value" in s2 && fn in s2 && !s2[fn]) {
            var a2 = dc(r, t);
            a2 && a2[fn] && (r[t] = s2.value, s2 = { configurable: pn2 in s2 ? s2[pn2] : a2[pn2], enumerable: cn in s2 ? s2[cn] : a2[cn], writable: false });
          }
          return ln(r, t, s2);
        } : ln : function(r, t, s2) {
          if (vr(r), t = Is(t), vr(s2), fc)
            try {
              return ln(r, t, s2);
            } catch {
            }
          if ("get" in s2 || "set" in s2)
            throw mc("Accessors not supported");
          return "value" in s2 && (r[t] = s2.value), r;
        };
      });
      var Dn = xe((G0, Ls2) => {
        var gc = yt2(), yc = kt2(), hc = lr2();
        Ls2.exports = gc ? function(e, r, t) {
          return yc.f(e, r, hc(1, t));
        } : function(e, r, t) {
          return e[r] = t, e;
        };
      });
      var qs = xe((U0, js2) => {
        var mn = yt2(), vc = Ct2(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn2 = vc(Os, "name"), Ec = dn2 && (function() {
        }).name === "something", Fc = dn2 && (!mn || mn && Cc(Os, "name").configurable);
        js2.exports = { EXISTS: dn2, PROPER: Ec, CONFIGURABLE: Fc };
      });
      var yn = xe((J0, Ms2) => {
        var Ac = mt2(), Sc = ot2(), gn2 = gr2(), xc = Ac(Function.toString);
        Sc(gn2.inspectSource) || (gn2.inspectSource = function(e) {
          return xc(e);
        });
        Ms2.exports = gn2.inspectSource;
      });
      var Vs2 = xe((z0, $s) => {
        var bc2 = pt2(), Tc = ot2(), Rs = bc2.WeakMap;
        $s.exports = Tc(Rs) && /native code/.test(String(Rs));
      });
      var Gs = xe((X0, Hs) => {
        var Bc = nn(), Nc = un2(), Ws = Bc("keys");
        Hs.exports = function(e) {
          return Ws[e] || (Ws[e] = Nc(e));
        };
      });
      var hn = xe((K0, Us) => {
        Us.exports = {};
      });
      var Ks = xe((Y0, Xs) => {
        var wc = Vs2(), zs = pt2(), _c = St2(), Pc = Dn(), vn = Ct2(), Cn = gr2(), Ic = Gs(), kc = hn(), Js2 = "Object already initialized", En2 = zs.TypeError, Lc = zs.WeakMap, Cr, Gt2, Er, Oc = function(e) {
          return Er(e) ? Gt2(e) : Cr(e, {});
        }, jc = function(e) {
          return function(r) {
            var t;
            if (!_c(r) || (t = Gt2(r)).type !== e)
              throw En2("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e, r) {
          if (gt.has(e))
            throw En2(Js2);
          return r.facade = e, gt.set(e, r), r;
        }, Gt2 = function(e) {
          return gt.get(e) || {};
        }, Er = function(e) {
          return gt.has(e);
        }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e, r) {
          if (vn(e, Bt))
            throw En2(Js2);
          return r.facade = e, Pc(e, Bt, r), r;
        }, Gt2 = function(e) {
          return vn(e, Bt) ? e[Bt] : {};
        }, Er = function(e) {
          return vn(e, Bt);
        });
        var gt, Bt;
        Xs.exports = { set: Cr, get: Gt2, has: Er, enforce: Oc, getterFor: jc };
      });
      var An = xe((Q0, Qs) => {
        var qc = Dt2(), Mc = ot2(), Fr2 = Ct2(), Fn = yt2(), Rc = qs().CONFIGURABLE, $c = yn(), Ys2 = Ks(), Vc = Ys2.enforce, Wc = Ys2.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
          return Ar(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r, t) {
          String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Fr2(e, "name") || Rc && e.name !== r) && (Fn ? Ar(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t && Fr2(t, "arity") && e.length !== t.arity && Ar(e, "length", { value: t.arity });
          try {
            t && Fr2(t, "constructor") && t.constructor ? Fn && Ar(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var s2 = Vc(e);
          return Fr2(s2, "source") || (s2.source = Gc.join(typeof r == "string" ? r : "")), e;
        };
        Function.prototype.toString = Uc(function() {
          return Mc(this) && Wc(this).source || $c(this);
        }, "toString");
      });
      var ei = xe((Z0, Zs2) => {
        var Jc = ot2(), zc = kt2(), Xc = An(), Kc = dr2();
        Zs2.exports = function(e, r, t, s2) {
          s2 || (s2 = {});
          var a2 = s2.enumerable, n = s2.name !== void 0 ? s2.name : r;
          if (Jc(t) && Xc(t, n, s2), s2.global)
            a2 ? e[r] = t : Kc(r, t);
          else {
            try {
              s2.unsafe ? e[r] && (a2 = true) : delete e[r];
            } catch {
            }
            a2 ? e[r] = t : zc.f(e, r, { value: t, enumerable: false, configurable: !s2.nonConfigurable, writable: !s2.nonWritable });
          }
          return e;
        };
      });
      var ri2 = xe((ey, ti) => {
        var Yc = Math.ceil, Qc = Math.floor;
        ti.exports = Math.trunc || function(r) {
          var t = +r;
          return (t > 0 ? Qc : Yc)(t);
        };
      });
      var Sr = xe((ty, ni) => {
        var Zc = ri2();
        ni.exports = function(e) {
          var r = +e;
          return r !== r || r === 0 ? 0 : Zc(r);
        };
      });
      var si = xe((ry, ui2) => {
        var ep = Sr(), tp = Math.max, rp = Math.min;
        ui2.exports = function(e, r) {
          var t = ep(e);
          return t < 0 ? tp(t + r, 0) : rp(t, r);
        };
      });
      var ai = xe((ny, ii) => {
        var np = Sr(), up = Math.min;
        ii.exports = function(e) {
          return e > 0 ? up(np(e), 9007199254740991) : 0;
        };
      });
      var Lt2 = xe((uy, oi2) => {
        var sp = ai();
        oi2.exports = function(e) {
          return sp(e.length);
        };
      });
      var pi2 = xe((sy, ci) => {
        var ip2 = pr2(), ap = si(), op2 = Lt2(), li2 = function(e) {
          return function(r, t, s2) {
            var a2 = ip2(r), n = op2(a2), u = ap(s2, n), i;
            if (e && t != t) {
              for (; n > u; )
                if (i = a2[u++], i != i)
                  return true;
            } else
              for (; n > u; u++)
                if ((e || u in a2) && a2[u] === t)
                  return e || u || 0;
            return !e && -1;
          };
        };
        ci.exports = { includes: li2(true), indexOf: li2(false) };
      });
      var mi = xe((iy, Di2) => {
        var lp = mt2(), Sn2 = Ct2(), cp = pr2(), pp = pi2().indexOf, fp = hn(), fi = lp([].push);
        Di2.exports = function(e, r) {
          var t = cp(e), s2 = 0, a2 = [], n;
          for (n in t)
            !Sn2(fp, n) && Sn2(t, n) && fi(a2, n);
          for (; r.length > s2; )
            Sn2(t, n = r[s2++]) && (~pp(a2, n) || fi(a2, n));
          return a2;
        };
      });
      var gi = xe((ay, di2) => {
        di2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var hi = xe((yi2) => {
        var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
        yi2.f = Object.getOwnPropertyNames || function(r) {
          return Dp(r, dp);
        };
      });
      var Ci = xe((vi2) => {
        vi2.f = Object.getOwnPropertySymbols;
      });
      var Fi2 = xe((cy, Ei) => {
        var gp = Wt(), yp = mt2(), hp = hi(), vp = Ci(), Cp = Tt2(), Ep = yp([].concat);
        Ei.exports = gp("Reflect", "ownKeys") || function(r) {
          var t = hp.f(Cp(r)), s2 = vp.f;
          return s2 ? Ep(t, s2(r)) : t;
        };
      });
      var xi = xe((py, Si2) => {
        var Ai = Ct2(), Fp = Fi2(), Ap = on(), Sp = kt2();
        Si2.exports = function(e, r, t) {
          for (var s2 = Fp(r), a2 = Sp.f, n = Ap.f, u = 0; u < s2.length; u++) {
            var i = s2[u];
            !Ai(e, i) && !(t && Ai(t, i)) && a2(e, i, n(r, i));
          }
        };
      });
      var Ti = xe((fy, bi) => {
        var xp = Dt2(), bp = ot2(), Tp = /#|\.prototype\./, Ut = function(e, r) {
          var t = Np[Bp(e)];
          return t == _p ? true : t == wp ? false : bp(r) ? xp(r) : !!r;
        }, Bp = Ut.normalize = function(e) {
          return String(e).replace(Tp, ".").toLowerCase();
        }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
        bi.exports = Ut;
      });
      var Jt2 = xe((Dy, Bi2) => {
        var xn2 = pt2(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr2(), Op = xi(), jp = Ti();
        Bi2.exports = function(e, r) {
          var t = e.target, s2 = e.global, a2 = e.stat, n, u, i, l, p2, y;
          if (s2 ? u = xn2 : a2 ? u = xn2[t] || Lp(t, {}) : u = (xn2[t] || {}).prototype, u)
            for (i in r) {
              if (p2 = r[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s2 ? i : t + (a2 ? "." : "#") + i, e.forced), !n && l !== void 0) {
                if (typeof p2 == typeof l)
                  continue;
                Op(p2, l);
              }
              (e.sham || l && l.sham) && Ip(p2, "sham", true), kp(u, i, p2, e);
            }
        };
      });
      var bn2 = xe((my, Ni) => {
        var qp = Vt2();
        Ni.exports = Array.isArray || function(r) {
          return qp(r) == "Array";
        };
      });
      var _i = xe((dy, wi2) => {
        var Mp = TypeError, Rp = 9007199254740991;
        wi2.exports = function(e) {
          if (e > Rp)
            throw Mp("Maximum allowed index exceeded");
          return e;
        };
      });
      var Ii = xe((gy, Pi) => {
        var $p = Vt2(), Vp = mt2();
        Pi.exports = function(e) {
          if ($p(e) === "Function")
            return Vp(e);
        };
      });
      var Tn2 = xe((yy, Li) => {
        var ki = Ii(), Wp = Ht(), Hp = ar2(), Gp = ki(ki.bind);
        Li.exports = function(e, r) {
          return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
            return e.apply(r, arguments);
          };
        };
      });
      var Bn = xe((hy, ji2) => {
        var Up = bn2(), Jp = Lt2(), zp = _i(), Xp = Tn2(), Oi = function(e, r, t, s2, a2, n, u, i) {
          for (var l = a2, p2 = 0, y = u ? Xp(u, i) : false, h2, g; p2 < s2; )
            p2 in t && (h2 = y ? y(t[p2], p2, r) : t[p2], n > 0 && Up(h2) ? (g = Jp(h2), l = Oi(e, r, h2, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h2), l++), p2++;
          return l;
        };
        ji2.exports = Oi;
      });
      var Ri = xe((vy, Mi) => {
        var Kp = bt2(), Yp = Kp("toStringTag"), qi = {};
        qi[Yp] = "z";
        Mi.exports = String(qi) === "[object z]";
      });
      var Nn2 = xe((Cy, $i) => {
        var Qp = Ri(), Zp = ot2(), xr2 = Vt2(), ef = bt2(), tf = ef("toStringTag"), rf = Object, nf = xr2(/* @__PURE__ */ function() {
          return arguments;
        }()) == "Arguments", uf = function(e, r) {
          try {
            return e[r];
          } catch {
          }
        };
        $i.exports = Qp ? xr2 : function(e) {
          var r, t, s2;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = uf(r = rf(e), tf)) == "string" ? t : nf ? xr2(r) : (s2 = xr2(r)) == "Object" && Zp(r.callee) ? "Arguments" : s2;
        };
      });
      var Ji = xe((Ey, Ui) => {
        var sf = mt2(), af = Dt2(), Vi = ot2(), of = Nn2(), lf = Wt(), cf2 = yn(), Wi = function() {
        }, pf2 = [], Hi2 = lf("Reflect", "construct"), wn2 = /^\s*(?:class|function)\b/, ff2 = sf(wn2.exec), Df2 = !wn2.exec(Wi), zt2 = function(r) {
          if (!Vi(r))
            return false;
          try {
            return Hi2(Wi, pf2, r), true;
          } catch {
            return false;
          }
        }, Gi = function(r) {
          if (!Vi(r))
            return false;
          switch (of(r)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Df2 || !!ff2(wn2, cf2(r));
          } catch {
            return true;
          }
        };
        Gi.sham = true;
        Ui.exports = !Hi2 || af(function() {
          var e;
          return zt2(zt2.call) || !zt2(Object) || !zt2(function() {
            e = true;
          }) || e;
        }) ? Gi : zt2;
      });
      var Yi = xe((Fy, Ki) => {
        var zi2 = bn2(), mf2 = Ji(), df2 = St2(), gf = bt2(), yf = gf("species"), Xi = Array;
        Ki.exports = function(e) {
          var r;
          return zi2(e) && (r = e.constructor, mf2(r) && (r === Xi || zi2(r.prototype)) ? r = void 0 : df2(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
        };
      });
      var _n2 = xe((Ay, Qi2) => {
        var hf = Yi();
        Qi2.exports = function(e, r) {
          return new (hf(e))(r === 0 ? 0 : r);
        };
      });
      var Zi = xe(() => {
        var vf = Jt2(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt2(), Sf = _n2();
        vf({ target: "Array", proto: true }, { flatMap: function(r) {
          var t = Ff(this), s2 = Af(t), a2;
          return Ef(r), a2 = Sf(t, 0), a2.length = Cf(a2, t, t, s2, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a2;
        } });
      });
      var Pn = xe((by, ea) => {
        ea.exports = {};
      });
      var ra2 = xe((Ty2, ta) => {
        var xf = bt2(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
        ta.exports = function(e) {
          return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
        };
      });
      var In2 = xe((By, ua) => {
        var Nf = Nn2(), na = mr2(), wf = cr(), _f = Pn(), Pf = bt2(), If = Pf("iterator");
        ua.exports = function(e) {
          if (!wf(e))
            return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
        };
      });
      var ia = xe((Ny, sa2) => {
        var kf = At2(), Lf = Ht(), Of = Tt2(), jf = Dr2(), qf = In2(), Mf = TypeError;
        sa2.exports = function(e, r) {
          var t = arguments.length < 2 ? qf(e) : r;
          if (Lf(t))
            return Of(kf(t, e));
          throw Mf(jf(e) + " is not iterable");
        };
      });
      var la = xe((wy, oa) => {
        var Rf = At2(), aa = Tt2(), $f = mr2();
        oa.exports = function(e, r, t) {
          var s2, a2;
          aa(e);
          try {
            if (s2 = $f(e, "return"), !s2) {
              if (r === "throw")
                throw t;
              return t;
            }
            s2 = Rf(s2, e);
          } catch (n) {
            a2 = true, s2 = n;
          }
          if (r === "throw")
            throw t;
          if (a2)
            throw s2;
          return aa(s2), t;
        };
      });
      var ma = xe((_y, Da) => {
        var Vf = Tn2(), Wf = At2(), Hf = Tt2(), Gf2 = Dr2(), Uf2 = ra2(), Jf2 = Lt2(), ca2 = Xr2(), zf = ia(), Xf = In2(), pa = la(), Kf2 = TypeError, br2 = function(e, r) {
          this.stopped = e, this.result = r;
        }, fa2 = br2.prototype;
        Da.exports = function(e, r, t) {
          var s2 = t && t.that, a2 = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r, s2), p2, y, h2, g, c2, f, F, _ = function(E) {
            return p2 && pa(p2, "normal", E), new br2(true, E);
          }, w = function(E) {
            return a2 ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
          };
          if (n)
            p2 = e.iterator;
          else if (u)
            p2 = e;
          else {
            if (y = Xf(e), !y)
              throw Kf2(Gf2(e) + " is not iterable");
            if (Uf2(y)) {
              for (h2 = 0, g = Jf2(e); g > h2; h2++)
                if (c2 = w(e[h2]), c2 && ca2(fa2, c2))
                  return c2;
              return new br2(false);
            }
            p2 = zf(e, y);
          }
          for (f = n ? e.next : p2.next; !(F = Wf(f, p2)).done; ) {
            try {
              c2 = w(F.value);
            } catch (E) {
              pa(p2, "throw", E);
            }
            if (typeof c2 == "object" && c2 && ca2(fa2, c2))
              return c2;
          }
          return new br2(false);
        };
      });
      var ga = xe((Py, da2) => {
        var Yf2 = hr2(), Qf2 = kt2(), Zf2 = lr2();
        da2.exports = function(e, r, t) {
          var s2 = Yf2(r);
          s2 in e ? Qf2.f(e, s2, Zf2(0, t)) : e[s2] = t;
        };
      });
      var ya2 = xe(() => {
        var eD2 = Jt2(), tD2 = ma(), rD = ga();
        eD2({ target: "Object", stat: true }, { fromEntries: function(r) {
          var t = {};
          return tD2(r, function(s2, a2) {
            rD(t, s2, a2);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var Ca2 = xe((Ly, va2) => {
        var ha2 = An(), nD2 = kt2();
        va2.exports = function(e, r, t) {
          return t.get && ha2(t.get, r, { getter: true }), t.set && ha2(t.set, r, { setter: true }), nD2.f(e, r, t);
        };
      });
      var Fa2 = xe((Oy, Ea2) => {
        var uD2 = Tt2();
        Ea2.exports = function() {
          var e = uD2(this), r = "";
          return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
        };
      });
      var xa2 = xe(() => {
        var sD2 = pt2(), iD2 = yt2(), aD2 = Ca2(), oD2 = Fa2(), lD2 = Dt2(), Aa2 = sD2.RegExp, Sa2 = Aa2.prototype, cD2 = iD2 && lD2(function() {
          var e = true;
          try {
            Aa2(".", "d");
          } catch {
            e = false;
          }
          var r = {}, t = "", s2 = e ? "dgimsy" : "gimsy", a2 = function(l, p2) {
            Object.defineProperty(r, l, { get: function() {
              return t += p2, true;
            } });
          }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          e && (n.hasIndices = "d");
          for (var u in n)
            a2(u, n[u]);
          var i = Object.getOwnPropertyDescriptor(Sa2, "flags").get.call(r);
          return i !== s2 || t !== s2;
        });
        cD2 && aD2(Sa2, "flags", { configurable: true, get: oD2 });
      });
      var ba2 = xe(() => {
        var pD2 = Jt2(), kn2 = pt2();
        pD2({ global: true, forced: kn2.globalThis !== kn2 }, { globalThis: kn2 });
      });
      var Ta2 = xe(() => {
        ba2();
      });
      var Ba2 = xe(() => {
        var fD2 = Jt2(), DD2 = Bn(), mD2 = yr(), dD2 = Lt2(), gD2 = Sr(), yD2 = _n2();
        fD2({ target: "Array", proto: true }, { flat: function() {
          var r = arguments.length ? arguments[0] : void 0, t = mD2(this), s2 = dD2(t), a2 = yD2(t, 0);
          return a2.length = DD2(a2, t, t, s2, 0, r === void 0 ? 1 : gD2(r)), a2;
        } });
      });
      var e0 = xe((Uy, jo) => {
        var hD2 = ["cliName", "cliCategory", "cliDescription"], vD2 = ["_"], CD2 = ["languageId"];
        function Hn2(e, r) {
          if (e == null)
            return {};
          var t = ED2(e, r), s2, a2;
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            for (a2 = 0; a2 < n.length; a2++)
              s2 = n[a2], !(r.indexOf(s2) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s2) && (t[s2] = e[s2]);
          }
          return t;
        }
        function ED2(e, r) {
          if (e == null)
            return {};
          var t = {}, s2 = Object.keys(e), a2, n;
          for (n = 0; n < s2.length; n++)
            a2 = s2[n], !(r.indexOf(a2) >= 0) && (t[a2] = e[a2]);
          return t;
        }
        Zi();
        ya2();
        xa2();
        Ta2();
        Ba2();
        var FD2 = Object.create, _r2 = Object.defineProperty, AD2 = Object.getOwnPropertyDescriptor, Gn2 = Object.getOwnPropertyNames, SD2 = Object.getPrototypeOf, xD2 = Object.prototype.hasOwnProperty, ht2 = (e, r) => function() {
          return e && (r = (0, e[Gn2(e)[0]])(e = 0)), r;
        }, te2 = (e, r) => function() {
          return r || (0, e[Gn2(e)[0]])((r = { exports: {} }).exports, r), r.exports;
        }, Kt2 = (e, r) => {
          for (var t in r)
            _r2(e, t, { get: r[t], enumerable: true });
        }, Pa2 = (e, r, t, s2) => {
          if (r && typeof r == "object" || typeof r == "function")
            for (let a2 of Gn2(r))
              !xD2.call(e, a2) && a2 !== t && _r2(e, a2, { get: () => r[a2], enumerable: !(s2 = AD2(r, a2)) || s2.enumerable });
          return e;
        }, bD2 = (e, r, t) => (t = e != null ? FD2(SD2(e)) : {}, Pa2(r || !e || !e.__esModule ? _r2(t, "default", { value: e, enumerable: true }) : t, e)), ft2 = (e) => Pa2(_r2({}, "__esModule", { value: true }), e), wt2, ne2 = ht2({ "<define:process>"() {
          wt2 = { env: {}, argv: [] };
        } }), Ia2 = te2({ "package.json"(e, r) {
          r.exports = { version: "2.8.8" };
        } }), TD2 = te2({ "node_modules/diff/lib/diff/base.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
          function r() {
          }
          r.prototype = { diff: function(n, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
            typeof i == "function" && (l = i, i = {}), this.options = i;
            var p2 = this;
            function y(N) {
              return l ? (setTimeout(function() {
                l(void 0, N);
              }, 0), true) : N;
            }
            n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
            var h2 = u.length, g = n.length, c2 = 1, f = h2 + g, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n, 0);
            if (F[0].newPos + 1 >= h2 && _ + 1 >= g)
              return y([{ value: this.join(u), count: u.length }]);
            function w() {
              for (var N = -1 * c2; N <= c2; N += 2) {
                var x2 = void 0, I = F[N - 1], P = F[N + 1], $2 = (P ? P.newPos : 0) - N;
                I && (F[N - 1] = void 0);
                var D = I && I.newPos + 1 < h2, T = P && 0 <= $2 && $2 < g;
                if (!D && !T) {
                  F[N] = void 0;
                  continue;
                }
                if (!D || T && I.newPos < P.newPos ? (x2 = s2(P), p2.pushComponent(x2.components, void 0, true)) : (x2 = I, x2.newPos++, p2.pushComponent(x2.components, true, void 0)), $2 = p2.extractCommon(x2, u, n, N), x2.newPos + 1 >= h2 && $2 + 1 >= g)
                  return y(t(p2, x2.components, u, n, p2.useLongestToken));
                F[N] = x2;
              }
              c2++;
            }
            if (l)
              (function N() {
                setTimeout(function() {
                  if (c2 > f)
                    return l();
                  w() || N();
                }, 0);
              })();
            else
              for (; c2 <= f; ) {
                var E = w();
                if (E)
                  return E;
              }
          }, pushComponent: function(n, u, i) {
            var l = n[n.length - 1];
            l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(n, u, i, l) {
            for (var p2 = u.length, y = i.length, h2 = n.newPos, g = h2 - l, c2 = 0; h2 + 1 < p2 && g + 1 < y && this.equals(u[h2 + 1], i[g + 1]); )
              h2++, g++, c2++;
            return c2 && n.components.push({ count: c2 }), n.newPos = h2, g;
          }, equals: function(n, u) {
            return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(n) {
            for (var u = [], i = 0; i < n.length; i++)
              n[i] && u.push(n[i]);
            return u;
          }, castInput: function(n) {
            return n;
          }, tokenize: function(n) {
            return n.split("");
          }, join: function(n) {
            return n.join("");
          } };
          function t(a2, n, u, i, l) {
            for (var p2 = 0, y = n.length, h2 = 0, g = 0; p2 < y; p2++) {
              var c2 = n[p2];
              if (c2.removed) {
                if (c2.value = a2.join(i.slice(g, g + c2.count)), g += c2.count, p2 && n[p2 - 1].added) {
                  var F = n[p2 - 1];
                  n[p2 - 1] = n[p2], n[p2] = F;
                }
              } else {
                if (!c2.added && l) {
                  var f = u.slice(h2, h2 + c2.count);
                  f = f.map(function(w, E) {
                    var N = i[g + E];
                    return N.length > w.length ? N : w;
                  }), c2.value = a2.join(f);
                } else
                  c2.value = a2.join(u.slice(h2, h2 + c2.count));
                h2 += c2.count, c2.added || (g += c2.count);
              }
            }
            var _ = n[y - 1];
            return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a2.equals("", _.value) && (n[y - 2].value += _.value, n.pop()), n;
          }
          function s2(a2) {
            return { newPos: a2.newPos, components: a2.components.slice(0) };
          }
        } }), BD2 = te2({ "node_modules/diff/lib/diff/array.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a2, e.arrayDiff = void 0;
          var r = t(TD2());
          function t(n) {
            return n && n.__esModule ? n : { default: n };
          }
          var s2 = new r.default();
          e.arrayDiff = s2, s2.tokenize = function(n) {
            return n.slice();
          }, s2.join = s2.removeEmpty = function(n) {
            return n;
          };
          function a2(n, u, i) {
            return s2.diff(n, u, i);
          }
        } }), Un2 = te2({ "src/document/doc-builders.js"(e, r) {
          ne2();
          function t(C) {
            return { type: "concat", parts: C };
          }
          function s2(C) {
            return { type: "indent", contents: C };
          }
          function a2(C, o) {
            return { type: "align", contents: o, n: C };
          }
          function n(C) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          function u(C) {
            return a2(Number.NEGATIVE_INFINITY, C);
          }
          function i(C) {
            return a2({ type: "root" }, C);
          }
          function l(C) {
            return a2(-1, C);
          }
          function p2(C, o) {
            return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
          }
          function y(C) {
            return { type: "fill", parts: C };
          }
          function h2(C, o) {
            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
          }
          function g(C, o) {
            return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
          }
          function c2(C) {
            return { type: "line-suffix", contents: C };
          }
          var f = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N = { type: "line" }, x2 = { type: "line", soft: true }, I = t([w, F]), P = t([E, F]), $2 = { type: "cursor", placeholder: Symbol("cursor") };
          function D(C, o) {
            let d = [];
            for (let v = 0; v < o.length; v++)
              v !== 0 && d.push(C), d.push(o[v]);
            return t(d);
          }
          function T(C, o, d) {
            let v = C;
            if (o > 0) {
              for (let S = 0; S < Math.floor(o / d); ++S)
                v = s2(v);
              v = a2(o % d, v), v = a2(Number.NEGATIVE_INFINITY, v);
            }
            return v;
          }
          function m2(C, o) {
            return { type: "label", label: C, contents: o };
          }
          r.exports = { concat: t, join: D, line: N, softline: x2, hardline: I, literalline: P, group: n, conditionalGroup: p2, fill: y, lineSuffix: c2, lineSuffixBoundary: f, cursor: $2, breakParent: F, ifBreak: h2, trim: _, indent: s2, indentIfBreak: g, align: a2, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m2 };
        } }), Jn2 = te2({ "src/common/end-of-line.js"(e, r) {
          ne2();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s2(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a2(u, i) {
            let l;
            switch (i) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
            }
            let p2 = u.match(l);
            return p2 ? p2.length : 0;
          }
          function n(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s2, countEndOfLineChars: a2, normalizeEndOfLine: n };
        } }), lt2 = te2({ "src/utils/get-last.js"(e, r) {
          ne2();
          var t = (s2) => s2[s2.length - 1];
          r.exports = t;
        } });
        function ND2() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r, e ? void 0 : "g");
        }
        var wD2 = ht2({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          ne2();
        } });
        function _D2(e) {
          if (typeof e != "string")
            throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(ND2(), "");
        }
        var PD2 = ht2({ "node_modules/strip-ansi/index.js"() {
          ne2(), wD2();
        } });
        function ID2(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var kD2 = ht2({ "node_modules/is-fullwidth-code-point/index.js"() {
          ne2();
        } }), LD2 = te2({ "node_modules/emoji-regex/index.js"(e, r) {
          ne2(), r.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ka2 = {};
        Kt2(ka2, { default: () => OD2 });
        function OD2(e) {
          if (typeof e != "string" || e.length === 0 || (e = _D2(e), e.length === 0))
            return 0;
          e = e.replace((0, La2.default)(), "  ");
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            let s2 = e.codePointAt(t);
            s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t++, r += ID2(s2) ? 2 : 1);
          }
          return r;
        }
        var La2, jD2 = ht2({ "node_modules/string-width/index.js"() {
          ne2(), PD2(), kD2(), La2 = bD2(LD2());
        } }), Oa2 = te2({ "src/utils/get-string-width.js"(e, r) {
          ne2();
          var t = (jD2(), ft2(ka2)).default, s2 = /[^\x20-\x7F]/;
          function a2(n) {
            return n ? s2.test(n) ? t(n) : n.length : 0;
          }
          r.exports = a2;
        } }), Yt2 = te2({ "src/document/doc-utils.js"(e, r) {
          ne2();
          var t = lt2(), { literalline: s2, join: a2 } = Un2(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
            if (Array.isArray(o))
              return o;
            if (o.type !== "concat" && o.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, i = {};
          function l(o, d, v, S) {
            let b = [o];
            for (; b.length > 0; ) {
              let B = b.pop();
              if (B === i) {
                v(b.pop());
                continue;
              }
              if (v && b.push(B, i), !d || d(B) !== false)
                if (n(B) || B.type === "fill") {
                  let k = u(B);
                  for (let M = k.length, R = M - 1; R >= 0; --R)
                    b.push(k[R]);
                } else if (B.type === "if-break")
                  B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                else if (B.type === "group" && B.expandedStates)
                  if (S)
                    for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                      b.push(B.expandedStates[M]);
                  else
                    b.push(B.contents);
                else
                  B.contents && b.push(B.contents);
            }
          }
          function p2(o, d) {
            let v = /* @__PURE__ */ new Map();
            return S(o);
            function S(B) {
              if (v.has(B))
                return v.get(B);
              let k = b(B);
              return v.set(B, k), k;
            }
            function b(B) {
              if (Array.isArray(B))
                return d(B.map(S));
              if (B.type === "concat" || B.type === "fill") {
                let k = B.parts.map(S);
                return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
              }
              if (B.type === "if-break") {
                let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
              }
              if (B.type === "group" && B.expandedStates) {
                let k = B.expandedStates.map(S), M = k[0];
                return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
              }
              if (B.contents) {
                let k = S(B.contents);
                return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
              }
              return d(B);
            }
          }
          function y(o, d, v) {
            let S = v, b = false;
            function B(k) {
              let M = d(k);
              if (M !== void 0 && (b = true, S = M), b)
                return false;
            }
            return l(o, B), S;
          }
          function h2(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
              return true;
          }
          function g(o) {
            return y(o, h2, false);
          }
          function c2(o) {
            if (o.length > 0) {
              let d = t(o);
              !d.expandedStates && !d.break && (d.break = "propagated");
            }
            return null;
          }
          function f(o) {
            let d = /* @__PURE__ */ new Set(), v = [];
            function S(B) {
              if (B.type === "break-parent" && c2(v), B.type === "group") {
                if (v.push(B), d.has(B))
                  return false;
                d.add(B);
              }
            }
            function b(B) {
              B.type === "group" && v.pop().break && c2(v);
            }
            l(o, S, b, true);
          }
          function F(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          function _(o) {
            return p2(o, F);
          }
          var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
          function E(o) {
            if (!o)
              return o;
            if (n(o) || o.type === "fill") {
              let d = u(o);
              for (; d.length > 1 && w(...d.slice(-2)); )
                d.length -= 2;
              if (d.length > 0) {
                let v = E(t(d));
                d[d.length - 1] = v;
              }
              return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d = E(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d });
              }
              case "if-break": {
                let d = E(o.breakContents), v = E(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
              }
            }
            return o;
          }
          function N(o) {
            return E(I(o));
          }
          function x2(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((v) => v === ""))
                  return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates)
                  return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                  return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents)
                  return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents)
                  return "";
                break;
            }
            if (!n(o))
              return o;
            let d = [];
            for (let v of u(o)) {
              if (!v)
                continue;
              let [S, ...b] = n(v) ? u(v) : [v];
              typeof S == "string" && typeof t(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
            }
            return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
          }
          function I(o) {
            return p2(o, (d) => x2(d));
          }
          function P(o) {
            let d = [], v = o.filter(Boolean);
            for (; v.length > 0; ) {
              let S = v.shift();
              if (S) {
                if (n(S)) {
                  v.unshift(...u(S));
                  continue;
                }
                if (d.length > 0 && typeof t(d) == "string" && typeof S == "string") {
                  d[d.length - 1] += S;
                  continue;
                }
                d.push(S);
              }
            }
            return d;
          }
          function $2(o) {
            return p2(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
          }
          function D(o) {
            return p2(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
          }
          function T(o) {
            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2;
            return a2(d, o.split(`
`)).parts;
          }
          function m2(o) {
            if (o.type === "line")
              return true;
          }
          function C(o) {
            return y(o, m2, false);
          }
          r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p2, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $2, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
        } }), qD2 = te2({ "src/document/doc-printer.js"(e, r) {
          ne2();
          var { convertEndOfLineToChars: t } = Jn2(), s2 = lt2(), a2 = Oa2(), { fill: n, cursor: u, indent: i } = Un2(), { isConcat: l, getDocParts: p2 } = Yt2(), y, h2 = 1, g = 2;
          function c2() {
            return { value: "", length: 0, queue: [] };
          }
          function f(x2, I) {
            return _(x2, { type: "indent" }, I);
          }
          function F(x2, I, P) {
            return I === Number.NEGATIVE_INFINITY ? x2.root || c2() : I < 0 ? _(x2, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x2), {}, { root: x2 }) : _(x2, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x2;
          }
          function _(x2, I, P) {
            let $2 = I.type === "dedent" ? x2.queue.slice(0, -1) : [...x2.queue, I], D = "", T = 0, m2 = 0, C = 0;
            for (let k of $2)
              switch (k.type) {
                case "indent":
                  v(), P.useTabs ? o(1) : d(P.tabWidth);
                  break;
                case "stringAlign":
                  v(), D += k.n, T += k.n.length;
                  break;
                case "numberAlign":
                  m2 += 1, C += k.n;
                  break;
                default:
                  throw new Error(`Unexpected type '${k.type}'`);
              }
            return b(), Object.assign(Object.assign({}, x2), {}, { value: D, length: T, queue: $2 });
            function o(k) {
              D += "	".repeat(k), T += P.tabWidth * k;
            }
            function d(k) {
              D += " ".repeat(k), T += k;
            }
            function v() {
              P.useTabs ? S() : b();
            }
            function S() {
              m2 > 0 && o(m2), B();
            }
            function b() {
              C > 0 && d(C), B();
            }
            function B() {
              m2 = 0, C = 0;
            }
          }
          function w(x2) {
            if (x2.length === 0)
              return 0;
            let I = 0;
            for (; x2.length > 0 && typeof s2(x2) == "string" && /^[\t ]*$/.test(s2(x2)); )
              I += x2.pop().length;
            if (x2.length > 0 && typeof s2(x2) == "string") {
              let P = s2(x2).replace(/[\t ]*$/, "");
              I += s2(x2).length - P.length, x2[x2.length - 1] = P;
            }
            return I;
          }
          function E(x2, I, P, $2, D) {
            let T = I.length, m2 = [x2], C = [];
            for (; P >= 0; ) {
              if (m2.length === 0) {
                if (T === 0)
                  return true;
                m2.push(I[--T]);
                continue;
              }
              let { mode: o, doc: d } = m2.pop();
              if (typeof d == "string")
                C.push(d), P -= a2(d);
              else if (l(d) || d.type === "fill") {
                let v = p2(d);
                for (let S = v.length - 1; S >= 0; S--)
                  m2.push({ mode: o, doc: v[S] });
              } else
                switch (d.type) {
                  case "indent":
                  case "align":
                  case "indent-if-break":
                  case "label":
                    m2.push({ mode: o, doc: d.contents });
                    break;
                  case "trim":
                    P += w(C);
                    break;
                  case "group": {
                    if (D && d.break)
                      return false;
                    let v = d.break ? h2 : o, S = d.expandedStates && v === h2 ? s2(d.expandedStates) : d.contents;
                    m2.push({ mode: v, doc: S });
                    break;
                  }
                  case "if-break": {
                    let S = (d.groupId ? y[d.groupId] || g : o) === h2 ? d.breakContents : d.flatContents;
                    S && m2.push({ mode: o, doc: S });
                    break;
                  }
                  case "line":
                    if (o === h2 || d.hard)
                      return true;
                    d.soft || (C.push(" "), P--);
                    break;
                  case "line-suffix":
                    $2 = true;
                    break;
                  case "line-suffix-boundary":
                    if ($2)
                      return false;
                    break;
                }
            }
            return false;
          }
          function N(x2, I) {
            y = {};
            let P = I.printWidth, $2 = t(I.endOfLine), D = 0, T = [{ ind: c2(), mode: h2, doc: x2 }], m2 = [], C = false, o = [];
            for (; T.length > 0; ) {
              let { ind: v, mode: S, doc: b } = T.pop();
              if (typeof b == "string") {
                let B = $2 !== `
` ? b.replace(/\n/g, $2) : b;
                m2.push(B), D += a2(B);
              } else if (l(b)) {
                let B = p2(b);
                for (let k = B.length - 1; k >= 0; k--)
                  T.push({ ind: v, mode: S, doc: B[k] });
              } else
                switch (b.type) {
                  case "cursor":
                    m2.push(u.placeholder);
                    break;
                  case "indent":
                    T.push({ ind: f(v, I), mode: S, doc: b.contents });
                    break;
                  case "align":
                    T.push({ ind: F(v, b.n, I), mode: S, doc: b.contents });
                    break;
                  case "trim":
                    D -= w(m2);
                    break;
                  case "group":
                    switch (S) {
                      case g:
                        if (!C) {
                          T.push({ ind: v, mode: b.break ? h2 : g, doc: b.contents });
                          break;
                        }
                      case h2: {
                        C = false;
                        let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                        if (!b.break && E(B, T, k, M))
                          T.push(B);
                        else if (b.expandedStates) {
                          let R = s2(b.expandedStates);
                          if (b.break) {
                            T.push({ ind: v, mode: h2, doc: R });
                            break;
                          } else
                            for (let q2 = 1; q2 < b.expandedStates.length + 1; q2++)
                              if (q2 >= b.expandedStates.length) {
                                T.push({ ind: v, mode: h2, doc: R });
                                break;
                              } else {
                                let J = b.expandedStates[q2], L = { ind: v, mode: g, doc: J };
                                if (E(L, T, k, M)) {
                                  T.push(L);
                                  break;
                                }
                              }
                        } else
                          T.push({ ind: v, mode: h2, doc: b.contents });
                        break;
                      }
                    }
                    b.id && (y[b.id] = s2(T).mode);
                    break;
                  case "fill": {
                    let B = P - D, { parts: k } = b;
                    if (k.length === 0)
                      break;
                    let [M, R] = k, q2 = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h2, doc: M }, L = E(q2, [], B, o.length > 0, true);
                    if (k.length === 1) {
                      L ? T.push(q2) : T.push(J);
                      break;
                    }
                    let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: h2, doc: R };
                    if (k.length === 2) {
                      L ? T.push(Q, q2) : T.push(V, J);
                      break;
                    }
                    k.splice(0, 2);
                    let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
                    E({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q2) : L ? T.push(j, V, q2) : T.push(j, V, J);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let B = b.groupId ? y[b.groupId] : S;
                    if (B === h2) {
                      let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                      k && T.push({ ind: v, mode: S, doc: k });
                    }
                    if (B === g) {
                      let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                      k && T.push({ ind: v, mode: S, doc: k });
                    }
                    break;
                  }
                  case "line-suffix":
                    o.push({ ind: v, mode: S, doc: b.contents });
                    break;
                  case "line-suffix-boundary":
                    o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                    break;
                  case "line":
                    switch (S) {
                      case g:
                        if (b.hard)
                          C = true;
                        else {
                          b.soft || (m2.push(" "), D += 1);
                          break;
                        }
                      case h2:
                        if (o.length > 0) {
                          T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                          break;
                        }
                        b.literal ? v.root ? (m2.push($2, v.root.value), D = v.root.length) : (m2.push($2), D = 0) : (D -= w(m2), m2.push($2 + v.value), D = v.length);
                        break;
                    }
                    break;
                  case "label":
                    T.push({ ind: v, mode: S, doc: b.contents });
                    break;
                }
              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
            }
            let d = m2.indexOf(u.placeholder);
            if (d !== -1) {
              let v = m2.indexOf(u.placeholder, d + 1), S = m2.slice(0, d).join(""), b = m2.slice(d + 1, v).join(""), B = m2.slice(v + 1).join("");
              return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
            }
            return { formatted: m2.join("") };
          }
          r.exports = { printDocToString: N };
        } }), MD2 = te2({ "src/document/doc-debug.js"(e, r) {
          ne2();
          var { isConcat: t, getDocParts: s2 } = Yt2();
          function a2(u) {
            if (!u)
              return "";
            if (t(u)) {
              let i = [];
              for (let l of s2(u))
                if (t(l))
                  i.push(...a2(l).parts);
                else {
                  let p2 = a2(l);
                  p2 !== "" && i.push(p2);
                }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a2(u.breakContents), flatContents: a2(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a2) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a2) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents) }) : u;
          }
          function n(u) {
            let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return p2(a2(u));
            function p2(h2, g, c2) {
              if (typeof h2 == "string")
                return JSON.stringify(h2);
              if (t(h2)) {
                let f = s2(h2).map(p2).filter(Boolean);
                return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
              }
              if (h2.type === "line") {
                let f = Array.isArray(c2) && c2[g + 1] && c2[g + 1].type === "break-parent";
                return h2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h2.soft ? "softline" : "line";
              }
              if (h2.type === "break-parent")
                return Array.isArray(c2) && c2[g - 1] && c2[g - 1].type === "line" && c2[g - 1].hard ? void 0 : "breakParent";
              if (h2.type === "trim")
                return "trim";
              if (h2.type === "indent")
                return "indent(" + p2(h2.contents) + ")";
              if (h2.type === "align")
                return h2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p2(h2.contents) + ")" : h2.n < 0 ? "dedent(" + p2(h2.contents) + ")" : h2.n.type === "root" ? "markAsRoot(" + p2(h2.contents) + ")" : "align(" + JSON.stringify(h2.n) + ", " + p2(h2.contents) + ")";
              if (h2.type === "if-break")
                return "ifBreak(" + p2(h2.breakContents) + (h2.flatContents ? ", " + p2(h2.flatContents) : "") + (h2.groupId ? (h2.flatContents ? "" : ', ""') + `, { groupId: ${y(h2.groupId)} }` : "") + ")";
              if (h2.type === "indent-if-break") {
                let f = [];
                h2.negate && f.push("negate: true"), h2.groupId && f.push(`groupId: ${y(h2.groupId)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return `indentIfBreak(${p2(h2.contents)}${F})`;
              }
              if (h2.type === "group") {
                let f = [];
                h2.break && h2.break !== "propagated" && f.push("shouldBreak: true"), h2.id && f.push(`id: ${y(h2.id)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return h2.expandedStates ? `conditionalGroup([${h2.expandedStates.map((_) => p2(_)).join(",")}]${F})` : `group(${p2(h2.contents)}${F})`;
              }
              if (h2.type === "fill")
                return `fill([${h2.parts.map((f) => p2(f)).join(", ")}])`;
              if (h2.type === "line-suffix")
                return "lineSuffix(" + p2(h2.contents) + ")";
              if (h2.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h2.type === "label")
                return `label(${JSON.stringify(h2.label)}, ${p2(h2.contents)})`;
              throw new Error("Unknown doc type " + h2.type);
            }
            function y(h2) {
              if (typeof h2 != "symbol")
                return JSON.stringify(String(h2));
              if (h2 in i)
                return i[h2];
              let g = String(h2).slice(7, -1) || "symbol";
              for (let c2 = 0; ; c2++) {
                let f = g + (c2 > 0 ? ` #${c2}` : "");
                if (!l.has(f))
                  return l.add(f), i[h2] = `Symbol.for(${JSON.stringify(f)})`;
              }
            }
          }
          r.exports = { printDocToDebug: n };
        } }), qe2 = te2({ "src/document/index.js"(e, r) {
          ne2(), r.exports = { builders: Un2(), printer: qD2(), utils: Yt2(), debug: MD2() };
        } }), ja2 = {};
        Kt2(ja2, { default: () => RD2 });
        function RD2(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var $D2 = ht2({ "node_modules/escape-string-regexp/index.js"() {
          ne2();
        } }), qa2 = te2({ "node_modules/semver/internal/debug.js"(e, r) {
          ne2();
          var t = typeof wt2 == "object" && wt2.env && wt2.env.NODE_DEBUG && /\bsemver\b/i.test(wt2.env.NODE_DEBUG) ? function() {
            for (var s2 = arguments.length, a2 = new Array(s2), n = 0; n < s2; n++)
              a2[n] = arguments[n];
            return console.error("SEMVER", ...a2);
          } : () => {
          };
          r.exports = t;
        } }), Ma2 = te2({ "node_modules/semver/internal/constants.js"(e, r) {
          ne2();
          var t = "2.0.0", s2 = 256, a2 = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
          r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2, MAX_SAFE_COMPONENT_LENGTH: n };
        } }), VD2 = te2({ "node_modules/semver/internal/re.js"(e, r) {
          ne2();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma2(), s2 = qa2();
          e = r.exports = {};
          var a2 = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p2, y, h2) => {
            let g = i++;
            s2(p2, g, y), u[p2] = g, n[g] = y, a2[g] = new RegExp(y, h2 ? "g" : void 0);
          };
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), WD2 = te2({ "node_modules/semver/internal/parse-options.js"(e, r) {
          ne2();
          var t = ["includePrerelease", "loose", "rtl"], s2 = (a2) => a2 ? typeof a2 != "object" ? { loose: true } : t.filter((n) => a2[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
          r.exports = s2;
        } }), HD2 = te2({ "node_modules/semver/internal/identifiers.js"(e, r) {
          ne2();
          var t = /^[0-9]+$/, s2 = (n, u) => {
            let i = t.test(n), l = t.test(u);
            return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
          }, a2 = (n, u) => s2(u, n);
          r.exports = { compareIdentifiers: s2, rcompareIdentifiers: a2 };
        } }), GD2 = te2({ "node_modules/semver/classes/semver.js"(e, r) {
          ne2();
          var t = qa2(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2 } = Ma2(), { re: n, t: u } = VD2(), i = WD2(), { compareIdentifiers: l } = HD2(), p2 = class {
            constructor(y, h2) {
              if (h2 = i(h2), y instanceof p2) {
                if (y.loose === !!h2.loose && y.includePrerelease === !!h2.includePrerelease)
                  return y;
                y = y.version;
              } else if (typeof y != "string")
                throw new TypeError(`Invalid Version: ${y}`);
              if (y.length > s2)
                throw new TypeError(`version is longer than ${s2} characters`);
              t("SemVer", y, h2), this.options = h2, this.loose = !!h2.loose, this.includePrerelease = !!h2.includePrerelease;
              let g = y.trim().match(h2.loose ? n[u.LOOSE] : n[u.FULL]);
              if (!g)
                throw new TypeError(`Invalid Version: ${y}`);
              if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a2 || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a2 || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a2 || this.patch < 0)
                throw new TypeError("Invalid patch version");
              g[4] ? this.prerelease = g[4].split(".").map((c2) => {
                if (/^[0-9]+$/.test(c2)) {
                  let f = +c2;
                  if (f >= 0 && f < a2)
                    return f;
                }
                return c2;
              }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y) {
              if (t("SemVer.compare", this.version, this.options, y), !(y instanceof p2)) {
                if (typeof y == "string" && y === this.version)
                  return 0;
                y = new p2(y, this.options);
              }
              return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
            }
            compareMain(y) {
              return y instanceof p2 || (y = new p2(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
            }
            comparePre(y) {
              if (y instanceof p2 || (y = new p2(y, this.options)), this.prerelease.length && !y.prerelease.length)
                return -1;
              if (!this.prerelease.length && y.prerelease.length)
                return 1;
              if (!this.prerelease.length && !y.prerelease.length)
                return 0;
              let h2 = 0;
              do {
                let g = this.prerelease[h2], c2 = y.prerelease[h2];
                if (t("prerelease compare", h2, g, c2), g === void 0 && c2 === void 0)
                  return 0;
                if (c2 === void 0)
                  return 1;
                if (g === void 0)
                  return -1;
                if (g === c2)
                  continue;
                return l(g, c2);
              } while (++h2);
            }
            compareBuild(y) {
              y instanceof p2 || (y = new p2(y, this.options));
              let h2 = 0;
              do {
                let g = this.build[h2], c2 = y.build[h2];
                if (t("prerelease compare", h2, g, c2), g === void 0 && c2 === void 0)
                  return 0;
                if (c2 === void 0)
                  return 1;
                if (g === void 0)
                  return -1;
                if (g === c2)
                  continue;
                return l(g, c2);
              } while (++h2);
            }
            inc(y, h2) {
              switch (y) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h2);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h2);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h2), this.inc("pre", h2);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h2), this.inc("pre", h2);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let g = this.prerelease.length;
                    for (; --g >= 0; )
                      typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                    g === -1 && this.prerelease.push(0);
                  }
                  h2 && (l(this.prerelease[0], h2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h2, 0]) : this.prerelease = [h2, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r.exports = p2;
        } }), zn2 = te2({ "node_modules/semver/functions/compare.js"(e, r) {
          ne2();
          var t = GD2(), s2 = (a2, n, u) => new t(a2, u).compare(new t(n, u));
          r.exports = s2;
        } }), UD2 = te2({ "node_modules/semver/functions/lt.js"(e, r) {
          ne2();
          var t = zn2(), s2 = (a2, n, u) => t(a2, n, u) < 0;
          r.exports = s2;
        } }), JD2 = te2({ "node_modules/semver/functions/gte.js"(e, r) {
          ne2();
          var t = zn2(), s2 = (a2, n, u) => t(a2, n, u) >= 0;
          r.exports = s2;
        } }), zD2 = te2({ "src/utils/arrayify.js"(e, r) {
          ne2(), r.exports = (t, s2) => Object.entries(t).map((a2) => {
            let [n, u] = a2;
            return Object.assign({ [s2]: n }, u);
          });
        } }), XD2 = te2({ "node_modules/outdent/lib/index.js"(e, r) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var E = [], N = 0; N < arguments.length; N++)
              E[N] = arguments[N];
          }
          function s2() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a2();
          }
          function a2() {
            return { add: t, delete: t, get: t, set: t, has: function(E) {
              return false;
            } };
          }
          var n = Object.prototype.hasOwnProperty, u = function(E, N) {
            return n.call(E, N);
          };
          function i(E, N) {
            for (var x2 in N)
              u(N, x2) && (E[x2] = N[x2]);
            return E;
          }
          var l = /^[ \t]*(?:\r\n|\r|\n)/, p2 = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function c2(E, N, x2) {
            var I = 0, P = E[0].match(h2);
            P && (I = P[1].length);
            var $2 = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($2, "g");
            N && (E = E.slice(1));
            var T = x2.newline, m2 = x2.trimLeadingNewline, C = x2.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
              return S = S.replace(D, "$1"), b === 0 && m2 && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p2, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                return T;
              })), S;
            });
            return v;
          }
          function f(E, N) {
            for (var x2 = "", I = 0, P = E.length; I < P; I++)
              x2 += E[I], I < P - 1 && (x2 += N[I]);
            return x2;
          }
          function F(E) {
            return u(E, "raw") && u(E, "length");
          }
          function _(E) {
            var N = s2(), x2 = s2();
            function I($2) {
              for (var D = [], T = 1; T < arguments.length; T++)
                D[T - 1] = arguments[T];
              if (F($2)) {
                var m2 = $2, C = (D[0] === I || D[0] === w) && g.test(m2[0]) && y.test(m2[1]), o = C ? x2 : N, d = o.get(m2);
                if (d || (d = c2(m2, C, E), o.set(m2, d)), D.length === 0)
                  return d[0];
                var v = f(d, C ? D.slice(1) : D);
                return v;
              } else
                return _(i(i({}, E), $2 || {}));
            }
            var P = i(I, { string: function($2) {
              return c2([$2], false, E)[0];
            } });
            return P;
          }
          var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = w, e.default = w, typeof r < "u")
            try {
              r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
            } catch {
            }
        } }), KD2 = te2({ "src/main/core-options.js"(e, r) {
          ne2();
          var { outdent: t } = XD2(), s2 = "Config", a2 = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p2 = "Special", y = { cursorOffset: { since: "1.4.0", category: p2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a2 }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h2) => typeof h2 == "string" || typeof h2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h2) => typeof h2 == "string" || typeof h2 == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h2) => typeof h2 == "string" || typeof h2 == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, rangeStart: { since: "1.4.0", category: p2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, requirePragma: { since: "1.7.0", category: p2, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: a2, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p2, options: y };
        } }), Xn2 = te2({ "src/main/support.js"(e, r) {
          ne2();
          var t = { compare: zn2(), lt: UD2(), gte: JD2() }, s2 = zD2(), a2 = Ia2().version, n = KD2().options;
          function u() {
            let { plugins: l = [], showUnreleased: p2 = false, showDeprecated: y = false, showInternal: h2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a2.split("-", 1)[0], c2 = l.flatMap((E) => E.languages || []).filter(F), f = s2(Object.assign({}, ...l.map((E) => {
              let { options: N } = E;
              return N;
            }), n), "name").filter((E) => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map((E) => {
              E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x2, I) => t.compare(I.since, x2.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x2) => F(x2) && _(x2)), E.name === "parser" && i(E, c2, l));
              let N = Object.fromEntries(l.filter((x2) => x2.defaultOptions && x2.defaultOptions[E.name] !== void 0).map((x2) => [x2.name, x2.defaultOptions[E.name]]));
              return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N });
            });
            return { languages: c2, options: f };
            function F(E) {
              return p2 || !("since" in E) || E.since && t.gte(g, E.since);
            }
            function _(E) {
              return y || !("deprecated" in E) || E.deprecated && t.lt(g, E.deprecated);
            }
            function w(E) {
              if (h2)
                return E;
              return Hn2(E, hD2);
            }
          }
          function i(l, p2, y) {
            let h2 = new Set(l.choices.map((g) => g.value));
            for (let g of p2)
              if (g.parsers) {
                for (let c2 of g.parsers)
                  if (!h2.has(c2)) {
                    h2.add(c2);
                    let f = y.find((_) => _.parsers && _.parsers[c2]), F = g.name;
                    f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({ value: c2, description: F });
                  }
              }
          }
          r.exports = { getSupportInfo: u };
        } }), Kn2 = te2({ "src/utils/is-non-empty-array.js"(e, r) {
          ne2();
          function t(s2) {
            return Array.isArray(s2) && s2.length > 0;
          }
          r.exports = t;
        } }), Pr2 = te2({ "src/utils/text/skip.js"(e, r) {
          ne2();
          function t(i) {
            return (l, p2, y) => {
              let h2 = y && y.backwards;
              if (p2 === false)
                return false;
              let { length: g } = l, c2 = p2;
              for (; c2 >= 0 && c2 < g; ) {
                let f = l.charAt(c2);
                if (i instanceof RegExp) {
                  if (!i.test(f))
                    return c2;
                } else if (!i.includes(f))
                  return c2;
                h2 ? c2-- : c2++;
              }
              return c2 === -1 || c2 === g ? c2 : false;
            };
          }
          var s2 = t(/\s/), a2 = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
          r.exports = { skipWhitespace: s2, skipSpaces: a2, skipToLineEnd: n, skipEverythingButNewLine: u };
        } }), Ra2 = te2({ "src/utils/text/skip-inline-comment.js"(e, r) {
          ne2();
          function t(s2, a2) {
            if (a2 === false)
              return false;
            if (s2.charAt(a2) === "/" && s2.charAt(a2 + 1) === "*") {
              for (let n = a2 + 2; n < s2.length; ++n)
                if (s2.charAt(n) === "*" && s2.charAt(n + 1) === "/")
                  return n + 2;
            }
            return a2;
          }
          r.exports = t;
        } }), $a2 = te2({ "src/utils/text/skip-trailing-comment.js"(e, r) {
          ne2();
          var { skipEverythingButNewLine: t } = Pr2();
          function s2(a2, n) {
            return n === false ? false : a2.charAt(n) === "/" && a2.charAt(n + 1) === "/" ? t(a2, n) : n;
          }
          r.exports = s2;
        } }), Va2 = te2({ "src/utils/text/skip-newline.js"(e, r) {
          ne2();
          function t(s2, a2, n) {
            let u = n && n.backwards;
            if (a2 === false)
              return false;
            let i = s2.charAt(a2);
            if (u) {
              if (s2.charAt(a2 - 1) === "\r" && i === `
`)
                return a2 - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a2 - 1;
            } else {
              if (i === "\r" && s2.charAt(a2 + 1) === `
`)
                return a2 + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a2 + 1;
            }
            return a2;
          }
          r.exports = t;
        } }), YD2 = te2({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
          ne2();
          var t = Ra2(), s2 = Va2(), a2 = $a2(), { skipSpaces: n } = Pr2();
          function u(i, l) {
            let p2 = null, y = l;
            for (; y !== p2; )
              p2 = y, y = n(i, y), y = t(i, y), y = a2(i, y), y = s2(i, y);
            return y;
          }
          r.exports = u;
        } }), Ue2 = te2({ "src/common/util.js"(e, r) {
          ne2();
          var { default: t } = ($D2(), ft2(ja2)), s2 = lt2(), { getSupportInfo: a2 } = Xn2(), n = Kn2(), u = Oa2(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p2, skipEverythingButNewLine: y } = Pr2(), h2 = Ra2(), g = $a2(), c2 = Va2(), f = YD2(), F = (V) => V[V.length - 2];
          function _(V) {
            return (j, Y, ie) => {
              let ee = ie && ie.backwards;
              if (Y === false)
                return false;
              let { length: ce } = j, W = Y;
              for (; W >= 0 && W < ce; ) {
                let K = j.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(K))
                    return W;
                } else if (!V.includes(K))
                  return W;
                ee ? W-- : W++;
              }
              return W === -1 || W === ce ? W : false;
            };
          }
          function w(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c2(V, ie, Y);
            return ie !== ee;
          }
          function E(V, j, Y) {
            for (let ie = j; ie < Y; ++ie)
              if (V.charAt(ie) === `
`)
                return true;
            return false;
          }
          function N(V, j, Y) {
            let ie = Y(j) - 1;
            ie = l(V, ie, { backwards: true }), ie = c2(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
            let ee = c2(V, ie, { backwards: true });
            return ie !== ee;
          }
          function x2(V, j) {
            let Y = null, ie = j;
            for (; ie !== Y; )
              Y = ie, ie = p2(V, ie), ie = h2(V, ie), ie = l(V, ie);
            return ie = g(V, ie), ie = c2(V, ie), ie !== false && w(V, ie);
          }
          function I(V, j, Y) {
            return x2(V, Y(j));
          }
          function P(V, j, Y) {
            return f(V, Y(j));
          }
          function $2(V, j, Y) {
            return V.charAt(P(V, j, Y));
          }
          function D(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, Y.backwards ? j - 1 : j, Y) !== j;
          }
          function T(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
            for (let ee = Y; ee < V.length; ++ee)
              V[ee] === "	" ? ie = ie + j - ie % j : ie++;
            return ie;
          }
          function m2(V, j) {
            let Y = V.lastIndexOf(`
`);
            return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
          }
          function C(V, j) {
            let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
            if (V.includes(ee.quote) || V.includes(ce.quote)) {
              let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
              W = K > de ? ce : ee;
            }
            return W;
          }
          function o(V, j) {
            let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
            return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
          }
          function d(V, j, Y) {
            let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
            return j + ce + j;
          }
          function v(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function S(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
          }
          function b(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            if (Y === null)
              return 0;
            let ie = /* @__PURE__ */ new Map(), ee = 0;
            for (let ce of Y) {
              let W = ce.length / j.length;
              ie.set(W, true), W > ee && (ee = W);
            }
            for (let ce = 1; ce < ee; ce++)
              if (!ie.get(ce))
                return ce;
            return ee + 1;
          }
          function B(V, j) {
            (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
          }
          function k(V, j) {
            j.leading = true, j.trailing = false, B(V, j);
          }
          function M(V, j, Y) {
            j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
          }
          function R(V, j) {
            j.leading = false, j.trailing = true, B(V, j);
          }
          function q2(V, j) {
            let { languages: Y } = a2({ plugins: j.plugins }), ie = Y.find((ee) => {
              let { name: ce } = ee;
              return ce.toLowerCase() === V;
            }) || Y.find((ee) => {
              let { aliases: ce } = ee;
              return Array.isArray(ce) && ce.includes(V);
            }) || Y.find((ee) => {
              let { extensions: ce } = ee;
              return Array.isArray(ce) && ce.includes(`.${V}`);
            });
            return ie && ie.parsers[0];
          }
          function J(V) {
            return V && V.type === "front-matter";
          }
          function L(V) {
            let j = /* @__PURE__ */ new WeakMap();
            return function(Y) {
              return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
            };
          }
          function Q(V) {
            let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return Y.length > 20 && (Y = Y.slice(0, 19) + "â¦"), j + (Y ? " " + Y : "");
          }
          r.exports = { inferParserByLanguage: q2, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $2, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p2, skipEverythingButNewLine: y, skipInlineComment: h2, skipTrailingComment: g, skipNewline: c2, isNextLineEmptyAfterIndex: x2, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m2, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
        } }), Wa2 = {};
        Kt2(Wa2, { basename: () => za2, default: () => Ka2, delimiter: () => Mn2, dirname: () => Ja2, extname: () => Xa2, isAbsolute: () => Qn2, join: () => Ga2, normalize: () => Yn2, relative: () => Ua2, resolve: () => wr2, sep: () => qn2 });
        function Ha2(e, r) {
          for (var t = 0, s2 = e.length - 1; s2 >= 0; s2--) {
            var a2 = e[s2];
            a2 === "." ? e.splice(s2, 1) : a2 === ".." ? (e.splice(s2, 1), t++) : t && (e.splice(s2, 1), t--);
          }
          if (r)
            for (; t--; t)
              e.unshift("..");
          return e;
        }
        function wr2() {
          for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
            var s2 = t >= 0 ? arguments[t] : "/";
            if (typeof s2 != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s2)
              continue;
            e = s2 + "/" + e, r = s2.charAt(0) === "/";
          }
          return e = Ha2(Zn2(e.split("/"), function(a2) {
            return !!a2;
          }), !r).join("/"), (r ? "/" : "") + e || ".";
        }
        function Yn2(e) {
          var r = Qn2(e), t = Ya2(e, -1) === "/";
          return e = Ha2(Zn2(e.split("/"), function(s2) {
            return !!s2;
          }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
        }
        function Qn2(e) {
          return e.charAt(0) === "/";
        }
        function Ga2() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Yn2(Zn2(e, function(r, t) {
            if (typeof r != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return r;
          }).join("/"));
        }
        function Ua2(e, r) {
          e = wr2(e).substr(1), r = wr2(r).substr(1);
          function t(p2) {
            for (var y = 0; y < p2.length && p2[y] === ""; y++)
              ;
            for (var h2 = p2.length - 1; h2 >= 0 && p2[h2] === ""; h2--)
              ;
            return y > h2 ? [] : p2.slice(y, h2 - y + 1);
          }
          for (var s2 = t(e.split("/")), a2 = t(r.split("/")), n = Math.min(s2.length, a2.length), u = n, i = 0; i < n; i++)
            if (s2[i] !== a2[i]) {
              u = i;
              break;
            }
          for (var l = [], i = u; i < s2.length; i++)
            l.push("..");
          return l = l.concat(a2.slice(u)), l.join("/");
        }
        function Ja2(e) {
          var r = Ir2(e), t = r[0], s2 = r[1];
          return !t && !s2 ? "." : (s2 && (s2 = s2.substr(0, s2.length - 1)), t + s2);
        }
        function za2(e, r) {
          var t = Ir2(e)[2];
          return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
        }
        function Xa2(e) {
          return Ir2(e)[3];
        }
        function Zn2(e, r) {
          if (e.filter)
            return e.filter(r);
          for (var t = [], s2 = 0; s2 < e.length; s2++)
            r(e[s2], s2, e) && t.push(e[s2]);
          return t;
        }
        var Na2, Ir2, qn2, Mn2, Ka2, Ya2, QD2 = ht2({ "node-modules-polyfills:path"() {
          ne2(), Na2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir2 = function(e) {
            return Na2.exec(e).slice(1);
          }, qn2 = "/", Mn2 = ":", Ka2 = { extname: Xa2, basename: za2, dirname: Ja2, sep: qn2, delimiter: Mn2, relative: Ua2, join: Ga2, isAbsolute: Qn2, normalize: Yn2, resolve: wr2 }, Ya2 = "ab".substr(-1) === "b" ? function(e, r, t) {
            return e.substr(r, t);
          } : function(e, r, t) {
            return r < 0 && (r = e.length + r), e.substr(r, t);
          };
        } }), ZD2 = te2({ "node-modules-polyfills-commonjs:path"(e, r) {
          ne2();
          var t = (QD2(), ft2(Wa2));
          if (t && t.default) {
            r.exports = t.default;
            for (let s2 in t)
              r.exports[s2] = t[s2];
          } else
            t && (r.exports = t);
        } }), Qt2 = te2({ "src/common/errors.js"(e, r) {
          ne2();
          var t = class extends Error {
          }, s2 = class extends Error {
          }, a2 = class extends Error {
          }, n = class extends Error {
          };
          r.exports = { ConfigError: t, DebugError: s2, UndefinedParserError: a2, ArgExpansionBailout: n };
        } }), vt2 = {};
        Kt2(vt2, { __assign: () => Nr2, __asyncDelegator: () => fm2, __asyncGenerator: () => pm2, __asyncValues: () => Dm2, __await: () => Xt2, __awaiter: () => sm2, __classPrivateFieldGet: () => ym2, __classPrivateFieldSet: () => hm2, __createBinding: () => am2, __decorate: () => rm2, __exportStar: () => om2, __extends: () => em2, __generator: () => im2, __importDefault: () => gm2, __importStar: () => dm2, __makeTemplateObject: () => mm2, __metadata: () => um2, __param: () => nm2, __read: () => Qa2, __rest: () => tm2, __spread: () => lm2, __spreadArrays: () => cm2, __values: () => Rn2 });
        function em2(e, r) {
          Br2(e, r);
          function t() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
        }
        function tm2(e, r) {
          var t = {};
          for (var s2 in e)
            Object.prototype.hasOwnProperty.call(e, s2) && r.indexOf(s2) < 0 && (t[s2] = e[s2]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a2 = 0, s2 = Object.getOwnPropertySymbols(e); a2 < s2.length; a2++)
              r.indexOf(s2[a2]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s2[a2]) && (t[s2[a2]] = e[s2[a2]]);
          return t;
        }
        function rm2(e, r, t, s2) {
          var a2 = arguments.length, n = a2 < 3 ? r : s2 === null ? s2 = Object.getOwnPropertyDescriptor(r, t) : s2, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            n = Reflect.decorate(e, r, t, s2);
          else
            for (var i = e.length - 1; i >= 0; i--)
              (u = e[i]) && (n = (a2 < 3 ? u(n) : a2 > 3 ? u(r, t, n) : u(r, t)) || n);
          return a2 > 3 && n && Object.defineProperty(r, t, n), n;
        }
        function nm2(e, r) {
          return function(t, s2) {
            r(t, s2, e);
          };
        }
        function um2(e, r) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, r);
        }
        function sm2(e, r, t, s2) {
          function a2(n) {
            return n instanceof t ? n : new t(function(u) {
              u(n);
            });
          }
          return new (t || (t = Promise))(function(n, u) {
            function i(y) {
              try {
                p2(s2.next(y));
              } catch (h2) {
                u(h2);
              }
            }
            function l(y) {
              try {
                p2(s2.throw(y));
              } catch (h2) {
                u(h2);
              }
            }
            function p2(y) {
              y.done ? n(y.value) : a2(y.value).then(i, l);
            }
            p2((s2 = s2.apply(e, r || [])).next());
          });
        }
        function im2(e, r) {
          var t = { label: 0, sent: function() {
            if (n[0] & 1)
              throw n[1];
            return n[1];
          }, trys: [], ops: [] }, s2, a2, n, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(p2) {
            return function(y) {
              return l([p2, y]);
            };
          }
          function l(p2) {
            if (s2)
              throw new TypeError("Generator is already executing.");
            for (; t; )
              try {
                if (s2 = 1, a2 && (n = p2[0] & 2 ? a2.return : p2[0] ? a2.throw || ((n = a2.return) && n.call(a2), 0) : a2.next) && !(n = n.call(a2, p2[1])).done)
                  return n;
                switch (a2 = 0, n && (p2 = [p2[0] & 2, n.value]), p2[0]) {
                  case 0:
                  case 1:
                    n = p2;
                    break;
                  case 4:
                    return t.label++, { value: p2[1], done: false };
                  case 5:
                    t.label++, a2 = p2[1], p2 = [0];
                    continue;
                  case 7:
                    p2 = t.ops.pop(), t.trys.pop();
                    continue;
                  default:
                    if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p2[0] === 6 || p2[0] === 2)) {
                      t = 0;
                      continue;
                    }
                    if (p2[0] === 3 && (!n || p2[1] > n[0] && p2[1] < n[3])) {
                      t.label = p2[1];
                      break;
                    }
                    if (p2[0] === 6 && t.label < n[1]) {
                      t.label = n[1], n = p2;
                      break;
                    }
                    if (n && t.label < n[2]) {
                      t.label = n[2], t.ops.push(p2);
                      break;
                    }
                    n[2] && t.ops.pop(), t.trys.pop();
                    continue;
                }
                p2 = r.call(e, t);
              } catch (y) {
                p2 = [6, y], a2 = 0;
              } finally {
                s2 = n = 0;
              }
            if (p2[0] & 5)
              throw p2[1];
            return { value: p2[0] ? p2[1] : void 0, done: true };
          }
        }
        function am2(e, r, t, s2) {
          s2 === void 0 && (s2 = t), e[s2] = r[t];
        }
        function om2(e, r) {
          for (var t in e)
            t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
        }
        function Rn2(e) {
          var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s2 = 0;
          if (t)
            return t.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s2 >= e.length && (e = void 0), { value: e && e[s2++], done: !e };
            } };
          throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Qa2(e, r) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t)
            return e;
          var s2 = t.call(e), a2, n = [], u;
          try {
            for (; (r === void 0 || r-- > 0) && !(a2 = s2.next()).done; )
              n.push(a2.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a2 && !a2.done && (t = s2.return) && t.call(s2);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return n;
        }
        function lm2() {
          for (var e = [], r = 0; r < arguments.length; r++)
            e = e.concat(Qa2(arguments[r]));
          return e;
        }
        function cm2() {
          for (var e = 0, r = 0, t = arguments.length; r < t; r++)
            e += arguments[r].length;
          for (var s2 = Array(e), a2 = 0, r = 0; r < t; r++)
            for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a2++)
              s2[a2] = n[u];
          return s2;
        }
        function Xt2(e) {
          return this instanceof Xt2 ? (this.v = e, this) : new Xt2(e);
        }
        function pm2(e, r, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s2 = t.apply(e, r || []), a2, n = [];
          return a2 = {}, u("next"), u("throw"), u("return"), a2[Symbol.asyncIterator] = function() {
            return this;
          }, a2;
          function u(g) {
            s2[g] && (a2[g] = function(c2) {
              return new Promise(function(f, F) {
                n.push([g, c2, f, F]) > 1 || i(g, c2);
              });
            });
          }
          function i(g, c2) {
            try {
              l(s2[g](c2));
            } catch (f) {
              h2(n[0][3], f);
            }
          }
          function l(g) {
            g.value instanceof Xt2 ? Promise.resolve(g.value.v).then(p2, y) : h2(n[0][2], g);
          }
          function p2(g) {
            i("next", g);
          }
          function y(g) {
            i("throw", g);
          }
          function h2(g, c2) {
            g(c2), n.shift(), n.length && i(n[0][0], n[0][1]);
          }
        }
        function fm2(e) {
          var r, t;
          return r = {}, s2("next"), s2("throw", function(a2) {
            throw a2;
          }), s2("return"), r[Symbol.iterator] = function() {
            return this;
          }, r;
          function s2(a2, n) {
            r[a2] = e[a2] ? function(u) {
              return (t = !t) ? { value: Xt2(e[a2](u)), done: a2 === "return" } : n ? n(u) : u;
            } : n;
          }
        }
        function Dm2(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r = e[Symbol.asyncIterator], t;
          return r ? r.call(e) : (e = typeof Rn2 == "function" ? Rn2(e) : e[Symbol.iterator](), t = {}, s2("next"), s2("throw"), s2("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s2(n) {
            t[n] = e[n] && function(u) {
              return new Promise(function(i, l) {
                u = e[n](u), a2(i, l, u.done, u.value);
              });
            };
          }
          function a2(n, u, i, l) {
            Promise.resolve(l).then(function(p2) {
              n({ value: p2, done: i });
            }, u);
          }
        }
        function mm2(e, r) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
        }
        function dm2(e) {
          if (e && e.__esModule)
            return e;
          var r = {};
          if (e != null)
            for (var t in e)
              Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
          return r.default = e, r;
        }
        function gm2(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function ym2(e, r) {
          if (!r.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return r.get(e);
        }
        function hm2(e, r, t) {
          if (!r.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return r.set(e, t), t;
        }
        var Br2, Nr2, Et2 = ht2({ "node_modules/tslib/tslib.es6.js"() {
          ne2(), Br2 = function(e, r) {
            return Br2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s2) {
              t.__proto__ = s2;
            } || function(t, s2) {
              for (var a2 in s2)
                s2.hasOwnProperty(a2) && (t[a2] = s2[a2]);
            }, Br2(e, r);
          }, Nr2 = function() {
            return Nr2 = Object.assign || function(r) {
              for (var t, s2 = 1, a2 = arguments.length; s2 < a2; s2++) {
                t = arguments[s2];
                for (var n in t)
                  Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
              }
              return r;
            }, Nr2.apply(this, arguments);
          };
        } }), Za2 = te2({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
            if (r === null || typeof r != "object")
              return JSON.stringify(r);
            if (Array.isArray(r))
              return `[${r.map((s2) => e.apiDescriptor.value(s2)).join(", ")}]`;
            let t = Object.keys(r);
            return t.length === 0 ? "{}" : `{ ${t.map((s2) => `${e.apiDescriptor.key(s2)}: ${e.apiDescriptor.value(r[s2])}`).join(", ")} }`;
          }, pair: (r) => {
            let { key: t, value: s2 } = r;
            return e.apiDescriptor.value({ [t]: s2 });
          } };
        } }), vm2 = te2({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Za2(), e);
        } }), kr2 = te2({ "scripts/build/shims/chalk.cjs"(e, r) {
          ne2();
          var t = (s2) => s2;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
        } }), eo2 = te2({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonDeprecatedHandler = (t, s2, a2) => {
            let { descriptor: n } = a2, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
            return s2 && u.push(`we now treat it as ${r.default.blue(typeof s2 == "string" ? n.key(s2) : n.pair(s2))}`), u.join("; ") + ".";
          };
        } }), Cm2 = te2({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(eo2(), e);
        } }), Em2 = te2({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonInvalidHandler = (t, s2, a2) => [`Invalid ${r.default.red(a2.descriptor.key(t))} value.`, `Expected ${r.default.blue(a2.schemas[t].expected(a2))},`, `but received ${r.default.red(a2.descriptor.value(s2))}.`].join(" ");
        } }), to2 = te2({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Em2(), e);
        } }), Fm2 = te2({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
          ne2();
          var t = [], s2 = [];
          r.exports = function(a2, n) {
            if (a2 === n)
              return 0;
            var u = a2;
            a2.length > n.length && (a2 = n, n = u);
            var i = a2.length, l = n.length;
            if (i === 0)
              return l;
            if (l === 0)
              return i;
            for (; i > 0 && a2.charCodeAt(~-i) === n.charCodeAt(~-l); )
              i--, l--;
            if (i === 0)
              return l;
            for (var p2 = 0; p2 < i && a2.charCodeAt(p2) === n.charCodeAt(p2); )
              p2++;
            if (i -= p2, l -= p2, i === 0)
              return l;
            for (var y, h2, g, c2, f = 0, F = 0; f < i; )
              s2[p2 + f] = a2.charCodeAt(p2 + f), t[f] = ++f;
            for (; F < l; )
              for (y = n.charCodeAt(p2 + F), g = F++, h2 = F, f = 0; f < i; f++)
                c2 = y === s2[p2 + f] ? g : g + 1, g = t[f], h2 = t[f] = g > h2 ? c2 > h2 ? h2 + 1 : c2 : c2 > g ? g + 1 : c2;
            return h2;
          };
        } }), ro2 = te2({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2(), t = Fm2();
          e.levenUnknownHandler = (s2, a2, n) => {
            let { descriptor: u, logger: i, schemas: l } = n, p2 = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s2, value: a2 }))}.`], y = Object.keys(l).sort().find((h2) => t(s2, h2) < 3);
            y && p2.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p2.join(" "));
          };
        } }), Am2 = te2({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(ro2(), e);
        } }), Sm2 = te2({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Cm2(), e), r.__exportStar(to2(), e), r.__exportStar(Am2(), e);
        } }), Ft2 = te2({ "node_modules/vnopts/lib/schema.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(n, u) {
            let i = new n(u), l = Object.create(i);
            for (let p2 of r)
              p2 in u && (l[p2] = a2(u[p2], i, s2.prototype[p2].length));
            return l;
          }
          e.createSchema = t;
          var s2 = class {
            constructor(n) {
              this.name = n.name;
            }
            static create(n) {
              return t(this, n);
            }
            default(n) {
            }
            expected(n) {
              return "nothing";
            }
            validate(n, u) {
              return false;
            }
            deprecated(n, u) {
              return false;
            }
            forward(n, u) {
            }
            redirect(n, u) {
            }
            overlap(n, u, i) {
              return n;
            }
            preprocess(n, u) {
              return n;
            }
            postprocess(n, u) {
              return n;
            }
          };
          e.Schema = s2;
          function a2(n, u, i) {
            return typeof n == "function" ? function() {
              for (var l = arguments.length, p2 = new Array(l), y = 0; y < l; y++)
                p2[y] = arguments[y];
              return n(...p2.slice(0, i - 1), u, ...p2.slice(i - 1));
            } : () => n;
          }
        } }), xm2 = te2({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            constructor(s2) {
              super(s2), this._sourceName = s2.sourceName;
            }
            expected(s2) {
              return s2.schemas[this._sourceName].expected(s2);
            }
            validate(s2, a2) {
              return a2.schemas[this._sourceName].validate(s2, a2);
            }
            redirect(s2, a2) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t;
        } }), bm2 = te2({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t;
        } }), Tm2 = te2({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2)), t = Ft2(), s2 = class extends t.Schema {
            constructor(n) {
              var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i })), this._valueSchema = u;
            }
            expected(n) {
              return `an array of ${this._valueSchema.expected(n)}`;
            }
            validate(n, u) {
              if (!Array.isArray(n))
                return false;
              let i = [];
              for (let l of n) {
                let p2 = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                p2 !== true && i.push(p2.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(n, u) {
              let i = [];
              for (let l of n) {
                let p2 = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                p2 !== false && i.push(...p2.map((y) => {
                  let { value: h2 } = y;
                  return { value: [h2] };
                }));
              }
              return i;
            }
            forward(n, u) {
              let i = [];
              for (let l of n) {
                let p2 = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i.push(...p2.map(a2));
              }
              return i;
            }
            redirect(n, u) {
              let i = [], l = [];
              for (let p2 of n) {
                let y = u.normalizeRedirectResult(this._valueSchema.redirect(p2, u), p2);
                "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a2));
              }
              return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
            }
            overlap(n, u) {
              return n.concat(u);
            }
          };
          e.ArraySchema = s2;
          function a2(n) {
            let { from: u, to: i } = n;
            return { from: [u], to: i };
          }
        } }), Bm2 = te2({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "true or false";
            }
            validate(s2) {
              return typeof s2 == "boolean";
            }
          };
          e.BooleanSchema = t;
        } }), eu2 = te2({ "node_modules/vnopts/lib/utils.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          function r(c2, f) {
            let F = /* @__PURE__ */ Object.create(null);
            for (let _ of c2) {
              let w = _[f];
              if (F[w])
                throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F[w] = _;
            }
            return F;
          }
          e.recordFromArray = r;
          function t(c2, f) {
            let F = /* @__PURE__ */ new Map();
            for (let _ of c2) {
              let w = _[f];
              if (F.has(w))
                throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F.set(w, _);
            }
            return F;
          }
          e.mapFromArray = t;
          function s2() {
            let c2 = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let F = JSON.stringify(f);
              return c2[F] ? true : (c2[F] = true, false);
            };
          }
          e.createAutoChecklist = s2;
          function a2(c2, f) {
            let F = [], _ = [];
            for (let w of c2)
              f(w) ? F.push(w) : _.push(w);
            return [F, _];
          }
          e.partition = a2;
          function n(c2) {
            return c2 === Math.floor(c2);
          }
          e.isInt = n;
          function u(c2, f) {
            if (c2 === f)
              return 0;
            let F = typeof c2, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
            return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c2) - Number(f) : c2.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i(c2) {
            return c2 === void 0 ? {} : c2;
          }
          e.normalizeDefaultResult = i;
          function l(c2, f) {
            return c2 === true ? true : c2 === false ? { value: f } : c2;
          }
          e.normalizeValidateResult = l;
          function p2(c2, f) {
            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return c2 === false ? false : c2 === true ? F ? true : [{ value: f }] : "value" in c2 ? [c2] : c2.length === 0 ? false : c2;
          }
          e.normalizeDeprecatedResult = p2;
          function y(c2, f) {
            return typeof c2 == "string" || "key" in c2 ? { from: f, to: c2 } : "from" in c2 ? { from: c2.from, to: c2.to } : { from: f, to: c2.to };
          }
          e.normalizeTransferResult = y;
          function h2(c2, f) {
            return c2 === void 0 ? [] : Array.isArray(c2) ? c2.map((F) => y(F, f)) : [y(c2, f)];
          }
          e.normalizeForwardResult = h2;
          function g(c2, f) {
            let F = h2(typeof c2 == "object" && "redirect" in c2 ? c2.redirect : c2, f);
            return F.length === 0 ? { remain: f, redirect: F } : typeof c2 == "object" && "remain" in c2 ? { remain: c2.remain, redirect: F } : { redirect: F };
          }
          e.normalizeRedirectResult = g;
        } }), Nm2 = te2({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = eu2(), s2 = class extends r.Schema {
            constructor(a2) {
              super(a2), this._choices = t.mapFromArray(a2.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
            }
            expected(a2) {
              let { descriptor: n } = a2, u = Array.from(this._choices.keys()).map((p2) => this._choices.get(p2)).filter((p2) => !p2.deprecated).map((p2) => p2.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
              return i.concat(l.join(" or ")).join(", ");
            }
            validate(a2) {
              return this._choices.has(a2);
            }
            deprecated(a2) {
              let n = this._choices.get(a2);
              return n && n.deprecated ? { value: a2 } : false;
            }
            forward(a2) {
              let n = this._choices.get(a2);
              return n ? n.forward : void 0;
            }
            redirect(a2) {
              let n = this._choices.get(a2);
              return n ? n.redirect : void 0;
            }
          };
          e.ChoiceSchema = s2;
        } }), no2 = te2({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "a number";
            }
            validate(s2, a2) {
              return typeof s2 == "number";
            }
          };
          e.NumberSchema = t;
        } }), wm2 = te2({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = eu2(), t = no2(), s2 = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a2, n) {
              return n.normalizeValidateResult(super.validate(a2, n), a2) === true && r.isInt(a2);
            }
          };
          e.IntegerSchema = s2;
        } }), _m2 = te2({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "a string";
            }
            validate(s2) {
              return typeof s2 == "string";
            }
          };
          e.StringSchema = t;
        } }), Pm2 = te2({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(xm2(), e), r.__exportStar(bm2(), e), r.__exportStar(Tm2(), e), r.__exportStar(Bm2(), e), r.__exportStar(Nm2(), e), r.__exportStar(wm2(), e), r.__exportStar(no2(), e), r.__exportStar(_m2(), e);
        } }), Im2 = te2({ "node_modules/vnopts/lib/defaults.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Za2(), t = eo2(), s2 = to2(), a2 = ro2();
          e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a2.levenUnknownHandler, e.defaultInvalidHandler = s2.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), km2 = te2({ "node_modules/vnopts/lib/normalize.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Im2(), t = eu2();
          e.normalize = (a2, n, u) => new s2(n, u).normalize(a2);
          var s2 = class {
            constructor(a2, n) {
              let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p2 = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a2, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p2, this._deprecatedHandler = y, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a2) {
              let n = {}, u = [a2], i = () => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), p2 = this._applyNormalization(l, n);
                  u.push(...p2);
                }
              };
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p2 = this._utils.schemas[l];
                if (!(l in n)) {
                  let y = t.normalizeDefaultResult(p2.default(this._utils));
                  "value" in y && u.push({ [l]: y.value });
                }
              }
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p2 = this._utils.schemas[l];
                l in n && (n[l] = p2.postprocess(n[l], this._utils));
              }
              return n;
            }
            _applyNormalization(a2, n) {
              let u = [], [i, l] = t.partition(Object.keys(a2), (p2) => p2 in this._utils.schemas);
              for (let p2 of i) {
                let y = this._utils.schemas[p2], h2 = y.preprocess(a2[p2], this._utils), g = t.normalizeValidateResult(y.validate(h2, this._utils), h2);
                if (g !== true) {
                  let { value: w } = g, E = this._invalidHandler(p2, w, this._utils);
                  throw typeof E == "string" ? new Error(E) : E;
                }
                let c2 = (w) => {
                  let { from: E, to: N } = w;
                  u.push(typeof N == "string" ? { [N]: E } : { [N.key]: N.value });
                }, f = (w) => {
                  let { value: E, redirectTo: N } = w, x2 = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h2, true);
                  if (x2 !== false)
                    if (x2 === true)
                      this._hasDeprecationWarned(p2) || this._utils.logger.warn(this._deprecatedHandler(p2, N, this._utils));
                    else
                      for (let { value: I } of x2) {
                        let P = { key: p2, value: I };
                        if (!this._hasDeprecationWarned(P)) {
                          let $2 = typeof N == "string" ? { key: N, value: I } : N;
                          this._utils.logger.warn(this._deprecatedHandler(P, $2, this._utils));
                        }
                      }
                };
                t.normalizeForwardResult(y.forward(h2, this._utils), h2).forEach(c2);
                let _ = t.normalizeRedirectResult(y.redirect(h2, this._utils), h2);
                if (_.redirect.forEach(c2), "remain" in _) {
                  let w = _.remain;
                  n[p2] = p2 in n ? y.overlap(n[p2], w, this._utils) : w, f({ value: w });
                }
                for (let { from: w, to: E } of _.redirect)
                  f({ value: w, redirectTo: E });
              }
              for (let p2 of l) {
                let y = a2[p2], h2 = this._unknownHandler(p2, y, this._utils);
                if (h2)
                  for (let g of Object.keys(h2)) {
                    let c2 = { [g]: h2[g] };
                    g in this._utils.schemas ? u.push(c2) : Object.assign(n, c2);
                  }
              }
              return u;
            }
          };
          e.Normalizer = s2;
        } }), Lm2 = te2({ "node_modules/vnopts/lib/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(vm2(), e), r.__exportStar(Sm2(), e), r.__exportStar(Pm2(), e), r.__exportStar(km2(), e), r.__exportStar(Ft2(), e);
        } }), Om2 = te2({ "src/main/options-normalizer.js"(e, r) {
          ne2();
          var t = Lm2(), s2 = lt2(), a2 = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
            let { key: c2, value: f } = g;
            return f === false ? `--no-${c2}` : f === true ? a2.key(c2) : f === "" ? `${a2.key(c2)} without an argument` : `${a2.key(c2)}=${f}`;
          } }, n = (g) => {
            let { colorsModule: c2, levenshteinDistance: f } = g;
            return class extends t.ChoiceSchema {
              constructor(_) {
                let { name: w, flags: E } = _;
                super({ name: w, choices: E }), this._flags = [...E].sort();
              }
              preprocess(_, w) {
                if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                  let E = this._flags.find((N) => f(N, _) < 3);
                  if (E)
                    return w.logger.warn([`Unknown flag ${c2.yellow(w.descriptor.value(_))},`, `did you mean ${c2.blue(w.descriptor.value(E))}?`].join(" ")), E;
                }
                return _;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i(g, c2) {
            let { logger: f = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m2) => _.includes(T) ? { [T]: m2 } : void 0 : (T, m2) => ({ [T]: m2 }) : (T, m2, C) => {
              let o = C.schemas, v = Hn2(o, vD2);
              return t.levenUnknownHandler(T, m2, Object.assign(Object.assign({}, C), {}, { schemas: v }));
            }, x2 = F ? a2 : t.apiDescriptor, I = l(c2, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x2 }), $2 = f !== false;
            $2 && u && (P._hasDeprecationWarned = u);
            let D = P.normalize(g);
            return $2 && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
          }
          function l(g, c2) {
            let { isCLI: f, colorsModule: F, levenshteinDistance: _ } = c2, w = [];
            f && w.push(t.AnySchema.create({ name: "_" }));
            for (let E of g)
              w.push(p2(E, { isCLI: f, optionInfos: g, colorsModule: F, levenshteinDistance: _ })), E.alias && f && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
            return w;
          }
          function p2(g, c2) {
            let { isCLI: f, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c2, { name: E } = g;
            if (E === "plugin-search-dir" || E === "pluginSearchDirs")
              return t.AnySchema.create({ name: E, preprocess(P) {
                return P === false || (P = Array.isArray(P) ? P : [P]), P;
              }, validate(P) {
                return P === false ? true : P.every(($2) => typeof $2 == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let N = { name: E }, x2, I = {};
            switch (g.type) {
              case "int":
                x2 = t.IntegerSchema, f && (N.preprocess = Number);
                break;
              case "string":
                x2 = t.StringSchema;
                break;
              case "choice":
                x2 = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                x2 = t.BooleanSchema;
                break;
              case "flag":
                x2 = n({ colorsModule: _, levenshteinDistance: w }), N.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                x2 = t.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g.type}`);
            }
            if (g.exception ? N.validate = (P, $2, D) => g.exception(P) || $2.validate(P, D) : N.validate = (P, $2, D) => P === void 0 || $2.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
              let P = N.preprocess || (($2) => $2);
              N.preprocess = ($2, D, T) => D.preprocess(P(Array.isArray($2) ? s2($2) : $2), T);
            }
            return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x2.create(N) })) : x2.create(Object.assign(Object.assign({}, N), I));
          }
          function y(g, c2, f) {
            return i(g, c2, f);
          }
          function h2(g, c2, f) {
            return i(g, c2, Object.assign({ isCLI: true }, f));
          }
          r.exports = { normalizeApiOptions: y, normalizeCliOptions: h2 };
        } }), ut2 = te2({ "src/language-js/loc.js"(e, r) {
          ne2();
          var t = Kn2();
          function s2(l) {
            var p2, y;
            let h2 = l.range ? l.range[0] : l.start, g = (p2 = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p2 !== void 0 ? p2 : l.decorators;
            return t(g) ? Math.min(s2(g[0]), h2) : h2;
          }
          function a2(l) {
            return l.range ? l.range[1] : l.end;
          }
          function n(l, p2) {
            let y = s2(l);
            return Number.isInteger(y) && y === s2(p2);
          }
          function u(l, p2) {
            let y = a2(l);
            return Number.isInteger(y) && y === a2(p2);
          }
          function i(l, p2) {
            return n(l, p2) && u(l, p2);
          }
          r.exports = { locStart: s2, locEnd: a2, hasSameLocStart: n, hasSameLoc: i };
        } }), jm2 = te2({ "src/main/load-parser.js"(e, r) {
          ne2(), r.exports = () => {
          };
        } }), qm2 = te2({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
          ne2();
          var t = kr2(), s2 = { shouldHighlight: () => false, getChalk: () => t };
          r.exports = s2;
        } }), Mm2 = te2({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
          var r = qm2(), t = false;
          function s2(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          var a2 = /\r\n|[\n\r\u2028\u2029]/;
          function n(l, p2, y) {
            let h2 = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h2, l.end), { linesAbove: c2 = 2, linesBelow: f = 3 } = y || {}, F = h2.line, _ = h2.column, w = g.line, E = g.column, N = Math.max(F - (c2 + 1), 0), x2 = Math.min(p2.length, w + f);
            F === -1 && (N = 0), w === -1 && (x2 = p2.length);
            let I = w - F, P = {};
            if (I)
              for (let $2 = 0; $2 <= I; $2++) {
                let D = $2 + F;
                if (!_)
                  P[D] = true;
                else if ($2 === 0) {
                  let T = p2[D - 1].length;
                  P[D] = [_, T - _ + 1];
                } else if ($2 === I)
                  P[D] = [0, E];
                else {
                  let T = p2[D - $2].length;
                  P[D] = [0, T];
                }
              }
            else
              _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
            return { start: N, end: x2, markerLines: P };
          }
          function u(l, p2) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h2 = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g = (0, r.getChalk)(y), c2 = s2(g), f = ($2, D) => h2 ? $2(D) : D, F = l.split(a2), { start: _, end: w, markerLines: E } = n(p2, F, y), N = p2.start && typeof p2.start.column == "number", x2 = String(w).length, P = (h2 ? (0, r.default)(l, y) : l).split(a2, w).slice(_, w).map(($2, D) => {
              let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x2)} |`, o = E[T], d = !E[T + 1];
              if (o) {
                let v = "";
                if (Array.isArray(o)) {
                  let S = $2.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  v = [`
 `, f(c2.gutter, C.replace(/\d/g, " ")), " ", S, f(c2.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f(c2.message, y.message));
                }
                return [f(c2.marker, ">"), f(c2.gutter, C), $2.length > 0 ? ` ${$2}` : "", v].join("");
              } else
                return ` ${f(c2.gutter, C)}${$2.length > 0 ? ` ${$2}` : ""}`;
            }).join(`
`);
            return y.message && !N && (P = `${" ".repeat(x2 + 1)}${y.message}
${P}`), h2 ? g.reset(P) : P;
          }
          function i(l, p2, y) {
            let h2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let c2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (wt2.emitWarning)
                wt2.emitWarning(c2, "DeprecationWarning");
              else {
                let f = new Error(c2);
                f.name = "DeprecationWarning", console.warn(new Error(c2));
              }
            }
            return y = Math.max(y, 0), u(l, { start: { column: y, line: p2 } }, h2);
          }
        } }), tu2 = te2({ "src/main/parser.js"(e, r) {
          ne2();
          var { ConfigError: t } = Qt2(), s2 = ut2();
          jm2();
          var { locStart: n, locEnd: u } = s2, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function p2(g) {
            let c2 = {};
            for (let f of g.plugins)
              if (f.parsers)
                for (let F of i(f.parsers))
                  Object.defineProperty(c2, F, l(f.parsers, F));
            return c2;
          }
          function y(g) {
            let c2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p2(g);
            if (typeof g.parser == "function")
              return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
            if (typeof g.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(c2, g.parser))
                return c2[g.parser];
              throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          function h2(g, c2) {
            let f = p2(c2), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
              return f[w].parse;
            } }]))), _ = y(c2, f);
            try {
              return _.preprocess && (g = _.preprocess(g, c2)), { text: g, ast: _.parse(g, F, c2) };
            } catch (w) {
              let { loc: E } = w;
              if (E) {
                let { codeFrameColumns: N } = Mm2();
                throw w.codeFrame = N(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
              }
              throw w;
            }
          }
          r.exports = { parse: h2, resolveParser: y };
        } }), uo2 = te2({ "src/main/options.js"(e, r) {
          ne2();
          var t = ZD2(), { UndefinedParserError: s2 } = Qt2(), { getSupportInfo: a2 } = Xn2(), n = Om2(), { resolveParser: u } = tu2(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h2) {
            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c2 = Object.assign({}, h2), f = a2({ plugins: h2.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x2) => x2.default !== void 0).map((x2) => [x2.name, x2.default])));
            if (!c2.parser) {
              if (!c2.filepath)
                (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c2.parser = "babel";
              else if (c2.parser = y(c2.filepath, c2.plugins), !c2.parser)
                throw new s2(`No parser could be inferred for file: ${c2.filepath}`);
            }
            let _ = u(n.normalizeApiOptions(c2, [f.find((x2) => x2.name === "parser")], { passThrough: true, logger: false }));
            c2.astFormat = _.astFormat, c2.locEnd = _.locEnd, c2.locStart = _.locStart;
            let w = p2(c2);
            c2.printer = w.printers[c2.astFormat];
            let E = Object.fromEntries(f.filter((x2) => x2.pluginDefaults && x2.pluginDefaults[w.name] !== void 0).map((x2) => [x2.name, x2.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, F), E);
            for (let [x2, I] of Object.entries(N))
              (c2[x2] === null || c2[x2] === void 0) && (c2[x2] = I);
            return c2.parser === "json" && (c2.trailingComma = "none"), n.normalizeApiOptions(c2, f, Object.assign({ passThrough: Object.keys(i) }, g));
          }
          function p2(h2) {
            let { astFormat: g } = h2;
            if (!g)
              throw new Error("getPlugin() requires astFormat to be set");
            let c2 = h2.plugins.find((f) => f.printers && f.printers[g]);
            if (!c2)
              throw new Error(`Couldn't find plugin for AST format "${g}"`);
            return c2;
          }
          function y(h2, g) {
            let c2 = t.basename(h2).toLowerCase(), F = a2({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c2.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c2));
            return F && F.parsers[0];
          }
          r.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
        } }), Rm2 = te2({ "src/main/massage-ast.js"(e, r) {
          ne2();
          function t(s2, a2, n) {
            if (Array.isArray(s2))
              return s2.map((p2) => t(p2, a2, n)).filter(Boolean);
            if (!s2 || typeof s2 != "object")
              return s2;
            let u = a2.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let l = {};
            for (let [p2, y] of Object.entries(s2))
              !i.has(p2) && typeof y != "function" && (l[p2] = t(y, a2, s2));
            if (u) {
              let p2 = u(s2, l, n);
              if (p2 === null)
                return;
              if (p2)
                return p2;
            }
            return l;
          }
          r.exports = t;
        } }), Zt2 = te2({ "scripts/build/shims/assert.cjs"(e, r) {
          ne2();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, r.exports = t;
        } }), et2 = te2({ "src/main/comments.js"(e, r) {
          ne2();
          var t = Zt2(), { builders: { line: s2, hardline: a2, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p2 } } = qe2(), { hasNewline: y, skipNewline: h2, skipSpaces: g, isPreviousLineEmpty: c2, addLeadingComment: f, addDanglingComment: F, addTrailingComment: _ } = Ue2(), w = /* @__PURE__ */ new WeakMap();
          function E(k, M, R) {
            if (!k)
              return;
            let { printer: q2, locStart: J, locEnd: L } = M;
            if (R) {
              if (q2.canAttachComment && q2.canAttachComment(k)) {
                let V;
                for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V)
                  ;
                R.splice(V + 1, 0, k);
                return;
              }
            } else if (w.has(k))
              return w.get(k);
            let Q = q2.getCommentChildNodes && q2.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [j] = V;
              return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
            }).map((V) => {
              let [, j] = V;
              return j;
            });
            if (Q) {
              R || (R = [], w.set(k, R));
              for (let V of Q)
                E(V, M, R);
              return R;
            }
          }
          function N(k, M, R, q2) {
            let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = E(k, R), Y, ie, ee = 0, ce = j.length;
            for (; ee < ce; ) {
              let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
              if (de <= Q && V <= ue)
                return N(K, M, R, K);
              if (ue <= Q) {
                Y = K, ee = W + 1;
                continue;
              }
              if (V <= de) {
                ie = K, ce = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q2 && q2.type === "TemplateLiteral") {
              let { quasis: W } = q2, K = C(W, M, R);
              Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
            }
            return { enclosingNode: q2, precedingNode: Y, followingNode: ie };
          }
          var x2 = () => false;
          function I(k, M, R, q2) {
            if (!Array.isArray(k))
              return;
            let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q2, { avoidAstMutation: j, ownLine: Y = x2, endOfLine: ie = x2, remaining: ee = x2 } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q2)), {}, { comment: W, text: R, options: q2, ast: M, isLastComment: k.length - 1 === K }));
            for (let [W, K] of ce.entries()) {
              let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(de) - L(se) <= 0) {
                  f(se, de);
                  continue;
                }
                if (Q(de) - Q(se) >= 0) {
                  _(se, de);
                  continue;
                }
              }
              let ge;
              if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $2(U, Z, ce, W))
                de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F(Fe || se, de));
              else if (D(U, Z, ce, W))
                de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de));
              else if (de.placement = "remaining", !ee(...ge))
                if (ue && z) {
                  let he = J.length;
                  he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
                } else
                  ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de);
            }
            if (T(J, R, q2), !j)
              for (let W of k)
                delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
          function $2(k, M, R, q2) {
            let { comment: J, precedingNode: L } = R[q2], { locStart: Q, locEnd: V } = M, j = Q(J);
            if (L)
              for (let Y = q2 - 1; Y >= 0; Y--) {
                let { comment: ie, precedingNode: ee } = R[Y];
                if (ee !== L || !P(k.slice(V(ie), j)))
                  break;
                j = Q(ie);
              }
            return y(k, j, { backwards: true });
          }
          function D(k, M, R, q2) {
            let { comment: J, followingNode: L } = R[q2], { locStart: Q, locEnd: V } = M, j = V(J);
            if (L)
              for (let Y = q2 + 1; Y < R.length; Y++) {
                let { comment: ie, followingNode: ee } = R[Y];
                if (ee !== L || !P(k.slice(j, Q(ie))))
                  break;
                j = V(ie);
              }
            return y(k, j);
          }
          function T(k, M, R) {
            let q2 = k.length;
            if (q2 === 0)
              return;
            let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
            for (Y = q2; Y > 0; --Y) {
              let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
              t.strictEqual(ee, J), t.strictEqual(ce, L);
              let W = M.slice(R.locEnd(ie), j);
              if (V.test(W))
                j = R.locStart(ie);
              else
                break;
            }
            for (let [ie, { comment: ee }] of k.entries())
              ie < Y ? _(J, ee) : f(L, ee);
            for (let ie of [J, L])
              ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
            k.length = 0;
          }
          function m2(k, M) {
            let R = k.getValue();
            return R.printed = true, M.printer.printComment(k, M);
          }
          function C(k, M, R) {
            let q2 = R.locStart(M) - 1;
            for (let J = 1; J < k.length; ++J)
              if (q2 < R.locStart(k[J]))
                return J - 1;
            return 0;
          }
          function o(k, M) {
            let R = k.getValue(), q2 = [m2(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
            if (J.isBlockComment && J.isBlockComment(R)) {
              let ie = y(L, V(R)) ? y(L, Q(R), { backwards: true }) ? a2 : s2 : " ";
              q2.push(ie);
            } else
              q2.push(a2);
            let Y = h2(L, g(L, V(R)));
            return Y !== false && y(L, Y) && q2.push(a2), q2;
          }
          function d(k, M) {
            let R = k.getValue(), q2 = m2(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
            if (y(L, Q(R), { backwards: true })) {
              let Y = c2(L, R, Q);
              return i([a2, Y ? a2 : "", q2]);
            }
            let j = [" ", q2];
            return V || (j = [i(j), n]), j;
          }
          function v(k, M, R, q2) {
            let J = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Q = k.getValue();
              !Q.leading && !Q.trailing && (!q2 || q2(Q)) && J.push(m2(k, M));
            }, "comments"), J.length === 0) ? "" : R ? l(a2, J) : u([a2, l(a2, J)]);
          }
          function S(k, M, R) {
            let q2 = k.getValue();
            if (!q2)
              return {};
            let J = q2.comments || [];
            R && (J = J.filter((j) => !R.has(j)));
            let L = q2 === M.cursorNode;
            if (J.length === 0) {
              let j = L ? p2 : "";
              return { leading: j, trailing: j };
            }
            let Q = [], V = [];
            return k.each(() => {
              let j = k.getValue();
              if (R && R.has(j))
                return;
              let { leading: Y, trailing: ie } = j;
              Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
            }, "comments"), L && (Q.unshift(p2), V.push(p2)), { leading: Q, trailing: V };
          }
          function b(k, M, R, q2) {
            let { leading: J, trailing: L } = S(k, R, q2);
            return !J && !L ? M : [J, M, L];
          }
          function B(k) {
            if (k)
              for (let M of k) {
                if (!M.printed)
                  throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                delete M.printed;
              }
          }
          r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
        } }), $m2 = te2({ "src/common/ast-path.js"(e, r) {
          ne2();
          var t = lt2();
          function s2(u, i) {
            let l = a2(u.stack, i);
            return l === -1 ? null : u.stack[l];
          }
          function a2(u, i) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let p2 = u[l];
              if (p2 && !Array.isArray(p2) && --i < 0)
                return l;
            }
            return -1;
          }
          var n = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: l } = i, p2 = t(i);
              for (var y = arguments.length, h2 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                h2[g - 1] = arguments[g];
              for (let f of h2)
                p2 = p2[f], i.push(f, p2);
              let c2 = u(this);
              return i.length = l, c2;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a2(this.stack, i + 1), p2 = this.stack.splice(l + 1), y = u(this);
              return this.stack.push(...p2), y;
            }
            each(u) {
              let { stack: i } = this, { length: l } = i, p2 = t(i);
              for (var y = arguments.length, h2 = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                h2[g - 1] = arguments[g];
              for (let c2 of h2)
                p2 = p2[c2], i.push(c2, p2);
              for (let c2 = 0; c2 < p2.length; ++c2)
                i.push(c2, p2[c2]), u(this, c2, p2), i.length -= 2;
              i.length = l;
            }
            map(u) {
              let i = [];
              for (var l = arguments.length, p2 = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                p2[y - 1] = arguments[y];
              return this.each((h2, g, c2) => {
                i[g] = u(h2, g, c2);
              }, ...p2), i;
            }
            try(u) {
              let { stack: i } = this, l = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, l = this.stack[u--];
              for (var p2 = arguments.length, y = new Array(p2), h2 = 0; h2 < p2; h2++)
                y[h2] = arguments[h2];
              for (let g of y) {
                if (l === void 0)
                  return false;
                let c2 = null;
                if (typeof i == "number" && (c2 = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c2))
                  return false;
                i = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, l = null, p2 = this.stack[i--];
              for (; p2; ) {
                let y = null;
                if (typeof l == "number" && (y = l, l = this.stack[i--], p2 = this.stack[i--]), l !== null && u(p2, l, y))
                  return p2;
                l = this.stack[i--], p2 = this.stack[i--];
              }
            }
          };
          r.exports = n;
        } }), Vm2 = te2({ "src/main/multiparser.js"(e, r) {
          ne2();
          var { utils: { stripTrailingHardline: t } } = qe2(), { normalize: s2 } = uo2(), a2 = et2();
          function n(i, l, p2, y) {
            if (p2.printer.embed && p2.embeddedLanguageFormatting === "auto")
              return p2.printer.embed(i, l, (h2, g, c2) => u(h2, g, p2, y, c2), p2);
          }
          function u(i, l, p2, y) {
            let { stripTrailingHardline: h2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s2(Object.assign(Object.assign(Object.assign({}, p2), l), {}, { parentParser: p2.parser, originalText: i }), { passThrough: true }), c2 = tu2().parse(i, g), { ast: f } = c2;
            i = c2.text;
            let F = f.comments;
            delete f.comments, a2.attach(F, f, i, g), g[Symbol.for("comments")] = F || [], g[Symbol.for("tokens")] = f.tokens || [];
            let _ = y(f, g);
            return a2.ensureAllCommentsPrinted(F), h2 ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
          }
          r.exports = { printSubtree: n };
        } }), Wm2 = te2({ "src/main/ast-to-doc.js"(e, r) {
          ne2();
          var t = $m2(), { builders: { hardline: s2, addAlignmentToDoc: a2 }, utils: { propagateBreaks: n } } = qe2(), { printComments: u } = et2(), i = Vm2();
          function l(h2, g) {
            let c2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
            f.preprocess && (h2 = f.preprocess(h2, g));
            let F = /* @__PURE__ */ new Map(), _ = new t(h2), w = E();
            return c2 > 0 && (w = a2([s2, w], c2, g.tabWidth)), n(w), w;
            function E(x2, I) {
              return x2 === void 0 || x2 === _ ? N(I) : Array.isArray(x2) ? _.call(() => N(I), ...x2) : _.call(() => N(I), x2);
            }
            function N(x2) {
              let I = _.getValue(), P = I && typeof I == "object" && x2 === void 0;
              if (P && F.has(I))
                return F.get(I);
              let $2 = y(_, g, E, x2);
              return P && F.set(I, $2), $2;
            }
          }
          function p2(h2, g) {
            let { originalText: c2, [Symbol.for("comments")]: f, locStart: F, locEnd: _ } = g, w = F(h2), E = _(h2), N = /* @__PURE__ */ new Set();
            for (let x2 of f)
              F(x2) >= w && _(x2) <= E && (x2.printed = true, N.add(x2));
            return { doc: c2.slice(w, E), printedComments: N };
          }
          function y(h2, g, c2, f) {
            let F = h2.getValue(), { printer: _ } = g, w, E;
            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h2))
              ({ doc: w, printedComments: E } = p2(F, g));
            else {
              if (F)
                try {
                  w = i.printSubtree(h2, c2, g, l);
                } catch (N) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw N;
                }
              w || (w = _.print(h2, g, c2, f));
            }
            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h2, g)) && (w = u(h2, w, g, E)), w;
          }
          r.exports = l;
        } }), Hm2 = te2({ "src/main/range-util.js"(e, r) {
          ne2();
          var t = Zt2(), s2 = et2(), a2 = (f) => {
            let { parser: F } = f;
            return F === "json" || F === "json5" || F === "json-stringify";
          };
          function n(f, F) {
            let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
            return _.find((E) => y.has(E.type) && w.has(E));
          }
          function u(f) {
            let F = f.length - 1;
            for (; ; ) {
              let _ = f[F];
              if (_ && (_.type === "Program" || _.type === "File"))
                F--;
              else
                break;
            }
            return f.slice(0, F + 1);
          }
          function i(f, F, _) {
            let { locStart: w, locEnd: E } = _, N = f.node, x2 = F.node;
            if (N === x2)
              return { startNode: N, endNode: x2 };
            let I = w(f.node);
            for (let $2 of u(F.parentNodes))
              if (w($2) >= I)
                x2 = $2;
              else
                break;
            let P = E(F.node);
            for (let $2 of u(f.parentNodes)) {
              if (E($2) <= P)
                N = $2;
              else
                break;
              if (N === x2)
                break;
            }
            return { startNode: N, endNode: x2 };
          }
          function l(f, F, _, w) {
            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x2, locEnd: I } = _, P = x2(f), $2 = I(f);
            if (!(F > $2 || F < P || N === "rangeEnd" && F === P || N === "rangeStart" && F === $2)) {
              for (let D of s2.getSortedChildNodes(f, _)) {
                let T = l(D, F, _, w, [f, ...E], N);
                if (T)
                  return T;
              }
              if (!w || w(f, E[0]))
                return { node: f, parentNodes: E };
            }
          }
          function p2(f, F) {
            return F !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g(f, F, _) {
            if (!F)
              return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return p2(F.type, _ && _.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y.has(F.type);
              case "graphql":
                return h2.has(F.kind);
              case "vue":
                return F.tag !== "root";
            }
            return false;
          }
          function c2(f, F, _) {
            let { rangeStart: w, rangeEnd: E, locStart: N, locEnd: x2 } = F;
            t.ok(E > w);
            let I = f.slice(w, E).search(/\S/), P = I === -1;
            if (!P)
              for (w += I; E > w && !/\S/.test(f[E - 1]); --E)
                ;
            let $2 = l(_, w, F, (C, o) => g(F, C, o), [], "rangeStart"), D = P ? $2 : l(_, E, F, (C) => g(F, C), [], "rangeEnd");
            if (!$2 || !D)
              return { rangeStart: 0, rangeEnd: 0 };
            let T, m2;
            if (a2(F)) {
              let C = n($2, D);
              T = C, m2 = C;
            } else
              ({ startNode: T, endNode: m2 } = i($2, D, F));
            return { rangeStart: Math.min(N(T), N(m2)), rangeEnd: Math.max(x2(T), x2(m2)) };
          }
          r.exports = { calculateRange: c2, findNodeAtOffset: l };
        } }), Gm2 = te2({ "src/main/core.js"(e, r) {
          ne2();
          var { diffArrays: t } = BD2(), { printer: { printDocToString: s2 }, debug: { printDocToDebug: a2 } } = qe2(), { getAlignmentSize: n } = Ue2(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p2 } = Jn2(), y = uo2().normalize, h2 = Rm2(), g = et2(), c2 = tu2(), f = Wm2(), F = Hm2(), _ = "\uFEFF", w = Symbol("cursor");
          function E(m2, C, o) {
            let d = C.comments;
            return d && (delete C.comments, g.attach(d, C, m2, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m2, d;
          }
          function N(m2, C) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m2 || m2.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d, text: v } = c2.parse(m2, C);
            if (C.cursorOffset >= 0) {
              let k = F.findNodeAtOffset(d, C.cursorOffset, C);
              k && k.node && (C.cursorNode = k.node);
            }
            let S = E(v, d, C), b = f(d, C, o), B = s2(b, C);
            if (g.ensureAllCommentsPrinted(S), o > 0) {
              let k = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
            }
            if (C.cursorOffset >= 0) {
              let k, M, R, q2, J;
              if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q2 = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q2 = 0, J = B.formatted), M === J)
                return { formatted: B.formatted, cursorOffset: q2 + R, comments: S };
              let L = [...M];
              L.splice(R, 0, w);
              let Q = [...J], V = t(L, Q), j = q2;
              for (let Y of V)
                if (Y.removed) {
                  if (Y.value.includes(w))
                    break;
                } else
                  j += Y.count;
              return { formatted: B.formatted, cursorOffset: j, comments: S };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: S };
          }
          function x2(m2, C) {
            let { ast: o, text: d } = c2.parse(m2, C), { rangeStart: v, rangeEnd: S } = F.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q2 = R.formatted.trimEnd(), { cursorOffset: J } = C;
            J > S ? J += q2.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
            let L = d.slice(0, v) + q2 + d.slice(S);
            if (C.endOfLine !== "lf") {
              let Q = i(C.endOfLine);
              J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
            }
            return { formatted: L, cursorOffset: J, comments: R.comments };
          }
          function I(m2, C, o) {
            return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m2.length ? o : C;
          }
          function P(m2, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
            return o = I(m2, o, -1), d = I(m2, d, 0), v = I(m2, v, m2.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
          }
          function $2(m2, C) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m2, C), b = m2.charAt(0) === _;
            if (b && (m2 = m2.slice(1), o--, d--, v--), S === "auto" && (S = u(m2)), m2.includes("\r")) {
              let B = (k) => l(m2.slice(0, Math.max(k, 0)), `\r
`);
              o -= B(o), d -= B(d), v -= B(v), m2 = p2(m2);
            }
            return { hasBOM: b, text: m2, options: P(m2, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
          }
          function D(m2, C) {
            let o = c2.resolveParser(C);
            return !o.hasPragma || o.hasPragma(m2);
          }
          function T(m2, C) {
            let { hasBOM: o, text: d, options: v } = $2(m2, y(C));
            if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v))
              return { formatted: m2, cursorOffset: C.cursorOffset, comments: [] };
            let S;
            return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x2(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
          }
          r.exports = { formatWithCursor: T, parse(m2, C, o) {
            let { text: d, options: v } = $2(m2, y(C)), S = c2.parse(d, v);
            return o && (S.ast = h2(S.ast, v)), S;
          }, formatAST(m2, C) {
            C = y(C);
            let o = f(m2, C);
            return s2(o, C);
          }, formatDoc(m2, C) {
            return T(a2(m2), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m2, C) {
            C = y(C);
            let { ast: o, text: d } = c2.parse(m2, C);
            return E(d, o, C), f(o, C);
          }, printDocToString(m2, C) {
            return s2(m2, y(C));
          } };
        } }), Um2 = te2({ "src/common/util-shared.js"(e, r) {
          ne2();
          var { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p2, skipToLineEnd: y, skipEverythingButNewLine: h2, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D } = Ue2();
          r.exports = { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p2, skipToLineEnd: y, skipEverythingButNewLine: h2, skipInlineComment: g, skipTrailingComment: c2, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x2, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D };
        } }), _t2 = te2({ "src/utils/create-language.js"(e, r) {
          ne2(), r.exports = function(t, s2) {
            let { languageId: a2 } = t, n = Hn2(t, CD2);
            return Object.assign(Object.assign({ linguistLanguageId: a2 }, n), s2(t));
          };
        } }), Jm2 = te2({ "node_modules/esutils/lib/ast.js"(e, r) {
          ne2(), function() {
            function t(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s2(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a2(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function n(l) {
              return a2(l) || l != null && l.type === "FunctionDeclaration";
            }
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            function i(l) {
              var p2;
              if (l.type !== "IfStatement" || l.alternate == null)
                return false;
              p2 = l.consequent;
              do {
                if (p2.type === "IfStatement" && p2.alternate == null)
                  return true;
                p2 = u(p2);
              } while (p2);
              return false;
            }
            r.exports = { isExpression: t, isStatement: a2, isIterationStatement: s2, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
          }();
        } }), so2 = te2({ "node_modules/esutils/lib/code.js"(e, r) {
          ne2(), function() {
            var t, s2, a2, n, u, i;
            s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(E) {
              return 48 <= E && E <= 57;
            }
            function p2(E) {
              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
            }
            function y(E) {
              return E >= 48 && E <= 55;
            }
            a2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h2(E) {
              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a2.indexOf(E) >= 0;
            }
            function g(E) {
              return E === 10 || E === 13 || E === 8232 || E === 8233;
            }
            function c2(E) {
              if (E <= 65535)
                return String.fromCharCode(E);
              var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x2 = String.fromCharCode((E - 65536) % 1024 + 56320);
              return N + x2;
            }
            for (n = new Array(128), i = 0; i < 128; ++i)
              n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i)
              u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function f(E) {
              return E < 128 ? n[E] : s2.NonAsciiIdentifierStart.test(c2(E));
            }
            function F(E) {
              return E < 128 ? u[E] : s2.NonAsciiIdentifierPart.test(c2(E));
            }
            function _(E) {
              return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c2(E));
            }
            function w(E) {
              return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c2(E));
            }
            r.exports = { isDecimalDigit: l, isHexDigit: p2, isOctalDigit: y, isWhiteSpace: h2, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
          }();
        } }), zm2 = te2({ "node_modules/esutils/lib/keyword.js"(e, r) {
          ne2(), function() {
            var t = so2();
            function s2(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a2(f, F) {
              return !F && f === "yield" ? false : n(f, F);
            }
            function n(f, F) {
              if (F && s2(f))
                return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, F) {
              return f === "null" || f === "true" || f === "false" || a2(f, F);
            }
            function i(f, F) {
              return f === "null" || f === "true" || f === "false" || n(f, F);
            }
            function l(f) {
              return f === "eval" || f === "arguments";
            }
            function p2(f) {
              var F, _, w;
              if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w)))
                return false;
              for (F = 1, _ = f.length; F < _; ++F)
                if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w))
                  return false;
              return true;
            }
            function y(f, F) {
              return (f - 55296) * 1024 + (F - 56320) + 65536;
            }
            function h2(f) {
              var F, _, w, E, N;
              if (f.length === 0)
                return false;
              for (N = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {
                if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {
                  if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343)))
                    return false;
                  w = y(w, E);
                }
                if (!N(w))
                  return false;
                N = t.isIdentifierPartES6;
              }
              return true;
            }
            function g(f, F) {
              return p2(f) && !u(f, F);
            }
            function c2(f, F) {
              return h2(f) && !i(f, F);
            }
            r.exports = { isKeywordES5: a2, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p2, isIdentifierNameES6: h2, isIdentifierES5: g, isIdentifierES6: c2 };
          }();
        } }), Xm2 = te2({ "node_modules/esutils/lib/utils.js"(e) {
          ne2(), function() {
            e.ast = Jm2(), e.code = so2(), e.keyword = zm2();
          }();
        } }), Pt = te2({ "src/language-js/utils/is-block-comment.js"(e, r) {
          ne2();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s2 = (a2) => t.has(a2 == null ? void 0 : a2.type);
          r.exports = s2;
        } }), Km2 = te2({ "src/language-js/utils/is-node-matches.js"(e, r) {
          ne2();
          function t(a2, n) {
            let u = n.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let l = u[i];
              if (i === 0)
                return a2.type === "Identifier" && a2.name === l;
              if (a2.type !== "MemberExpression" || a2.optional || a2.computed || a2.property.type !== "Identifier" || a2.property.name !== l)
                return false;
              a2 = a2.object;
            }
          }
          function s2(a2, n) {
            return n.some((u) => t(a2, u));
          }
          r.exports = s2;
        } }), Ke2 = te2({ "src/language-js/utils/index.js"(e, r) {
          ne2();
          var t = Xm2().keyword.isIdentifierNameES5, { getLast: s2, hasNewline: a2, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue2(), { locStart: p2, locEnd: y, hasSameLocStart: h2 } = ut2(), g = Pt(), c2 = Km2(), f = "(?:(?=.)\\s)", F = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
          function w(O) {
            var me, _e;
            return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);
          }
          function E(O) {
            let me = O == null ? void 0 : O[0];
            return g(me) && _.test(me.value);
          }
          function N(O, me) {
            if (!O || typeof O != "object")
              return false;
            if (Array.isArray(O))
              return O.some((He) => N(He, me));
            let _e = me(O);
            return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
          }
          function x2(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
          }
          function I(O) {
            var me, _e, He, Ge, it, Qe;
            return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
          }
          function P(O, me) {
            if (me.expressions)
              return ["expressions", 0];
            if (me.left)
              return ["left"];
            if (me.test)
              return ["test"];
            if (me.object)
              return ["object"];
            if (me.callee)
              return ["callee"];
            if (me.tag)
              return ["tag"];
            if (me.argument)
              return ["argument"];
            if (me.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function $2(O) {
            return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
          }
          var D = $2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m2(O) {
            let me = O.getParentNode();
            return O.getName() === "declaration" && T(me) ? me : null;
          }
          var C = $2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function d(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
          }
          function v(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var S = $2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $2(["FunctionExpression", "ArrowFunctionExpression"]);
          function B(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function k(O) {
            return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M = $2(["JSXElement", "JSXFragment"]);
          function R(O, me) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
              return false;
            let _e = me.getNode();
            if (!_e.expression || !M(_e.expression))
              return false;
            let He = me.getParentNode();
            return He.type === "Program" && He.body.length === 1;
          }
          function q2(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function J(O) {
            return q2(O) || h2(O, O.value);
          }
          function L(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
          }
          function Q(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h2(O, O.typeAnnotation);
          }
          var V = $2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function j(O) {
            return ue(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ie(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
          }
          function ee(O) {
            let me = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
          }
          var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return c2(O, ce);
          }
          function K(O, me) {
            if (O.type !== "CallExpression")
              return false;
            if (O.arguments.length === 1) {
              if (k(O) && me && K(me))
                return b(O.arguments[0]);
              if (ee(O))
                return k(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee))
              return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
            return false;
          }
          var de = $2(["CallExpression", "OptionalCallExpression"]), ue = $2(["MemberExpression", "OptionalMemberExpression"]);
          function Fe(O) {
            let me = "expressions";
            O.type === "TSTemplateLiteralType" && (me = "types");
            let _e = O[me];
            return _e.length === 0 ? false : _e.every((He) => {
              if (Me(He))
                return false;
              if (He.type === "Identifier" || He.type === "ThisExpression")
                return true;
              if (ue(He)) {
                let Ge = He;
                for (; ue(Ge); )
                  if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge)))
                    return false;
                return Ge.type === "Identifier" || Ge.type === "ThisExpression";
              }
              return false;
            });
          }
          function z(O, me) {
            return O === "+" || O === "-" ? O + me : me;
          }
          function U(O, me) {
            let _e = p2(me), He = n(O, y(me));
            return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
          }
          function Z(O, me) {
            return M(me) ? Oe(me) : Me(me, Te2.Leading, (_e) => a2(O, y(_e)));
          }
          function se(O, me) {
            return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
          }
          function fe(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function ge(O, me) {
            let _e = /^[fx]?(?:describe|it|test)$/;
            return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
          }
          function he(O) {
            return O.quasis.some((me) => me.value.raw.includes(`
`));
          }
          function we(O, me) {
            return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a2(me, p2(O), { backwards: true });
          }
          function ke(O) {
            if (!Me(O))
              return false;
            let me = s2(ae(O, Te2.Dangling));
            return me && !g(me);
          }
          function Re(O) {
            if (O.length <= 1)
              return false;
            let me = 0;
            for (let _e of O)
              if (b(_e)) {
                if (me += 1, me > 1)
                  return true;
              } else if (de(_e)) {
                for (let He of _e.arguments)
                  if (b(He))
                    return true;
              }
            return false;
          }
          function Ne(O) {
            let me = O.getValue(), _e = O.getParentNode();
            return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
          }
          function Pe(O, me) {
            if (me >= 2)
              return false;
            let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            if (He && l(He) > 5)
              return false;
            if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
              return true;
            if (O.type === "TemplateLiteral")
              return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
            if (O.type === "ObjectExpression")
              return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
            if (O.type === "ArrayExpression")
              return O.elements.every((Qe) => Qe === null || _e(Qe));
            if (tt(O))
              return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
            if (ue(O))
              return Pe(O.object, me) && Pe(O.property, me);
            let Ge = { "!": true, "-": true, "+": true, "~": true };
            if (O.type === "UnaryExpression" && Ge[O.operator])
              return Pe(O.argument, me);
            let it = { "++": true, "--": true };
            return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
          }
          function oe(O) {
            var me, _e;
            return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
          }
          function H(O) {
            return O;
          }
          function pe(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function X(O) {
            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
          }
          function le(O, me) {
            switch (O.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
              case "NGPipeExpression":
                return le(O.left, me);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return le(O.object, me);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
              case "ConditionalExpression":
                return le(O.test, me);
              case "UpdateExpression":
                return !O.prefix && le(O.argument, me);
              case "BindExpression":
                return O.object && le(O.object, me);
              case "SequenceExpression":
                return le(O.expressions[0], me);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return le(O.expression, me);
              default:
                return me(O);
            }
          }
          var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
          function A(O, me) {
            return !(re2(me) !== re2(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
          }
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
          function re2(O) {
            return G.get(O);
          }
          function ye(O) {
            return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
          }
          function Ce(O) {
            var me;
            if (O.rest)
              return true;
            let _e = ve(O);
            return ((me = s2(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
          }
          var Be = /* @__PURE__ */ new WeakMap();
          function ve(O) {
            if (Be.has(O))
              return Be.get(O);
            let me = [];
            return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
          }
          function ze(O, me) {
            let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
            _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
          }
          var be = /* @__PURE__ */ new WeakMap();
          function Ye(O) {
            if (be.has(O))
              return be.get(O);
            let me = O.arguments;
            return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
          }
          function Se(O, me) {
            let _e = O.getValue();
            _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
          }
          function Ie(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Oe(O) {
            return O && (O.prettierIgnore || Me(O, Te2.PrettierIgnore));
          }
          function Je(O) {
            let me = O.getValue();
            return Oe(me);
          }
          var Te2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
            if (typeof O == "function" && (me = O, O = 0), O || me)
              return (_e, He, Ge) => !(O & Te2.Leading && !_e.leading || O & Te2.Trailing && !_e.trailing || O & Te2.Dangling && (_e.leading || _e.trailing) || O & Te2.Block && !g(_e) || O & Te2.Line && !D(_e) || O & Te2.First && He !== 0 || O & Te2.Last && He !== Ge.length - 1 || O & Te2.PrettierIgnore && !Ie(_e) || me && !me(_e));
          };
          function Me(O, me, _e) {
            if (!u(O == null ? void 0 : O.comments))
              return false;
            let He = je(me, _e);
            return He ? O.comments.some(He) : true;
          }
          function ae(O, me, _e) {
            if (!Array.isArray(O == null ? void 0 : O.comments))
              return [];
            let He = je(me, _e);
            return He ? O.comments.filter(He) : O.comments;
          }
          var nt = (O, me) => {
            let { originalText: _e } = me;
            return i(_e, y(O));
          };
          function tt(O) {
            return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function Ve(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function We(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var Xe = Symbol("ifWithoutBlockAndSameLineComment");
          function st(O) {
            return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
          }
          r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m2, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x2, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q2, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re2, hasComment: Me, getComments: ae, CommentCheckFlags: Te2, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
        } }), jt2 = te2({ "src/language-js/print/template-literal.js"(e, r) {
          ne2();
          var t = lt2(), { getStringWidth: s2, getIndentSize: a2 } = Ue2(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p2, align: y, lineSuffixBoundary: h2, addAlignmentToDoc: g }, printer: { printDocToString: c2 }, utils: { mapDoc: f } } = qe2(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N, isTSTypeExpression: x2 } = Ke2();
          function I(C, o, d) {
            let v = C.getValue();
            if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
              let R = P(C, d, o);
              if (R)
                return R;
            }
            let b = "expressions";
            v.type === "TSTemplateLiteralType" && (b = "types");
            let B = [], k = C.map(o, b), M = w(v);
            return M && (k = k.map((R) => c2(R, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h2, "`"), C.each((R) => {
              let q2 = R.getName();
              if (B.push(o()), q2 < k.length) {
                let { tabWidth: J } = d, L = R.getValue(), Q = a2(L.value.raw, J), V = k[q2];
                if (!M) {
                  let Y = v[b][q2];
                  (E(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x2(Y) || F(Y)) && (V = [p2([i, V]), i]);
                }
                let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                B.push(l(["${", j, h2, "}"]));
              }
            }, "quasis"), B.push("`"), B;
          }
          function P(C, o, d) {
            let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (S.length > 1 || S.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = C.map(d, "expressions");
              o.__inJestEach = false;
              let B = [], k = b.map((L) => "${" + c2(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < v.quasis.length; L++) {
                let Q = t(M), V = k[L - 1];
                Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
              }
              let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q2 = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
                for (let [Q, V] of L.entries())
                  q2[Q] = Math.max(q2[Q], s2(V));
              return B.push(h2, "`", p2([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q2[V] - s2(Q))))))]), u, "`"), B;
            }
          }
          function $2(C, o) {
            let d = C.getValue(), v = o();
            return E(d) && (v = l([p2([i, v]), i])), ["${", v, h2, "}"];
          }
          function D(C, o) {
            return C.map((d) => $2(d, o), "expressions");
          }
          function T(C, o) {
            return f(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m2(d) : d);
          }
          function m2(C) {
            return C.replace(/([\\`]|\${)/g, "\\$1");
          }
          r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m2 };
        } }), Ym2 = te2({ "src/language-js/embed/markdown.js"(e, r) {
          ne2();
          var { builders: { indent: t, softline: s2, literalline: a2, dedentToRoot: n } } = qe2(), { escapeTemplateCharacters: u } = jt2();
          function i(p2, y, h2) {
            let c2 = p2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c2), F = f !== "";
            F && (c2 = c2.replace(new RegExp(`^${f}`, "gm"), ""));
            let _ = u(h2(c2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", F ? t([s2, _]) : [a2, n(_)], s2, "`"];
          }
          function l(p2) {
            let y = p2.match(/^([^\S\n]*)\S/m);
            return y === null ? "" : y[1];
          }
          r.exports = i;
        } }), Qm2 = te2({ "src/language-js/embed/css.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s2, hardline: a2, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe2(), { printTemplateExpressions: p2 } = jt2();
          function y(c2, f, F) {
            let _ = c2.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N = w.reduce((P, $2, D) => D === 0 ? $2 : P + "@prettier-placeholder-" + E++ + "-id" + $2, ""), x2 = F(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p2(c2, f);
            return h2(x2, _, I);
          }
          function h2(c2, f, F) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
              return "``";
            let w = g(c2, F);
            if (!w)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s2([a2, w]), n, "`"];
          }
          function g(c2, f) {
            if (!t(f))
              return c2;
            let F = 0, _ = u(l(c2), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f[E])));
            return f.length === F ? _ : null;
          }
          r.exports = y;
        } }), Zm2 = te2({ "src/language-js/embed/graphql.js"(e, r) {
          ne2();
          var { builders: { indent: t, join: s2, hardline: a2 } } = qe2(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt2();
          function i(p2, y, h2) {
            let g = p2.getValue(), c2 = g.quasis.length;
            if (c2 === 1 && g.quasis[0].value.raw.trim() === "")
              return "``";
            let f = u(p2, y), F = [];
            for (let _ = 0; _ < c2; _++) {
              let w = g.quasis[_], E = _ === 0, N = _ === c2 - 1, x2 = w.value.cooked, I = x2.split(`
`), P = I.length, $2 = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m2 = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!N && /#[^\n\r]*$/.test(I[P - 1]))
                return null;
              let C = null;
              m2 ? C = l(I) : C = h2(x2, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F.push(""), F.push(C), !N && T && F.push("")) : !E && !N && D && F.push(""), $2 && F.push($2);
            }
            return ["`", t([a2, s2(a2, F)]), a2, "`"];
          }
          function l(p2) {
            let y = [], h2 = false, g = p2.map((c2) => c2.trim());
            for (let [c2, f] of g.entries())
              f !== "" && (g[c2 - 1] === "" && h2 ? y.push([a2, f]) : y.push(f), h2 = true);
            return y.length === 0 ? null : s2(a2, y);
          }
          r.exports = i;
        } }), ed2 = te2({ "src/language-js/embed/html.js"(e, r) {
          ne2();
          var { builders: { indent: t, line: s2, hardline: a2, group: n }, utils: { mapDoc: u } } = qe2(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt2(), p2 = 0;
          function y(h2, g, c2, f, F) {
            let { parser: _ } = F, w = h2.getValue(), E = p2;
            p2 = p2 + 1 >>> 0;
            let N = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x2 = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(""), I = i(h2, g);
            if (I.length === 0 && x2.trim().length === 0)
              return "``";
            let P = new RegExp(N("(\\d+)"), "g"), $2 = 0, D = c2(x2, { parser: _, __onHtmlRoot(d) {
              $2 = d.children.length;
            } }, { stripTrailingHardline: true }), T = u(D, (d) => {
              if (typeof d != "string")
                return d;
              let v = [], S = d.split(P);
              for (let b = 0; b < S.length; b++) {
                let B = S[b];
                if (b % 2 === 0) {
                  B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                  continue;
                }
                let k = Number(B);
                v.push(I[k]);
              }
              return v;
            }), m2 = /^\s/.test(x2) ? " " : "", C = /\s$/.test(x2) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a2 : m2 && C ? s2 : null;
            return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m2, $2 > 1 ? t(n(T)) : n(T), C, "`"]);
          }
          r.exports = y;
        } }), td2 = te2({ "src/language-js/embed.js"(e, r) {
          ne2();
          var { hasComment: t, CommentCheckFlags: s2, isObjectProperty: a2 } = Ke2(), n = Ym2(), u = Qm2(), i = Zm2(), l = ed2();
          function p2(D) {
            if (g(D) || _(D) || w(D) || c2(D))
              return "css";
            if (x2(D))
              return "graphql";
            if (P(D))
              return "html";
            if (f(D))
              return "angular";
            if (h2(D))
              return "markdown";
          }
          function y(D, T, m2, C) {
            let o = D.getValue();
            if (o.type !== "TemplateLiteral" || $2(o))
              return;
            let d = p2(D);
            if (d) {
              if (d === "markdown")
                return n(D, T, m2);
              if (d === "css")
                return u(D, T, m2);
              if (d === "graphql")
                return i(D, T, m2);
              if (d === "html" || d === "angular")
                return l(D, T, m2, C, { parser: d });
            }
          }
          function h2(D) {
            let T = D.getValue(), m2 = D.getParentNode();
            return m2 && m2.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m2.tag.type === "Identifier" && (m2.tag.name === "md" || m2.tag.name === "markdown");
          }
          function g(D) {
            let T = D.getValue(), m2 = D.getParentNode(), C = D.getParentNode(1);
            return C && T.quasis && m2.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "Identifier" && m2.tag.name === "css" || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "MemberExpression" && m2.tag.object.name === "css" && (m2.tag.property.name === "global" || m2.tag.property.name === "resolve");
          }
          function c2(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m2) => T.type === "ArrayExpression" && m2 === "elements", (T, m2) => a2(T) && T.key.type === "Identifier" && T.key.name === "styles" && m2 === "value", ...F);
          }
          function f(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m2) => a2(T) && T.key.type === "Identifier" && T.key.name === "template" && m2 === "value", ...F);
          }
          var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
          function _(D) {
            let T = D.getParentNode();
            if (!T || T.type !== "TaggedTemplateExpression")
              return false;
            let m2 = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
            switch (m2.type) {
              case "MemberExpression":
                return E(m2.object) || N(m2);
              case "CallExpression":
                return E(m2.callee) || m2.callee.type === "MemberExpression" && (m2.callee.object.type === "MemberExpression" && (E(m2.callee.object.object) || N(m2.callee.object)) || m2.callee.object.type === "CallExpression" && E(m2.callee.object.callee));
              case "Identifier":
                return m2.name === "css";
              default:
                return false;
            }
          }
          function w(D) {
            let T = D.getParentNode(), m2 = D.getParentNode(1);
            return m2 && T.type === "JSXExpressionContainer" && m2.type === "JSXAttribute" && m2.name.type === "JSXIdentifier" && m2.name.name === "css";
          }
          function E(D) {
            return D.type === "Identifier" && D.name === "styled";
          }
          function N(D) {
            return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
          }
          function x2(D) {
            let T = D.getValue(), m2 = D.getParentNode();
            return I(T, "GraphQL") || m2 && (m2.type === "TaggedTemplateExpression" && (m2.tag.type === "MemberExpression" && m2.tag.object.name === "graphql" && m2.tag.property.name === "experimental" || m2.tag.type === "Identifier" && (m2.tag.name === "gql" || m2.tag.name === "graphql")) || m2.type === "CallExpression" && m2.callee.type === "Identifier" && m2.callee.name === "graphql");
          }
          function I(D, T) {
            return t(D, s2.Block | s2.Leading, (m2) => {
              let { value: C } = m2;
              return C === ` ${T} `;
            });
          }
          function P(D) {
            return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m2) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m2 === "quasi");
          }
          function $2(D) {
            let { quasis: T } = D;
            return T.some((m2) => {
              let { value: { cooked: C } } = m2;
              return C === null;
            });
          }
          r.exports = y;
        } }), rd2 = te2({ "src/language-js/clean.js"(e, r) {
          ne2();
          var t = Pt(), s2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a2 = (u) => {
            for (let i of u.quasis)
              delete i.value;
          };
          function n(u, i, l) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h2) => h2.name.name === "jsx"))
              for (let { type: h2, expression: g } of i.children)
                h2 === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a2(g);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a2(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let p2 = u.expression || u.callee;
            if (u.type === "Decorator" && p2.type === "CallExpression" && p2.callee.name === "Component" && p2.arguments.length === 1) {
              let h2 = u.expression.arguments[0].properties;
              for (let [g, c2] of i.expression.arguments[0].properties.entries())
                switch (h2[g].key.name) {
                  case "styles":
                    c2.value.type === "ArrayExpression" && a2(c2.value.elements[0]);
                    break;
                  case "template":
                    c2.value.type === "TemplateLiteral" && a2(c2.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a2(i.quasi), u.type === "TemplateLiteral") {
              var y;
              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((c2) => g.value === ` ${c2} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a2(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i.types[0];
          }
          n.ignoredProperties = s2, r.exports = n;
        } }), io2 = {};
        Kt2(io2, { EOL: () => Wn2, arch: () => nd2, cpus: () => Do2, default: () => vo2, endianness: () => ao2, freemem: () => po2, getNetworkInterfaces: () => ho2, hostname: () => oo2, loadavg: () => lo2, networkInterfaces: () => yo2, platform: () => ud2, release: () => go2, tmpDir: () => $n2, tmpdir: () => Vn2, totalmem: () => fo2, type: () => mo2, uptime: () => co2 });
        function ao2() {
          if (typeof Tr2 > "u") {
            var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
            if (r[0] = 1, r[1] = 2, t[0] === 258)
              Tr2 = "BE";
            else if (t[0] === 513)
              Tr2 = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Tr2;
        }
        function oo2() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function lo2() {
          return [];
        }
        function co2() {
          return 0;
        }
        function po2() {
          return Number.MAX_VALUE;
        }
        function fo2() {
          return Number.MAX_VALUE;
        }
        function Do2() {
          return [];
        }
        function mo2() {
          return "Browser";
        }
        function go2() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function yo2() {
        }
        function ho2() {
        }
        function nd2() {
          return "javascript";
        }
        function ud2() {
          return "browser";
        }
        function $n2() {
          return "/tmp";
        }
        var Tr2, Vn2, Wn2, vo2, sd2 = ht2({ "node-modules-polyfills:os"() {
          ne2(), Vn2 = $n2, Wn2 = `
`, vo2 = { EOL: Wn2, tmpdir: Vn2, tmpDir: $n2, networkInterfaces: yo2, getNetworkInterfaces: ho2, release: go2, type: mo2, cpus: Do2, totalmem: fo2, freemem: po2, uptime: co2, loadavg: lo2, hostname: oo2, endianness: ao2 };
        } }), id2 = te2({ "node-modules-polyfills-commonjs:os"(e, r) {
          ne2();
          var t = (sd2(), ft2(io2));
          if (t && t.default) {
            r.exports = t.default;
            for (let s2 in t)
              r.exports[s2] = t[s2];
          } else
            t && (r.exports = t);
        } }), ad2 = te2({ "node_modules/detect-newline/index.js"(e, r) {
          ne2();
          var t = (s2) => {
            if (typeof s2 != "string")
              throw new TypeError("Expected a string");
            let a2 = s2.match(/(?:\r?\n)/g) || [];
            if (a2.length === 0)
              return;
            let n = a2.filter((i) => i === `\r
`).length, u = a2.length - n;
            return n > u ? `\r
` : `
`;
          };
          r.exports = t, r.exports.graceful = (s2) => typeof s2 == "string" && t(s2) || `
`;
        } }), od2 = te2({ "node_modules/jest-docblock/build/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c2, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f;
          function r() {
            let N = id2();
            return r = function() {
              return N;
            }, N;
          }
          function t() {
            let N = s2(ad2());
            return t = function() {
              return N;
            }, N;
          }
          function s2(N) {
            return N && N.__esModule ? N : { default: N };
          }
          var a2 = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h2 = /(\r?\n|^) *\* ?/g, g = [];
          function c2(N) {
            let x2 = N.match(u);
            return x2 ? x2[0].trimLeft() : "";
          }
          function f(N) {
            let x2 = N.match(u);
            return x2 && x2[0] ? N.substring(x2[0].length) : N;
          }
          function F(N) {
            return _(N).pragmas;
          }
          function _(N) {
            let x2 = (0, t().default)(N) || r().EOL;
            N = N.replace(n, "").replace(a2, "").replace(h2, "$1");
            let I = "";
            for (; I !== N; )
              I = N, N = N.replace(p2, `${x2}$1 $2${x2}`);
            N = N.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $2 = N.replace(y, "").replace(l, "").trimRight(), D;
            for (; D = y.exec(N); ) {
              let T = D[2].replace(i, "");
              typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
            }
            return { comments: $2, pragmas: P };
          }
          function w(N) {
            let { comments: x2 = "", pragmas: I = {} } = N, P = (0, t().default)(x2) || r().EOL, $2 = "/**", D = " *", T = " */", m2 = Object.keys(I), C = m2.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
            if (!x2) {
              if (m2.length === 0)
                return "";
              if (m2.length === 1 && !Array.isArray(I[m2[0]])) {
                let d = I[m2[0]];
                return `${$2} ${E(m2[0], d)[0]}${T}`;
              }
            }
            let o = x2.split(P).map((d) => `${D} ${d}`).join(P) + P;
            return $2 + P + (x2 ? o : "") + (x2 && m2.length ? D + P : "") + C + T;
          }
          function E(N, x2) {
            return g.concat(x2).map((I) => `@${N} ${I}`.trim());
          }
        } }), ld2 = te2({ "src/language-js/utils/get-shebang.js"(e, r) {
          ne2();
          function t(s2) {
            if (!s2.startsWith("#!"))
              return "";
            let a2 = s2.indexOf(`
`);
            return a2 === -1 ? s2 : s2.slice(0, a2);
          }
          r.exports = t;
        } }), Co2 = te2({ "src/language-js/pragma.js"(e, r) {
          ne2();
          var { parseWithComments: t, strip: s2, extract: a2, print: n } = od2(), { normalizeEndOfLine: u } = Jn2(), i = ld2();
          function l(h2) {
            let g = i(h2);
            g && (h2 = h2.slice(g.length + 1));
            let c2 = a2(h2), { pragmas: f, comments: F } = t(c2);
            return { shebang: g, text: h2, pragmas: f, comments: F };
          }
          function p2(h2) {
            let g = Object.keys(l(h2).pragmas);
            return g.includes("prettier") || g.includes("format");
          }
          function y(h2) {
            let { shebang: g, text: c2, pragmas: f, comments: F } = l(h2), _ = s2(c2), w = n({ pragmas: Object.assign({ format: "" }, f), comments: F.trimStart() });
            return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
          }
          r.exports = { hasPragma: p2, insertPragma: y };
        } }), cd2 = te2({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
          ne2();
          var t = Pt();
          function s2(a2) {
            return t(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/.test(a2.value);
          }
          r.exports = s2;
        } }), Eo2 = te2({ "src/language-js/comments.js"(e, r) {
          ne2();
          var { getLast: t, hasNewline: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a2, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p2, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h2 } = Ue2(), { getFunctionParameters: g, isPrettierIgnoreComment: c2, isJsxNode: f, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isLineComment: $2, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m2 } = Ke2(), { locStart: C, locEnd: o } = ut2(), d = Pt(), v = cd2();
          function S(De) {
            return [H, Fe, Q, q2, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
          }
          function b(De) {
            return [R, Fe, V, we, q2, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A) => A(De));
          }
          function B(De) {
            return [H, q2, J, j, ue, ce, ge, de, K, pe, U, oe].some((A) => A(De));
          }
          function k(De, A) {
            let G = (De.body || De.properties).find((re2) => {
              let { type: ye } = re2;
              return ye !== "EmptyStatement";
            });
            G ? i(G, A) : p2(De, A);
          }
          function M(De, A) {
            De.type === "BlockStatement" ? k(De, A) : i(De, A);
          }
          function R(De) {
            let { comment: A, followingNode: G } = De;
            return G && v(A) ? (i(G, A), true) : false;
          }
          function q2(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
            if ((re2 == null ? void 0 : re2.type) !== "IfStatement" || !ye)
              return false;
            if (n(Ce, A, o) === ")")
              return l(G, A), true;
            if (G === re2.consequent && ye === re2.alternate) {
              if (G.type === "BlockStatement")
                l(G, A);
              else {
                let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                ve && ze ? p2(G, A, m2) : p2(re2, A);
              }
              return true;
            }
            return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re2.consequent === ye ? (i(ye, A), true) : false;
          }
          function J(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
            return (re2 == null ? void 0 : re2.type) !== "WhileStatement" || !ye ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re2.body === ye ? (i(ye, A), true) : false;
          }
          function L(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
            return (re2 == null ? void 0 : re2.type) !== "TryStatement" && (re2 == null ? void 0 : re2.type) !== "CatchClause" || !ye ? false : re2.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
          }
          function Q(De) {
            let { comment: A, enclosingNode: G, followingNode: re2 } = De;
            return I(G) && (re2 == null ? void 0 : re2.type) === "Identifier" ? (i(G, A), true) : false;
          }
          function V(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
            return (!G || !Be) && ((re2 == null ? void 0 : re2.type) === "ConditionalExpression" || (re2 == null ? void 0 : re2.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
          }
          function j(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2 } = De;
            return P(re2) && re2.shorthand && re2.key === G && re2.value.type === "AssignmentPattern" ? (l(re2.value.left, A), true) : false;
          }
          var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function ie(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
            if (Y.has(re2 == null ? void 0 : re2.type)) {
              if (h2(re2.decorators) && !(ye && ye.type === "Decorator"))
                return l(t(re2.decorators), A), true;
              if (re2.body && ye === re2.body)
                return k(re2.body, A), true;
              if (ye) {
                if (re2.superClass && ye === re2.superClass && G && (G === re2.id || G === re2.typeParameters))
                  return l(G, A), true;
                for (let Ce of ["implements", "extends", "mixins"])
                  if (re2[Ce] && ye === re2[Ce][0])
                    return G && (G === re2.id || G === re2.typeParameters || G === re2.superClass) ? l(G, A) : p2(re2, A, Ce), true;
              }
            }
            return false;
          }
          var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
          function ce(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
            return re2 && G && n(ye, A, o) === "(" && (re2.type === "Property" || re2.type === "TSDeclareMethod" || re2.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re2.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re2 == null ? void 0 : re2.type) ? (l(G, A), true) : false;
          }
          var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function K(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
            return n(ye, A, o) !== "(" ? false : G && W.has(re2 == null ? void 0 : re2.type) ? (l(G, A), true) : false;
          }
          function de(De) {
            let { comment: A, enclosingNode: G, text: re2 } = De;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
              return false;
            let ye = y(re2, A, o);
            return ye !== false && re2.slice(ye, ye + 2) === "=>" ? (p2(G, A), true) : false;
          }
          function ue(De) {
            let { comment: A, enclosingNode: G, text: re2 } = De;
            return n(re2, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p2(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p2(G.value, A), true) : false;
          }
          function Fe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye, text: Ce } = De;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re2 == null ? void 0 : re2.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re2 && le(re2) && n(Ce, A, o) === ")")
              return l(G, A), true;
            if ((re2 == null ? void 0 : re2.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
              let Be = (() => {
                let ve = g(re2);
                if (ve.length > 0)
                  return a2(Ce, o(t(ve)));
                let ze = a2(Ce, o(re2.id));
                return ze !== false && a2(Ce, ze + 1);
              })();
              if (C(A) > Be)
                return k(ye, A), true;
            }
            return false;
          }
          function z(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
          }
          function U(De) {
            let { comment: A, enclosingNode: G } = De;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
          }
          function Z(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2 } = De;
            return x2(re2) && G && re2.callee === G && re2.arguments.length > 0 ? (i(re2.arguments[0], A), true) : false;
          }
          function se(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
            return (re2 == null ? void 0 : re2.type) === "UnionTypeAnnotation" || (re2 == null ? void 0 : re2.type) === "TSUnionType" ? (c2(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c2(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
          }
          function fe(De) {
            let { comment: A, enclosingNode: G } = De;
            return P(G) ? (i(G, A), true) : false;
          }
          function ge(De) {
            let { comment: A, enclosingNode: G, followingNode: re2, ast: ye, isLastComment: Ce } = De;
            return ye && ye.body && ye.body.length === 0 ? (Ce ? p2(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h2(G.directives) ? (Ce ? p2(G, A) : i(G, A), true) : (re2 == null ? void 0 : re2.type) === "Program" && (re2 == null ? void 0 : re2.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p2(re2, A), true) : false;
          }
          function he(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
          }
          function we(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, text: ye } = De;
            if ((re2 == null ? void 0 : re2.type) === "ImportSpecifier" || (re2 == null ? void 0 : re2.type) === "ExportSpecifier")
              return i(re2, A), true;
            let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re2 == null ? void 0 : re2.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re2 == null ? void 0 : re2.type) === "ExportNamedDeclaration";
            return (Ce || Be) && s2(ye, o(A)) ? (l(G, A), true) : false;
          }
          function ke(De) {
            let { comment: A, enclosingNode: G } = De;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
          }
          var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function Pe(De) {
            let { comment: A, enclosingNode: G, followingNode: re2 } = De;
            return Re.has(G == null ? void 0 : G.type) && re2 && (Ne.has(re2.type) || d(A)) ? (i(re2, A), true) : false;
          }
          function oe(De) {
            let { comment: A, enclosingNode: G, followingNode: re2, text: ye } = De;
            return !re2 && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A, o) === ";" ? (l(G, A), true) : false;
          }
          function H(De) {
            let { comment: A, enclosingNode: G, followingNode: re2 } = De;
            if (c2(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re2 == null ? void 0 : re2.type) === "TSTypeParameter" && re2.constraint)
              return G.prettierIgnore = true, A.unignore = true, true;
          }
          function pe(De) {
            let { comment: A, precedingNode: G, enclosingNode: re2, followingNode: ye } = De;
            return (re2 == null ? void 0 : re2.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
          }
          function X(De) {
            let { comment: A, enclosingNode: G, followingNode: re2 } = De;
            return !G || G.type !== "SwitchCase" || G.test || !re2 || re2 !== G.consequent[0] ? false : (re2.type === "BlockStatement" && $2(A) ? k(re2, A) : p2(G, A), true);
          }
          function le(De) {
            return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
          }
          function Ae(De, A) {
            if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h2(De.value.typeParameters) && De.value.body)
              return [...De.decorators || [], De.key, De.value.body];
          }
          function Ee(De) {
            let A = De.getValue(), G = De.getParentNode(), re2 = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
            return (A && (f(A) || F(A) || x2(G) && re2(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
        } }), qt2 = te2({ "src/language-js/needs-parens.js"(e, r) {
          ne2();
          var t = lt2(), s2 = Kn2(), { getFunctionParameters: a2, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p2, startsWithNoLookaheadToken: y, shouldFlatten: h2, getPrecedence: g, isCallExpression: c2, isMemberExpression: f, isObjectProperty: F, isTSTypeExpression: _ } = Ke2();
          function w(D, T) {
            let m2 = D.getParentNode();
            if (!m2)
              return false;
            let C = D.getName(), o = D.getNode();
            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
              return true;
            if (E(o))
              return false;
            if (T.parser !== "flow" && u(D.getValue()))
              return true;
            if (o.type === "Identifier") {
              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m2.await || o.name === "let") && m2.type === "ForOfStatement")
                return true;
              if (o.name === "let") {
                var d;
                let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                if (S && y(S, (b) => b === o))
                  return true;
              }
              if (C === "object" && o.name === "let" && m2.type === "MemberExpression" && m2.computed && !m2.optional) {
                let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                if (b && y(b, (B) => B === o))
                  return true;
              }
              return false;
            }
            if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
              var v;
              let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
              if (S && y(S, (b) => b === o))
                return true;
            }
            switch (m2.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $2(D, T) || o.type === "SequenceExpression";
              case "Decorator": {
                if (C === "expression") {
                  if (f(o) && o.computed)
                    return true;
                  let S = false, b = false, B = o;
                  for (; B; )
                    switch (B.type) {
                      case "MemberExpression":
                        b = true, B = B.object;
                        break;
                      case "CallExpression":
                        if (b || S)
                          return T.parser !== "typescript";
                        S = true, B = B.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return T.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ArrowFunctionExpression": {
                if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression"))
                  return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m2.type === "UnaryExpression")
                  return o.prefix && (o.operator === "++" && m2.operator === "+" || o.operator === "--" && m2.operator === "-");
              case "UnaryExpression":
                switch (m2.type) {
                  case "UnaryExpression":
                    return o.operator === m2.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "BinaryExpression":
                    return C === "left" && m2.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m2.type === "UpdateExpression" || o.operator === "in" && N(D))
                  return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let S = D.getParentNode(1);
                  if (S.type === "BinaryExpression" && S.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m2.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !_(o);
                  case "ConditionalExpression":
                    return _(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return C === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression")
                      return m2.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: S, type: b } = o;
                    if (!S && b !== "TSTypeAssertion")
                      return true;
                    let B = g(S), k = m2.operator, M = g(k);
                    return M > B || C === "right" && M === B || M === B && !h2(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p2(k);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m2.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return C !== "expression";
                  case "ArrowFunctionExpression":
                    return C !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m2.type === "UnaryExpression" || m2.type === "AwaitExpression" || _(m2) || m2.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (m2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m2.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
              case "TSFunctionType":
              case "TSConstructorType":
                if (C === "extendsType" && m2.type === "TSConditionalType") {
                  if (o.type === "TSConditionalType")
                    return true;
                  let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                  if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                    return true;
                }
                if (C === "checkType" && m2.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m2.type === "TSUnionType" || m2.type === "TSIntersectionType") && m2.types.length > 1 && (!o.types || o.types.length > 1))
                  return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m2.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return m2.type === "TSArrayType" || m2.type === "TSOptionalType" || m2.type === "TSRestType" || C === "objectType" && m2.type === "TSIndexedAccessType" || m2.type === "TSTypeOperator" || m2.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
              case "TSTypeQuery":
                return C === "objectType" && m2.type === "TSIndexedAccessType" || C === "elementType" && m2.type === "TSArrayType";
              case "TypeofTypeAnnotation":
                return C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType") || C === "elementType" && m2.type === "ArrayTypeAnnotation";
              case "ArrayTypeAnnotation":
                return m2.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m2.type === "ArrayTypeAnnotation" || m2.type === "NullableTypeAnnotation" || m2.type === "IntersectionTypeAnnotation" || m2.type === "UnionTypeAnnotation" || C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m2.type === "ArrayTypeAnnotation" || C === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let S = m2.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m2;
                return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m2.type === "FunctionTypeParam" && m2.name === null && a2(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return C === "objectType" && m2.type === "IndexedAccessType";
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m2.type === "ExpressionStatement" && !m2.directive) {
                  let S = D.getParentNode(1);
                  return S.type === "Program" || S.type === "BlockStatement";
                }
                return C === "object" && m2.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let S = D.getParentNode(1);
                return C === "body" && m2.type === "ArrowFunctionExpression" ? true : C === "key" && (m2.type === "ClassProperty" || m2.type === "PropertyDefinition") && m2.computed || (C === "init" || C === "update") && m2.type === "ForStatement" ? false : m2.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m2.type === "TSPropertySignature" || m2.type === "AssignmentExpression" || m2.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m2 || S.update === m2) || C === "value" && m2.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m2) || m2.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m2.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m2.type) {
                  case "BinaryExpression":
                    return m2.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return C === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s2(o.decorators))
                  return true;
                switch (m2.type) {
                  case "NewExpression":
                    return C === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let S = D.getParentNode(1);
                if (C === "object" && m2.type === "MemberExpression" || C === "callee" && (m2.type === "CallExpression" || m2.type === "NewExpression") || m2.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m2)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (C === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression")) {
                  let S = o;
                  for (; S; )
                    switch (S.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        S = S.object;
                        break;
                      case "TaggedTemplateExpression":
                        S = S.tag;
                        break;
                      case "TSNonNullExpression":
                        S = S.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return C === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression") || C === "object" && f(m2);
              case "NGPipeExpression":
                return !(m2.type === "NGRoot" || m2.type === "NGMicrosyntaxExpression" || m2.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m2.type === "ArrayExpression" || c2(m2) && m2.arguments[C] === o || C === "right" && m2.type === "NGPipeExpression" || C === "property" && m2.type === "MemberExpression" || m2.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return C === "callee" || C === "left" && m2.type === "BinaryExpression" && m2.operator === "<" || m2.type !== "ArrayExpression" && m2.type !== "ArrowFunctionExpression" && m2.type !== "AssignmentExpression" && m2.type !== "AssignmentPattern" && m2.type !== "BinaryExpression" && m2.type !== "NewExpression" && m2.type !== "ConditionalExpression" && m2.type !== "ExpressionStatement" && m2.type !== "JsExpressionRoot" && m2.type !== "JSXAttribute" && m2.type !== "JSXElement" && m2.type !== "JSXExpressionContainer" && m2.type !== "JSXFragment" && m2.type !== "LogicalExpression" && !c2(m2) && !F(m2) && m2.type !== "ReturnStatement" && m2.type !== "ThrowStatement" && m2.type !== "TypeCastExpression" && m2.type !== "VariableDeclarator" && m2.type !== "YieldExpression";
              case "TypeAnnotation":
                return C === "returnType" && m2.type === "ArrowFunctionExpression" && x2(o);
            }
            return false;
          }
          function E(D) {
            return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
          }
          function N(D) {
            let T = 0, m2 = D.getValue();
            for (; m2; ) {
              let C = D.getParentNode(T++);
              if (C && C.type === "ForStatement" && C.init === m2)
                return true;
              m2 = C;
            }
            return false;
          }
          function x2(D) {
            return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m2) => m2.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function I(D) {
            switch (D.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function P(D) {
            let T = D.getValue(), m2 = D.getParentNode(), C = D.getName();
            switch (m2.type) {
              case "NGPipeExpression":
                if (typeof C == "number" && m2.arguments[C] === T && m2.arguments.length - 1 === C)
                  return D.callParent(P);
                break;
              case "ObjectProperty":
                if (C === "value") {
                  let o = D.getParentNode(1);
                  return t(o.properties) === m2;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (C === "right")
                  return D.callParent(P);
                break;
              case "ConditionalExpression":
                if (C === "alternate")
                  return D.callParent(P);
                break;
              case "UnaryExpression":
                if (m2.prefix)
                  return D.callParent(P);
                break;
            }
            return false;
          }
          function $2(D, T) {
            let m2 = D.getValue(), C = D.getParentNode();
            return m2.type === "FunctionExpression" || m2.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m2) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $2(o, T), ...n(D, m2));
          }
          r.exports = w;
        } }), Fo2 = te2({ "src/language-js/print-preprocess.js"(e, r) {
          ne2();
          function t(s2, a2) {
            switch (a2.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s2), {}, { type: a2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s2, comments: [], rootMarker: a2.rootMarker });
              default:
                return s2;
            }
          }
          r.exports = t;
        } }), pd2 = te2({ "src/language-js/print/html-binding.js"(e, r) {
          ne2();
          var { builders: { join: t, line: s2, group: a2, softline: n, indent: u } } = qe2();
          function i(p2, y, h2) {
            let g = p2.getValue();
            if (y.__onHtmlBindingRoot && p2.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
              if (y.__isVueForBindingLeft)
                return p2.call((c2) => {
                  let f = t([",", s2], c2.map(h2, "params")), { params: F } = c2.getValue();
                  return F.length === 1 ? f : ["(", u([n, a2(f)]), n, ")"];
                }, "program", "body", 0);
              if (y.__isVueBindings)
                return p2.call((c2) => t([",", s2], c2.map(h2, "params")), "program", "body", 0);
            }
          }
          function l(p2) {
            switch (p2.type) {
              case "MemberExpression":
                switch (p2.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(p2.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
        } }), ru2 = te2({ "src/language-js/print/binaryish.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { getLast: s2 } = Ue2(), { builders: { join: a2, line: n, softline: u, group: i, indent: l, align: p2, indentIfBreak: y }, utils: { cleanDoc: h2, getDocParts: g, isConcat: c2 } } = qe2(), { hasLeadingOwnLineComment: f, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N, isCallExpression: x2, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $2 } = Ke2(), D = 0;
          function T(o, d, v) {
            let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $2(d) && S.operator === "|>", R = m2(o, v, d, false, k);
            if (k)
              return R;
            if (M)
              return i(R);
            if (x2(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
              return i([l([u, ...R]), u]);
            let q2 = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x2(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
            if (q2 || C(S) && !L || !C(S) && J)
              return i(R);
            if (R.length === 0)
              return "";
            let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
            if (!Q)
              return ee;
            let ce = s2(R);
            return i([ee, y(ce, { groupId: ie })]);
          }
          function m2(o, d, v, S, b) {
            let B = o.getValue();
            if (!F(B))
              return [i(d())];
            let k = [];
            w(B.operator, B.left.operator) ? k = o.call((Y) => m2(Y, d, v, true, b), "left") : k.push(i(d("left")));
            let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q2 = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a2([n, ": "], o.map(d, "arguments").map((Y) => p2(2, i(Y))))])) : "", L;
            if (M)
              L = [q2, " ", d("right"), J];
            else {
              let ie = $2(v) && q2 === "|>" ? o.call((ee) => m2(ee, d, v, true, b), "right") : d("right");
              L = [R ? n : "", q2, R ? " " : n, ie, J];
            }
            let Q = o.getParentNode(), V = E(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
            if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
              let Y = h2(t(o, k, v));
              return c2(Y) || Y.type === "fill" ? g(Y) : [Y];
            }
            return k;
          }
          function C(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
          }
          r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
        } }), fd2 = te2({ "src/language-js/print/angular.js"(e, r) {
          ne2();
          var { builders: { join: t, line: s2, group: a2 } } = qe2(), { hasNode: n, hasComment: u, getComments: i } = Ke2(), { printBinaryishExpression: l } = ru2();
          function p2(g, c2, f) {
            let F = g.getValue();
            if (F.type.startsWith("NG"))
              switch (F.type) {
                case "NGRoot":
                  return [f("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return l(g, c2, f);
                case "NGChainedExpression":
                  return a2(t([";", s2], g.map((_) => h2(_) ? f() : ["(", f(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [F.prefix, ": ", F.value.trim()];
                case "NGMicrosyntax":
                  return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F) ? " " : [";", s2], f()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
                case "NGMicrosyntaxExpression":
                  return [f("expression"), F.alias === null ? "" : [" as ", f("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let _ = g.getName(), w = g.getParentNode(), E = y(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                  return [f("key"), E ? " " : ": ", f("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", f("key"), F.value === null ? "" : [" = ", f("value")]];
                case "NGMicrosyntaxAs":
                  return [f("key"), " as ", f("alias")];
                default:
                  throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
              }
          }
          function y(g, c2, f) {
            return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c2 === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function h2(g) {
            return n(g.getValue(), (c2) => {
              switch (c2.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          r.exports = { printAngular: p2 };
        } }), Dd2 = te2({ "src/language-js/print/jsx.js"(e, r) {
          ne2();
          var { printComments: t, printDanglingComments: s2, printCommentsSeparately: a2 } = et2(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p2, conditionalGroup: y, fill: h2, ifBreak: g, lineSuffixBoundary: c2, join: f }, utils: { willBreak: F } } = qe2(), { getLast: _, getPreferredQuote: w } = Ue2(), { isJsxNode: E, rawText: N, isCallExpression: x2, isStringLiteral: I, isBinaryish: P, hasComment: $2, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke2(), m2 = qt2(), { willPrintOwnComments: C } = Eo2(), o = (U) => U === "" || U === n || U === u || U === i;
          function d(U, Z, se) {
            let fe = U.getValue();
            if (fe.type === "JSXElement" && de(fe))
              return [se("openingElement"), se("closingElement")];
            let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
            if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
              return [ge, ...U.map(se, "children"), he];
            fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
            let we = fe.children.some(E), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A) => ue(A));
            for (let A = X.length - 2; A >= 0; A--) {
              let G = X[A] === "" && X[A + 1] === "", re2 = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
              re2 && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
            }
            for (; X.length > 0 && o(_(X)); )
              X.pop();
            for (; X.length > 1 && o(X[0]) && o(X[1]); )
              X.shift(), X.shift();
            let Ae = [];
            for (let [A, G] of X.entries()) {
              if (G === H) {
                if (A === 1 && X[A - 1] === "") {
                  if (X.length === 2) {
                    Ae.push(oe);
                    continue;
                  }
                  Ae.push([oe, u]);
                  continue;
                } else if (A === X.length - 1) {
                  Ae.push(oe);
                  continue;
                } else if (X[A - 1] === "" && X[A - 2] === u) {
                  Ae.push(oe);
                  continue;
                }
              }
              Ae.push(G), F(G) && (Ne = true);
            }
            let Ee = le ? h2(Ae) : l(Ae, { shouldBreak: true });
            if (Pe)
              return Ee;
            let De = l([ge, p2([u, Ee]), u, he]);
            return Ne ? De : y([l([ge, ...X, he]), De]);
          }
          function v(U, Z, se, fe, ge) {
            let he = [];
            return U.each((we, ke, Re) => {
              let Ne = we.getValue();
              if (Ne.type === "JSXText") {
                let Pe = N(Ne);
                if (ue(Ne)) {
                  let oe = Pe.split(ce);
                  if (oe[0] === "") {
                    if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                      let pe = Re[ke + 1];
                      he.push(b(ge, oe[1], Ne, pe));
                    } else
                      he.push(fe);
                    oe.shift();
                  }
                  let H;
                  if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
                    return;
                  for (let [pe, X] of oe.entries())
                    pe % 2 === 1 ? he.push(n) : he.push(X);
                  if (H !== void 0)
                    if (/\n/.test(H)) {
                      let pe = Re[ke + 1];
                      he.push(b(ge, _(he), Ne, pe));
                    } else
                      he.push(fe);
                  else {
                    let pe = Re[ke + 1];
                    he.push(S(ge, _(he), Ne, pe));
                  }
                } else
                  /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
              } else {
                let Pe = se();
                he.push(Pe);
                let oe = Re[ke + 1];
                if (oe && ue(oe)) {
                  let pe = K(N(oe)).split(ce)[0];
                  he.push(S(ge, pe, Ne, oe));
                } else
                  he.push(u);
              }
            }, "children"), he;
          }
          function S(U, Z, se, fe) {
            return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
          }
          function b(U, Z, se, fe) {
            return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
          }
          function B(U, Z, se) {
            let fe = U.getParentNode();
            if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
              return Z;
            let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x2, (ke) => ke.type === "JSXExpressionContainer"), we = m2(U, se);
            return l([we ? "" : g("("), p2([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
          }
          function k(U, Z, se) {
            let fe = U.getValue(), ge = [];
            if (ge.push(se("name")), fe.value) {
              let he;
              if (I(fe.value)) {
                let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                ke = ke.replace(Pe, Re);
                let { leading: oe, trailing: H } = U.call(() => a2(U, Z), "value");
                he = [oe, Ne, ke, Ne, H];
              } else
                he = se("value");
              ge.push("=", he);
            }
            return ge;
          }
          function M(U, Z, se) {
            let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$2(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x2(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
            return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c2, "}"]) : l(["{", p2([i, se("expression")]), i, c2, "}"]);
          }
          function R(U, Z, se) {
            let fe = U.getValue(), ge = fe.name && $2(fe.name) || fe.typeParameters && $2(fe.typeParameters);
            if (fe.selfClosing && fe.attributes.length === 0 && !ge)
              return ["<", se("name"), se("typeParameters"), " />"];
            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$2(fe.attributes[0]))
              return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
            let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
            return l(["<", se("name"), se("typeParameters"), p2(U.map(() => [we, se()], "attributes")), ...q2(fe, Z, ge)], { shouldBreak: he });
          }
          function q2(U, Z, se) {
            return U.selfClosing ? [n, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
          }
          function J(U, Z, se) {
            let fe = U.attributes.length > 0 && $2(_(U.attributes), D.Trailing);
            return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
          }
          function L(U, Z, se) {
            let fe = U.getValue(), ge = [];
            ge.push("</");
            let he = se("name");
            return $2(fe.name, D.Leading | D.Line) ? ge.push(p2([u, he]), u) : $2(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
          }
          function Q(U, Z) {
            let se = U.getValue(), fe = $2(se), ge = $2(se, D.Line), he = se.type === "JSXOpeningFragment";
            return [he ? "<" : "</", p2([ge ? u : fe && !he ? " " : "", s2(U, Z, true)]), ge ? u : "", ">"];
          }
          function V(U, Z, se) {
            let fe = t(U, d(U, Z, se), Z);
            return B(U, fe, Z);
          }
          function j(U, Z) {
            let se = U.getValue(), fe = $2(se, D.Line);
            return [s2(U, Z, !fe), fe ? u : ""];
          }
          function Y(U, Z, se) {
            let fe = U.getValue();
            return ["{", U.call((ge) => {
              let he = ["...", se()], we = ge.getValue();
              return !$2(we) || !C(ge) ? he : [p2([i, t(ge, he, Z)]), i];
            }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function ie(U, Z, se) {
            let fe = U.getValue();
            if (fe.type.startsWith("JSX"))
              switch (fe.type) {
                case "JSXAttribute":
                  return k(U, Z, se);
                case "JSXIdentifier":
                  return String(fe.name);
                case "JSXNamespacedName":
                  return f(":", [se("namespace"), se("name")]);
                case "JSXMemberExpression":
                  return f(".", [se("object"), se("property")]);
                case "JSXSpreadAttribute":
                  return Y(U, Z, se);
                case "JSXSpreadChild":
                  return Y(U, Z, se);
                case "JSXExpressionContainer":
                  return M(U, Z, se);
                case "JSXFragment":
                case "JSXElement":
                  return V(U, Z, se);
                case "JSXOpeningElement":
                  return R(U, Z, se);
                case "JSXClosingElement":
                  return L(U, Z, se);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return Q(U, Z);
                case "JSXEmptyExpression":
                  return j(U, Z);
                case "JSXText":
                  throw new Error("JSXText should be handled by JSXElement");
                default:
                  throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
              }
          }
          var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
          function de(U) {
            if (U.children.length === 0)
              return true;
            if (U.children.length > 1)
              return false;
            let Z = U.children[0];
            return Z.type === "JSXText" && !ue(Z);
          }
          function ue(U) {
            return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
          }
          function Fe(U) {
            return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$2(U.expression);
          }
          function z(U) {
            let Z = U.getValue(), se = U.getParentNode();
            if (!se || !Z || !E(Z) || !E(se))
              return false;
            let fe = se.children.indexOf(Z), ge = null;
            for (let he = fe; he > 0; he--) {
              let we = se.children[he - 1];
              if (!(we.type === "JSXText" && !ue(we))) {
                ge = we;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
          }
          r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
        } }), ct2 = te2({ "src/language-js/print/misc.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s2, join: a2, line: n } } = qe2(), { isFlowAnnotationComment: u } = Ke2();
          function i(_) {
            let w = _.getValue();
            return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function l(_) {
            return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          function p2(_, w, E) {
            let N = _.getValue();
            return N.typeArguments ? E("typeArguments") : N.typeParameters ? E("typeParameters") : "";
          }
          function y(_, w, E) {
            let N = _.getValue();
            if (!N.typeAnnotation)
              return "";
            let x2 = _.getParentNode(), I = x2.type === "DeclareFunction" && x2.id === N;
            return u(w.originalText, N.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
          }
          function h2(_, w, E) {
            return ["::", E("callee")];
          }
          function g(_, w, E) {
            let N = _.getValue();
            return t(N.modifiers) ? [a2(" ", _.map(E, "modifiers")), " "] : "";
          }
          function c2(_, w, E) {
            return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s2([n, w]);
          }
          function f(_, w, E) {
            return ["...", E("argument"), y(_, w, E)];
          }
          function F(_, w) {
            let E = _.slice(1, -1);
            if (E.includes('"') || E.includes("'"))
              return _;
            let N = w.singleQuote ? "'" : '"';
            return N + E + N;
          }
          r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p2, printBindExpressionCallee: h2, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f, adjustClause: c2, printDirective: F };
        } }), er2 = te2({ "src/language-js/print/array.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { line: s2, softline: a2, hardline: n, group: u, indent: i, ifBreak: l, fill: p2 } } = qe2(), { getLast: y, hasNewline: h2 } = Ue2(), { shouldPrintComma: g, hasComment: c2, CommentCheckFlags: f, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke2(), { locStart: E } = ut2(), { printOptionalToken: N, printTypeAnnotation: x2 } = ct2();
          function I(T, m2, C) {
            let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
            if (o.elements.length === 0)
              c2(o, f.Dangling) ? d.push(u([v, t(T, m2), a2, S])) : d.push(v, S);
            else {
              let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m2.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                let j = L && L.type;
                if (j !== "ArrayExpression" && j !== "ObjectExpression")
                  return false;
                let Y = V[Q + 1];
                if (Y && j !== Y.type)
                  return false;
                let ie = j === "ArrayExpression" ? "elements" : "properties";
                return L[ie] && L[ie].length > 1;
              }), q2 = P(o, m2), J = B ? k ? "," : g(m2) ? q2 ? l(",", "", { groupId: M }) : l(",") : "" : "";
              d.push(u([v, i([a2, q2 ? D(T, m2, C, J) : [$2(T, m2, "elements", C), J], t(T, m2, true)]), a2, S], { shouldBreak: R, id: M }));
            }
            return d.push(N(T), x2(T, m2, C)), d;
          }
          function P(T, m2) {
            return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c2(C.argument)) && !c2(C, f.Trailing | f.Line, (o) => !h2(m2.originalText, E(o), { backwards: true })));
          }
          function $2(T, m2, C, o) {
            let d = [], v = [];
            return T.each((S) => {
              d.push(v, u(o())), v = [",", s2], S.getValue() && F(S.getValue(), m2) && v.push(a2);
            }, C), d;
          }
          function D(T, m2, C, o) {
            let d = [];
            return T.each((v, S, b) => {
              let B = S === b.length - 1;
              d.push([C(), B ? o : ","]), B || d.push(F(v.getValue(), m2) ? [n, n] : c2(b[S + 1], f.Leading | f.Line) ? n : s2);
            }, "elements"), p2(d);
          }
          r.exports = { printArray: I, printArrayItems: $2, isConciselyPrintedArray: P };
        } }), Ao2 = te2({ "src/language-js/print/call-arguments.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { getLast: s2, getPenultimate: a2 } = Ue2(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p2, isLongCurriedCallExpression: y, shouldPrintComma: h2, getCallArguments: g, iterateCallArgumentsPath: c2, isNextLineEmpty: f, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke2(), { builders: { line: N, hardline: x2, softline: I, group: P, indent: $2, conditionalGroup: D, ifBreak: T, breakParent: m2 }, utils: { willBreak: C } } = qe2(), { ArgExpansionBailout: o } = Qt2(), { isConciselyPrintedArray: d } = er2();
          function v(q2, J, L) {
            let Q = q2.getValue(), V = Q.type === "ImportExpression", j = g(Q);
            if (j.length === 0)
              return ["(", t(q2, J, true), ")"];
            if (k(j))
              return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let Y = false, ie = false, ee = j.length - 1, ce = [];
            c2(q2, (z, U) => {
              let Z = z.getNode(), se = [L()];
              U === ee || (f(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x2, x2)) : se.push(",", N)), ce.push(se);
            });
            let W = !(V || Q.callee && Q.callee.type === "Import") && h2(J, "all") ? "," : "";
            function K() {
              return P(["(", $2([N, ...ce]), W, N, ")"], { shouldBreak: true });
            }
            if (Y || q2.getParentNode().type !== "Decorator" && l(j))
              return K();
            let de = B(j), ue = b(j, J);
            if (de || ue) {
              if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C))
                return K();
              let z = [];
              try {
                q2.try(() => {
                  c2(q2, (U, Z) => {
                    de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x2 : N, ie ? x2 : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (U) {
                if (U instanceof o)
                  return K();
                throw U;
              }
              return [ce.some(C) ? m2 : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s2(z), { shouldBreak: true }), ")"], K()])];
            }
            let Fe = ["(", $2([I, ...ce]), T(W), I, ")"];
            return y(q2) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
          }
          function S(q2) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q2.type === "ObjectExpression" && (q2.properties.length > 0 || u(q2)) || q2.type === "ArrayExpression" && (q2.elements.length > 0 || u(q2)) || q2.type === "TSTypeAssertion" && S(q2.expression) || E(q2) && S(q2.expression) || q2.type === "FunctionExpression" || q2.type === "ArrowFunctionExpression" && (!q2.returnType || !q2.returnType.typeAnnotation || q2.returnType.typeAnnotation.type !== "TSTypeReference" || M(q2.body)) && (q2.body.type === "BlockStatement" || q2.body.type === "ArrowFunctionExpression" && S(q2.body, true) || q2.body.type === "ObjectExpression" || q2.body.type === "ArrayExpression" || !J && (F(q2.body) || q2.body.type === "ConditionalExpression") || p2(q2.body)) || q2.type === "DoExpression" || q2.type === "ModuleExpression";
          }
          function b(q2, J) {
            let L = s2(q2), Q = a2(q2);
            return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q2.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q2.length > 1 && L.type === "ArrayExpression" && d(L, J));
          }
          function B(q2) {
            if (q2.length !== 2)
              return false;
            let [J, L] = q2;
            return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
          }
          function k(q2) {
            return q2.length === 2 && q2[0].type === "ArrowFunctionExpression" && n(q2[0]).length === 0 && q2[0].body.type === "BlockStatement" && q2[1].type === "ArrayExpression" && !q2.some((J) => u(J));
          }
          function M(q2) {
            return q2.type === "BlockStatement" && (q2.body.some((J) => J.type !== "EmptyStatement") || u(q2, i.Dangling));
          }
          function R(q2) {
            return q2.type === "ObjectExpression" && q2.properties.length === 1 && w(q2.properties[0]) && q2.properties[0].key.type === "Identifier" && q2.properties[0].key.name === "type" && _(q2.properties[0].value) && q2.properties[0].value.value === "module";
          }
          r.exports = v;
        } }), So2 = te2({ "src/language-js/print/member.js"(e, r) {
          ne2();
          var { builders: { softline: t, group: s2, indent: a2, label: n } } = qe2(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke2(), { printOptionalToken: p2 } = ct2();
          function y(g, c2, f) {
            let F = g.getValue(), _ = g.getParentNode(), w, E = 0;
            do
              w = g.getParentNode(E), E++;
            while (w && (i(w) || w.type === "TSNonNullExpression"));
            let N = f("object"), x2 = h2(g, c2, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === "member-chain");
            return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x2 : s2(a2([t, x2]))]);
          }
          function h2(g, c2, f) {
            let F = f("property"), _ = g.getValue(), w = p2(g);
            return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s2([w, "[", a2([t, F]), t, "]"]) : [w, ".", F];
          }
          r.exports = { printMemberExpression: y, printMemberLookup: h2 };
        } }), md2 = te2({ "src/language-js/print/member-chain.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { getLast: s2, isNextLineEmptyAfterIndex: a2, getNextNonSpaceNonCommentCharacterIndex: n } = Ue2(), u = qt2(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p2, isLongCurriedCallExpression: y, isMemberish: h2, isNumericLiteral: g, isSimpleCallArgument: c2, hasComment: f, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke2(), { locEnd: w } = ut2(), { builders: { join: E, hardline: N, group: x2, indent: I, conditionalGroup: P, breakParent: $2, label: D }, utils: { willBreak: T } } = qe2(), m2 = Ao2(), { printMemberLookup: C } = So2(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct2();
          function S(b, B, k) {
            let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q2 = [];
            function J(Ne) {
              let { originalText: Pe } = B, oe = n(Pe, Ne, w);
              return Pe.charAt(oe) === ")" ? oe !== false && a2(Pe, oe + 1) : _(Ne, B);
            }
            function L(Ne) {
              let Pe = Ne.getValue();
              i(Pe) && (h2(Pe.callee) || i(Pe.callee)) ? (q2.unshift({ node: Pe, printed: [t(Ne, [o(Ne), d(Ne, B, k), m2(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : h2(Pe) ? (q2.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q2.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q2.unshift({ node: Pe, printed: k() });
            }
            let Q = b.getValue();
            q2.unshift({ node: Q, printed: [o(b), d(b, B, k), m2(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
            let V = [], j = [q2[0]], Y = 1;
            for (; Y < q2.length && (q2[Y].node.type === "TSNonNullExpression" || i(q2[Y].node) || l(q2[Y].node) && q2[Y].node.computed && g(q2[Y].node.property)); ++Y)
              j.push(q2[Y]);
            if (!i(q2[0].node))
              for (; Y + 1 < q2.length && (h2(q2[Y].node) && h2(q2[Y + 1].node)); ++Y)
                j.push(q2[Y]);
            V.push(j), j = [];
            let ie = false;
            for (; Y < q2.length; ++Y) {
              if (ie && h2(q2[Y].node)) {
                if (q2[Y].node.computed && g(q2[Y].node.property)) {
                  j.push(q2[Y]);
                  continue;
                }
                V.push(j), j = [], ie = false;
              }
              (i(q2[Y].node) || q2[Y].node.type === "ImportExpression") && (ie = true), j.push(q2[Y]), f(q2[Y].node, F.Trailing) && (V.push(j), j = [], ie = false);
            }
            j.length > 0 && V.push(j);
            function ee(Ne) {
              return /^[A-Z]|^[$_]+$/.test(Ne);
            }
            function ce(Ne) {
              return Ne.length <= B.tabWidth;
            }
            function W(Ne) {
              let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
              if (Ne[0].length === 1) {
                let H = Ne[0][0].node;
                return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
              }
              let oe = s2(Ne[0]).node;
              return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
            }
            let K = V.length >= 2 && !f(V[1][0].node) && W(V);
            function de(Ne) {
              let Pe = Ne.map((oe) => oe.printed);
              return Ne.length > 0 && s2(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
            }
            function ue(Ne) {
              return Ne.length === 0 ? "" : I(x2([N, E(N, Ne.map(de))]));
            }
            let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, F.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, F.Trailing)) || V[U] && f(V[U][0].node, F.Leading);
            if (V.length <= U && !se)
              return y(b) ? z : x2(z);
            let fe = s2(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q2.map((Ne) => {
              let { node: Pe } = Ne;
              return Pe;
            }).filter(i);
            function ke() {
              let Ne = s2(s2(V)).node, Pe = s2(Fe);
              return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p2));
            }
            let Re;
            return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c2(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x2(he) : Re = [T(z) || ge ? $2 : "", P([z, he])], D("member-chain", Re);
          }
          r.exports = S;
        } }), xo2 = te2({ "src/language-js/print/call-expression.js"(e, r) {
          ne2();
          var { builders: { join: t, group: s2 } } = qe2(), a2 = qt2(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p2, isTemplateOnItsOwnLine: y, isTestCall: h2, iterateCallArgumentsPath: g } = Ke2(), c2 = md2(), f = Ao2(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct2();
          function w(N, x2, I) {
            let P = N.getValue(), $2 = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m2 = F(N), C = n(P);
            if (C.length > 0 && (!T && !D && E(P, $2) || C.length === 1 && y(C[0], x2.originalText) || !D && h2(P, $2))) {
              let v = [];
              return g(N, () => {
                v.push(I());
              }), [D ? "new " : "", I("callee"), m2, _(N, x2, I), "(", t(", ", v), ")"];
            }
            let o = (x2.parser === "babel" || x2.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a2(v, x2), "callee"))
              return c2(N, x2, I);
            let d = [D ? "new " : "", T ? "import" : I("callee"), m2, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x2, I), f(N, x2, I)];
            return T || i(P.callee) ? s2(d) : d;
          }
          function E(N, x2) {
            if (N.callee.type !== "Identifier")
              return false;
            if (N.callee.name === "require")
              return true;
            if (N.callee.name === "define") {
              let I = n(N);
              return x2.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p2(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          r.exports = { printCallExpression: w };
        } }), tr2 = te2({ "src/language-js/print/assignment.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, getStringWidth: s2 } = Ue2(), { builders: { line: a2, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p2, willBreak: y, canBreak: h2 } } = qe2(), { hasLeadingOwnLineComment: g, isBinaryish: c2, isStringLiteral: f, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N, rawText: x2, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $2 } = Ke2(), { shouldInlineLogicalExpression: D } = ru2(), { printCallExpression: T } = xo2();
          function m2(W, K, de, ue, Fe, z) {
            let U = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
            switch (U) {
              case "break-after-operator":
                return n([n(ue), Fe, n(u([a2, Z]))]);
              case "never-break-after-operator":
                return n([n(ue), Fe, " ", Z]);
              case "fluid": {
                let se = Symbol("assignment");
                return n([n(ue), Fe, n(u(a2), { id: se }), l, i(Z, { groupId: se })]);
              }
              case "break-lhs":
                return n([ue, Fe, " ", n(Z)]);
              case "chain":
                return [n(ue), Fe, a2, Z];
              case "chain-tail":
                return [n(ue), Fe, u([a2, Z])];
              case "chain-tail-arrow-chain":
                return [n(ue), Fe, Z];
              case "only-left":
                return ue;
            }
          }
          function C(W, K, de) {
            let ue = W.getValue();
            return m2(W, K, de, de("left"), [" ", ue.operator], "right");
          }
          function o(W, K, de) {
            return m2(W, K, de, de("id"), " =", "init");
          }
          function d(W, K, de, ue, Fe) {
            let z = W.getValue(), U = z[Fe];
            if (!U)
              return "only-left";
            let Z = !b(U);
            if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
              return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(U.right) || g(K.originalText, U))
              return "break-after-operator";
            if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json")
              return "never-break-after-operator";
            if (S(z) || k(z) || q2(z) || J(z) && h2(ue))
              return "break-lhs";
            let ge = ie(z, ue, K);
            return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function v(W, K, de, ue) {
            let Fe = W.getValue();
            if (c2(Fe) && !D(Fe))
              return true;
            switch (Fe.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Fe;
                return c2(Z) && !D(Z);
              }
              case "ClassExpression":
                return t(Fe.decorators);
            }
            if (ue)
              return false;
            let z = Fe, U = [];
            for (; ; )
              if (z.type === "UnaryExpression")
                z = z.argument, U.push("argument");
              else if (z.type === "TSNonNullExpression")
                z = z.expression, U.push("expression");
              else
                break;
            return !!(f(z) || W.call(() => V(W, K, de), ...U));
          }
          function S(W) {
            if (B(W)) {
              let K = W.left || W.id;
              return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $2(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          function B(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          function k(W) {
            let K = M(W);
            if (t(K)) {
              let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (K.length > 1 && K.some((ue) => ue[de] || ue.default))
                return true;
            }
            return false;
          }
          function M(W) {
            return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function R(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function q2(W) {
            if (W.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: K } = W.id;
            if (!K || !K.typeAnnotation)
              return false;
            let de = L(K.typeAnnotation);
            return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
          }
          function J(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function L(W) {
            return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Q(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function V(W, K, de) {
            let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
            if (Fe.type === "TSNonNullExpression")
              return W.call(z, "expression");
            if (w(Fe)) {
              if (T(W, K, de).label === "member-chain")
                return false;
              let Z = N(Fe);
              return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
            }
            return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
          }
          var j = 0.25;
          function Y(W, K) {
            let { printWidth: de } = K;
            if (I(W))
              return false;
            let ue = de * j;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument))
              return true;
            let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Fe ? Fe.length <= ue : f(W) ? x2(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F(W);
          }
          function ie(W, K, de) {
            if (!$2(W))
              return false;
            K = p2(K);
            let ue = 3;
            return typeof K == "string" && s2(K) < de.tabWidth + ue;
          }
          function ee(W, K) {
            let de = ce(W);
            if (t(de)) {
              if (de.length > 1)
                return true;
              if (de.length === 1) {
                let Fe = de[0];
                if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation")
                  return true;
              }
              let ue = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y(K(ue)))
                return true;
            }
            return false;
          }
          function ce(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m2, isArrowFunctionVariableDeclarator: J };
        } }), Lr2 = te2({ "src/language-js/print/function-parameters.js"(e, r) {
          ne2();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue2(), { printDanglingComments: s2 } = et2(), { builders: { line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p2 }, utils: { removeLines: y, willBreak: h2 } } = qe2(), { getFunctionParameters: g, iterateFunctionParametersPath: c2, isSimpleType: f, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N, shouldPrintComma: x2, hasComment: I, isNextLineEmpty: P } = Ke2(), { locEnd: $2 } = ut2(), { ArgExpansionBailout: D } = Qt2(), { printFunctionTypeParameters: T } = ct2();
          function m2(v, S, b, B, k) {
            let M = v.getValue(), R = g(M), q2 = k ? T(v, b, S) : "";
            if (R.length === 0)
              return [q2, "(", s2(v, b, true, (ie) => t(b.originalText, ie, $2) === ")"), ")"];
            let J = v.getParentNode(), L = F(J), Q = C(M), V = [];
            if (c2(v, (ie, ee) => {
              let ce = ee === R.length - 1;
              ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a2));
            }), B) {
              if (h2(q2) || h2(V))
                throw new D();
              return i([y(q2), "(", y(V), ")"]);
            }
            let j = R.every((ie) => !ie.decorators);
            return Q && j ? [q2, "(", ...V, ")"] : L ? [q2, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q2, "(", l([u, ...V]), p2(!N(M) && x2(b, "all") ? "," : ""), u, ")"];
          }
          function C(v) {
            if (!v)
              return false;
            let S = g(v);
            if (S.length !== 1)
              return false;
            let [b] = S;
            return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          function o(v) {
            let S;
            return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
          }
          function d(v, S) {
            let b = o(v);
            if (!b)
              return false;
            let B = v.typeParameters && v.typeParameters.params;
            if (B) {
              if (B.length > 1)
                return false;
              if (B.length === 1) {
                let k = B[0];
                if (k.constraint || k.default)
                  return false;
              }
            }
            return g(v).length === 1 && (w(b) || h2(S));
          }
          r.exports = { printFunctionParameters: m2, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
        } }), Or2 = te2({ "src/language-js/print/type-annotation.js"(e, r) {
          ne2();
          var { printComments: t, printDanglingComments: s2 } = et2(), { isNonEmptyArray: a2 } = Ue2(), { builders: { group: n, join: u, line: i, softline: l, indent: p2, align: y, ifBreak: h2 } } = qe2(), g = qt2(), { locStart: c2 } = ut2(), { isSimpleType: f, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke2(), { printAssignment: N } = tr2(), { printFunctionParameters: x2, shouldGroupFunctionParameters: I } = Lr2(), { printArrayItems: P } = er2();
          function $2(b) {
            if (f(b) || F(b))
              return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
              if (b.types.length - 1 === B && k)
                return true;
            }
            return false;
          }
          function D(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
            return q2.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q2.push(": ", k("supertype")), R.impltype && q2.push(" = ", k("impltype")), q2.push(M), q2;
          }
          function T(b, B, k) {
            let M = B.semi ? ";" : "", R = b.getValue(), q2 = [];
            R.declare && q2.push("declare "), q2.push("type ", k("id"), k("typeParameters"));
            let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [N(b, B, k, q2, " =", J), M];
          }
          function m2(b, B, k) {
            let M = b.getValue(), R = b.map(k, "types"), q2 = [], J = false;
            for (let L = 0; L < R.length; ++L)
              L === 0 ? q2.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q2.push([" & ", J ? p2(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q2.push(p2([" &", i, R[L]])) : (L > 1 && (J = true), q2.push(" & ", L > 1 ? p2(R[L]) : R[L]));
            return n(q2);
          }
          function C(b, B, k) {
            let M = b.getValue(), R = b.getParentNode(), q2 = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $2(M), L = b.map((j) => {
              let Y = k();
              return J || (Y = y(2, Y)), t(j, Y, B);
            }, "types");
            if (J)
              return u(" | ", L);
            let Q = q2 && !_(B.originalText, M), V = [h2([Q ? i : "", "| "]), u([i, "| "], L)];
            return g(b, B) ? n([p2(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p2([h2(["(", l]), V]), l, h2(")")]) : n(q2 ? p2(V) : V);
          }
          function o(b, B, k) {
            let M = b.getValue(), R = [], q2 = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q2.type === "ObjectTypeProperty" || q2.type === "ObjectTypeInternalSlot") && !q2.variance && !q2.optional && c2(q2) === c2(M) || q2.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation"), j = V && Q && (q2.type === "TypeAnnotation" || q2.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            w(q2) && (Q = true, V = true), j && R.push("(");
            let Y = x2(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
            return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
          }
          function d(b, B, k) {
            let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q2 = M[R], J = a2(q2), L = J ? l : "";
            return n(["[", p2([L, P(b, B, R, k)]), h2(J && E(B, "all") ? "," : ""), s2(b, B, true), L, "]"]);
          }
          function v(b, B, k) {
            let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [k("objectType"), R, k("indexType"), "]"];
          }
          function S(b, B, k) {
            let M = b.getValue();
            return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
          }
          r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m2, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $2, printJSDocType: S };
        } }), jr2 = te2({ "src/language-js/print/type-parameters.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { join: s2, line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p2 } } = qe2(), { isTestCall: y, hasComment: h2, CommentCheckFlags: g, isTSXFile: c2, shouldPrintComma: f, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke2(), { createGroupIdMapper: E } = Ue2(), { shouldHugType: N } = Or2(), { isArrowFunctionVariableDeclarator: x2 } = tr2(), I = E("typeParameters");
          function P(T, m2, C, o) {
            let d = T.getValue();
            if (!d[o])
              return "";
            if (!Array.isArray(d[o]))
              return C(o);
            let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x2);
            if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N(d[o][0]))))
              return ["<", s2(", ", T.map(C, o)), $2(T, m2), ">"];
            let k = d.type === "TSTypeParameterInstantiation" ? "" : F(d).length === 1 && c2(m2) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m2, "all") ? p2(",") : "";
            return i(["<", l([u, s2([",", a2], T.map(C, o))]), k, u, ">"], { id: I(d) });
          }
          function $2(T, m2) {
            let C = T.getValue();
            if (!h2(C, g.Dangling))
              return "";
            let o = !h2(C, g.Line), d = t(T, m2, o);
            return o ? d : [d, n];
          }
          function D(T, m2, C) {
            let o = T.getValue(), d = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
            return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
          }
          r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
        } }), rr2 = te2({ "src/language-js/print/property.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { printString: s2, printNumber: a2 } = Ue2(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p2 } = Ke2(), { printAssignment: y } = tr2(), h2 = /* @__PURE__ */ new WeakMap();
          function g(f, F, _) {
            let w = f.getNode();
            if (w.computed)
              return ["[", _("key"), "]"];
            let E = f.getParentNode(), { key: N } = w;
            if (F.quoteProps === "consistent" && !h2.has(E)) {
              let x2 = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F));
              h2.set(E, x2);
            }
            if ((N.type === "Identifier" || n(N) && u(a2(p2(N))) && String(N.value) === a2(p2(N)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h2.get(E))) {
              let x2 = s2(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), F);
              return f.call((I) => t(I, x2, F), "key");
            }
            return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h2.get(E)) ? f.call((x2) => t(x2, /^\d/.test(N.value) ? a2(N.value) : N.value, F), "key") : _("key");
          }
          function c2(f, F, _) {
            return f.getValue().shorthand ? _("value") : y(f, F, _, g(f, F, _), ":", "value");
          }
          r.exports = { printProperty: c2, printPropertyKey: g };
        } }), qr = te2({ "src/language-js/print/function.js"(e, r) {
          ne2();
          var t = Zt2(), { printDanglingComments: s2, printCommentsSeparately: a2 } = et2(), n = lt2(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue2(), { builders: { line: i, softline: l, group: p2, indent: y, ifBreak: h2, hardline: g, join: c2, indentIfBreak: f }, utils: { removeLines: F, willBreak: _ } } = qe2(), { ArgExpansionBailout: w } = Qt2(), { getFunctionParameters: E, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x2, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $2, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m2, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke2(), { locEnd: M } = ut2(), { printFunctionParameters: R, shouldGroupFunctionParameters: q2 } = Lr2(), { printPropertyKey: J } = rr2(), { printFunctionTypeParameters: L } = ct2();
          function Q(U, Z, se, fe) {
            let ge = U.getValue(), he = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
              let Pe = U.getParentNode();
              S(Pe) && b(Pe).length > 1 && (he = true);
            }
            let we = [];
            ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
            let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q2(ge, Re);
            return we.push(L(U, se, Z), p2([Ne ? p2(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
          }
          function V(U, Z, se) {
            let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
          }
          function j(U, Z, se) {
            let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q2(fe, he), ke = [L(U, Z, se), p2([we ? p2(ge) : ge, he])];
            return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
          }
          function Y(U, Z, se, fe) {
            let ge = U.getValue(), he = [];
            if (ge.async && he.push("async "), W(U, Z))
              he.push(se(["params", 0]));
            else {
              let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
              if (ke) {
                if (_(Re))
                  throw new w();
                Re = p2(F(Re));
              }
              he.push(p2([R(U, se, Z, ke, true), Re]));
            }
            let we = s2(U, Z, true, (ke) => {
              let Re = u(Z.originalText, ke, M);
              return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
            });
            return we && he.push(" ", we), he;
          }
          function ie(U, Z, se, fe, ge, he) {
            let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
            return he.body.type === "SequenceExpression" && (ge = p2(["(", y([l, ge]), l, ")"])), p2([p2(y([Re || Ne ? l : "", p2(c2([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h2(l, "", { groupId: H }) : ""]);
          }
          function ee(U, Z, se, fe) {
            let ge = U.getValue(), he = [], we = [], ke = false;
            if (function H() {
              let pe = Y(U, Z, se, fe);
              if (he.length === 0)
                he.push(pe);
              else {
                let { leading: X, trailing: le } = a2(U, Z);
                he.push([X, pe]), we.unshift(le);
              }
              ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
            }(), he.length > 1)
              return ie(U, fe, he, ke, we, ge);
            let Re = he;
            if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
              return p2([...Re, " ", we]);
            if (ge.body.type === "SequenceExpression")
              return p2([...Re, p2([" (", y([l, we]), l, ")"])]);
            let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $2(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
            return p2([...Re, p2([y([i, oe ? h2("", "(") : "", we, oe ? h2("", ")") : ""]), Ne ? [h2(Pe ? "," : ""), l] : ""])]);
          }
          function ce(U) {
            let Z = E(U);
            return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
          }
          function W(U, Z) {
            if (Z.arrowParens === "always")
              return false;
            if (Z.arrowParens === "avoid") {
              let se = U.getValue();
              return ce(se);
            }
            return false;
          }
          function K(U, Z, se) {
            let fe = U.getValue(), ge = Z("returnType");
            if (fe.returnType && x2(se.originalText, fe.returnType))
              return [" /*: ", ge, " */"];
            let he = [ge];
            return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
          }
          function de(U, Z, se) {
            let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
            fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p2([h2(" (", " "), y([l, se("argument")]), l, h2(")")])) : he.push(" ", se("argument")));
            let we = o(fe), ke = n(we), Re = ke && m2(ke);
            return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s2(U, Z, true)), Re || he.push(ge), he;
          }
          function ue(U, Z, se) {
            return ["return", de(U, Z, se)];
          }
          function Fe(U, Z, se) {
            return ["throw", de(U, Z, se)];
          }
          function z(U, Z) {
            if (N(U.originalText, Z))
              return true;
            if (B(Z)) {
              let se = Z, fe;
              for (; fe = k(se); )
                if (se = fe, N(U.originalText, se))
                  return true;
            }
            return false;
          }
          r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
        } }), nu2 = te2({ "src/language-js/print/decorators.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, hasNewline: s2 } = Ue2(), { builders: { line: a2, hardline: n, join: u, breakParent: i, group: l } } = qe2(), { locStart: p2, locEnd: y } = ut2(), { getParentExportDeclaration: h2 } = Ke2();
          function g(w, E, N) {
            let x2 = w.getValue();
            return l([u(a2, w.map(N, "decorators")), F(x2, E) ? n : a2]);
          }
          function c2(w, E, N) {
            return [u(n, w.map(N, "declaration", "decorators")), n];
          }
          function f(w, E, N) {
            let x2 = w.getValue(), { decorators: I } = x2;
            if (!t(I) || _(w.getParentNode()))
              return;
            let P = x2.type === "ClassExpression" || x2.type === "ClassDeclaration" || F(x2, E);
            return [h2(w) ? n : P ? i : "", u(a2, w.map(N, "decorators")), a2];
          }
          function F(w, E) {
            return w.decorators.some((N) => s2(E.originalText, y(N)));
          }
          function _(w) {
            if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
              return false;
            let E = w.declaration && w.declaration.decorators;
            return t(E) && p2(w) === p2(E[0]);
          }
          r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c2, hasDecoratorsBeforeExport: _ };
        } }), nr = te2({ "src/language-js/print/class.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, createGroupIdMapper: s2 } = Ue2(), { printComments: a2, printDanglingComments: n } = et2(), { builders: { join: u, line: i, hardline: l, softline: p2, group: y, indent: h2, ifBreak: g } } = qe2(), { hasComment: c2, CommentCheckFlags: f } = Ke2(), { getTypeParametersGroupId: F } = jr2(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N } = ct2(), { printPropertyKey: x2 } = rr2(), { printAssignment: I } = tr2(), { printClassMemberDecorators: P } = nu2();
          function $2(b, B, k) {
            let M = b.getValue(), R = [];
            M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
            let q2 = M.id && c2(M.id, f.Trailing) || M.typeParameters && c2(M.typeParameters, f.Trailing) || M.superClass && c2(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
            if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
              let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a2(j, Q, B)], "superClass");
              q2 ? L.push(i, y(V)) : L.push(" ", V);
            } else
              L.push(o(b, B, k, "extends"));
            if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q2) {
              let Q;
              C(M) ? Q = [...J, h2(L)] : Q = h2([...J, L]), R.push(y(Q, { id: D(M) }));
            } else
              R.push(...J, ...L);
            return R.push(" ", k("body")), R;
          }
          var D = s2("heritageGroup");
          function T(b) {
            return g(l, "", { groupId: D(b) });
          }
          function m2(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
          }
          function C(b) {
            return b.typeParameters && !c2(b.typeParameters, f.Trailing | f.Line) && !m2(b);
          }
          function o(b, B, k, M) {
            let R = b.getValue();
            if (!t(R[M]))
              return "";
            let q2 = n(b, B, true, (J) => {
              let { marker: L } = J;
              return L === M;
            });
            return [C(R) ? g(" ", i, { groupId: F(R.typeParameters) }) : i, q2, q2 && l, M, y(h2([i, u([",", i], b.map(k, M))]))];
          }
          function d(b, B, k) {
            let M = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h2([p2, M]), p2, ")"], M)) : M;
          }
          function v(b, B, k) {
            let M = b.getValue(), R = [];
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
          }
          function S(b, B, k) {
            let M = b.getValue(), R = [], q2 = B.semi ? ";" : "";
            return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x2(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q2];
          }
          r.exports = { printClass: $2, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
        } }), bo2 = te2({ "src/language-js/print/interface.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { join: s2, line: a2, group: n, indent: u, ifBreak: i } } = qe2(), { hasComment: l, identity: p2, CommentCheckFlags: y } = Ke2(), { getTypeParametersGroupId: h2 } = jr2(), { printTypeScriptModifiers: g } = ct2();
          function c2(f, F, _) {
            let w = f.getValue(), E = [];
            w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f, F, _)), E.push("interface");
            let N = [], x2 = [];
            w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
            let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
            return t(w.extends) && x2.push(I ? i(" ", a2, { groupId: h2(w.typeParameters) }) : a2, "extends ", (w.extends.length === 1 ? p2 : u)(s2([",", a2], f.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n([...N, u(x2)])) : E.push(n(u([...N, ...x2]))) : E.push(...N, ...x2), E.push(" ", _("body")), n(E);
          }
          r.exports = { printInterface: c2 };
        } }), To2 = te2({ "src/language-js/print/module.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { softline: s2, group: a2, indent: n, join: u, line: i, ifBreak: l, hardline: p2 } } = qe2(), { printDanglingComments: y } = et2(), { hasComment: h2, CommentCheckFlags: g, shouldPrintComma: c2, needsHardlineAfterDanglingComment: f, isStringLiteral: F, rawText: _ } = Ke2(), { locStart: w, hasSameLoc: E } = ut2(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x2 } = nu2();
          function I(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q2 } = k;
            return R.push("import"), q2 && q2 !== "value" && R.push(" ", q2), R.push(m2(S, b, B), T(S, b, B), o(S, b, B), M), R;
          }
          function P(S, b, B) {
            let k = S.getValue(), M = [];
            N(k) && M.push(x2(S, b, B));
            let { type: R, exportKind: q2, declaration: J } = k;
            return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h2(k, g.Dangling) && (M.push(" ", y(S, b, true)), f(k) && M.push(p2)), J ? M.push(" ", B("declaration")) : M.push(q2 === "type" ? " type" : "", m2(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
          }
          function $2(S, b, B) {
            let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q2, exported: J } = k;
            return R.push("export"), q2 === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
          }
          function D(S, b) {
            if (!b.semi)
              return false;
            let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
            if (!k)
              return true;
            let { type: R } = k;
            return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
          }
          function T(S, b, B) {
            let k = S.getValue();
            if (!k.source)
              return "";
            let M = [];
            return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
          }
          function m2(S, b, B) {
            let k = S.getValue();
            if (C(k, b))
              return "";
            let M = [" "];
            if (t(k.specifiers)) {
              let R = [], q2 = [];
              S.each(() => {
                let J = S.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                  R.push(B());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                  q2.push(B());
                else
                  throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), M.push(u(", ", R)), q2.length > 0 && (R.length > 0 && M.push(", "), q2.length > 1 || R.length > 0 || k.specifiers.some((L) => h2(L)) ? M.push(a2(["{", n([b.bracketSpacing ? i : s2, u([",", i], q2)]), l(c2(b) ? "," : ""), b.bracketSpacing ? i : s2, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q2, b.bracketSpacing ? " " : "", "}"]));
            } else
              M.push("{}");
            return M;
          }
          function C(S, b) {
            let { type: B, importKind: k, source: M, specifiers: R } = S;
            return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
          }
          function o(S, b, B) {
            let k = S.getNode();
            return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          function d(S, b, B) {
            let k = S.getNode(), { type: M } = k, R = [], q2 = M === "ImportSpecifier" ? k.importKind : k.exportKind;
            q2 && q2 !== "value" && R.push(q2, " ");
            let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
          }
          function v(S) {
            if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
              return false;
            let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
            if (b.type !== B.type || !E(b, B))
              return false;
            if (F(b))
              return b.value === B.value && _(b) === _(B);
            switch (b.type) {
              case "Identifier":
                return b.name === B.name;
              default:
                return false;
            }
          }
          r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $2, printModuleSpecifier: d };
        } }), uu2 = te2({ "src/language-js/print/object.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { line: s2, softline: a2, group: n, indent: u, ifBreak: i, hardline: l } } = qe2(), { getLast: p2, hasNewlineInRange: y, hasNewline: h2, isNonEmptyArray: g } = Ue2(), { shouldPrintComma: c2, hasComment: f, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke2(), { locStart: E, locEnd: N } = ut2(), { printOptionalToken: x2, printTypeAnnotation: I } = ct2(), { shouldHugFunctionParameters: P } = Lr2(), { shouldHugType: $2 } = Or2(), { printHardlineAfterHeritage: D } = nr();
          function T(m2, C, o) {
            let d = C.semi ? ";" : "", v = m2.getValue(), S;
            v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
            let b = v.type === "ObjectTypeAnnotation", B = [S];
            b && B.push("indexers", "callProperties", "internalSlots");
            let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m2.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m2.getName() === "body", q2 = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
            for (let W of B)
              m2.each((K) => {
                let de = K.getValue();
                V.push({ node: de, printed: o(), loc: E(de) });
              }, W);
            B.length > 1 && V.sort((W, K) => W.loc - K.loc);
            let j = [], Y = V.map((W) => {
              let K = [...j, n(W.printed)];
              return j = [J, s2], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
            });
            if (v.inexact) {
              let W;
              if (f(v, _.Dangling)) {
                let K = f(v, _.Line);
                W = [t(m2, C, true), K || h2(C.originalText, N(p2(F(v)))) ? l : s2, "..."];
              } else
                W = ["..."];
              Y.push([...j, ...W]);
            }
            let ie = p2(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
            if (Y.length === 0) {
              if (!f(v, _.Dangling))
                return [L, Q, I(m2, C, o)];
              ce = n([L, t(m2, C), a2, Q, x2(m2), I(m2, C, o)]);
            } else
              ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s2 : a2, ...Y]), i(ee && (J !== "," || c2(C)) ? J : ""), C.bracketSpacing ? s2 : a2, Q, x2(m2), I(m2, C, o)];
            return m2.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m2.match($2, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q2 && m2.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q2 });
          }
          r.exports = { printObject: T };
        } }), dd2 = te2({ "src/language-js/print/flow.js"(e, r) {
          ne2();
          var t = Zt2(), { printDanglingComments: s2 } = et2(), { printString: a2, printNumber: n } = Ue2(), { builders: { hardline: u, softline: i, group: l, indent: p2 } } = qe2(), { getParentExportDeclaration: y, isFunctionNotation: h2, isGetterOrSetter: g, rawText: c2, shouldPrintComma: f } = Ke2(), { locStart: F, locEnd: _ } = ut2(), { replaceTextEndOfLine: w } = Yt2(), { printClass: E } = nr(), { printOpaqueType: N, printTypeAlias: x2, printIntersectionType: I, printUnionType: P, printFunctionType: $2, printTupleType: D, printIndexedAccessType: T } = Or2(), { printInterface: m2 } = bo2(), { printTypeParameter: C, printTypeParameters: o } = jr2(), { printExportDeclaration: d, printExportAllDeclaration: v } = To2(), { printArrayItems: S } = er2(), { printObject: b } = uu2(), { printPropertyKey: B } = rr2(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct2();
          function q2(L, Q, V) {
            let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
            switch (j.type) {
              case "DeclareClass":
                return J(L, E(L, Q, V));
              case "DeclareFunction":
                return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
              case "DeclareModule":
                return J(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
              case "DeclareVariable":
                return J(L, ["var ", V("id"), Y]);
              case "DeclareOpaqueType":
                return J(L, N(L, Q, V));
              case "DeclareInterface":
                return J(L, m2(L, Q, V));
              case "DeclareTypeAlias":
                return J(L, x2(L, Q, V));
              case "DeclareExportDeclaration":
                return J(L, d(L, Q, V));
              case "DeclareExportAllDeclaration":
                return J(L, v(L, Q, V));
              case "OpaqueType":
                return N(L, Q, V);
              case "TypeAlias":
                return x2(L, Q, V);
              case "IntersectionTypeAnnotation":
                return I(L, Q, V);
              case "UnionTypeAnnotation":
                return P(L, Q, V);
              case "FunctionTypeAnnotation":
                return $2(L, Q, V);
              case "TupleTypeAnnotation":
                return D(L, Q, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Q, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return T(L, Q, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return C(L, Q, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(j.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (j.type === "EnumSymbolBody" || j.explicitType) {
                  let ee = null;
                  switch (j.type) {
                    case "EnumBooleanBody":
                      ee = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee = "number";
                      break;
                    case "EnumStringBody":
                      ee = "string";
                      break;
                    case "EnumSymbolBody":
                      ee = "symbol";
                      break;
                  }
                  ie.push("of ", ee, " ");
                }
                if (j.members.length === 0 && !j.hasUnknownMembers)
                  ie.push(l(["{", s2(L, Q), i, "}"]));
                else {
                  let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                  ie.push(l(["{", p2([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s2(L, Q, true), u, "}"]));
                }
                return ie;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m2(L, Q, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: ee } = j;
                return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return j.static && ie.push("static "), ie.push(V("value")), ie;
              case "ObjectTypeIndexer":
                return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let ee = "";
                return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h2(j) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Q, V);
              case "ObjectTypeInternalSlot":
                return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return R(L, Q, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return w(a2(c2(j), Q));
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof j.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return j.extra ? n(j.extra.raw) : n(j.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), M(L, Q, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee = o(L, Q, V, "params");
                if (Q.parser === "flow") {
                  let ce = F(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                  if (K !== -1 && de !== -1) {
                    let ue = Q.originalText.slice(K + 2, de).trim();
                    if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                      return ["/*:: ", ee, " */"];
                  }
                }
                return ee;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(j.type));
            }
          }
          function J(L, Q) {
            let V = y(L);
            return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
          }
          r.exports = { printFlow: q2 };
        } }), gd2 = te2({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
          ne2();
          function t(s2) {
            let { type: a2 } = s2;
            return a2.startsWith("TS") && a2.endsWith("Keyword");
          }
          r.exports = t;
        } }), Bo2 = te2({ "src/language-js/print/ternary.js"(e, r) {
          ne2();
          var { hasNewlineInRange: t } = Ue2(), { isJsxNode: s2, getComments: a2, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke2(), { locStart: l, locEnd: p2 } = ut2(), y = Pt(), { builders: { line: h2, softline: g, group: c2, indent: f, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe2();
          function N(D) {
            let T = [D];
            for (let m2 = 0; m2 < T.length; m2++) {
              let C = T[m2];
              for (let o of ["test", "consequent", "alternate"]) {
                let d = C[o];
                if (s2(d))
                  return true;
                d.type === "ConditionalExpression" && T.push(d);
              }
            }
            return false;
          }
          function x2(D, T, m2) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m2("test") : [m2("checkType"), " ", "extends", " ", m2("extendsType")];
            return v.type === C.type && v[d] === C ? F(2, S) : S;
          }
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(D) {
            let T = D.getValue();
            if (T.type !== "ConditionalExpression")
              return false;
            let m2, C = T;
            for (let o = 0; !m2; o++) {
              let d = D.getParentNode(o);
              if (n(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                C = d;
                continue;
              }
              d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m2 = D.getParentNode(o + 1), C = d) : m2 = d;
            }
            return C === T ? false : m2[I.get(m2.type)] === C;
          }
          function $2(D, T, m2) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R = D.getParentNode(), q2 = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q2, L, Q, V = 0;
            do
              Q = L || C, L = D.getParentNode(V), V++;
            while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
            let j = L || R, Y = Q;
            if (o && (s2(C[S[0]]) || s2(b) || s2(B) || N(Y))) {
              M = true, J = true;
              let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
              k.push(" ? ", Fe(b) ? m2(d) : ue(m2(d)), " : ", B.type === C.type || Fe(B) ? m2(v) : ue(m2(v)));
            } else {
              let ue = [h2, "? ", b.type === C.type ? _("", "(") : "", F(2, m2(d)), b.type === C.type ? _("", ")") : "", h2, ": ", B.type === C.type ? m2(v) : F(2, m2(v))];
              k.push(R.type !== C.type || R[v] === C || q2 ? ue : T.useTabs ? w(f(ue)) : F(Math.max(0, T.tabWidth - 2), ue));
            }
            let ee = [...S.map((ue) => a2(C[ue])), a2(b), a2(B)].flat().some((ue) => y(ue) && t(T.originalText, l(ue), p2(ue))), ce = (ue) => R === j ? c2(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x2(D, T, m2), J ? k : f(k), o && W && !K ? g : ""]);
            return q2 || K ? c2([f([g, de]), g]) : de;
          }
          r.exports = { printTernary: $2 };
        } }), No = te2({ "src/language-js/print/statement.js"(e, r) {
          ne2();
          var { builders: { hardline: t } } = qe2(), s2 = qt2(), { getLeftSidePathName: a2, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p2, isNextLineEmpty: y } = Ke2(), { shouldPrintParamsWithoutParens: h2 } = qr();
          function g(x2, I, P, $2) {
            let D = x2.getValue(), T = [], m2 = D.type === "ClassBody", C = c2(D[$2]);
            return x2.each((o, d, v) => {
              let S = o.getValue();
              if (S.type === "EmptyStatement")
                return;
              let b = P();
              !I.semi && !m2 && !i(I, o) && f(o, I) ? l(S, p2.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m2 && E(S) && N(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t), y(S, I) && T.push(t));
            }, $2), T;
          }
          function c2(x2) {
            for (let I = x2.length - 1; I >= 0; I--) {
              let P = x2[I];
              if (P.type !== "EmptyStatement")
                return P;
            }
          }
          function f(x2, I) {
            return x2.getNode().type !== "ExpressionStatement" ? false : x2.call(($2) => F($2, I), "expression");
          }
          function F(x2, I) {
            let P = x2.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h2(x2, I))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $2, operator: D } = P;
                if ($2 && (D === "+" || D === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!P.object)
                  return true;
                break;
              }
              case "Literal": {
                if (P.regex)
                  return true;
                break;
              }
              default:
                if (u(P))
                  return true;
            }
            return s2(x2, I) ? true : n(P) ? x2.call(($2) => F($2, I), ...a2(x2, P)) : false;
          }
          function _(x2, I, P) {
            return g(x2, I, P, "body");
          }
          function w(x2, I, P) {
            return g(x2, I, P, "consequent");
          }
          var E = (x2) => {
            let { type: I } = x2;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
          };
          function N(x2, I) {
            let { type: P, name: $2 } = x2.key;
            if (!x2.computed && P === "Identifier" && ($2 === "static" || $2 === "get" || $2 === "set" || $2 === "accessor") && !x2.value && !x2.typeAnnotation)
              return true;
            if (!I || I.static || I.accessibility)
              return false;
            if (!I.computed) {
              let D = I.key && I.key.name;
              if (D === "in" || D === "instanceof")
                return true;
            }
            if (E(I) && I.variance && !I.static && !I.declare)
              return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                  return false;
                let T = I.value ? I.value.generator : I.generator;
                return !!(I.computed || T);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          r.exports = { printBody: _, printSwitchCaseConsequent: w };
        } }), wo = te2({ "src/language-js/print/block.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { isNonEmptyArray: s2 } = Ue2(), { builders: { hardline: a2, indent: n } } = qe2(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke2(), { printHardlineAfterHeritage: p2 } = nr(), { printBody: y } = No();
          function h2(c2, f, F) {
            let _ = c2.getValue(), w = [];
            if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s2(_.body)) {
              let N = c2.getParentNode();
              w.push(p2(N));
            }
            w.push("{");
            let E = g(c2, f, F);
            if (E)
              w.push(n([a2, E]), a2);
            else {
              let N = c2.getParentNode(), x2 = c2.getParentNode(1);
              N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x2.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a2);
            }
            return w.push("}"), w;
          }
          function g(c2, f, F) {
            let _ = c2.getValue(), w = s2(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
            if (!w && !E && !N)
              return "";
            let x2 = [];
            if (w && c2.each((I, P, $2) => {
              x2.push(F()), (P < $2.length - 1 || E || N) && (x2.push(a2), l(I.getValue(), f) && x2.push(a2));
            }, "directives"), E && x2.push(y(c2, f, F)), N && x2.push(t(c2, f, true)), _.type === "Program") {
              let I = c2.getParentNode();
              (!I || I.type !== "ModuleExpression") && x2.push(a2);
            }
            return x2;
          }
          r.exports = { printBlock: h2, printBlockBody: g };
        } }), yd2 = te2({ "src/language-js/print/typescript.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { hasNewlineInRange: s2 } = Ue2(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p2, conditionalGroup: y, ifBreak: h2 } } = qe2(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c2, shouldPrintComma: f, isCallExpression: F, isMemberExpression: _ } = Ke2(), w = gd2(), { locStart: E, locEnd: N } = ut2(), { printOptionalToken: x2, printTypeScriptModifiers: I } = ct2(), { printTernary: P } = Bo2(), { printFunctionParameters: $2, shouldGroupFunctionParameters: D } = Lr2(), { printTemplateLiteral: T } = jt2(), { printArrayItems: m2 } = er2(), { printObject: C } = uu2(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr2(), { printPropertyKey: b } = rr2(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo2(), { printBlock: R } = wo(), { printTypeAlias: q2, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or2();
          function ie(ee, ce, W) {
            let K = ee.getValue();
            if (!K.type.startsWith("TS"))
              return;
            if (w(K))
              return K.type.slice(2, -7).toLowerCase();
            let de = ce.semi ? ";" : "", ue = [];
            switch (K.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p2([i, W("typeAnnotation")]), i, ">"]), U = [h2("("), p2([i, W("expression")]), i, h2(")")];
                return Fe ? y([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return B(ee, W, ce);
              case "TSExportAssignment":
                return ["export = ", W("expression"), de];
              case "TSModuleBlock":
                return R(ee, ce, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return C(ee, ce, W);
              case "TSTypeAliasDeclaration":
                return q2(ee, ce, W);
              case "TSQualifiedName":
                return a2(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d(ee, ce, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(ee, ce, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
              case "TSTemplateLiteralType":
                return T(ee, W, ce);
              case "TSNamedTupleMember":
                return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(ee, ce, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return S(ee, ce, W, "params");
              case "TSTypeParameter":
                return v(ee, ce, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                let z = ee.getParentNode();
                return F(z) && z.callee === K || _(z) && z.object === K ? l([p2([i, ...ue]), i]) : ue;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x2(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSParameterProperty":
                return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h2(f(ce) ? "," : "") : "", U = l([p2([i, a2([", ", i], ee.map(W, "parameters"))]), z, i]);
                return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
              }
              case "TSTypePredicate":
                return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return j(ee, ce, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($2(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                  let Fe = K.type === "TSConstructorType";
                  ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ue;
              }
              case "TSTypeOperator":
                return [K.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Fe = s2(ce.originalText, E(K), N(K));
                return l(["{", p2([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c2(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h2(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
              }
              case "TSMethodSignature": {
                let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x2(ee));
                let z = $2(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
                return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
              }
              case "TSNamespaceExportDeclaration":
                return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
              case "TSEnumDeclaration":
                return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p2([u, m2(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
              case "TSEnumMember":
                return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
              case "TSImportEqualsDeclaration":
                return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                if (U)
                  ue.push(".");
                else {
                  K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                  let se = ce.originalText.slice(E(K), E(K.id));
                  K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                }
                return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
              }
              case "TSConditionalType":
                return P(ee, ce, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J(ee, ce, W);
              case "TSUnionType":
                return L(ee, ce, W);
              case "TSFunctionType":
                return Q(ee, ce, W);
              case "TSTupleType":
                return V(ee, ce, W);
              case "TSTypeReference":
                return [W("typeName"), S(ee, ce, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(ee, ce, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Y(ee, W, "?");
              case "TSJSDocNonNullableType":
                return Y(ee, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
            }
          }
          r.exports = { printTypescript: ie };
        } }), hd2 = te2({ "src/language-js/print/comment.js"(e, r) {
          ne2();
          var { hasNewline: t } = Ue2(), { builders: { join: s2, hardline: a2 }, utils: { replaceTextEndOfLine: n } } = qe2(), { isLineComment: u } = Ke2(), { locStart: i, locEnd: l } = ut2(), p2 = Pt();
          function y(c2, f) {
            let F = c2.getValue();
            if (u(F))
              return f.originalText.slice(i(F), l(F)).trimEnd();
            if (p2(F)) {
              if (h2(F)) {
                let E = g(F);
                return F.trailing && !t(f.originalText, i(F), { backwards: true }) ? [a2, E] : E;
              }
              let _ = l(F), w = f.originalText.slice(_ - 3, _) === "*-/";
              return ["/*", n(F.value), w ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(F));
          }
          function h2(c2) {
            let f = `*${c2.value}*`.split(`
`);
            return f.length > 1 && f.every((F) => F.trim()[0] === "*");
          }
          function g(c2) {
            let f = c2.value.split(`
`);
            return ["/*", s2(a2, f.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f.length - 1 ? F.trim() : F.trimStart()))), "*/"];
          }
          r.exports = { printComment: y };
        } }), vd2 = te2({ "src/language-js/print/literal.js"(e, r) {
          ne2();
          var { printString: t, printNumber: s2 } = Ue2(), { replaceTextEndOfLine: a2 } = Yt2(), { printDirective: n } = ct2();
          function u(y, h2) {
            let g = y.getNode();
            switch (g.type) {
              case "RegExpLiteral":
                return p2(g);
              case "BigIntLiteral":
                return l(g.bigint || g.extra.raw);
              case "NumericLiteral":
                return s2(g.extra.raw);
              case "StringLiteral":
                return a2(t(g.extra.raw, h2));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(g.value);
              case "DecimalLiteral":
                return s2(g.value) + "m";
              case "Literal": {
                if (g.regex)
                  return p2(g.regex);
                if (g.bigint)
                  return l(g.raw);
                if (g.decimal)
                  return s2(g.decimal) + "m";
                let { value: c2 } = g;
                return typeof c2 == "number" ? s2(g.raw) : typeof c2 == "string" ? i(y) ? n(g.raw, h2) : a2(t(g.raw, h2)) : String(c2);
              }
            }
          }
          function i(y) {
            if (y.getName() !== "expression")
              return;
            let h2 = y.getParentNode();
            return h2.type === "ExpressionStatement" && h2.directive;
          }
          function l(y) {
            return y.toLowerCase();
          }
          function p2(y) {
            let { pattern: h2, flags: g } = y;
            return g = [...g].sort().join(""), `/${h2}/${g}`;
          }
          r.exports = { printLiteral: u };
        } }), Cd2 = te2({ "src/language-js/printer-estree.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { hasNewline: s2 } = Ue2(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p2 }, utils: { replaceTextEndOfLine: y } } = qe2(), h2 = td2(), g = rd2(), { insertPragma: c2 } = Co2(), f = Eo2(), F = qt2(), _ = Fo2(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x2, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $2, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m2, markerForIfWithoutBlockAndSameLineComment: C } = Ke2(), { locStart: o, locEnd: d } = ut2(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd2(), { printAngular: B } = fd2(), { printJsx: k, hasJsxIgnoreComment: M } = Dd2(), { printFlow: R } = dd2(), { printTypescript: q2 } = yd2(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct2(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To2(), { printTernary: de } = Bo2(), { printTemplateLiteral: ue } = jt2(), { printArray: Fe } = er2(), { printObject: z } = uu2(), { printClass: U, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr2(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo2(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr2(), { printBinaryishExpression: H } = ru2(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So2(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd2(), { printLiteral: De } = vd2(), { printDecorators: A } = nu2();
          function G(Ce, Be, ve, ze) {
            let be = re2(Ce, Be, ve, ze);
            if (!be)
              return "";
            let Ye = Ce.getValue(), { type: Se } = Ye;
            if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod")
              return be;
            let Ie = [be], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
            if (Oe && (Ie = [...Oe, be], !Je))
              return l(Ie);
            if (!F(Ce, Be))
              return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
            if (Je && (Ie = [p2([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
              let [je] = Ye.trailingComments;
              Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
            }
            return Je && Ie.push(n), Ie.push(")"), Ie;
          }
          function re2(Ce, Be, ve, ze) {
            let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
            if (!be)
              return "";
            if (typeof be == "string")
              return be;
            for (let Ie of [De, S, B, k, R, q2]) {
              let Oe = Ie(Ce, Be, ve);
              if (typeof Oe < "u")
                return Oe;
            }
            let Se = [];
            switch (be.type) {
              case "JsExpressionRoot":
                return ve("node");
              case "JsonRoot":
                return [ve("node"), u];
              case "File":
                return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
              case "Program":
                return Ae(Ce, Be, ve);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                  let Oe = Ce.getParentNode();
                  if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be)
                    return [ve("expression"), b(be.expression) ? ";" : ""];
                }
                let Ie = t(Ce, Be, true, (Oe) => {
                  let { marker: Je } = Oe;
                  return Je === C;
                });
                return [ve("expression"), x2(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
              }
              case "ParenthesizedExpression":
                return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p2([i, ve("expression")]), i, ")"]);
              case "AssignmentExpression":
                return oe(Ce, Be, ve);
              case "VariableDeclarator":
                return Pe(Ce, Be, ve);
              case "BinaryExpression":
              case "LogicalExpression":
                return H(Ce, Be, ve);
              case "AssignmentPattern":
                return [ve("left"), " = ", ve("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X(Ce, Be, ve);
              case "MetaProperty":
                return [ve("meta"), ".", ve("property")];
              case "BindExpression":
                return be.object && Se.push(ve("object")), Se.push(l(p2([i, L(Ce, Be, ve)]))), Se;
              case "Identifier":
                return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
              case "V8IntrinsicIdentifier":
                return ["%", be.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return j(Ce, Be, ve);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Ce, ve, Be, ze);
              case "ArrowFunctionExpression":
                return he(Ce, Be, ve, ze);
              case "YieldExpression":
                return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
              case "AwaitExpression": {
                if (Se.push("await"), be.argument) {
                  Se.push(" ", ve("argument"));
                  let Ie = Ce.getParentNode();
                  if (T(Ie) && Ie.callee === be || m2(Ie) && Ie.object === be) {
                    Se = [p2([i, ...Se]), i];
                    let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                    if (!Oe || Oe.type !== "AwaitExpression")
                      return l(Se);
                  }
                }
                return Se;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ce(Ce, Be, ve);
              case "ExportAllDeclaration":
                return W(Ce, Be, ve);
              case "ImportDeclaration":
                return ee(Ce, Be, ve);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return K(Ce, Be, ve);
              case "ImportAttribute":
                return [ve("key"), ": ", ve("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return le(Ce, Be, ve);
              case "ThrowStatement":
                return Re(Ce, Be, ve);
              case "ReturnStatement":
                return ke(Ce, Be, ve);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return Ne(Ce, Be, ve);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Ce, Be, ve);
              case "ObjectProperty":
              case "Property":
                return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
              case "ObjectMethod":
                return we(Ce, Be, ve);
              case "Decorator":
                return ["@", ve("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Fe(Ce, Be, ve);
              case "SequenceExpression": {
                let Ie = Ce.getParentNode(0);
                if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                  let Oe = [];
                  return Ce.each((Je, Te2) => {
                    Te2 === 0 ? Oe.push(ve()) : Oe.push(",", p2([n, ve()]));
                  }, "expressions"), l(Oe);
                }
                return l(a2([",", n], Ce.map(ve, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [ve("value"), Ye];
              case "DirectiveLiteral":
                return ie(be.extra.raw, Be);
              case "UnaryExpression":
                return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p2([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
              case "UpdateExpression":
                return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
              case "ConditionalExpression":
                return de(Ce, Be, ve);
              case "VariableDeclaration": {
                let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te2 = be.declarations.some((Me) => Me.init), je;
                return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p2(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p2(Ie.slice(1).map((Me) => [",", Te2 && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
              }
              case "WithStatement":
                return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
              case "IfStatement": {
                let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p2([i, ve("test")]), i]), ")", Ie]);
                if (Se.push(Oe), be.alternate) {
                  let Je = E(be.consequent, N.Trailing | N.Line) || $2(be), Te2 = be.consequent.type === "BlockStatement" && !Je;
                  Se.push(Te2 ? " " : u), E(be, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                }
                return Se;
              }
              case "ForStatement": {
                let Ie = V(be.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p2([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
              }
              case "WhileStatement":
                return l(["while (", l([p2([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
              case "ForInStatement":
                return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
              case "ForOfStatement":
                return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
              case "DoWhileStatement": {
                let Ie = V(be.body, ve("body"));
                return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p2([i, ve("test")]), i]), ")", Ye), Se;
              }
              case "DoExpression":
                return [be.async ? "async " : "", "do ", ve("body")];
              case "BreakStatement":
                return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "ContinueStatement":
                return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
              case "LabeledStatement":
                return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
              case "TryStatement":
                return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
              case "CatchClause":
                if (be.param) {
                  let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s2(Be.originalText, d(Je)) || Je.trailing && s2(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                  return ["catch ", Ie ? ["(", p2([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                }
                return ["catch ", ve("body")];
              case "SwitchStatement":
                return [l(["switch (", p2([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p2([u, a2(u, Ce.map((Ie, Oe, Je) => {
                  let Te2 = Ie.getValue();
                  return [ve(), Oe !== Je.length - 1 && P(Te2, Be) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N.Dangling) && Se.push(" ", t(Ce, Be, true));
                let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                if (Ie.length > 0) {
                  let Oe = pe(Ce, Be, ve);
                  Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p2([u, Oe]));
                }
                return Se;
              }
              case "DebuggerStatement":
                return ["debugger", Ye];
              case "ClassDeclaration":
              case "ClassExpression":
                return U(Ce, Be, ve);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Ce, Be, ve);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return se(Ce, Be, ve);
              case "TemplateElement":
                return y(be.value.raw);
              case "TemplateLiteral":
                return ue(Ce, ve, Be);
              case "TaggedTemplateExpression":
                return [ve("tag"), ve("typeParameters"), ve("quasi")];
              case "PrivateIdentifier":
                return ["#", ve("name")];
              case "PrivateName":
                return ["#", ve("id")];
              case "InterpreterDirective":
                return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Se.push("module {");
                let Ie = ve("body");
                return Ie && Se.push(p2([u, Ie]), u), Se.push("}"), Se;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(be.type));
            }
          }
          function ye(Ce) {
            return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
          }
          r.exports = { preprocess: _, print: G, embed: h2, insertPragma: c2, massageAstNode: g, hasPrettierIgnore(Ce) {
            return D(Ce) || M(Ce);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Ed2 = te2({ "src/language-js/printer-estree-json.js"(e, r) {
          ne2();
          var { builders: { hardline: t, indent: s2, join: a2 } } = qe2(), n = Fo2();
          function u(y, h2, g) {
            let c2 = y.getValue();
            switch (c2.type) {
              case "JsonRoot":
                return [g("node"), t];
              case "ArrayExpression": {
                if (c2.elements.length === 0)
                  return "[]";
                let f = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                return ["[", s2([t, a2([",", t], f)]), t, "]"];
              }
              case "ObjectExpression":
                return c2.properties.length === 0 ? "{}" : ["{", s2([t, a2([",", t], y.map(g, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [g("key"), ": ", g("value")];
              case "UnaryExpression":
                return [c2.operator === "+" ? "" : c2.operator, g("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return c2.value ? "true" : "false";
              case "StringLiteral":
                return JSON.stringify(c2.value);
              case "NumericLiteral":
                return i(y) ? JSON.stringify(String(c2.value)) : JSON.stringify(c2.value);
              case "Identifier":
                return i(y) ? JSON.stringify(c2.name) : c2.name;
              case "TemplateLiteral":
                return g(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(c2.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(c2.type));
            }
          }
          function i(y) {
            return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
          }
          var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function p2(y, h2) {
            let { type: g } = y;
            if (g === "ObjectProperty") {
              let { key: c2 } = y;
              c2.type === "Identifier" ? h2.key = { type: "StringLiteral", value: c2.name } : c2.type === "NumericLiteral" && (h2.key = { type: "StringLiteral", value: String(c2.value) });
              return;
            }
            if (g === "UnaryExpression" && y.operator === "+")
              return h2.argument;
            if (g === "ArrayExpression") {
              for (let [c2, f] of y.elements.entries())
                f === null && h2.elements.splice(c2, 0, { type: "NullLiteral" });
              return;
            }
            if (g === "TemplateLiteral")
              return { type: "StringLiteral", value: y.quasis[0].value.cooked };
          }
          p2.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p2 };
        } }), Mt2 = te2({ "src/common/common-options.js"(e, r) {
          ne2();
          var t = "Common";
          r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Fd2 = te2({ "src/language-js/options.js"(e, r) {
          ne2();
          var t = Mt2(), s2 = "JavaScript";
          r.exports = { arrowParens: { since: "1.9.0", category: s2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), Ad2 = te2({ "src/language-js/parse/parsers.js"() {
          ne2();
        } }), Ln2 = te2({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
          r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Sd2 = te2({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
          r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), xd2 = te2({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
          r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), wa2 = te2({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
          r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), bd2 = te2({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
          r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), Td2 = te2({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
          r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Bd2 = te2({ "src/language-js/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = Cd2(), a2 = Ed2(), n = Fd2(), u = Ad2(), i = [t(Ln2(), (p2) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p2.interpreters, "zx"], extensions: [...p2.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Ln2(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln2(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa2(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa2(), (p2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p2.extensions.filter((y) => y !== ".jsonl") })), t(bd2(), (p2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p2.filenames, ".eslintrc", ".swcrc"] })), t(Td2(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s2, "estree-json": a2 };
          r.exports = { languages: i, options: n, printers: l, parsers: u };
        } }), Nd2 = te2({ "src/language-css/clean.js"(e, r) {
          ne2();
          var { isFrontMatterNode: t } = Ue2(), s2 = lt2(), a2 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function n(i, l, p2) {
            if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p2.type === "css-root" && p2.nodes.length > 0 && ((p2.nodes[0] === i || t(p2.nodes[0]) && p2.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p2.type === "css-root" && s2(p2.nodes) === i))
              return null;
            if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h2, g) => {
              let c2 = Number(h2);
              return Number.isNaN(c2) ? y : c2 + g.toLowerCase();
            })), i.type === "selector-tag") {
              let y = i.value.toLowerCase();
              ["from", "to"].includes(y) && (l.value = y);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
              let y = i.groups.findIndex((h2) => h2.type === "value-number" && h2.unit === "...");
              y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
            if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]")))
              return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
          }
          n.ignoredProperties = a2;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          r.exports = n;
        } }), su = te2({ "src/utils/front-matter/print.js"(e, r) {
          ne2();
          var { builders: { hardline: t, markAsRoot: s2 } } = qe2();
          function a2(n, u) {
            if (n.lang === "yaml") {
              let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s2([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
            }
          }
          r.exports = a2;
        } }), wd2 = te2({ "src/language-css/embed.js"(e, r) {
          ne2();
          var { builders: { hardline: t } } = qe2(), s2 = su();
          function a2(n, u, i) {
            let l = n.getValue();
            if (l.type === "front-matter") {
              let p2 = s2(l, i);
              return p2 ? [p2, t] : "";
            }
          }
          r.exports = a2;
        } }), _o = te2({ "src/utils/front-matter/parse.js"(e, r) {
          ne2();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s2(a2) {
            let n = a2.match(t);
            if (!n)
              return { content: a2 };
            let { startDelimiter: u, language: i, value: l = "", endDelimiter: p2 } = n.groups, y = i.trim() || "yaml";
            if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p2)
              return { content: a2 };
            let [h2] = n;
            return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p2, raw: h2.replace(/\n$/, "") }, content: h2.replace(/[^\n]/g, " ") + a2.slice(h2.length) };
          }
          r.exports = s2;
        } }), _d2 = te2({ "src/language-css/pragma.js"(e, r) {
          ne2();
          var t = Co2(), s2 = _o();
          function a2(u) {
            return t.hasPragma(s2(u).content);
          }
          function n(u) {
            let { frontMatter: i, content: l } = s2(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(l);
          }
          r.exports = { hasPragma: a2, insertPragma: n };
        } }), Pd2 = te2({ "src/language-css/utils/index.js"(e, r) {
          ne2();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s2(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = -1, fe;
            for (; fe = z.getParentNode(++se); )
              if (Z.includes(fe.type))
                return se;
            return -1;
          }
          function a2(z, U) {
            let Z = s2(z, U);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          function n(z) {
            var U;
            let Z = a2(z, "css-decl");
            return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(z) {
            return u.has(z.toLowerCase());
          }
          function l(z, U) {
            let Z = a2(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
          }
          function p2(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          function y(z, U) {
            var Z;
            let se = a2(z, "value-func");
            return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
          }
          function h2(z) {
            var U;
            let Z = a2(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
            return se && (se.startsWith(":import") || se.startsWith(":export"));
          }
          function g(z, U) {
            let Z = Array.isArray(U) ? U : [U], se = a2(z, "css-atrule");
            return se && Z.includes(se.name.toLowerCase());
          }
          function c2(z) {
            let U = z.getValue(), Z = a2(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
          }
          function f(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          function F(z, U) {
            var Z;
            let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return se && se.indexOf(U) === se.length - 1;
          }
          function _(z) {
            let { selector: U } = z;
            return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
          }
          function w(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          function E(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          function N(z) {
            return z.type === "value-word" && z.value === "in";
          }
          function x2(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          function $2(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          function D(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          function T(z) {
            return x2(z) || I(z) || P(z) || $2(z) || D(z);
          }
          function m2(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          function C(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          function d(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          function v(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          function S(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          function b(z, U) {
            return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
          }
          function B(z) {
            var U, Z;
            return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          function k(z) {
            var U, Z, se;
            return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          function M(z) {
            var U;
            return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
          }
          function R(z) {
            var U, Z;
            return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          function q2(z) {
            var U;
            return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
          }
          function J(z) {
            var U;
            let Z = z.getValue();
            if (Z.groups.length === 0)
              return false;
            let se = z.getParentNode(1);
            if (!q2(Z) && !(se && q2(se)))
              return false;
            let fe = a2(z, "css-decl");
            return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q2(se) || se.type === "value-func");
          }
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          function Q(z) {
            return z.type === "value-word" && z.value === "#";
          }
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          function j(z) {
            return z.type === "value-word" && z.value === "}";
          }
          function Y(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          function ie(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          function ee(z, U) {
            if (!R(U))
              return false;
            let { groups: Z } = U, se = Z.indexOf(z);
            return se === -1 ? false : ie(Z[se + 1]);
          }
          function ce(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          function W(z) {
            return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
          }
          function K(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          function de(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          function ue(z, U) {
            var Z, se;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
              return false;
            if (U.type === "value-comma_group") {
              let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                return true;
            }
            return false;
          }
          function Fe(z) {
            var U, Z;
            return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          r.exports = { getAncestorCounter: s2, getAncestorNode: a2, getPropOfDeclNode: n, maybeToLowerCase: p2, insideValueFunctionNode: y, insideICSSRuleNode: h2, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c2, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m2, isMultiplicationNode: x2, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $2, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q2, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
        } }), Id2 = te2({ "src/utils/line-column-to-index.js"(e, r) {
          ne2(), r.exports = function(t, s2) {
            let a2 = 0;
            for (let n = 0; n < t.line - 1; ++n)
              a2 = s2.indexOf(`
`, a2) + 1;
            return a2 + t.column;
          };
        } }), kd2 = te2({ "src/language-css/loc.js"(e, r) {
          ne2();
          var { skipEverythingButNewLine: t } = Pr2(), s2 = lt2(), a2 = Id2();
          function n(c2, f) {
            return typeof c2.sourceIndex == "number" ? c2.sourceIndex : c2.source ? a2(c2.source.start, f) - 1 : null;
          }
          function u(c2, f) {
            if (c2.type === "css-comment" && c2.inline)
              return t(f, c2.source.startOffset);
            let F = c2.nodes && s2(c2.nodes);
            return F && c2.source && !c2.source.end && (c2 = F), c2.source && c2.source.end ? a2(c2.source.end, f) : null;
          }
          function i(c2, f) {
            c2.source && (c2.source.startOffset = n(c2, f), c2.source.endOffset = u(c2, f));
            for (let F in c2) {
              let _ = c2[F];
              F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p2(c2), _.text || _.value) : i(_, f));
            }
          }
          function l(c2, f, F) {
            c2.source && (c2.source.startOffset = n(c2, F) + f, c2.source.endOffset = u(c2, F) + f);
            for (let _ in c2) {
              let w = c2[_];
              _ === "source" || !w || typeof w != "object" || l(w, f, F);
            }
          }
          function p2(c2) {
            let f = c2.source.startOffset;
            return typeof c2.prop == "string" && (f += c2.prop.length), c2.type === "css-atrule" && typeof c2.name == "string" && (f += 1 + c2.name.length + c2.raws.afterName.match(/^\s*:?\s*/)[0].length), c2.type !== "css-atrule" && c2.raws && typeof c2.raws.between == "string" && (f += c2.raws.between.length), f;
          }
          function y(c2) {
            let f = "initial", F = "initial", _, w = false, E = [];
            for (let N = 0; N < c2.length; N++) {
              let x2 = c2[N];
              switch (f) {
                case "initial":
                  if (x2 === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (x2 === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((x2 === "u" || x2 === "U") && c2.slice(N, N + 4).toLowerCase() === "url(") {
                    f = "url", N += 3;
                    continue;
                  }
                  if (x2 === "*" && c2[N - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (x2 === "/" && c2[N - 1] === "/") {
                    f = "comment-inline", _ = N - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (x2 === "'" && c2[N - 1] !== "\\" && (f = F, F = "initial"), x2 === `
` || x2 === "\r")
                    return c2;
                  continue;
                case "double-quotes":
                  if (x2 === '"' && c2[N - 1] !== "\\" && (f = F, F = "initial"), x2 === `
` || x2 === "\r")
                    return c2;
                  continue;
                case "url":
                  if (x2 === ")" && (f = "initial"), x2 === `
` || x2 === "\r")
                    return c2;
                  if (x2 === "'") {
                    f = "single-quotes", F = "url";
                    continue;
                  }
                  if (x2 === '"') {
                    f = "double-quotes", F = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  x2 === "/" && c2[N - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (x2 === '"' || x2 === "'" || x2 === "*") && (w = true), (x2 === `
` || x2 === "\r") && (w && E.push([_, N]), f = "initial", w = false);
                  continue;
              }
            }
            for (let [N, x2] of E)
              c2 = c2.slice(0, N) + c2.slice(N, x2).replace(/["'*]/g, " ") + c2.slice(x2);
            return c2;
          }
          function h2(c2) {
            return c2.source.startOffset;
          }
          function g(c2) {
            return c2.source.endOffset;
          }
          r.exports = { locStart: h2, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
        } }), Ld2 = te2({ "src/language-css/utils/is-less-parser.js"(e, r) {
          ne2();
          function t(s2) {
            return s2.parser === "css" || s2.parser === "less";
          }
          r.exports = t;
        } }), Od2 = te2({ "src/language-css/utils/is-scss.js"(e, r) {
          ne2();
          function t(s2, a2) {
            return s2 === "less" || s2 === "scss" ? s2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a2);
          }
          r.exports = t;
        } }), jd2 = te2({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
          r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), qd2 = te2({ "src/language-css/utils/print-unit.js"(e, r) {
          ne2();
          var t = jd2();
          function s2(a2) {
            let n = a2.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a2;
          }
          r.exports = s2;
        } }), Md2 = te2({ "src/language-css/printer-postcss.js"(e, r) {
          ne2();
          var t = lt2(), { printNumber: s2, printString: a2, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue2(), { builders: { join: p2, line: y, hardline: h2, softline: g, group: c2, fill: f, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N, getDocParts: x2 } } = qe2(), I = Nd2(), P = wd2(), { insertPragma: $2 } = _d2(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m2, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q2, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd2(), { locStart: Ae, locEnd: Ee } = kd2(), De = Ld2(), A = Od2(), G = qd2();
          function re2(Te2) {
            return Te2.trailingComma === "es5" || Te2.trailingComma === "all";
          }
          function ye(Te2, je, Me) {
            let ae = Te2.getValue();
            if (!ae)
              return "";
            if (typeof ae == "string")
              return ae;
            switch (ae.type) {
              case "front-matter":
                return [ae.raw, h2];
              case "css-root": {
                let Ve = Ce(Te2, je, Me), We = ae.raws.after.trim();
                return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x2(Ve).length > 0 ? h2 : ""];
              }
              case "css-comment": {
                let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                return Ve ? We.trimEnd() : We;
              }
              case "css-rule":
                return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F([h2, Ce(Te2, je, Me)]) : "", h2, "}", M(ae) ? ";" : ""] : ";"];
              case "css-decl": {
                let Ve = Te2.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
                return !st && H(Xe) && (O = F([h2, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te2) ? ae.prop : m2(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F([g, Ce(Te2, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te2, ae) ? w(";") : ";"];
              }
              case "css-atrule": {
                let Ve = Te2.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                if (De(je)) {
                  if (ae.mixin)
                    return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                  if (ae.function)
                    return [ae.name, Me("params"), We ? "" : ";"];
                  if (ae.variable)
                    return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F([ae.nodes.length > 0 ? g : "", Ce(Te2, je, Me)]), g, "}"] : "", We ? "" : ";"];
                }
                return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m2(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h2, h2] : /^\s*\n/.test(ae.raws.afterName) ? h2 : " " : " ", Me("params")] : "", ae.selector ? F([" ", Me("selector")]) : "", ae.value ? c2([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F([ae.nodes.length > 0 ? g : "", Ce(Te2, je, Me)]), g, "}"] : We ? "" : ";"];
              }
              case "media-query-list": {
                let Ve = [];
                return Te2.each((We) => {
                  let Xe = We.getValue();
                  Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                }, "nodes"), c2(F(p2(y, Ve)));
              }
              case "media-query":
                return [p2(" ", Te2.map(Me, "nodes")), B(Te2, ae) ? "" : ","];
              case "media-type":
                return Oe(Se(ae.value, je));
              case "media-feature-expression":
                return ae.nodes ? ["(", ...Te2.map(Me, "nodes"), ")"] : ae.value;
              case "media-feature":
                return m2(Se(ae.value.replace(/ +/g, " "), je));
              case "media-colon":
                return [ae.value, " "];
              case "media-value":
                return Oe(Se(ae.value, je));
              case "media-keyword":
                return Se(ae.value, je);
              case "media-url":
                return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
              case "media-unknown":
                return ae.value;
              case "selector-root":
                return c2([d(Te2, "custom-selector") ? [D(Te2, "css-atrule").customSelector, y] : "", p2([",", d(Te2, ["extend", "custom-selector", "nest"]) ? y : h2], Te2.map(Me, "nodes"))]);
              case "selector-selector":
                return c2(F(Te2.map(Me, "nodes")));
              case "selector-comment":
                return ae.value;
              case "selector-string":
                return Se(ae.value, je);
              case "selector-tag": {
                let Ve = Te2.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te2, ae.value) ? ae.value.toLowerCase() : ae.value)];
              }
              case "selector-id":
                return ["#", ae.value];
              case "selector-class":
                return [".", Oe(Se(ae.value, je))];
              case "selector-attribute": {
                var nt;
                return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                  let Xe = Te2.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te2, ae) ? "" : " "];
                }
                let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                return [Ve, We];
              }
              case "selector-universal":
                return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
              case "selector-pseudo":
                return [m2(ae.value), l(ae.nodes) ? c2(["(", F([g, p2([",", y], Te2.map(Me, "nodes"))]), g, ")"]) : ""];
              case "selector-nesting":
                return ae.value;
              case "selector-unknown": {
                let Ve = D(Te2, "css-rule");
                if (Ve && Ve.isSCSSNesterProperty)
                  return Oe(Se(m2(ae.value), je));
                let We = Te2.getParentNode();
                if (We.raws && We.raws.selector) {
                  let st = Ae(We), O = st + We.raws.selector.length;
                  return je.originalText.slice(st, O).trim();
                }
                let Xe = Te2.getParentNode(1);
                if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                  return H(me) ? [E, me] : me;
                }
                return ae.value;
              }
              case "value-value":
              case "value-root":
                return Me("group");
              case "value-comment":
                return je.originalText.slice(Ae(ae), Ee(ae));
              case "value-comma_group": {
                let Ve = Te2.getParentNode(), We = Te2.getParentNode(1), Xe = T(Te2), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te2, "css-atrule"), me = O && k(O), _e = ae.groups.some((at2) => ge(at2)), He = Te2.map(Me, "groups"), Ge = [], it = C(Te2, "url"), Qe = false, rt = false;
                for (let at2 = 0; at2 < ae.groups.length; ++at2) {
                  var tt;
                  Ge.push(He[at2]);
                  let Ze = ae.groups[at2 - 1], Le = ae.groups[at2], $e = ae.groups[at2 + 1], sr2 = ae.groups[at2 + 2];
                  if (it) {
                    ($e && Q($e) || Q(Le)) && Ge.push(" ");
                    continue;
                  }
                  if (d(Te2, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e))
                    continue;
                  if (Le.type === "value-string" && Le.quoted) {
                    let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                    $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                  }
                  if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e))
                    continue;
                  let Rr = j(Le), ou = j($e);
                  if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te2, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e))
                    continue;
                  let qo = (Q(Le) || V(Le)) && at2 === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr2 && sr2.type === "value-func" || sr2 && Re(sr2) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                  if (!(!(J($e) || J(Le)) && !C(Te2, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                    if (ge(Le)) {
                      if (Ve.type === "value-paren_group") {
                        Ge.push(_(h2));
                        continue;
                      }
                      Ge.push(h2);
                      continue;
                    }
                    if (me && (q2($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                      Ge.push(" ");
                      continue;
                    }
                    if (O && O.name.toLowerCase() === "namespace") {
                      Ge.push(" ");
                      continue;
                    }
                    if (st) {
                      Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h2), rt = true) : Ge.push(" ");
                      continue;
                    }
                    if (ou) {
                      Ge.push(" ");
                      continue;
                    }
                    if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                      if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                        Ge.push(g);
                        continue;
                      }
                      if (Le.value === "with" && le($e)) {
                        Ge.push(" ");
                        continue;
                      }
                      (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                    }
                  }
                }
                return _e && Ge.push(E), rt && Ge.unshift(h2), me ? c2(F(Ge)) : v(Te2) ? c2(f(Ge)) : c2(F(f(Ge)));
              }
              case "value-paren_group": {
                let Ve = Te2.getParentNode();
                if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
                  return [ae.open ? Me("open") : "", p2(",", Te2.map(Me, "groups")), ae.close ? Me("close") : ""];
                if (!ae.open) {
                  let it = Te2.map(Me, "groups"), Qe = [];
                  for (let rt = 0; rt < it.length; rt++)
                    rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                  return c2(F(f(Qe)));
                }
                let We = fe(Te2), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c2([ae.open ? Me("open") : "", F([g, p2([y], Te2.map((it, Qe) => {
                  let rt = it.getValue(), at2 = Qe === ae.groups.length - 1, Ze = [Me(), at2 ? "" : ","];
                  if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                    let Le = x2(Ze[0].contents.contents);
                    Le[1] = c2(Le[1]), Ze = [c2(_(Ze))];
                  }
                  if (!at2 && rt.type === "value-comma_group" && l(rt.groups)) {
                    let Le = t(rt.groups);
                    !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h2);
                  }
                  return Ze;
                }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re2(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                return He ? _(Ge) : Ge;
              }
              case "value-func":
                return [ae.value, d(Te2, "supports") && Pe(ae) ? " " : "", Me("group")];
              case "value-paren":
                return ae.value;
              case "value-number":
                return [Je(ae.value), G(ae.unit)];
              case "value-operator":
                return ae.value;
              case "value-word":
                return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
              case "value-colon": {
                let Ve = Te2.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te2, "url") ? "" : y];
              }
              case "value-comma":
                return [ae.value, " "];
              case "value-string":
                return a2(ae.raws.quote + ae.value + ae.raws.quote, je);
              case "value-atword":
                return ["@", ae.value];
              case "value-unicode-range":
                return ae.value;
              case "value-unknown":
                return ae.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
            }
          }
          function Ce(Te2, je, Me) {
            let ae = [];
            return Te2.each((nt, tt, Ve) => {
              let We = Ve[tt - 1];
              if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                let Xe = nt.getValue();
                ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
              } else
                ae.push(Me());
              tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h2), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h2)));
            }, "nodes"), ae;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
          function Se(Te2, je) {
            return Te2.replace(Be, (Me) => a2(Me, je));
          }
          function Ie(Te2, je) {
            let Me = je.singleQuote ? "'" : '"';
            return Te2.includes('"') || Te2.includes("'") ? Te2 : Me + Te2 + Me;
          }
          function Oe(Te2) {
            return Te2.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m2(tt || "") : je);
          }
          function Je(Te2) {
            return s2(Te2).replace(/\.0(?=$|e)/, "");
          }
          r.exports = { print: ye, embed: P, insertPragma: $2, massageAstNode: I };
        } }), Rd2 = te2({ "src/language-css/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { singleQuote: t.singleQuote };
        } }), $d2 = te2({ "src/language-css/parsers.js"() {
          ne2();
        } }), Vd2 = te2({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
          r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Wd2 = te2({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
          r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Hd2 = te2({ "node_modules/linguist-languages/data/Less.json"(e, r) {
          r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Gd2 = te2({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
          r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Ud2 = te2({ "src/language-css/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = Md2(), a2 = Rd2(), n = $d2(), u = [t(Vd2(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd2(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd2(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd2(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s2 };
          r.exports = { languages: u, options: a2, printers: i, parsers: n };
        } }), Jd2 = te2({ "src/language-handlebars/loc.js"(e, r) {
          ne2();
          function t(a2) {
            return a2.loc.start.offset;
          }
          function s2(a2) {
            return a2.loc.end.offset;
          }
          r.exports = { locStart: t, locEnd: s2 };
        } }), zd2 = te2({ "src/language-handlebars/clean.js"(e, r) {
          ne2();
          function t(s2, a2) {
            if (s2.type === "TextNode") {
              let n = s2.chars.trim();
              if (!n)
                return null;
              a2.chars = n.replace(/[\t\n\f\r ]+/g, " ");
            }
            s2.type === "AttrNode" && s2.name.toLowerCase() === "class" && delete a2.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
        } }), Xd2 = te2({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
          r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
        } }), Kd2 = te2({ "src/language-handlebars/utils.js"(e, r) {
          ne2();
          var t = lt2(), s2 = Xd2();
          function a2(x2) {
            let I = x2.getValue(), P = x2.getParentNode(0);
            return !!(g(x2, ["ElementNode"]) && t(P.children) === I || g(x2, ["Block"]) && t(P.body) === I);
          }
          function n(x2) {
            return x2.toUpperCase() === x2;
          }
          function u(x2) {
            return h2(x2, ["ElementNode"]) && typeof x2.tag == "string" && !x2.tag.startsWith(":") && (n(x2.tag[0]) || x2.tag.includes("."));
          }
          var i = new Set(s2);
          function l(x2) {
            return i.has(x2.toLowerCase()) && !n(x2[0]);
          }
          function p2(x2) {
            return x2.selfClosing === true || l(x2.tag) || u(x2) && x2.children.every((I) => y(I));
          }
          function y(x2) {
            return h2(x2, ["TextNode"]) && !/\S/.test(x2.chars);
          }
          function h2(x2, I) {
            return x2 && I.includes(x2.type);
          }
          function g(x2, I) {
            let P = x2.getParentNode(0);
            return h2(P, I);
          }
          function c2(x2, I) {
            let P = _(x2);
            return h2(P, I);
          }
          function f(x2, I) {
            let P = w(x2);
            return h2(P, I);
          }
          function F(x2, I) {
            var P, $2, D, T;
            let m2 = x2.getValue(), C = (P = x2.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($2 = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $2 !== void 0 ? $2 : [], d = o.indexOf(m2);
            return d !== -1 && o[d + I];
          }
          function _(x2) {
            let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return F(x2, -I);
          }
          function w(x2) {
            return F(x2, 1);
          }
          function E(x2) {
            return h2(x2, ["MustacheCommentStatement"]) && typeof x2.value == "string" && x2.value.trim() === "prettier-ignore";
          }
          function N(x2) {
            let I = x2.getValue(), P = _(x2, 2);
            return E(I) || E(P);
          }
          r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a2, isNextNodeOfSomeType: f, isNodeOfSomeType: h2, isParentOfSomeType: g, isPreviousNodeOfSomeType: c2, isVoid: p2, isWhitespaceNode: y };
        } }), Yd2 = te2({ "src/language-handlebars/printer-glimmer.js"(e, r) {
          ne2();
          var { builders: { dedent: t, fill: s2, group: a2, hardline: n, ifBreak: u, indent: i, join: l, line: p2, softline: y }, utils: { getDocParts: h2, replaceTextEndOfLine: g } } = qe2(), { getPreferredQuote: c2, isNonEmptyArray: f } = Ue2(), { locStart: F, locEnd: _ } = Jd2(), w = zd2(), { getNextNode: E, getPreviousNode: N, hasPrettierIgnore: x2, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $2, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m2, isWhitespaceNode: C } = Kd2(), o = 2;
          function d(H, pe, X) {
            let le = H.getValue();
            if (!le)
              return "";
            if (x2(H))
              return pe.originalText.slice(F(le), _(le));
            let Ae = pe.singleQuote ? "'" : '"';
            switch (le.type) {
              case "Block":
              case "Program":
              case "Template":
                return a2(H.map(X, "body"));
              case "ElementNode": {
                let Ee = a2(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                if (m2(le))
                  return [Ee, De];
                let A = ["</", le.tag, ">"];
                return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a2(b(H, pe, X))), i(A), De];
              }
              case "BlockStatement": {
                let Ee = H.getParentNode(1);
                return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a2([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
              }
              case "ElementModifierStatement":
                return a2(["{{", Re(H, X), "}}"]);
              case "MustacheStatement":
                return a2([k(le), Re(H, X), M(le)]);
              case "SubExpression":
                return a2(["(", ke(H, X), y, ")"]);
              case "AttrNode": {
                let Ee = le.value.type === "TextNode";
                if (Ee && le.value.chars === "" && F(le.value) === _(le.value))
                  return le.name;
                let A = Ee ? c2(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c2(le.value.parts.filter((re2) => re2.type === "TextNode").map((re2) => re2.chars).join(""), Ae).quote : "", G = X("value");
                return [le.name, "=", A, le.name === "class" && A ? a2(i(G)) : G, A];
              }
              case "ConcatStatement":
                return H.map(X, "parts");
              case "Hash":
                return l(p2, H.map(X, "pairs"));
              case "HashPair":
                return [le.key, "=", X("value")];
              case "TextNode": {
                let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
                if (De) {
                  if (De === "class") {
                    let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                    return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p2 : "", Ye, Ie ? p2 : ""];
                  }
                  return g(Ee);
                }
                let G = /^[\t\n\f\r ]*$/.test(Ee), re2 = !N(H), ye = !E(H);
                if (pe.htmlWhitespaceSensitivity !== "ignore") {
                  let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re2 && D(H, ["Template"]);
                  if (G) {
                    if (Oe || Ie)
                      return "";
                    let ae = [p2], nt = Z(Ee);
                    return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
                  }
                  let [Je] = Ee.match(Ye), [Te2] = Ee.match(Se), je = [];
                  if (Je) {
                    je = [p2];
                    let ae = Z(Je);
                    ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                  }
                  let Me = [];
                  if (Te2) {
                    if (!Ie) {
                      Me = [p2];
                      let ae = Z(Te2);
                      ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
                    }
                    Ee = Ee.replace(Se, "");
                  }
                  return [...je, s2(Fe(Ee)), ...Me];
                }
                let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                if ((re2 || ye) && G && D(H, ["Block", "ElementNode", "Template"]))
                  return "";
                G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let ze = "", be = "";
                return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re2 && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s2(Fe(Ee)), ...ge(ve)];
              }
              case "MustacheCommentStatement": {
                let Ee = F(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re2 = le.value.includes("}}") ? "--" : "";
                return ["{{", A ? "~" : "", "!", re2, le.value, re2, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return le.original;
              case "BooleanLiteral":
                return String(le.value);
              case "CommentStatement":
                return ["<!--", le.value, "-->"];
              case "StringLiteral": {
                if (we(H)) {
                  let Ee = pe.singleQuote ? '"' : "'";
                  return he(le.value, Ee);
                }
                return he(le.value, Ae);
              }
              case "NumberLiteral":
                return String(le.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
            }
          }
          function v(H, pe) {
            return F(H) - F(pe);
          }
          function S(H, pe) {
            let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
            for (let Ee of le)
              H.each((De) => {
                let A = Ae.indexOf(De.getValue());
                Ae.splice(A, 1, [p2, pe()]);
              }, Ee);
            return f(X.blockParams) && Ae.push(p2, oe(X)), ["<", X.tag, i(Ae), B(X)];
          }
          function b(H, pe, X) {
            let Ae = H.getValue().children.every((Ee) => C(Ee));
            return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
              let A = X();
              return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A] : A;
            }, "children");
          }
          function B(H) {
            return m2(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
          }
          function k(H) {
            let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
            return [pe, X];
          }
          function M(H) {
            let pe = H.escaped === false ? "}}}" : "}}";
            return [H.strip && H.strip.close ? "~" : "", pe];
          }
          function R(H) {
            let pe = k(H), X = H.openStrip.open ? "~" : "";
            return [pe, X, "#"];
          }
          function q2(H) {
            let pe = M(H);
            return [H.openStrip.close ? "~" : "", pe];
          }
          function J(H) {
            let pe = k(H), X = H.closeStrip.open ? "~" : "";
            return [pe, X, "/"];
          }
          function L(H) {
            let pe = M(H);
            return [H.closeStrip.close ? "~" : "", pe];
          }
          function Q(H) {
            let pe = k(H), X = H.inverseStrip.open ? "~" : "";
            return [pe, X];
          }
          function V(H) {
            let pe = M(H);
            return [H.inverseStrip.close ? "~" : "", pe];
          }
          function j(H, pe) {
            let X = H.getValue(), le = [], Ae = Pe(H, pe);
            return Ae && le.push(a2(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a2([R(X), Ne(H, pe), le.length > 0 ? i([p2, l(p2, le)]) : "", y, q2(X)]);
          }
          function Y(H, pe) {
            return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
          }
          function ie(H, pe, X) {
            let le = H.getValue(), Ae = H.getParentNode(1);
            return a2([Q(Ae), ["else", " ", X], i([p2, a2(Pe(H, pe)), ...f(le.program.blockParams) ? [p2, oe(le.program)] : []]), y, V(Ae)]);
          }
          function ee(H, pe, X) {
            let le = H.getValue();
            return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
          }
          function ce(H) {
            return $2(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
          }
          function W(H) {
            return K(H) && H.inverse.body.length === 1 && $2(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
          }
          function K(H) {
            return $2(H, ["BlockStatement"]) && H.inverse;
          }
          function de(H, pe, X) {
            let le = H.getValue();
            if (ce(le))
              return "";
            let Ae = pe("program");
            return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
          }
          function ue(H, pe, X) {
            let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
            return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
          }
          function Fe(H) {
            return h2(l(p2, z(H)));
          }
          function z(H) {
            return H.split(/[\t\n\f\r ]+/);
          }
          function U(H) {
            for (let pe = 0; pe < 2; pe++) {
              let X = H.getParentNode(pe);
              if (X && X.type === "AttrNode")
                return X.name.toLowerCase();
            }
          }
          function Z(H) {
            return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
          }
          function se(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(pe);
          }
          function fe(H) {
            H = typeof H == "string" ? H : "";
            let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(pe);
          }
          function ge() {
            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(H, o) }).fill(n);
          }
          function he(H, pe) {
            let { quote: X, regex: le } = c2(H, pe);
            return [X, H.replace(le, `\\${X}`), X];
          }
          function we(H) {
            let pe = 0, X = H.getParentNode(pe);
            for (; X && $2(X, ["SubExpression"]); )
              pe++, X = H.getParentNode(pe);
            return !!(X && $2(H.getParentNode(pe + 1), ["ConcatStatement"]) && $2(H.getParentNode(pe + 2), ["AttrNode"]));
          }
          function ke(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? i([X, p2, a2(le)]) : X;
          }
          function Re(H, pe) {
            let X = Ne(H, pe), le = Pe(H, pe);
            return le ? [i([X, p2, le]), y] : X;
          }
          function Ne(H, pe) {
            return pe("path");
          }
          function Pe(H, pe) {
            let X = H.getValue(), le = [];
            if (X.params.length > 0) {
              let Ae = H.map(pe, "params");
              le.push(...Ae);
            }
            if (X.hash && X.hash.pairs.length > 0) {
              let Ae = pe("hash");
              le.push(Ae);
            }
            return le.length === 0 ? "" : l(p2, le);
          }
          function oe(H) {
            return ["as |", H.blockParams.join(" "), "|"];
          }
          r.exports = { print: d, massageAstNode: w };
        } }), Qd2 = te2({ "src/language-handlebars/parsers.js"() {
          ne2();
        } }), Zd2 = te2({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
          r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), eg2 = te2({ "src/language-handlebars/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = Yd2(), a2 = Qd2(), n = [t(Zd2(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s2 };
          r.exports = { languages: n, printers: u, parsers: a2 };
        } }), tg2 = te2({ "src/language-graphql/pragma.js"(e, r) {
          ne2();
          function t(a2) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a2);
          }
          function s2(a2) {
            return `# @format

` + a2;
          }
          r.exports = { hasPragma: t, insertPragma: s2 };
        } }), rg2 = te2({ "src/language-graphql/loc.js"(e, r) {
          ne2();
          function t(a2) {
            return typeof a2.start == "number" ? a2.start : a2.loc && a2.loc.start;
          }
          function s2(a2) {
            return typeof a2.end == "number" ? a2.end : a2.loc && a2.loc.end;
          }
          r.exports = { locStart: t, locEnd: s2 };
        } }), ng2 = te2({ "src/language-graphql/printer-graphql.js"(e, r) {
          ne2();
          var { builders: { join: t, hardline: s2, line: a2, softline: n, group: u, indent: i, ifBreak: l } } = qe2(), { isNextLineEmpty: p2, isNonEmptyArray: y } = Ue2(), { insertPragma: h2 } = tg2(), { locStart: g, locEnd: c2 } = rg2();
          function f(P, $2, D) {
            let T = P.getValue();
            if (!T)
              return "";
            if (typeof T == "string")
              return T;
            switch (T.kind) {
              case "Document": {
                let m2 = [];
                return P.each((C, o, d) => {
                  m2.push(D()), o !== d.length - 1 && (m2.push(s2), p2($2.originalText, C.getValue(), c2) && m2.push(s2));
                }, "definitions"), [...m2, s2];
              }
              case "OperationDefinition": {
                let m2 = $2.originalText[g(T)] !== "{", C = Boolean(T.name);
                return [m2 ? T.operation : "", m2 && C ? [" ", D("name")] : "", m2 && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? !m2 && !C ? "" : " " : "", D("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
              case "SelectionSet":
                return ["{", i([s2, t(s2, _(P, $2, D, "selections"))]), s2, "}"];
              case "Field":
                return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
              case "Name":
                return T.value;
              case "StringValue": {
                if (T.block) {
                  let m2 = T.value.replace(/"""/g, "\\$&").split(`
`);
                  return m2.length === 1 && (m2[0] = m2[0].trim()), m2.every((C) => C === "") && (m2.length = 0), t(s2, ['"""', ...m2, '"""']);
                }
                return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return T.value;
              case "BooleanValue":
                return T.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", D("name")];
              case "ListValue":
                return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
              case "ObjectValue":
                return u(["{", $2.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $2.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [D("name"), ": ", D("value")];
              case "Directive":
                return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : ""];
              case "NamedType":
                return D("name");
              case "VariableDefinition":
                return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [D("description"), T.description ? s2 : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
              case "FieldDefinition":
                return [D("description"), T.description ? s2 : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F(P, D, T)];
              case "DirectiveDefinition":
                return [D("description"), T.description ? s2 : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [D("description"), T.description ? s2 : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "values"))]), s2, "}"] : ""];
              case "EnumValueDefinition":
                return [D("description"), T.description ? s2 : "", D("name"), F(P, D, T)];
              case "InputValueDefinition":
                return [D("description"), T.description ? T.description.block ? s2 : a2 : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [D("description"), T.description ? s2 : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "operationTypes"))]), s2, "}"] : []];
              case "SchemaDefinition":
                return [D("description"), T.description ? s2 : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s2, t(s2, _(P, $2, D, "operationTypes"))]) : "", s2, "}"];
              case "OperationTypeDefinition":
                return [D("operation"), ": ", D("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [D("description"), T.description ? s2 : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s2, t(s2, _(P, $2, D, "fields"))]), s2, "}"] : ""];
              case "FragmentSpread":
                return ["...", D("name"), F(P, D, T)];
              case "InlineFragment":
                return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([D("description"), T.description ? s2 : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a2, "  "]), t([a2, "| "], P.map(D, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [D("description"), T.description ? s2 : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
              case "NonNullType":
                return [D("type"), "!"];
              case "ListType":
                return ["[", D("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
            }
          }
          function F(P, $2, D) {
            if (D.directives.length === 0)
              return "";
            let T = t(a2, P.map($2, "directives"));
            return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a2, T]) : [" ", u(i([n, T]))];
          }
          function _(P, $2, D, T) {
            return P.map((m2, C, o) => {
              let d = D();
              return C < o.length - 1 && p2($2.originalText, m2.getValue(), c2) ? [d, s2] : d;
            }, T);
          }
          function w(P) {
            return P.kind && P.kind !== "Comment";
          }
          function E(P) {
            let $2 = P.getValue();
            if ($2.kind === "Comment")
              return "#" + $2.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($2));
          }
          function N(P, $2, D) {
            let T = P.getNode(), m2 = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
            for (let d = 0; d < C.length; d++) {
              let v = C[d];
              m2.push(o[d]);
              let S = C[d + 1];
              if (S) {
                let b = $2.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m2.push(k === "," ? "," : " &", B ? a2 : " ");
              }
            }
            return m2;
          }
          function x2(P, $2) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($2.value = $2.value.trim());
          }
          x2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P) {
            var $2;
            let D = P.getValue();
            return D == null || ($2 = D.comments) === null || $2 === void 0 ? void 0 : $2.some((T) => T.value.trim() === "prettier-ignore");
          }
          r.exports = { print: f, massageAstNode: x2, hasPrettierIgnore: I, insertPragma: h2, printComment: E, canAttachComment: w };
        } }), ug2 = te2({ "src/language-graphql/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { bracketSpacing: t.bracketSpacing };
        } }), sg2 = te2({ "src/language-graphql/parsers.js"() {
          ne2();
        } }), ig2 = te2({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
          r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), ag2 = te2({ "src/language-graphql/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = ng2(), a2 = ug2(), n = sg2(), u = [t(ig2(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s2 };
          r.exports = { languages: u, options: a2, printers: i, parsers: n };
        } }), Po = te2({ "node_modules/collapse-white-space/index.js"(e, r) {
          ne2(), r.exports = t;
          function t(s2) {
            return String(s2).replace(/\s+/g, " ");
          }
        } }), Io = te2({ "src/language-markdown/loc.js"(e, r) {
          ne2();
          function t(a2) {
            return a2.position.start.offset;
          }
          function s2(a2) {
            return a2.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s2 };
        } }), og2 = te2({ "src/language-markdown/constants.evaluate.js"(e, r) {
          r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), iu = te2({ "src/language-markdown/utils.js"(e, r) {
          ne2();
          var { getLast: t } = Ue2(), { locStart: s2, locEnd: a2 } = Io(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og2(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p2 = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h2 = new RegExp(i);
          function g(E, N) {
            let x2 = "non-cjk", I = "cj-letter", P = "k-letter", $2 = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [C, o] of T.entries()) {
              if (C % 2 === 1) {
                D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((C === 0 || C === T.length - 1) && o === "")
                continue;
              let d = o.split(new RegExp(`(${n})`));
              for (let [v, S] of d.entries())
                if (!((v === 0 || v === d.length - 1) && S === "")) {
                  if (v % 2 === 0) {
                    S !== "" && m2({ type: "word", value: S, kind: x2, hasLeadingPunctuation: h2.test(S[0]), hasTrailingPunctuation: h2.test(t(S)) });
                    continue;
                  }
                  m2(h2.test(S) ? { type: "word", value: S, kind: $2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return D;
            function m2(C) {
              let o = t(D);
              o && o.type === "word" && (o.kind === x2 && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x2 && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x2, $2) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
              function d(v, S) {
                return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
              }
            }
          }
          function c2(E, N) {
            let [, x2, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: x2, marker: I, leadingSpaces: P };
          }
          function f(E, N) {
            if (!E.ordered || E.children.length < 2)
              return false;
            let x2 = Number(c2(E.children[0], N.originalText).numberText), I = Number(c2(E.children[1], N.originalText).numberText);
            if (x2 === 0 && E.children.length > 2) {
              let P = Number(c2(E.children[2], N.originalText).numberText);
              return I === 1 && P === 1;
            }
            return I === 1;
          }
          function F(E, N) {
            let { value: x2 } = E;
            return E.position.end.offset === N.length && x2.endsWith(`
`) && N.endsWith(`
`) ? x2.slice(0, -1) : x2;
          }
          function _(E, N) {
            return function x2(I, P, $2) {
              let D = Object.assign({}, N(I, P, $2));
              return D.children && (D.children = D.children.map((T, m2) => x2(T, m2, [D, ...$2]))), D;
            }(E, null, []);
          }
          function w(E) {
            if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
              return false;
            let [N] = E.children;
            return s2(E) === s2(N) && a2(E) === a2(N);
          }
          r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c2, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p2, isAutolink: w };
        } }), lg2 = te2({ "src/language-markdown/embed.js"(e, r) {
          ne2();
          var { inferParserByLanguage: t, getMaxContinuousCount: s2 } = Ue2(), { builders: { hardline: a2, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe2(), i = su(), { getFencedCodeBlockValue: l } = iu();
          function p2(y, h2, g, c2) {
            let f = y.getValue();
            if (f.type === "code" && f.lang !== null) {
              let F = t(f.lang, c2);
              if (F) {
                let _ = c2.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s2(f.value, _) + 1)), E = { parser: F };
                f.lang === "tsx" && (E.filepath = "dummy.tsx");
                let N = g(l(f, c2.originalText), E, { stripTrailingHardline: true });
                return n([w, f.lang, f.meta ? " " + f.meta : "", a2, u(N), a2, w]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, g);
              case "importExport":
                return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a2];
              case "jsx":
                return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          r.exports = p2;
        } }), ko = te2({ "src/language-markdown/pragma.js"(e, r) {
          ne2();
          var t = _o(), s2 = ["format", "prettier"];
          function a2(n) {
            let u = `@(${s2.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
            return (l == null ? void 0 : l.index) === 0;
          }
          r.exports = { startWithPragma: a2, hasPragma: (n) => a2(t(n).content.trimStart()), insertPragma: (n) => {
            let u = t(n), i = `<!-- @${s2[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
          } };
        } }), cg2 = te2({ "src/language-markdown/print-preprocess.js"(e, r) {
          ne2();
          var t = lt2(), { getOrderedListItemInfo: s2, mapAst: a2, splitText: n } = iu(), u = /^.$/su;
          function i(w, E) {
            return w = y(w, E), w = c2(w), w = p2(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h2(w), w;
          }
          function l(w) {
            return a2(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
          }
          function p2(w, E) {
            return a2(w, (N) => N.type !== "inlineCode" || E.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
          }
          function y(w, E) {
            return a2(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: E.originalText.slice(N.position.start.offset, N.position.end.offset) }));
          }
          function h2(w) {
            return g(w, (E, N) => E.type === "importExport" && N.type === "importExport", (E, N) => ({ type: "importExport", value: E.value + `

` + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function g(w, E, N) {
            return a2(w, (x2) => {
              if (!x2.children)
                return x2;
              let I = x2.children.reduce((P, $2) => {
                let D = t(P);
                return D && E(D, $2) ? P.splice(-1, 1, N(D, $2)) : P.push($2), P;
              }, []);
              return Object.assign(Object.assign({}, x2), {}, { children: I });
            });
          }
          function c2(w) {
            return g(w, (E, N) => E.type === "text" && N.type === "text", (E, N) => ({ type: "text", value: E.value + N.value, position: { start: E.position.start, end: N.position.end } }));
          }
          function f(w, E) {
            return a2(w, (N, x2, I) => {
              let [P] = I;
              if (N.type !== "text")
                return N;
              let { value: $2 } = N;
              return P.type === "paragraph" && (x2 === 0 && ($2 = $2.trimStart()), x2 === P.children.length - 1 && ($2 = $2.trimEnd())), { type: "sentence", position: N.position, children: n($2, E) };
            });
          }
          function F(w, E) {
            return a2(w, (N, x2, I) => {
              if (N.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));
                if (N.isIndented = P, P)
                  for (let $2 = 0; $2 < I.length; $2++) {
                    let D = I[$2];
                    if (D.hasIndentedCodeblock)
                      break;
                    D.type === "list" && (D.hasIndentedCodeblock = true);
                  }
              }
              return N;
            });
          }
          function _(w, E) {
            return a2(w, (I, P, $2) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let D = 0; D < $2.length; D++) {
                  let T = $2[D];
                  if (T.type === "list" && !T.isAligned)
                    return I.isAligned = false, I;
                }
                I.isAligned = x2(I);
              }
              return I;
            });
            function N(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function x2(I) {
              if (!I.ordered)
                return true;
              let [P, $2] = I.children;
              if (s2(P, E.originalText).leadingSpaces.length > 1)
                return true;
              let T = N(P);
              if (T === -1)
                return false;
              if (I.children.length === 1)
                return T % E.tabWidth === 0;
              let m2 = N($2);
              return T !== m2 ? false : T % E.tabWidth === 0 ? true : s2($2, E.originalText).leadingSpaces.length > 1;
            }
          }
          r.exports = i;
        } }), pg2 = te2({ "src/language-markdown/clean.js"(e, r) {
          ne2();
          var t = Po(), { isFrontMatterNode: s2 } = Ue2(), { startWithPragma: a2 } = ko(), n = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(i, l, p2) {
            if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p2 && p2.type === "root" && p2.children.length > 0 && (p2.children[0] === i || s2(p2.children[0]) && p2.children[1] === i) && i.type === "html" && a2(i.value)))
              return null;
          }
          u.ignoredProperties = n, r.exports = u;
        } }), fg2 = te2({ "src/language-markdown/printer-markdown.js"(e, r) {
          ne2();
          var t = Po(), { getLast: s2, getMinNotPresentContinuousCount: a2, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue2(), { builders: { breakParent: l, join: p2, line: y, literalline: h2, markAsRoot: g, hardline: c2, softline: f, ifBreak: F, fill: _, align: w, indent: E, group: N, hardlineWithoutBreakParent: x2 }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $2 } } = qe2(), D = lg2(), { insertPragma: T } = ko(), { locStart: m2, locEnd: C } = Io(), o = cg2(), d = pg2(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q2 = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function Q(oe, H, pe) {
            let X = oe.getValue();
            if (ge(oe))
              return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
            switch (X.type) {
              case "front-matter":
                return H.originalText.slice(X.position.start.offset, X.position.end.offset);
              case "root":
                return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q2.has(z(X).type) ? "" : c2];
              case "paragraph":
                return ue(oe, H, pe, { postprocessor: _ });
              case "sentence":
                return ue(oe, H, pe);
              case "word": {
                let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re2, ye) => (G ? `${A}${G}` : `${re2}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
                return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
              }
              case "whitespace": {
                let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                return W(oe, X.value, { proseWrap: De });
              }
              case "emphasis": {
                let le;
                if (R(X.children[0]))
                  le = H.originalText[X.position.start.offset];
                else {
                  let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
                  le = De && De.type === "sentence" && De.children.length > 0 && s2(De.children).type === "word" && !s2(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                }
                return [le, ue(oe, H, pe), le];
              }
              case "strong":
                return ["**", ue(oe, H, pe), "**"];
              case "delete":
                return ["~~", ue(oe, H, pe), "~~"];
              case "inlineCode": {
                let le = a2(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                return [Ae, Ee, X.value, Ee, Ae];
              }
              case "wikiLink": {
                let le = "";
                return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
              }
              case "link":
                switch (H.originalText[X.position.start.offset]) {
                  case "<": {
                    let le = "mailto:";
                    return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                  }
                  case "[":
                    return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                  default:
                    return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                }
              case "image":
                return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
              case "blockquote":
                return ["> ", w("> ", ue(oe, H, pe))];
              case "heading":
                return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
              case "code": {
                if (X.isIndented) {
                  let Ee = " ".repeat(4);
                  return w(Ee, [Ee, ...P(X.value, c2)]);
                }
                let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
                return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c2, ...P(v(X, H.originalText), c2), c2, Ae];
              }
              case "html": {
                let le = oe.getParentNode(), Ae = le.type === "root" && s2(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                return P(Ae, Ee ? c2 : g(h2));
              }
              case "list": {
                let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                return ue(oe, H, pe, { processor: (Ee, De) => {
                  let A = re2(), G = Ee.getValue();
                  if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
                    return [A, V(Ee, H, pe, A)];
                  return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
                  function re2() {
                    let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                    return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                  }
                } });
              }
              case "thematicBreak": {
                let le = ee(oe, "list");
                return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (X.referenceType) {
                  case "full":
                    return ["![", X.alt || "", "]", Ne(X)];
                  default:
                    return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let le = H.proseWrap === "always" ? y : " ";
                return N([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
              }
              case "footnote":
                return ["[^", ue(oe, H, pe), "]"];
              case "footnoteReference":
                return Pe(X);
              case "footnoteDefinition": {
                let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
              }
              case "table":
                return K(oe, H, pe);
              case "tableCell":
                return ue(oe, H, pe);
              case "break":
                return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h2)] : ["\\", c2];
              case "liquidNode":
                return P(X.value, c2);
              case "importExport":
                return [X.value, c2];
              case "esComment":
                return ["{/* ", X.value, " */}"];
              case "jsx":
                return X.value;
              case "math":
                return ["$$", c2, X.value ? [...P(X.value, c2), c2] : "", "$$"];
              case "inlineMath":
                return H.originalText.slice(m2(X), C(X));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
            }
          }
          function V(oe, H, pe, X) {
            let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
            return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
              if (De === 0 && Ee.getValue().type !== "list")
                return w(" ".repeat(Ae.length), pe());
              let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
              return [A, w(A, pe())];
            } })];
          }
          function j(oe, H) {
            let pe = X();
            return oe + " ".repeat(pe >= 4 ? 0 : pe);
            function X() {
              let le = oe.length % H.tabWidth;
              return le === 0 ? 0 : H.tabWidth - le;
            }
          }
          function Y(oe, H) {
            return ie(oe, H, (pe) => pe.ordered === oe.ordered);
          }
          function ie(oe, H, pe) {
            let X = -1;
            for (let le of H.children)
              if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe)
                return X;
          }
          function ee(oe, H) {
            let pe = Array.isArray(H) ? H : [H], X = -1, le;
            for (; le = oe.getParentNode(++X); )
              if (pe.includes(le.type))
                return X;
            return -1;
          }
          function ce(oe, H) {
            let pe = ee(oe, H);
            return pe === -1 ? null : oe.getParentNode(pe);
          }
          function W(oe, H, pe) {
            if (pe.proseWrap === "preserve" && H === `
`)
              return c2;
            let X = pe.proseWrap === "always" && !ce(oe, J);
            return H !== "" ? X ? y : " " : X ? f : "";
          }
          function K(oe, H, pe) {
            let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
              let ve = $2(pe(), H).formatted, ze = u(ve);
              return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
            }, "children"), "children"), Ee = A(false);
            if (H.proseWrap !== "never")
              return [l, Ee];
            let De = A(true);
            return [l, N(F(De, Ee))];
            function A(ye) {
              let Ce = [re2(Ae[0], ye), G(ye)];
              return Ae.length > 1 && Ce.push(p2(x2, Ae.slice(1).map((Be) => re2(Be, ye)))), p2(x2, Ce);
            }
            function G(ye) {
              return `| ${le.map((Be, ve) => {
                let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                return `${be}${Se}${Ye}`;
              }).join(" | ")} |`;
            }
            function re2(ye, Ce) {
              return `| ${ye.map((ve, ze) => {
                let { text: be, width: Ye } = ve;
                if (Ce)
                  return be;
                let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                let Je = Se - Oe;
                return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
              }).join(" | ")} |`;
            }
          }
          function de(oe, H, pe) {
            let X = [], le = null, { children: Ae } = oe.getValue();
            for (let [Ee, De] of Ae.entries())
              switch (U(De)) {
                case "start":
                  le === null && (le = { index: Ee, offset: De.position.end.offset });
                  break;
                case "end":
                  le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                  break;
              }
            return ue(oe, H, pe, { processor: (Ee, De) => {
              if (X.length > 0) {
                let A = X[0];
                if (De === A.start.index)
                  return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
                if (A.start.index < De && De < A.end.index)
                  return false;
                if (De === A.end.index)
                  return X.shift(), false;
              }
              return pe();
            } });
          }
          function ue(oe, H, pe) {
            let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
            return oe.each((G, re2) => {
              let ye = G.getValue(), Ce = Ae(G, re2);
              if (Ce !== false) {
                let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
                Z(ye, Be) && (De.push(c2), A && q2.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c2), fe(ye, Be) && De.push(c2)), De.push(Ce), A = ye;
              }
            }, "children"), le ? le(De) : De;
          }
          function Fe(oe) {
            if (oe.type === "html")
              return oe.value;
            if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
              return ["{/* ", oe.children[0].value, " */}"];
          }
          function z(oe) {
            let H = oe;
            for (; i(H.children); )
              H = s2(H.children);
            return H;
          }
          function U(oe) {
            let H;
            if (oe.type === "html")
              H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let pe;
              oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return H ? H[1] || "next" : false;
          }
          function Z(oe, H) {
            let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
            return !pe && !X && !le;
          }
          function se(oe, H) {
            var pe, X, le;
            let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re2 = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
            return A || !(Ee || De || G || re2 || ye);
          }
          function fe(oe, H) {
            let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
            return pe && X;
          }
          function ge(oe) {
            let H = ce(oe, ["linkReference", "imageReference"]);
            return H && (H.type !== "linkReference" || H.referenceType !== "full");
          }
          function he(oe) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
            return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
          }
          function we(oe, H) {
            let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!oe)
              return "";
            if (pe)
              return " " + we(oe, H, false);
            if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
              return `(${oe})`;
            let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
            return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
          }
          function ke(oe, H, pe) {
            return oe < H ? H : oe > pe ? pe : oe;
          }
          function Re(oe) {
            let H = Number(oe.getName());
            if (H === 0)
              return false;
            let pe = oe.getParentNode().children[H - 1];
            return U(pe) === "next";
          }
          function Ne(oe) {
            return `[${t(oe.label)}]`;
          }
          function Pe(oe) {
            return `[^${oe.label}]`;
          }
          r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
        } }), Dg2 = te2({ "src/language-markdown/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), mg2 = te2({ "src/language-markdown/parsers.js"() {
          ne2();
        } }), _a3 = te2({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
          r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), dg2 = te2({ "src/language-markdown/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = fg2(), a2 = Dg2(), n = mg2(), u = [t(_a3(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p2) => p2 !== ".mdx") })), t(_a3(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s2 };
          r.exports = { languages: u, options: a2, printers: i, parsers: n };
        } }), gg2 = te2({ "src/language-html/clean.js"(e, r) {
          ne2();
          var { isFrontMatterNode: t } = Ue2(), s2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a2(n, u) {
            if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
              return null;
            n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
          }
          a2.ignoredProperties = s2, r.exports = a2;
        } }), yg2 = te2({ "src/language-html/constants.evaluate.js"(e, r) {
          r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), hg2 = te2({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
          ne2();
          function t(s2) {
            return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
          }
          r.exports = t;
        } }), Rt2 = te2({ "src/language-html/utils/index.js"(e, r) {
          ne2();
          var { inferParserByLanguage: t, isFrontMatterNode: s2 } = Ue2(), { builders: { line: a2, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe2(), { CSS_DISPLAY_TAGS: p2, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h2, CSS_WHITE_SPACE_DEFAULT: g } = yg2(), c2 = hg2(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => E(_(A)), x2 = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
            let [, G, re2, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: ye, text: re2 };
          }, $2 = (A) => /[\t\n\f\r ]/.test(A);
          function D(A, G) {
            return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re2) => re2.type !== "text" && re2.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
          }
          function T(A) {
            return A.type === "attribute" || !A.parent || !A.prev ? false : m2(A.prev);
          }
          function m2(A) {
            return A.type === "comment" && A.value.trim() === "prettier-ignore";
          }
          function C(A) {
            return A.type === "text" || A.type === "comment";
          }
          function o(A) {
            return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c2(A) && (A.name === "script" || A.name === "style"));
          }
          function d(A) {
            return A.children && !o(A);
          }
          function v(A) {
            return o(A) || A.type === "interpolation" || S(A);
          }
          function S(A) {
            return we(A).startsWith("pre");
          }
          function b(A, G) {
            let re2 = ye();
            if (re2 && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
              return A.type === "interpolation";
            return re2;
            function ye() {
              return s2(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
            }
          }
          function B(A, G) {
            return s2(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
          }
          function k(A) {
            return Z(A.cssDisplay) && !o(A);
          }
          function M(A) {
            return s2(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
          }
          function R(A) {
            return q2(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
          }
          function q2(A) {
            return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
          }
          function J(A) {
            return Y(A) || A.prev && L(A.prev) || Q(A);
          }
          function L(A) {
            return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
          }
          function Q(A) {
            return V(A) && j(A);
          }
          function V(A) {
            return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
          }
          function j(A) {
            return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
          }
          function Y(A) {
            switch (A.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(A.name);
            }
            return false;
          }
          function ie(A) {
            return A.lastChild ? ie(A.lastChild) : A;
          }
          function ee(A) {
            return A.children && A.children.some((G) => G.type !== "text");
          }
          function ce(A) {
            let { type: G, lang: re2 } = A.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re2 === "jsx")
              return "babel";
            if (G === "application/x-typescript" || re2 === "ts" || re2 === "tsx")
              return "typescript";
            if (G === "text/markdown")
              return "markdown";
            if (G === "text/html")
              return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
              return "json";
            if (G === "text/x-handlebars-template")
              return "glimmer";
          }
          function W(A, G) {
            let { lang: re2 } = A.attrMap;
            if (!re2 || re2 === "postcss" || re2 === "css")
              return "css";
            if (re2 === "scss")
              return "scss";
            if (re2 === "less")
              return "less";
            if (re2 === "stylus")
              return t("stylus", G);
          }
          function K(A, G) {
            if (A.name === "script" && !A.attrMap.src)
              return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
            if (A.name === "style")
              return W(A, G);
            if (G && X(A, G))
              return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
          }
          function de(A) {
            return A === "block" || A === "list-item" || A.startsWith("table");
          }
          function ue(A) {
            return !de(A) && A !== "inline-block";
          }
          function Fe(A) {
            return !de(A) && A !== "inline-block";
          }
          function z(A) {
            return !de(A);
          }
          function U(A) {
            return !de(A);
          }
          function Z(A) {
            return !de(A) && A !== "inline-block";
          }
          function se(A) {
            return we(A).startsWith("pre");
          }
          function fe(A, G) {
            let re2 = 0;
            for (let ye = A.stack.length - 1; ye >= 0; ye--) {
              let Ce = A.stack[ye];
              Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re2++;
            }
            return re2;
          }
          function ge(A, G) {
            let re2 = A;
            for (; re2; ) {
              if (G(re2))
                return true;
              re2 = re2.parent;
            }
            return false;
          }
          function he(A, G) {
            if (A.prev && A.prev.type === "comment") {
              let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (ye)
                return ye[1];
            }
            let re2 = false;
            if (A.type === "element" && A.namespace === "svg")
              if (ge(A, (ye) => ye.fullName === "svg:foreignObject"))
                re2 = true;
              else
                return A.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re2 || c2(A)) && p2[A.name] || y;
            }
          }
          function we(A) {
            return A.type === "element" && (!A.namespace || c2(A)) && h2[A.name] || g;
          }
          function ke(A) {
            let G = Number.POSITIVE_INFINITY;
            for (let re2 of A.split(`
`)) {
              if (re2.length === 0)
                continue;
              if (!f.has(re2[0]))
                return 0;
              let ye = I(re2).length;
              re2.length !== ye && ye < G && (G = ye);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          function Re(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
            return G === 0 ? A : A.split(`
`).map((re2) => re2.slice(G)).join(`
`);
          }
          function Ne(A, G) {
            let re2 = 0;
            for (let ye = 0; ye < A.length; ye++)
              A[ye] === G && re2++;
            return re2;
          }
          function Pe(A) {
            return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function H(A, G) {
            return pe(A, G) && !oe.has(A.fullName);
          }
          function pe(A, G) {
            return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
          }
          function X(A, G) {
            return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
          }
          function le(A) {
            let G = A.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          function Ae(A, G) {
            let re2 = A.parent;
            if (!pe(re2, G))
              return false;
            let ye = re2.fullName, Ce = A.fullName;
            return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
          }
          function Ee(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
            return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a2, x2(G)));
          }
          function De(A, G) {
            return pe(A, G) && A.name === "script";
          }
          r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $2, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q2, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c2, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
        } }), vg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function r(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          e.isWhitespace = r;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          e.isDigit = t;
          function s2(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          e.isAsciiLetter = s2;
          function a2(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          e.isAsciiHexDigit = a2;
          function n(i) {
            return i === e.$LF || i === e.$CR;
          }
          e.isNewLine = n;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Cg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = class {
            constructor(s2, a2, n) {
              this.filePath = s2, this.name = a2, this.members = n;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          };
          e.StaticSymbol = r;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s2, a2, n) {
              n = n || [];
              let u = n.length ? `.${n.join(".")}` : "", i = `"${s2}".${a2}${u}`, l = this.cache.get(i);
              return l || (l = new r(s2, a2, n), this.cache.set(i, l)), l;
            }
          };
          e.StaticSymbolCache = t;
        } }), Eg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(r, function() {
              for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++)
                v[S] = arguments[S];
              return v[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s2(o, d) {
            return n(o, ":", d);
          }
          e.splitAtColon = s2;
          function a2(o, d) {
            return n(o, ".", d);
          }
          e.splitAtPeriod = a2;
          function n(o, d, v) {
            let S = o.indexOf(d);
            return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
          }
          function u(o, d, v) {
            return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
          }
          e.visitValue = u;
          function i(o) {
            return o != null;
          }
          e.isDefined = i;
          function l(o) {
            return o === void 0 ? null : o;
          }
          e.noUndefined = l;
          var p2 = class {
            visitArray(o, d) {
              return o.map((v) => u(v, this, d));
            }
            visitStringMap(o, d) {
              let v = {};
              return Object.keys(o).forEach((S) => {
                v[S] = u(o[S], this, d);
              }), v;
            }
            visitPrimitive(o, d) {
              return o;
            }
            visitOther(o, d) {
              return o;
            }
          };
          e.ValueTransformer = p2, e.SyncAsync = { assertSync: (o) => {
            if (P(o))
              throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          e.error = y;
          function h2(o, d) {
            let v = Error(o);
            return v[g] = true, d && (v[c2] = d), v;
          }
          e.syntaxError = h2;
          var g = "ngSyntaxError", c2 = "ngParseErrors";
          function f(o) {
            return o[g];
          }
          e.isSyntaxError = f;
          function F(o) {
            return o[c2] || [];
          }
          e.getParseErrors = F;
          function _(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = _;
          var w = Object.getPrototypeOf({});
          function E(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
          }
          function N(o) {
            let d = "";
            for (let v = 0; v < o.length; v++) {
              let S = o.charCodeAt(v);
              if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                let b = o.charCodeAt(v + 1);
                b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
              }
              S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
            }
            return d;
          }
          e.utf8Encode = N;
          function x2(o) {
            if (typeof o == "string")
              return o;
            if (o instanceof Array)
              return "[" + o.map(x2).join(", ") + "]";
            if (o == null)
              return "" + o;
            if (o.overriddenName)
              return `${o.overriddenName}`;
            if (o.name)
              return `${o.name}`;
            if (!o.toString)
              return "object";
            let d = o.toString();
            if (d == null)
              return "" + d;
            let v = d.indexOf(`
`);
            return v === -1 ? d : d.substring(0, v);
          }
          e.stringify = x2;
          function I(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e.resolveForwardRef = I;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          e.isPromise = P;
          var $2 = class {
            constructor(o) {
              this.full = o;
              let d = o.split(".");
              this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
            }
          };
          e.Version = $2;
          var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m2 = typeof globalThis < "u" && globalThis, C = m2 || D || T;
          e.global = C;
        } }), Fg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Cg2(), t = Eg2(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a2(v) {
            return v.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a2;
          var n = 0;
          function u(v) {
            if (!v || !v.reference)
              return null;
            let S = v.reference;
            if (S instanceof r.StaticSymbol)
              return S.name;
            if (S.__anonymousType)
              return S.__anonymousType;
            let b = t.stringify(S);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a2(b), b;
          }
          e.identifierName = u;
          function i(v) {
            let S = v.reference;
            return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
          }
          e.identifierModuleUrl = i;
          function l(v, S) {
            return `View_${u({ reference: v })}_${S}`;
          }
          e.viewClassName = l;
          function p2(v) {
            return `RenderType_${u({ reference: v })}`;
          }
          e.rendererTypeName = p2;
          function y(v) {
            return `HostView_${u({ reference: v })}`;
          }
          e.hostViewClassName = y;
          function h2(v) {
            return `${u({ reference: v })}NgFactory`;
          }
          e.componentFactoryName = h2;
          var g;
          (function(v) {
            v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
          })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function c2(v) {
            return v.value != null ? a2(v.value) : u(v.identifier);
          }
          e.tokenName = c2;
          function f(v) {
            return v.identifier != null ? v.identifier.reference : v.value;
          }
          e.tokenReference = f;
          var F = class {
            constructor() {
              let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
            }
          };
          e.CompileStylesheetMetadata = F;
          var _ = class {
            constructor(v) {
              let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q2, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q2), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = _;
          var w = class {
            static create(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
              L != null && Object.keys(L).forEach((se) => {
                let fe = L[se], ge = se.match(s2);
                ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
              });
              let U = {};
              q2 != null && q2.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                U[fe[0]] = fe[1];
              });
              let Z = {};
              return J != null && J.forEach((se) => {
                let fe = t.splitAtColon(se, [se, se]);
                Z[fe[0]] = fe[1];
              }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
            }
            constructor(v) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q2, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q2, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
            }
            toSummary() {
              return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = w;
          var E = class {
            constructor(v) {
              let { type: S, name: b, pure: B } = v;
              this.type = S, this.name = b, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = E;
          var N = class {
          };
          e.CompileShallowModuleMetadata = N;
          var x2 = class {
            constructor(v) {
              let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q2, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q2), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
            }
            toSummary() {
              let v = this.transitiveModule;
              return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = x2;
          var I = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(v, S) {
              this.providers.push({ provider: v, module: S });
            }
            addDirective(v) {
              this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
            }
            addExportedDirective(v) {
              this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
            }
            addPipe(v) {
              this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
            }
            addExportedPipe(v) {
              this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
            }
            addModule(v) {
              this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
            }
            addEntryComponent(v) {
              this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I;
          function P(v) {
            return v || [];
          }
          var $2 = class {
            constructor(v, S) {
              let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q2 } = S;
              this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q2;
            }
          };
          e.ProviderMeta = $2;
          function D(v) {
            return v.reduce((S, b) => {
              let B = Array.isArray(b) ? D(b) : b;
              return S.concat(B);
            }, []);
          }
          e.flatten = D;
          function T(v) {
            return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function m2(v, S, b) {
            let B;
            return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
          }
          e.templateSourceUrl = m2;
          function C(v, S) {
            let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
            return T(`css/${S}${B}.ngstyle.js`);
          }
          e.sharedStylesheetJitUrl = C;
          function o(v) {
            return T(`${u(v.type)}/module.ngfactory.js`);
          }
          e.ngModuleJitUrl = o;
          function d(v, S) {
            return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
          }
          e.templateJitUrl = d;
        } }), Ag2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = vg2(), t = Fg2(), s2 = class {
            constructor(y, h2, g, c2) {
              this.file = y, this.offset = h2, this.line = g, this.col = c2;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y) {
              let h2 = this.file.content, g = h2.length, c2 = this.offset, f = this.line, F = this.col;
              for (; c2 > 0 && y < 0; )
                if (c2--, y++, h2.charCodeAt(c2) == r.$LF) {
                  f--;
                  let w = h2.substr(0, c2 - 1).lastIndexOf(String.fromCharCode(r.$LF));
                  F = w > 0 ? c2 - w : c2;
                } else
                  F--;
              for (; c2 < g && y > 0; ) {
                let _ = h2.charCodeAt(c2);
                c2++, y--, _ == r.$LF ? (f++, F = 0) : F++;
              }
              return new s2(this.file, c2, f, F);
            }
            getContext(y, h2) {
              let g = this.file.content, c2 = this.offset;
              if (c2 != null) {
                c2 > g.length - 1 && (c2 = g.length - 1);
                let f = c2, F = 0, _ = 0;
                for (; F < y && c2 > 0 && (c2--, F++, !(g[c2] == `
` && ++_ == h2)); )
                  ;
                for (F = 0, _ = 0; F < y && f < g.length - 1 && (f++, F++, !(g[f] == `
` && ++_ == h2)); )
                  ;
                return { before: g.substring(c2, this.offset), after: g.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s2;
          var a2 = class {
            constructor(y, h2) {
              this.content = y, this.url = h2;
            }
          };
          e.ParseSourceFile = a2;
          var n = class {
            constructor(y, h2) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y, this.end = h2, this.details = g;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s2(new a2("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(y) {
            y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = class {
            constructor(y, h2) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y, this.msg = h2, this.level = g;
            }
            contextualMessage() {
              let y = this.span.start.getContext(100, 3);
              return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
            }
            toString() {
              let y = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y}`;
            }
          };
          e.ParseError = i;
          function l(y, h2) {
            let g = t.identifierModuleUrl(h2), c2 = g != null ? `in ${y} ${t.identifierName(h2)} in ${g}` : `in ${y} ${t.identifierName(h2)}`, f = new a2("", c2);
            return new n(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
          }
          e.typeSourceSpan = l;
          function p2(y, h2, g) {
            let c2 = `in ${y} ${h2} in ${g}`, f = new a2("", c2);
            return new n(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = p2;
        } }), Sg2 = te2({ "src/language-html/print-preprocess.js"(e, r) {
          ne2();
          var { ParseSourceSpan: t } = Ag2(), { htmlTrim: s2, getLeadingAndTrailingHtmlWhitespace: a2, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p2, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h2, isWhitespaceSensitiveNode: g, isVueScriptTag: c2 } = Rt2(), f = [_, w, N, I, P, T, $2, D, m2, x2, C];
          function F(o, d) {
            for (let v of f)
              v(o, d);
            return o;
          }
          function _(o) {
            o.walk((d) => {
              if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                let v = d.children[0];
                v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
              }
            });
          }
          function w(o) {
            let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
            o.walk((v) => {
              if (v.children)
                for (let S = 0; S < v.children.length; S++) {
                  let b = v.children[S];
                  if (!d(b))
                    continue;
                  let B = b.prev, k = b.firstChild;
                  v.removeChild(B), S--;
                  let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
                  b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
                }
            });
          }
          function E(o, d, v) {
            o.walk((S) => {
              if (S.children)
                for (let b = 0; b < S.children.length; b++) {
                  let B = S.children[b];
                  if (B.type !== "text" && !d(B))
                    continue;
                  B.type !== "text" && (B.type = "text", B.value = v(B));
                  let k = B.prev;
                  !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                }
            });
          }
          function N(o) {
            return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
          }
          function x2(o) {
            let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
            o.walk((v) => {
              if (v.children)
                for (let S = 0; S < v.children.length; S++) {
                  let b = v.children[S];
                  if (!d(b))
                    continue;
                  let B = b.prev, k = b.next;
                  B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
                }
            });
          }
          function I(o, d) {
            if (d.parser === "html")
              return;
            let v = /{{(.+?)}}/s;
            o.walk((S) => {
              if (u(S))
                for (let b of S.children) {
                  if (b.type !== "text")
                    continue;
                  let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                  for (let R = 0; R < M.length; R++, B = k) {
                    let q2 = M[R];
                    if (R % 2 === 0) {
                      k = B.moveBy(q2.length), q2.length > 0 && S.insertChildBefore(b, { type: "text", value: q2, sourceSpan: new t(B, k) });
                      continue;
                    }
                    k = B.moveBy(q2.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q2.length === 0 ? [] : [{ type: "text", value: q2, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                  }
                  S.removeChild(b);
                }
            });
          }
          function P(o) {
            o.walk((d) => {
              if (!d.children)
                return;
              if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s2(d.children[0].value).length === 0) {
                d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                return;
              }
              let v = g(d), S = p2(d);
              if (!v)
                for (let b = 0; b < d.children.length; b++) {
                  let B = d.children[b];
                  if (B.type !== "text")
                    continue;
                  let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a2(B.value), q2 = B.prev, J = B.next;
                  M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q2 && (q2.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R) && (q2 && (q2.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                }
              d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
            });
          }
          function $2(o) {
            o.walk((d) => {
              d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
            });
          }
          function D(o, d) {
            o.walk((v) => {
              v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
            });
          }
          function T(o, d) {
            o.walk((v) => {
              v.cssDisplay = i(v, d);
            });
          }
          function m2(o, d) {
            o.walk((v) => {
              let { children: S } = v;
              if (S) {
                if (S.length === 0) {
                  v.isDanglingSpaceSensitive = l(v);
                  return;
                }
                for (let b of S)
                  b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h2(b, d);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function C(o, d) {
            if (d.parser === "vue") {
              let v = o.children.find((b) => c2(b, d));
              if (!v)
                return;
              let { lang: S } = v.attrMap;
              (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
            }
          }
          r.exports = F;
        } }), xg2 = te2({ "src/language-html/pragma.js"(e, r) {
          ne2();
          function t(a2) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a2);
          }
          function s2(a2) {
            return `<!-- @format -->

` + a2.replace(/^\s*\n/, "");
          }
          r.exports = { hasPragma: t, insertPragma: s2 };
        } }), au = te2({ "src/language-html/loc.js"(e, r) {
          ne2();
          function t(a2) {
            return a2.sourceSpan.start.offset;
          }
          function s2(a2) {
            return a2.sourceSpan.end.offset;
          }
          r.exports = { locStart: t, locEnd: s2 };
        } }), ur = te2({ "src/language-html/print/tag.js"(e, r) {
          ne2();
          var t = Zt2(), { isNonEmptyArray: s2 } = Ue2(), { builders: { indent: a2, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p2 } } = qe2(), { locStart: y, locEnd: h2 } = au(), { isTextLikeNode: g, getLastDescendant: c2, isPreLikeNode: f, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt2();
          function E(L, Q) {
            return [L.isSelfClosing ? "" : N(L, Q), x2(L, Q)];
          }
          function N(L, Q) {
            return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $2(L, Q)];
          }
          function x2(L, Q) {
            return (L.next ? m2(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
          }
          function I(L, Q) {
            return C(L) ? D(L.lastChild, Q) : "";
          }
          function P(L, Q) {
            return o(L) ? $2(L.parent, Q) : d(L) ? q2(L.next) : "";
          }
          function $2(L, Q) {
            if (t(!L.isSelfClosing), T(L, Q))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          function D(L, Q) {
            if (T(L, Q))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function T(L, Q) {
            return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
          }
          function m2(L) {
            return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function C(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c2(L.lastChild)) && !f(L);
          }
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c2(L));
          }
          function d(L) {
            return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          function v(L) {
            let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
          }
          function S(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function b(L, Q, V) {
            let j = L.getValue();
            if (!s2(j.attrs))
              return j.isSelfClosing ? " " : "";
            let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
              let Fe = ue.getValue();
              return ie(Fe) ? p2(Q.originalText.slice(y(Fe), h2(Fe))) : V();
            }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a2([ce ? " " : u, n(K, ee)])];
            return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
          }
          function B(L) {
            return L.firstChild && S(L.firstChild) ? "" : J(L);
          }
          function k(L, Q, V) {
            let j = L.getValue();
            return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
          }
          function M(L, Q) {
            return L.prev && d(L.prev) ? "" : [R(L, Q), q2(L)];
          }
          function R(L, Q) {
            return S(L) ? J(L.parent) : m2(L) ? D(L.prev, Q) : "";
          }
          function q2(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition)
                  return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          function J(L) {
            switch (t(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          r.exports = { printClosingTag: E, printClosingTagStart: N, printClosingTagStartMarker: $2, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x2, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m2, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q2, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
        } }), bg2 = te2({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
          ne2(), function(t, s2) {
            typeof r == "object" && r.exports ? r.exports = s2() : t.parseSrcset = s2();
          }(e, function() {
            return function(t, s2) {
              var a2 = s2 && s2.logger || console;
              function n($2) {
                return $2 === " " || $2 === "	" || $2 === `
` || $2 === "\f" || $2 === "\r";
              }
              function u($2) {
                var D, T = $2.exec(t.substring(N));
                if (T)
                  return D = T[0], N += D.length, D;
              }
              for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p2 = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g = /^\d+$/, c2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N = 0, x2 = []; ; ) {
                if (u(p2), N >= i)
                  return x2;
                f = u(y), F = [], f.slice(-1) === "," ? (f = f.replace(h2, ""), P()) : I();
              }
              function I() {
                for (u(l), _ = "", w = "in descriptor"; ; ) {
                  if (E = t.charAt(N), w === "in descriptor")
                    if (n(E))
                      _ && (F.push(_), _ = "", w = "after descriptor");
                    else if (E === ",") {
                      N += 1, _ && F.push(_), P();
                      return;
                    } else if (E === "(")
                      _ = _ + E, w = "in parens";
                    else if (E === "") {
                      _ && F.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w === "in parens")
                    if (E === ")")
                      _ = _ + E, w = "in descriptor";
                    else if (E === "") {
                      F.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w === "after descriptor" && !n(E))
                    if (E === "") {
                      P();
                      return;
                    } else
                      w = "in descriptor", N -= 1;
                  N += 1;
                }
              }
              function P() {
                var $2 = false, D, T, m2, C, o = {}, d, v, S, b, B;
                for (C = 0; C < F.length; C++)
                  d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($2 = true), b === 0 ? $2 = true : D = b) : c2.test(S) && v === "x" ? ((D || T || m2) && ($2 = true), B < 0 ? $2 = true : T = B) : g.test(S) && v === "h" ? ((m2 || T) && ($2 = true), b === 0 ? $2 = true : m2 = b) : $2 = true;
                $2 ? a2 && a2.error && a2.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m2 && (o.h = m2), x2.push(o));
              }
            };
          });
        } }), Tg2 = te2({ "src/language-html/syntax-attribute.js"(e, r) {
          ne2();
          var t = bg2(), { builders: { ifBreak: s2, join: a2, line: n } } = qe2();
          function u(l) {
            let p2 = t(l, { logger: { error(I) {
              throw new Error(I);
            } } }), y = p2.some((I) => {
              let { w: P } = I;
              return P;
            }), h2 = p2.some((I) => {
              let { h: P } = I;
              return P;
            }), g = p2.some((I) => {
              let { d: P } = I;
              return P;
            });
            if (y + h2 + g > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let c2 = y ? "w" : h2 ? "h" : "d", f = y ? "w" : h2 ? "h" : "x", F = (I) => Math.max(...I), _ = p2.map((I) => I.url), w = F(_.map((I) => I.length)), E = p2.map((I) => I[c2]).map((I) => I ? I.toString() : ""), N = E.map((I) => {
              let P = I.indexOf(".");
              return P === -1 ? I.length : P;
            }), x2 = F(N);
            return a2([",", n], _.map((I, P) => {
              let $2 = [I], D = E[P];
              if (D) {
                let T = w - I.length + 1, m2 = x2 - N[P], C = " ".repeat(T + m2);
                $2.push(s2(C, " "), D + f);
              }
              return $2;
            }));
          }
          function i(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          r.exports = { printImgSrcset: u, printClassNames: i };
        } }), Bg2 = te2({ "src/language-html/syntax-vue.js"(e, r) {
          ne2();
          var { builders: { group: t } } = qe2();
          function s2(i, l) {
            let { left: p2, operator: y, right: h2 } = a2(i);
            return [t(l(`function _(${p2}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a2(i) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, p2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h2 = i.match(l);
            if (!h2)
              return;
            let g = {};
            if (g.for = h2[3].trim(), !g.for)
              return;
            let c2 = h2[1].trim().replace(y, ""), f = c2.match(p2);
            f ? (g.alias = c2.replace(p2, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c2;
            let F = [g.alias, g.iterator1, g.iterator2];
            if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean))))
              return { left: F.filter(Boolean).join(","), operator: h2[2], right: g.for };
          }
          function n(i, l) {
            return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
          }
          function u(i) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p2 = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
            return l.test(y) || p2.test(y);
          }
          r.exports = { isVueEventBindingExpression: u, printVueFor: s2, printVueBindings: n };
        } }), Lo = te2({ "src/language-html/get-node-content.js"(e, r) {
          ne2();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s2, needsToBorrowLastChildClosingTagEndMarker: a2, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
          function l(p2, y) {
            let h2 = p2.startSourceSpan.end.offset;
            p2.firstChild && u(p2.firstChild) && (h2 -= i(p2).length);
            let g = p2.endSourceSpan.start.offset;
            return p2.lastChild && t(p2.lastChild) ? g += s2(p2, y).length : a2(p2) && (g -= n(p2.lastChild, y).length), y.originalText.slice(h2, g);
          }
          r.exports = l;
        } }), Ng2 = te2({ "src/language-html/embed.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, group: s2, hardline: a2, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p2, replaceTextEndOfLine: y } } = qe2(), h2 = su(), { printClosingTag: g, printClosingTagSuffix: c2, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg2(), { printVueFor: N, printVueBindings: x2, isVueEventBindingExpression: I } = Bg2(), { isScriptLikeTag: P, isVueNonHtmlBlock: $2, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m2, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt2(), S = Lo();
          function b(k, M, R) {
            let q2 = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
              let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, V = (ee) => s2(ee), j = function(ee) {
              let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s2([n([l, ee]), ce ? l : ""]);
            }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
              return j(w(J()));
            if (k.fullName === "class" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{"))
                return E(ee);
            }
            if (k.fullName === "style" && !R.parentParser) {
              let ee = J();
              if (!ee.includes("{{"))
                return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (R.parser === "vue") {
              if (k.fullName === "v-for")
                return N(J(), ie);
              if (o(k) || d(k, R))
                return x2(J(), ie);
              let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
              if (q2(ee)) {
                let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Y(ie(K, { parser: de }));
              }
              if (q2(ce))
                return Y(ie(J(), { parser: "__vue_expression" }));
              if (q2(W))
                return Y(ie(J(), { parser: "__js_expression" }));
            }
            if (R.parser === "angular") {
              let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
              if (q2(W))
                return Y(ee(J(), { parser: "__ng_action" }));
              if (q2(K))
                return Y(ee(J(), { parser: "__ng_binding" }));
              if (q2(de)) {
                let z = J().trim();
                return j(i(v(k, z)), !z.includes("@@"));
              }
              if (q2(ce))
                return Y(ee(J(), { parser: "__ng_directive" }));
              let ue = /{{(.+?)}}/s, Fe = J();
              if (ue.test(Fe)) {
                let z = [];
                for (let [U, Z] of Fe.split(ue).entries())
                  if (U % 2 === 0)
                    z.push(y(Z));
                  else
                    try {
                      z.push(s2(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      z.push("{{", y(Z), "}}");
                    }
                return s2(z);
              }
            }
            return null;
          }
          function B(k, M, R, q2) {
            let J = k.getValue();
            switch (J.type) {
              case "element": {
                if (P(J) || J.type === "interpolation")
                  return;
                if (!J.isSelfClosing && $2(J, q2)) {
                  let L = D(J, q2);
                  if (!L)
                    return;
                  let Q = S(J, q2), V = /^\s*$/.test(Q), j = "";
                  return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q2), s2(_(k, q2, M)), V ? "" : a2, j, V ? "" : a2, g(J, q2), c2(J, q2)];
                }
                break;
              }
              case "text": {
                if (P(J.parent)) {
                  let L = D(J.parent, q2);
                  if (L) {
                    let Q = L === "markdown" ? m2(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                    if (q2.parser === "html" && L === "babel") {
                      let j = "script", { attrMap: Y } = J.parent;
                      Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                    }
                    return [t, F(J, q2), R(Q, V, { stripTrailingHardline: true }), c2(J, q2)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q2.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q2.parser === "vue" ? L.parser = q2.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q2.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                if (q2.parser === "lwc" && /^{.*}$/s.test(q2.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q2);
                if (L)
                  return [J.rawName, '="', s2(p2(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                break;
              }
              case "front-matter":
                return h2(J, R);
            }
          }
          r.exports = B;
        } }), Oo = te2({ "src/language-html/print/children.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, group: s2, ifBreak: a2, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe2(), { locStart: p2, locEnd: y } = au(), { forceBreakChildren: h2, forceNextEmptyLine: g, isTextLikeNode: c2, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F } = Rt2(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x2, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
          function $2(m2, C, o) {
            let d = m2.getValue();
            return f(d) ? [_(d, C), ...l(C.originalText.slice(p2(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x2(d, C).length : 0))), I(d, C)] : o();
          }
          function D(m2, C) {
            return c2(m2) && c2(C) ? m2.isTrailingSpaceSensitive ? m2.hasTrailingSpaces ? F(C) ? i : n : "" : F(C) ? i : u : w(m2) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m2.type === "element" && m2.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m2.lastChild && P(m2.lastChild) && m2.lastChild.lastChild && P(m2.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
          }
          function T(m2, C, o) {
            let d = m2.getValue();
            if (h2(d))
              return [t, ...m2.map((S) => {
                let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                return [B ? [B, g(b.prev) ? i : ""] : "", $2(S, C, o)];
              }, "children")];
            let v = d.children.map(() => Symbol(""));
            return m2.map((S, b) => {
              let B = S.getValue();
              if (c2(B)) {
                if (B.prev && c2(B.prev)) {
                  let Q = D(B.prev, B);
                  if (Q)
                    return g(B.prev) ? [i, i, $2(S, C, o)] : [Q, $2(S, C, o)];
                }
                return $2(S, C, o);
              }
              let k = [], M = [], R = [], q2 = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
              return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c2(B.prev) ? M.push(J) : M.push(a2("", u, { groupId: v[b - 1] }))), L && (g(B) ? c2(B.next) && q2.push(i, i) : L === i ? c2(B.next) && q2.push(i) : R.push(L)), [...k, s2([...M, s2([$2(S, C, o), ...R], { id: v[b] })]), ...q2];
            }, "children");
          }
          r.exports = { printChildren: T };
        } }), wg2 = te2({ "src/language-html/print/element.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, dedentToRoot: s2, group: a2, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p2 }, utils: { replaceTextEndOfLine: y } } = qe2(), h2 = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c2, isVueCustomBlock: f, countParents: F, forceBreakContent: _ } = Rt2(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N, printClosingTag: x2, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $2 } = Oo();
          function D(T, m2, C) {
            let o = T.getValue();
            if (g(o, m2))
              return [w(o, m2), a2(E(T, m2, C)), ...y(h2(o, m2)), ...x2(o, m2), N(o, m2)];
            let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a2([a2(E(T, m2, C), { id: v }), M, x2(o, m2)]), b = (M) => d ? u(M, { groupId: v }) : (c2(o) || f(o, m2)) && o.parent.type === "root" && m2.parser === "vue" && !m2.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n(p2, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s2(p2) : p2, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n(p2, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m2.tabWidth * F(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p2;
            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $2(T, m2, C)]), k()]);
          }
          r.exports = { printElement: D };
        } }), _g2 = te2({ "src/language-html/printer-html.js"(e, r) {
          ne2();
          var { builders: { fill: t, group: s2, hardline: a2, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p2 } } = qe2(), y = gg2(), { countChars: h2, unescapeQuoteEntities: g, getTextValueParts: c2 } = Rt2(), f = Sg2(), { insertPragma: F } = xg2(), { locStart: _, locEnd: w } = au(), E = Ng2(), { printClosingTagSuffix: N, printClosingTagEnd: x2, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $2 } = wg2(), { printChildren: D } = Oo();
          function T(m2, C, o) {
            let d = m2.getValue();
            switch (d.type) {
              case "front-matter":
                return p2(d.raw);
              case "root":
                return C.__onHtmlRoot && C.__onHtmlRoot(d), [s2(D(m2, C, o)), a2];
              case "element":
              case "ieConditionalComment":
                return $2(m2, C, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d), x2(d)];
              case "interpolation":
                return [P(d, C), ...m2.map(o, "children"), x2(d, C)];
              case "text": {
                if (d.parent.type === "interpolation") {
                  let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                  return [...p2(B), b ? a2 : ""];
                }
                let v = u([I(d, C), ...c2(d), N(d, C)]);
                return l(v) || v.type === "fill" ? t(i(v)) : v;
              }
              case "docType":
                return [s2([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x2(d, C)];
              case "comment":
                return [I(d, C), ...p2(C.originalText.slice(_(d), w(d)), n), N(d, C)];
              case "attribute": {
                if (d.value === null)
                  return d.rawName;
                let v = g(d.value), S = h2(v, "'"), b = h2(v, '"'), B = S < b ? "'" : '"';
                return [d.rawName, "=", B, ...p2(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error(`Unexpected node type ${d.type}`);
            }
          }
          r.exports = { preprocess: f, print: T, insertPragma: F, massageAstNode: y, embed: E };
        } }), Pg2 = te2({ "src/language-html/options.js"(e, r) {
          ne2();
          var t = Mt2(), s2 = "HTML";
          r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Ig2 = te2({ "src/language-html/parsers.js"() {
          ne2();
        } }), On2 = te2({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
          r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), kg2 = te2({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
          r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Lg2 = te2({ "src/language-html/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = _g2(), a2 = Pg2(), n = Ig2(), u = [t(On2(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On2(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On2(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg2(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s2 };
          r.exports = { languages: u, printers: i, options: a2, parsers: n };
        } }), Og2 = te2({ "src/language-yaml/pragma.js"(e, r) {
          ne2();
          function t(n) {
            return /^\s*@(?:prettier|format)\s*$/.test(n);
          }
          function s2(n) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
          }
          function a2(n) {
            return `# @format

${n}`;
          }
          r.exports = { isPragma: t, hasPragma: s2, insertPragma: a2 };
        } }), jg2 = te2({ "src/language-yaml/loc.js"(e, r) {
          ne2();
          function t(a2) {
            return a2.position.start.offset;
          }
          function s2(a2) {
            return a2.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s2 };
        } }), qg2 = te2({ "src/language-yaml/embed.js"(e, r) {
          ne2();
          function t(s2, a2, n, u) {
            if (s2.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
              return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          r.exports = t;
        } }), $t2 = te2({ "src/language-yaml/utils.js"(e, r) {
          ne2();
          var { getLast: t, isNonEmptyArray: s2 } = Ue2();
          function a2(D, T) {
            let m2 = 0, C = D.stack.length - 1;
            for (let o = 0; o < C; o++) {
              let d = D.stack[o];
              n(d) && T(d) && m2++;
            }
            return m2;
          }
          function n(D, T) {
            return D && typeof D.type == "string" && (!T || T.includes(D.type));
          }
          function u(D, T, m2) {
            return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m2);
          }
          function i(D, T, m2) {
            Object.defineProperty(D, T, { get: m2, enumerable: false });
          }
          function l(D, T) {
            let m2 = 0, C = T.length;
            for (let o = D.position.end.offset - 1; o < C; o++) {
              let d = T[o];
              if (d === `
` && m2++, m2 === 1 && /\S/.test(d))
                return false;
              if (m2 === 2)
                return true;
            }
            return false;
          }
          function p2(D) {
            switch (D.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m2 = D.stack.length;
            for (let C = 1; C < m2; C++) {
              let o = D.stack[C], d = D.stack[C - 1];
              if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                return false;
            }
            return true;
          }
          function y(D) {
            return s2(D.children) ? y(t(D.children)) : D;
          }
          function h2(D) {
            return D.value.trim() === "prettier-ignore";
          }
          function g(D) {
            let T = D.getValue();
            if (T.type === "documentBody") {
              let m2 = D.getParentNode();
              return N(m2.head) && h2(t(m2.head.endComments));
            }
            return F(T) && h2(t(T.leadingComments));
          }
          function c2(D) {
            return !s2(D.children) && !f(D);
          }
          function f(D) {
            return F(D) || _(D) || w(D) || E(D) || N(D);
          }
          function F(D) {
            return s2(D == null ? void 0 : D.leadingComments);
          }
          function _(D) {
            return s2(D == null ? void 0 : D.middleComments);
          }
          function w(D) {
            return D == null ? void 0 : D.indicatorComment;
          }
          function E(D) {
            return D == null ? void 0 : D.trailingComment;
          }
          function N(D) {
            return s2(D == null ? void 0 : D.endComments);
          }
          function x2(D) {
            let T = [], m2;
            for (let C of D.split(/( +)/))
              C !== " " ? m2 === " " ? T.push(C) : T.push((T.pop() || "") + C) : m2 === void 0 && T.unshift(""), m2 = C;
            return m2 === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
          }
          function I(D, T, m2) {
            let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
            return m2.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x2(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m2.proseWrap === "never" ? [o.join(" ")] : o);
          }
          function P(D, T) {
            let { parentIndent: m2, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
            if (D.indent === null) {
              let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              v = D.indent - 1 + m2;
            let S = d.split(`
`).map((B) => B.slice(v));
            if (o.proseWrap === "preserve" || D.type === "blockLiteral")
              return b(S.map((B) => B.length === 0 ? [] : [B]));
            return b(S.map((B) => B.length === 0 ? [] : x2(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
            function b(B) {
              if (D.chomping === "keep")
                return t(B).length === 0 ? B.slice(0, -1) : B;
              let k = 0;
              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                k++;
              return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
            }
          }
          function $2(D) {
            if (!D)
              return true;
            switch (D.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          r.exports = { getLast: t, getAncestorCount: a2, isNode: n, isEmptyNode: c2, isInlineNode: $2, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p2, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N };
        } }), Mg2 = te2({ "src/language-yaml/print-preprocess.js"(e, r) {
          ne2();
          var { defineShortcut: t, mapNode: s2 } = $t2();
          function a2(u) {
            return s2(u, n);
          }
          function n(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          r.exports = a2;
        } }), Mr = te2({ "src/language-yaml/print/misc.js"(e, r) {
          ne2();
          var { builders: { softline: t, align: s2 } } = qe2(), { hasEndComments: a2, isNextLineEmpty: n, isNode: u } = $t2(), i = /* @__PURE__ */ new WeakMap();
          function l(h2, g) {
            let c2 = h2.getValue(), f = h2.stack[0], F;
            return i.has(f) ? F = i.get(f) : (F = /* @__PURE__ */ new Set(), i.set(f, F)), !F.has(c2.position.end.line) && (F.add(c2.position.end.line), n(c2, g) && !p2(h2.getParentNode())) ? t : "";
          }
          function p2(h2) {
            return a2(h2) && !u(h2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function y(h2, g) {
            return s2(" ".repeat(h2), g);
          }
          r.exports = { alignWithSpaces: y, shouldPrintEndComments: p2, printNextEmptyLine: l };
        } }), Rg2 = te2({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
          ne2();
          var { builders: { ifBreak: t, line: s2, softline: a2, hardline: n, join: u } } = qe2(), { isEmptyNode: i, getLast: l, hasEndComments: p2 } = $t2(), { printNextEmptyLine: y, alignWithSpaces: h2 } = Mr();
          function g(f, F, _) {
            let w = f.getValue(), E = w.type === "flowMapping", N = E ? "{" : "[", x2 = E ? "}" : "]", I = a2;
            E && w.children.length > 0 && _.bracketSpacing && (I = s2);
            let P = l(w.children), $2 = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
            return [N, h2(_.tabWidth, [I, c2(f, F, _), _.trailingComma === "none" ? "" : t(","), p2(w) ? [n, u(n, f.map(F, "endComments"))] : ""]), $2 ? "" : I, x2];
          }
          function c2(f, F, _) {
            let w = f.getValue();
            return f.map((N, x2) => [F(), x2 === w.children.length - 1 ? "" : [",", s2, w.children[x2].position.start.line !== w.children[x2 + 1].position.start.line ? y(N, _.originalText) : ""]], "children");
          }
          r.exports = { printFlowMapping: g, printFlowSequence: g };
        } }), $g = te2({ "src/language-yaml/print/mapping-item.js"(e, r) {
          ne2();
          var { builders: { conditionalGroup: t, group: s2, hardline: a2, ifBreak: n, join: u, line: i } } = qe2(), { hasLeadingComments: l, hasMiddleComments: p2, hasTrailingComment: y, hasEndComments: h2, isNode: g, isEmptyNode: c2, isInlineNode: f } = $t2(), { alignWithSpaces: F } = Mr();
          function _(x2, I, P, $2, D) {
            let { key: T, value: m2 } = x2, C = c2(T), o = c2(m2);
            if (C && o)
              return ": ";
            let d = $2("key"), v = E(x2) ? " " : "";
            if (o)
              return x2.type === "flowMappingItem" && I.type === "flowMapping" ? d : x2.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F(2, d)];
            let S = $2("value");
            if (C)
              return [": ", F(2, S)];
            if (l(m2) || !f(T.content))
              return ["? ", F(2, d), a2, u("", P.map($2, "value", "leadingComments").map((q2) => [q2, a2])), ": ", F(2, S)];
            if (N(T.content) && !l(T.content) && !p2(T.content) && !y(T.content) && !h2(T) && !l(m2.content) && !p2(m2.content) && !h2(m2) && w(m2.content, D))
              return [d, v, ": ", S];
            let b = Symbol("mappingKey"), B = s2([n("? "), s2(F(2, d), { id: b })]), k = [a2, ": ", F(2, S)], M = [v, ":"];
            l(m2.content) || h2(m2) && m2.content && !g(m2.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f(m2.content) || g(m2.content, ["mapping", "sequence"]) && m2.content.tag === null && m2.content.anchor === null ? M.push(a2) : m2.content && M.push(i), M.push(S);
            let R = F(D.tabWidth, M);
            return w(T.content, D) && !l(T.content) && !p2(T.content) && !h2(T) ? t([[d, R]]) : t([[B, n(k, R, { groupId: b })]]);
          }
          function w(x2, I) {
            if (!x2)
              return true;
            switch (x2.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve")
              return x2.position.start.line === x2.position.end.line;
            if (/\\$/m.test(I.originalText.slice(x2.position.start.offset, x2.position.end.offset)))
              return false;
            switch (I.proseWrap) {
              case "never":
                return !x2.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(x2.value);
              default:
                return false;
            }
          }
          function E(x2) {
            return x2.key.content && x2.key.content.type === "alias";
          }
          function N(x2) {
            if (!x2)
              return true;
            switch (x2.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return x2.position.start.line === x2.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          r.exports = _;
        } }), Vg = te2({ "src/language-yaml/print/block.js"(e, r) {
          ne2();
          var { builders: { dedent: t, dedentToRoot: s2, fill: a2, hardline: n, join: u, line: i, literalline: l, markAsRoot: p2 }, utils: { getDocParts: y } } = qe2(), { getAncestorCount: h2, getBlockValueLineContents: g, hasIndicatorComment: c2, isLastDescendantNode: f, isNode: F } = $t2(), { alignWithSpaces: _ } = Mr();
          function w(E, N, x2) {
            let I = E.getValue(), P = h2(E, (C) => F(C, ["sequence", "mapping"])), $2 = f(E), D = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c2(I) && D.push(" ", N("indicatorComment"));
            let T = g(I, { parentIndent: P, isLastDescendant: $2, options: x2 }), m2 = [];
            for (let [C, o] of T.entries())
              C === 0 && m2.push(n), m2.push(a2(y(u(i, o)))), C !== T.length - 1 ? m2.push(o.length === 0 ? n : p2(l)) : I.chomping === "keep" && $2 && m2.push(s2(o.length === 0 ? n : l));
            return I.indent === null ? D.push(t(_(x2.tabWidth, m2))) : D.push(s2(_(I.indent - 1 + P, m2))), D;
          }
          r.exports = w;
        } }), Wg = te2({ "src/language-yaml/printer-yaml.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, fill: s2, group: a2, hardline: n, join: u, line: i, lineSuffix: l, literalline: p2 }, utils: { getDocParts: y, replaceTextEndOfLine: h2 } } = qe2(), { isPreviousLineEmpty: g } = Ue2(), { insertPragma: c2, isPragma: f } = Og2(), { locStart: F } = jg2(), _ = qg2(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N, hasMiddleComments: x2, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $2, isLastDescendantNode: D, isNode: T, isInlineNode: m2 } = $t2(), C = Mg2(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg2(), B = $g(), k = Vg();
          function M(j, Y, ie) {
            let ee = j.getValue(), ce = [];
            ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
            let { tag: W, anchor: K } = ee;
            W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
            let de = "";
            T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x2(ee) ? ce.push(n) : ce.push(" ")), x2(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
            let ue = j.getParentNode();
            return $2(j) ? ce.push(h2(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p2)) : ce.push(a2(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m2(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
          }
          function R(j, Y, ie, ee, ce) {
            switch (j.type) {
              case "root": {
                let { children: W } = j, K = [];
                ie.each((ue, Fe) => {
                  let z = W[Fe], U = W[Fe + 1];
                  Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
                }, "children");
                let de = E(j);
                return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
              }
              case "document": {
                let W = Y.children[ie.getName() + 1], K = [];
                return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q2(j) && K.push(ce("body")), u(n, K);
              }
              case "documentHead":
                return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: K } = j, de = "";
                if (W.length > 0 && K.length > 0) {
                  let ue = E(j);
                  T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
                }
                return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [j.name, ...j.parameters])];
              case "comment":
                return ["#", j.value];
              case "alias":
                return ["*", j.value];
              case "tag":
                return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
              case "anchor":
                return ["&", j.value];
              case "plain":
                return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                  let Fe = j.type === "quoteDouble" ? K : W;
                  return [Fe, Q(j.type, de, ee), Fe];
                }
                if (de.includes(K))
                  return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                if (de.includes(W))
                  return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                let ue = ee.singleQuote ? W : K;
                return [ue, Q(j.type, de, ee), ue];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(ie, ce, ee);
              case "mapping":
              case "sequence":
                return u(n, ie.map(ce, "children"));
              case "sequenceItem":
                return ["- ", o(2, j.content ? ce("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return j.content ? ce("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B(j, Y, ie, ce, ee);
              case "flowMapping":
                return S(ie, ce, ee);
              case "flowSequence":
                return b(ie, ce, ee);
              case "flowSequenceItem":
                return ce("content");
              default:
                throw new Error(`Unexpected node type ${j.type}`);
            }
          }
          function q2(j) {
            return j.body.children.length > 0 || P(j.body);
          }
          function J(j, Y) {
            return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
          }
          function L(j, Y, ie, ee) {
            return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
          }
          function Q(j, Y, ie) {
            let ee = w(j, Y, ie);
            return u(n, ee.map((ce) => s2(y(u(i, ce)))));
          }
          function V(j, Y) {
            if (T(Y))
              switch (delete Y.position, Y.type) {
                case "comment":
                  if (f(Y.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  Y.type = "quote";
                  break;
              }
          }
          r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c2 };
        } }), Hg = te2({ "src/language-yaml/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Gg = te2({ "src/language-yaml/parsers.js"() {
          ne2();
        } }), Ug = te2({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
          r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Jg = te2({ "src/language-yaml/index.js"(e, r) {
          ne2();
          var t = _t2(), s2 = Wg(), a2 = Hg(), n = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          r.exports = { languages: u, printers: { yaml: s2 }, options: a2, parsers: n };
        } }), zg = te2({ "src/languages.js"(e, r) {
          ne2(), r.exports = [Bd2(), Ud2(), eg2(), ag2(), dg2(), Lg2(), Jg()];
        } });
        ne2();
        var { version: Xg } = Ia2(), Ot2 = Gm2(), { getSupportInfo: Kg } = Xn2(), Yg = Um2(), Qg = zg(), Zg = qe2();
        function Nt2(e) {
          let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s2 = new Array(t), a2 = 0; a2 < t; a2++)
              s2[a2] = arguments[a2];
            let n = s2[r] || {}, u = n.plugins || [];
            return s2[r] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s2);
          };
        }
        var jn2 = Nt2(Ot2.formatWithCursor);
        jo.exports = { formatWithCursor: jn2, format(e, r) {
          return jn2(e, r).formatted;
        }, check(e, r) {
          let { formatted: t } = jn2(e, r);
          return t === e;
        }, doc: Zg, getSupportInfo: Nt2(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt2(Ot2.parse), formatAST: Nt2(Ot2.formatAST), formatDoc: Nt2(Ot2.formatDoc), printToDoc: Nt2(Ot2.printToDoc), printDocToString: Nt2(Ot2.printDocToString) } };
      });
      return e0();
    });
  })(standalone);
  var standaloneExports = standalone.exports;
  var Prettier = /* @__PURE__ */ getDefaultExportFromCjs(standaloneExports);
  const unifiedLatexStringCompiler = function unifiedLatexStringCompiler2(options2) {
    const {
      pretty = false,
      printWidth = 80,
      useTabs = true,
      forceNewlineEnding = false
    } = options2 || {};
    const prettyPrinter = (ast2) => {
      let formatted = Prettier.format("_", {
        useTabs,
        printWidth,
        parser: "latex-dummy-parser",
        plugins: [
          {
            languages: [
              {
                name: "latex",
                extensions: [".tex"],
                parsers: ["latex-dummy-parser"]
              }
            ],
            parsers: {
              "latex-dummy-parser": {
                parse: () => ast2,
                astFormat: "latex-ast",
                locStart: () => 0,
                locEnd: () => 1
              }
            },
            printers: {
              "latex-ast": {
                print: printLatexAst
              }
            }
          }
        ],
        ...options2 || {}
      });
      if (forceNewlineEnding && !formatted.endsWith("\n")) {
        formatted += "\n";
      }
      return formatted;
    };
    Object.assign(this, {
      Compiler: (ast2) => {
        if (!pretty) {
          return printRaw(ast2);
        }
        return prettyPrinter(ast2);
      }
    });
  };
  unified().use(unifiedLatexStringCompiler, { pretty: true }).freeze();
  const processLatexViaUnified = (options2) => {
    return unified().use(unifiedLatexFromString, options2).use(
      unifiedLatexStringCompiler,
      Object.assign({ pretty: true }, options2)
    );
  };
  function formatNodeForError$1(node2) {
    try {
      return printRaw(node2);
    } catch {
    }
    return JSON.stringify(node2);
  }
  function toHastWithLoggerFactory(logger) {
    return function toHast2(node2) {
      const htmlNode = node2;
      if (isHtmlLikeTag(htmlNode)) {
        const extracted = extractFromHtmlLike(htmlNode);
        const attributes2 = extracted.attributes;
        return h(
          extracted.tag,
          attributes2,
          extracted.content.flatMap(toHast2)
        );
      }
      switch (node2.type) {
        case "string":
          return {
            type: "text",
            value: node2.content,
            position: node2.position
          };
        case "comment":
          return {
            type: "comment",
            value: node2.content,
            position: node2.position
          };
        case "inlinemath":
          return h(
            "span",
            { className: "inline-math" },
            printRaw(node2.content)
          );
        case "mathenv":
        case "displaymath":
          return h(
            "div",
            { className: "display-math" },
            printRaw(node2.content)
          );
        case "verb":
        case "verbatim":
          return h("pre", { className: node2.env }, node2.content);
        case "whitespace":
          return { type: "text", value: " ", position: node2.position };
        case "parbreak":
          return h("br");
        case "group":
          return node2.content.flatMap(toHast2);
        case "environment":
          logger(
            `Unknown environment when converting to HTML \`${formatNodeForError$1(
              node2.env
            )}\``,
            node2
          );
          return h(
            "div",
            { className: ["environment", printRaw(node2.env)] },
            node2.content.flatMap(toHast2)
          );
        case "macro":
          logger(
            `Unknown macro when converting to HTML \`${formatNodeForError$1(
              node2
            )}\``,
            node2
          );
          return h(
            "span",
            { className: ["macro", `macro-${node2.content}`] },
            (node2.args || []).map(toHast2).flat()
          );
        case "argument":
          return h(
            "span",
            {
              className: ["argument"],
              "data-open-mark": node2.openMark,
              "data-close-mark": node2.closeMark
            },
            printRaw(node2.content)
          );
        case "root":
          return node2.content.flatMap(toHast2);
        default: {
          throw new Error(
            `Unknown node type; cannot convert to HAST ${JSON.stringify(
              node2
            )}`
          );
        }
      }
    };
  }
  function splitForPars$1(nodes, options2) {
    const ret = [];
    let currBody = [];
    trim(nodes);
    const isParBreakingMacro = match.createMacroMatcher(
      options2.macrosThatBreakPars
    );
    const isEnvThatShouldNotBreakPar = match.createEnvironmentMatcher(
      options2.environmentsThatDontBreakPars
    );
    function pushBody() {
      if (currBody.length > 0) {
        trim(currBody);
        ret.push({ content: currBody, wrapInPar: true });
        currBody = [];
      }
    }
    for (const node2 of nodes) {
      if (isParBreakingMacro(node2)) {
        pushBody();
        ret.push({ content: [node2], wrapInPar: false });
        continue;
      }
      if (match.anyEnvironment(node2) && !isEnvThatShouldNotBreakPar(node2)) {
        pushBody();
        ret.push({ content: [node2], wrapInPar: false });
        continue;
      }
      if (node2.type === "displaymath") {
        pushBody();
        ret.push({ content: [node2], wrapInPar: false });
        continue;
      }
      if (match.parbreak(node2) || match.macro(node2, "par")) {
        pushBody();
        continue;
      }
      currBody.push(node2);
    }
    pushBody();
    return ret;
  }
  function wrapPars$1(nodes, options2) {
    const {
      macrosThatBreakPars = [
        "part",
        "chapter",
        "section",
        "subsection",
        "subsubsection",
        "paragraph",
        "subparagraph",
        "vspace",
        "smallskip",
        "medskip",
        "bigskip",
        "hfill"
      ],
      environmentsThatDontBreakPars = []
    } = options2 || {};
    const parSplits = splitForPars$1(nodes, {
      macrosThatBreakPars,
      environmentsThatDontBreakPars
    });
    return parSplits.flatMap((part) => {
      if (part.wrapInPar) {
        return htmlLike({ tag: "p", content: part.content });
      } else {
        return part.content;
      }
    });
  }
  var ITEM_ARG_NAMES_REG$1 = ["label"];
  var ITEM_ARG_NAMES_BEAMER$1 = [null, "label", null];
  function getItemArgs$1(node2) {
    if (!Array.isArray(node2.args)) {
      throw new Error(
        `Cannot find \\item macros arguments; you must attach the \\item body to the macro before calling this function ${JSON.stringify(
          node2
        )}`
      );
    }
    const argNames = node2.args.length - 1 === ITEM_ARG_NAMES_BEAMER$1.length ? ITEM_ARG_NAMES_BEAMER$1 : ITEM_ARG_NAMES_REG$1;
    const ret = Object.assign(
      { body: node2.args[node2.args.length - 1].content },
      getNamedArgsContent(node2, argNames)
    );
    return ret;
  }
  function enumerateFactory$1(parentTag = "ol", className = "enumerate") {
    return function enumerateToHtml(env2) {
      const items = env2.content.filter((node2) => match.macro(node2, "item"));
      const content2 = items.flatMap((node2) => {
        if (!match.macro(node2) || !node2.args) {
          return [];
        }
        const attributes2 = {};
        const namedArgs = getItemArgs$1(node2);
        if (namedArgs.label != null) {
          const formattedLabel = cssesc$1(printRaw(namedArgs.label || []));
          attributes2.style = {
            // Note the space after `formattedLabel`. That is on purpose!
            "list-style-type": formattedLabel ? `'${formattedLabel} '` : "none"
          };
        }
        const body2 = namedArgs.body;
        return htmlLike({
          tag: "li",
          content: wrapPars$1(body2),
          attributes: attributes2
        });
      });
      return htmlLike({
        tag: parentTag,
        attributes: { className },
        content: content2
      });
    };
  }
  function createCenteredElement(env2) {
    return htmlLike({
      tag: "center",
      attributes: { className: "center" },
      content: env2.content
    });
  }
  function createTableFromTabular$1(env2) {
    const tabularBody = parseAlignEnvironment(env2.content);
    const args = getArgsContent(env2);
    let columnSpecs = [];
    try {
      columnSpecs = parseTabularSpec(args[1] || []);
    } catch (e) {
    }
    const tableBody = tabularBody.map((row2) => {
      const content2 = row2.cells.map((cell2, i) => {
        const columnSpec = columnSpecs[i];
        const styles = {};
        if (columnSpec) {
          const { alignment } = columnSpec;
          if (alignment.alignment === "center") {
            styles["text-align"] = "center";
          }
          if (alignment.alignment === "right") {
            styles["text-align"] = "right";
          }
          if (columnSpec.pre_dividers.some(
            (div) => div.type === "vert_divider"
          )) {
            styles["border-left"] = "1px solid";
          }
          if (columnSpec.post_dividers.some(
            (div) => div.type === "vert_divider"
          )) {
            styles["border-right"] = "1px solid";
          }
        }
        return htmlLike(
          Object.keys(styles).length > 0 ? {
            tag: "td",
            content: cell2,
            attributes: { style: styles }
          } : {
            tag: "td",
            content: cell2
          }
        );
      });
      return htmlLike({ tag: "tr", content: content2 });
    });
    return htmlLike({
      tag: "table",
      content: [
        htmlLike({
          tag: "tbody",
          content: tableBody
        })
      ],
      attributes: { className: "tabular" }
    });
  }
  var environmentReplacements$1 = {
    enumerate: enumerateFactory$1("ol"),
    itemize: enumerateFactory$1("ul", "itemize"),
    center: createCenteredElement,
    tabular: createTableFromTabular$1,
    quote: (env2) => {
      return htmlLike({
        tag: "blockquote",
        content: env2.content,
        attributes: { className: "environment quote" }
      });
    }
  };
  var LEFT$1 = { type: "macro", content: "left" };
  var RIGHT$1 = { type: "macro", content: "right" };
  var DEFAULT_LEFT_DELIM$1 = { type: "macro", content: "{" };
  var DEFAULT_RIGHT_DELIM$1 = { type: "string", content: "." };
  var katexSpecificMacroReplacements$1 = {
    systeme: (node2) => {
      var _a3, _b;
      try {
        const args = getArgsContent(node2);
        const whitelistedVariables = args[1] || void 0;
        const equations = args[3] || [];
        const ret = systemeContentsToArray(equations, {
          properSpacing: false,
          whitelistedVariables
        });
        if ((_a3 = node2._renderInfo) == null ? void 0 : _a3.sysdelims) {
          const [frontDelim, backDelim] = (_b = node2._renderInfo) == null ? void 0 : _b.sysdelims;
          return [LEFT$1, frontDelim, ret, RIGHT$1, backDelim];
        }
        return [LEFT$1, DEFAULT_LEFT_DELIM$1, ret, RIGHT$1, DEFAULT_RIGHT_DELIM$1];
      } catch (e) {
        return node2;
      }
    },
    sysdelim: () => []
  };
  function wrapInDisplayMath$1(ast2) {
    const content2 = Array.isArray(ast2) ? ast2 : [ast2];
    return { type: "displaymath", content: content2 };
  }
  var katexSpecificEnvironmentReplacements$1 = {
    // katex supports the align environments, but it will only render them
    // if you are already in math mode. Warning: these will produce invalid latex!
    align: wrapInDisplayMath$1,
    "align*": wrapInDisplayMath$1,
    alignat: wrapInDisplayMath$1,
    "alignat*": wrapInDisplayMath$1,
    equation: wrapInDisplayMath$1,
    "equation*": wrapInDisplayMath$1
  };
  function attachNeededRenderInfo$1(ast2) {
    attachSystemeSettingsAsRenderInfo(ast2);
  }
  function factory$2(tag, attributes2) {
    return (macro2) => {
      if (!macro2.args) {
        throw new Error(
          `Found macro to replace but couldn't find content ${printRaw(
            macro2
          )}`
        );
      }
      const args = getArgsContent(macro2);
      const content2 = args[args.length - 1] || [];
      return htmlLike({ tag, content: content2, attributes: attributes2 });
    };
  }
  function createHeading$1(tag, attrs = {}) {
    return (macro2) => {
      const args = getArgsContent(macro2);
      const starred = !!args[0];
      const attributes2 = starred ? { className: "starred" } : {};
      if (attrs) {
        Object.assign(attributes2, attrs);
      }
      return htmlLike({
        tag,
        content: args[args.length - 1] || [],
        attributes: attributes2
      });
    };
  }
  var macroReplacements$1 = {
    emph: factory$2("em", { className: "emph" }),
    textrm: factory$2("span", { className: "textrm" }),
    textsf: factory$2("span", { className: "textsf" }),
    texttt: factory$2("span", { className: "texttt" }),
    textsl: factory$2("span", { className: "textsl" }),
    textit: factory$2("i", { className: "textit" }),
    textbf: factory$2("b", { className: "textbf" }),
    underline: factory$2("span", { className: "underline" }),
    mbox: factory$2("span", { className: "mbox" }),
    phantom: factory$2("span", { className: "phantom" }),
    part: createHeading$1("h1"),
    chapter: createHeading$1("h2"),
    section: createHeading$1("h3"),
    subsection: createHeading$1("h4"),
    subsubsection: createHeading$1("h5"),
    paragraph: createHeading$1("h6", { className: "section-paragraph" }),
    subparagraph: createHeading$1("h6", {
      className: "section-subparagraph"
    }),
    appendix: createHeading$1("h2"),
    smallskip: () => htmlLike({
      tag: "br",
      attributes: { className: "smallskip" }
    }),
    medskip: () => htmlLike({
      tag: "br",
      attributes: { className: "medskip" }
    }),
    bigskip: () => htmlLike({
      tag: "br",
      attributes: { className: "bigskip" }
    }),
    "\n": () => htmlLike({
      tag: "br",
      attributes: { className: "literal-newline" }
    }),
    url: (node2) => {
      const args = getArgsContent(node2);
      const url = printRaw(args[0] || "#");
      return htmlLike({
        tag: "a",
        attributes: {
          className: "url",
          href: url
        },
        content: [{ type: "string", content: url }]
      });
    },
    href: (node2) => {
      const args = getArgsContent(node2);
      const url = printRaw(args[1] || "#");
      return htmlLike({
        tag: "a",
        attributes: {
          className: "href",
          href: url
        },
        content: args[2] || []
      });
    },
    hyperref: (node2) => {
      const args = getArgsContent(node2);
      const url = "#" + printRaw(args[0] || "");
      return htmlLike({
        tag: "a",
        attributes: {
          className: "href",
          href: url
        },
        content: args[1] || []
      });
    },
    "\\": () => htmlLike({
      tag: "br",
      attributes: { className: "linebreak" }
    }),
    vspace: (node2) => {
      const args = getArgsContent(node2);
      return htmlLike({
        tag: "div",
        attributes: {
          className: "vspace",
          "data-amount": printRaw(args[1] || [])
        },
        content: []
      });
    },
    hspace: (node2) => {
      const args = getArgsContent(node2);
      return htmlLike({
        tag: "span",
        attributes: {
          className: "vspace",
          "data-amount": printRaw(args[1] || [])
        },
        content: []
      });
    },
    textcolor: (node2) => {
      const args = getArgsContent(node2);
      const computedColor = xcolorMacroToHex(node2);
      const color2 = computedColor.hex;
      if (color2) {
        return htmlLike({
          tag: "span",
          attributes: { style: `color: ${color2};` },
          content: args[2] || []
        });
      } else {
        return htmlLike({
          tag: "span",
          attributes: {
            style: `color: var(${computedColor.cssVarName});`
          },
          content: args[2] || []
        });
      }
    },
    textsize: (node2) => {
      const args = getArgsContent(node2);
      const textSize = printRaw(args[0] || []);
      return htmlLike({
        tag: "span",
        attributes: {
          className: `textsize-${textSize}`
        },
        content: args[1] || []
      });
    },
    makebox: (node2) => {
      const args = getArgsContent(node2);
      return htmlLike({
        tag: "span",
        attributes: {
          className: `latex-box`,
          style: "display: inline-block;"
        },
        content: args[3] || []
      });
    },
    noindent: () => ({ type: "string", content: "" }),
    includegraphics: (node2) => {
      const args = getArgsContent(node2);
      const src = printRaw(args[args.length - 1] || []);
      return htmlLike({
        tag: "img",
        attributes: {
          className: "includegraphics",
          src
        },
        content: []
      });
    }
  };
  function factory2(macroName, ...boundArgs) {
    return (content2, originalCommand) => {
      return m(macroName, boundArgs.map((a2) => arg(a2)).concat(arg(content2)));
    };
  }
  var streamingMacroReplacements$1 = {
    color: colorToTextcolorMacro,
    bfseries: factory2("textbf"),
    itshape: factory2("textit"),
    rmfamily: factory2("textrm"),
    scshape: factory2("textsc"),
    sffamily: factory2("textsf"),
    slshape: factory2("textsl"),
    ttfamily: factory2("texttt"),
    Huge: factory2("textsize", "Huge"),
    huge: factory2("textsize", "huge"),
    LARGE: factory2("textsize", "LARGE"),
    Large: factory2("textsize", "Large"),
    large: factory2("textsize", "large"),
    normalsize: factory2("textsize", "normalsize"),
    small: factory2("textsize", "small"),
    footnotesize: factory2("textsize", "footnotesize"),
    scriptsize: factory2("textsize", "scriptsize"),
    tiny: factory2("textsize", "tiny")
  };
  var unifiedLatexWrapPars$1 = function unifiedLatexWrapPars2(options2) {
    const { macrosThatBreakPars, environmentsThatDontBreakPars } = options2 || {};
    return (tree) => {
      let hasDocumentEnv = false;
      visit$3(
        tree,
        (env2) => {
          if (match.environment(env2, "document")) {
            hasDocumentEnv = true;
            env2.content = wrapPars$1(env2.content, {
              macrosThatBreakPars,
              environmentsThatDontBreakPars
            });
            return EXIT$2;
          }
        },
        { test: match.anyEnvironment }
      );
      if (!hasDocumentEnv) {
        tree.content = wrapPars$1(tree.content, {
          macrosThatBreakPars,
          environmentsThatDontBreakPars
        });
      }
    };
  };
  var unifiedLatexToHtmlLike = function unifiedLatexToHtmlLike2(options2) {
    const macroReplacements2 = Object.assign(
      {},
      macroReplacements$1,
      (options2 == null ? void 0 : options2.macroReplacements) || {}
    );
    const environmentReplacements2 = Object.assign(
      {},
      environmentReplacements$1,
      (options2 == null ? void 0 : options2.environmentReplacements) || {}
    );
    const isReplaceableMacro = match.createMacroMatcher(macroReplacements2);
    const isReplaceableEnvironment = match.createEnvironmentMatcher(
      environmentReplacements2
    );
    const isKatexMacro = match.createMacroMatcher(
      katexSpecificMacroReplacements$1
    );
    const isKatexEnvironment = match.createEnvironmentMatcher(
      katexSpecificEnvironmentReplacements$1
    );
    return (tree) => {
      const originalTree = tree;
      deleteComments(tree);
      let processor = unified().use(unifiedLatexLintNoTexFontShapingCommands, { fix: true }).use(unifiedLatexReplaceStreamingCommands, {
        replacers: streamingMacroReplacements$1
      });
      if (shouldBeWrappedInPars$1(tree)) {
        processor = processor.use(unifiedLatexWrapPars$1);
      }
      tree = processor.runSync(tree);
      replaceNode(tree, (node2, info) => {
        if (info.context.hasMathModeAncestor) {
          return;
        }
        if (isReplaceableEnvironment(node2)) {
          return environmentReplacements2[printRaw(node2.env)](node2, info);
        }
      });
      replaceNode(tree, (node2, info) => {
        if (info.context.hasMathModeAncestor) {
          return;
        }
        if (isReplaceableMacro(node2)) {
          const replacement = macroReplacements2[node2.content](node2, info);
          return replacement;
        }
      });
      attachNeededRenderInfo$1(tree);
      replaceNode(tree, (node2) => {
        if (isKatexMacro(node2)) {
          return katexSpecificMacroReplacements$1[node2.content](node2);
        }
        if (isKatexEnvironment(node2)) {
          return katexSpecificEnvironmentReplacements$1[printRaw(node2.env)](
            node2
          );
        }
      });
      originalTree.content = tree.content;
    };
  };
  function shouldBeWrappedInPars$1(tree) {
    let content2 = tree.content;
    visit$3(
      tree,
      (env2) => {
        if (match.anyEnvironment(env2)) {
          content2 = env2.content;
          return EXIT$2;
        }
      },
      { test: (node2) => match.environment(node2, "document") }
    );
    return content2.some(
      (node2) => match.parbreak(node2) || match.macro(node2, "par")
    );
  }
  var unifiedLatexToHast = function unifiedLatexAttachMacroArguments(options2) {
    const { skipHtmlValidation = false } = options2 || {};
    return (tree, file) => {
      unified().use(unifiedLatexToHtmlLike, options2).run(tree);
      expandUnicodeLigatures(tree);
      let content2 = tree.content;
      visit$3(
        tree,
        (env2) => {
          content2 = env2.content;
          return EXIT$2;
        },
        {
          test: (node2) => match.environment(
            node2,
            "document"
          )
        }
      );
      const toHast2 = toHastWithLoggerFactory(file.message.bind(file));
      let converted = toHast2({ type: "root", content: content2 });
      if (!Array.isArray(converted)) {
        converted = [converted];
      }
      let ret = h();
      ret.children = converted;
      if (!skipHtmlValidation) {
        ret = unified().use(rehypeRaw).runSync(ret);
      }
      return ret;
    };
  };
  var _processor = processLatexViaUnified().use(unifiedLatexToHast).use(rehypeStringify);
  function convertToHtml(tree, options2) {
    let processor = _processor;
    if (!Array.isArray(tree) && tree.type !== "root") {
      tree = { type: "root", content: [tree] };
    }
    if (Array.isArray(tree)) {
      tree = { type: "root", content: tree };
    }
    if (options2) {
      processor = _processor.use(unifiedLatexToHast, options2);
    }
    const hast = processor.runSync(tree);
    return processor.stringify(hast);
  }
  const x = (
    // Note: not yet possible to use the spread `...children` in JSDoc overloads.
    /**
     * @type {{
     *   (): Root
     *   (name: null | undefined, ...children: Array<Child>): Root
     *   (name: string, attributes?: Attributes, ...children: Array<Child>): Element
     *   (name: string, ...children: Array<Child>): Element
     * }}
     */
    /**
     * @param {string | null | undefined} [name]
     * @param {Attributes | Child | null | undefined} [attributes]
     * @param {Array<Child>} children
     * @returns {Result}
     */
    function(name2, attributes2, ...children) {
      let index2 = -1;
      let node2;
      if (name2 === void 0 || name2 === null) {
        node2 = { type: "root", children: [] };
        children.unshift(attributes2);
      } else if (typeof name2 === "string") {
        node2 = { type: "element", name: name2, attributes: {}, children: [] };
        if (isAttributes(attributes2)) {
          let key2;
          for (key2 in attributes2) {
            if (attributes2[key2] !== void 0 && attributes2[key2] !== null && (typeof attributes2[key2] !== "number" || !Number.isNaN(attributes2[key2]))) {
              node2.attributes[key2] = String(attributes2[key2]);
            }
          }
        } else {
          children.unshift(attributes2);
        }
      } else {
        throw new TypeError("Expected element name, got `" + name2 + "`");
      }
      while (++index2 < children.length) {
        addChild(node2.children, children[index2]);
      }
      return node2;
    }
  );
  function addChild(nodes, value2) {
    let index2 = -1;
    if (value2 === void 0 || value2 === null)
      ;
    else if (typeof value2 === "string" || typeof value2 === "number") {
      nodes.push({ type: "text", value: String(value2) });
    } else if (Array.isArray(value2)) {
      while (++index2 < value2.length) {
        addChild(nodes, value2[index2]);
      }
    } else if (typeof value2 === "object" && "type" in value2) {
      if (value2.type === "root") {
        addChild(nodes, value2.children);
      } else {
        nodes.push(value2);
      }
    } else {
      throw new TypeError("Expected node, nodes, string, got `" + value2 + "`");
    }
  }
  function isAttributes(value2) {
    if (value2 === null || value2 === void 0 || typeof value2 !== "object" || Array.isArray(value2)) {
      return false;
    }
    return true;
  }
  function stringifyPosition(value2) {
    if (!value2 || typeof value2 !== "object") {
      return "";
    }
    if ("position" in value2 || "type" in value2) {
      return position$1(value2.position);
    }
    if ("start" in value2 || "end" in value2) {
      return position$1(value2);
    }
    if ("line" in value2 || "column" in value2) {
      return point$1(value2);
    }
    return "";
  }
  function point$1(point2) {
    return index(point2 && point2.line) + ":" + index(point2 && point2.column);
  }
  function position$1(pos) {
    return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
  }
  function index(value2) {
    return value2 && typeof value2 === "number" ? value2 : 1;
  }
  class VFileMessage extends Error {
    /**
     * Create a message for `reason`.
     *
     * > ðª¦ **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(causeOrReason, optionsOrParentOrPlace, origin) {
      super();
      if (typeof optionsOrParentOrPlace === "string") {
        origin = optionsOrParentOrPlace;
        optionsOrParentOrPlace = void 0;
      }
      let reason = "";
      let options2 = {};
      let legacyCause = false;
      if (optionsOrParentOrPlace) {
        if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
          options2 = { place: optionsOrParentOrPlace };
        } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
          options2 = { place: optionsOrParentOrPlace };
        } else if ("type" in optionsOrParentOrPlace) {
          options2 = {
            ancestors: [optionsOrParentOrPlace],
            place: optionsOrParentOrPlace.position
          };
        } else {
          options2 = { ...optionsOrParentOrPlace };
        }
      }
      if (typeof causeOrReason === "string") {
        reason = causeOrReason;
      } else if (!options2.cause && causeOrReason) {
        legacyCause = true;
        reason = causeOrReason.message;
        options2.cause = causeOrReason;
      }
      if (!options2.ruleId && !options2.source && typeof origin === "string") {
        const index2 = origin.indexOf(":");
        if (index2 === -1) {
          options2.ruleId = origin;
        } else {
          options2.source = origin.slice(0, index2);
          options2.ruleId = origin.slice(index2 + 1);
        }
      }
      if (!options2.place && options2.ancestors && options2.ancestors) {
        const parent = options2.ancestors[options2.ancestors.length - 1];
        if (parent) {
          options2.place = parent.position;
        }
      }
      const start = options2.place && "start" in options2.place ? options2.place.start : options2.place;
      this.ancestors = options2.ancestors || void 0;
      this.cause = options2.cause || void 0;
      this.column = start ? start.column : void 0;
      this.fatal = void 0;
      this.file;
      this.message = reason;
      this.line = start ? start.line : void 0;
      this.name = stringifyPosition(options2.place) || "1:1";
      this.place = options2.place || void 0;
      this.reason = this.message;
      this.ruleId = options2.ruleId || void 0;
      this.source = options2.source || void 0;
      this.stack = legacyCause && options2.cause && typeof options2.cause.stack === "string" ? options2.cause.stack : "";
      this.actual;
      this.expected;
      this.note;
      this.url;
    }
  }
  VFileMessage.prototype.file = "";
  VFileMessage.prototype.name = "";
  VFileMessage.prototype.reason = "";
  VFileMessage.prototype.message = "";
  VFileMessage.prototype.stack = "";
  VFileMessage.prototype.column = void 0;
  VFileMessage.prototype.line = void 0;
  VFileMessage.prototype.ancestors = void 0;
  VFileMessage.prototype.cause = void 0;
  VFileMessage.prototype.fatal = void 0;
  VFileMessage.prototype.place = void 0;
  VFileMessage.prototype.ruleId = void 0;
  VFileMessage.prototype.source = void 0;
  (function() {
    if (typeof globalThis === "object") {
      return;
    }
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
      // This makes it possible to `delete` the getter later.
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  })();
  const clone = typeof globalThis.structuredClone === "function" ? globalThis.structuredClone : (obj) => JSON.parse(JSON.stringify(obj));
  function structuredClone$2(obj) {
    return clone(obj);
  }
  function createMatchers$1() {
    return {
      isHash: (node2) => match.string(node2, "#"),
      isNumber: (node2) => match.string(node2) && 0 < +node2.content.charAt(0),
      splitNumber: (node2) => {
        const number2 = +node2.content.charAt(0);
        if (node2.content.length > 1) {
          return {
            number: number2,
            rest: { type: "string", content: node2.content.slice(1) }
          };
        }
        return { number: number2 };
      }
    };
  }
  function parseMacroSubstitutions(ast2) {
    if (!Array.isArray(ast2)) {
      throw new Error("You must pass an array of nodes");
    }
    ast2 = decorateArrayForPegjs([...ast2]);
    return MacroSubstitutionPegParser.parse(ast2, createMatchers$1());
  }
  const LATEX_NEWCOMMAND = /* @__PURE__ */ new Set([
    "newcommand",
    "renewcommand",
    "providecommand"
  ]);
  const XPARSE_NEWCOMMAND = /* @__PURE__ */ new Set([
    "NewDocumentCommand",
    "RenewDocumentCommand",
    "ProvideDocumentCommand",
    "DeclareDocumentCommand",
    "NewExpandableDocumentCommand",
    "RenewExpandableDocumentCommand",
    "ProvideExpandableDocumentCommand",
    "DeclareExpandableDocumentCommand"
  ]);
  const NEWCOMMAND_ARGUMENTS_REG = [
    "starred",
    "name",
    "numArgs",
    "default",
    "body"
  ];
  const NEWCOMMAND_ARGUMENTS_BEAMER = [
    "starred",
    null,
    "name",
    "numArgs",
    "default",
    "body"
  ];
  function getNewcommandNamedArgs(node2) {
    if (!Array.isArray(node2.args)) {
      throw new Error(
        `Found a '\\newcommand' macro without any arguments "${JSON.stringify(
          node2
        )}"`
      );
    }
    const argNames = node2.args.length === NEWCOMMAND_ARGUMENTS_BEAMER.length ? NEWCOMMAND_ARGUMENTS_BEAMER : NEWCOMMAND_ARGUMENTS_REG;
    return getNamedArgsContent(node2, argNames);
  }
  function newcommandMacroToSpec(node2) {
    var _a3, _b;
    if (LATEX_NEWCOMMAND.has(node2.content)) {
      if (!node2.args) {
        console.warn(
          String.raw`Found a '\newcommand' macro that doesn't have any args`,
          node2
        );
        return "";
      }
      const namedArgs = getNewcommandNamedArgs(node2);
      if (namedArgs.numArgs == null) {
        return "";
      }
      let numArgsForSig = +printRaw(namedArgs.numArgs);
      let sigOptionalArg = [];
      if (namedArgs.default != null) {
        numArgsForSig--;
        sigOptionalArg = [`O{${printRaw(namedArgs.default)}}`];
      }
      return [
        ...sigOptionalArg,
        ...Array.from({ length: numArgsForSig }).map((_) => "m")
      ].join(" ");
    }
    if (XPARSE_NEWCOMMAND.has(node2.content)) {
      if (!((_a3 = node2.args) == null ? void 0 : _a3.length)) {
        console.warn(
          String.raw`Found a '\NewDocumentCommand' macro that doesn't have any args`,
          node2
        );
        return "";
      }
      const macroSpec = printRaw((_b = node2.args[1]) == null ? void 0 : _b.content);
      return macroSpec.trim();
    }
    return "";
  }
  function normalizeCommandName(str) {
    str = str.trim();
    return str.startsWith("\\") ? str.slice(1) : str;
  }
  function newcommandMacroToName(node2) {
    var _a3, _b, _c;
    if (LATEX_NEWCOMMAND.has(node2.content)) {
      if (!((_a3 = node2.args) == null ? void 0 : _a3.length)) {
        return "";
      }
      const namedArgs = getNewcommandNamedArgs(node2);
      const definedName = namedArgs.name;
      if (!definedName) {
        console.warn("Could not find macro name defined in", node2);
        return "";
      }
      return normalizeCommandName(printRaw(definedName));
    }
    if (XPARSE_NEWCOMMAND.has(node2.content)) {
      if (!((_b = node2.args) == null ? void 0 : _b.length)) {
        return "";
      }
      const definedName = (_c = node2.args[0]) == null ? void 0 : _c.content[0];
      if (!definedName) {
        console.warn("Could not find macro name defined in", node2);
        return "";
      }
      return normalizeCommandName(printRaw(node2.args[0].content));
    }
    return "";
  }
  function newcommandMacroToSubstitutionAst(node2) {
    var _a3, _b, _c;
    if (LATEX_NEWCOMMAND.has(node2.content)) {
      if (!((_a3 = node2.args) == null ? void 0 : _a3.length)) {
        return [];
      }
      const namedArgs = getNewcommandNamedArgs(node2);
      const substitution = namedArgs.body;
      if (!substitution) {
        console.warn("Could not find macro name defined in", node2);
        return [];
      }
      return substitution;
    }
    if (XPARSE_NEWCOMMAND.has(node2.content)) {
      if (!((_b = node2.args) == null ? void 0 : _b.length)) {
        return [];
      }
      return ((_c = node2.args[2]) == null ? void 0 : _c.content) || [];
    }
    return [];
  }
  function defaultExpanderArgs() {
    return Array.from({ length: 10 }).map((_, i) => ({
      hashNumbers: [],
      content: [{ type: "string", content: `#${i + 1}` }]
    }));
  }
  function createMacroExpander(substitution) {
    const cachedSubstitutionTree = structuredClone$2(substitution);
    const hashNumbers = parseHashNumbers(cachedSubstitutionTree);
    return (macro2) => {
      if (hashNumbers.length === 0) {
        return structuredClone$2(cachedSubstitutionTree);
      }
      const cachedSubstitutions = defaultExpanderArgs().map(
        (expanderArg, i) => {
          var _a3, _b;
          const number2 = i + 1;
          if (!hashNumbers.includes(number2)) {
            return expanderArg;
          }
          const arg2 = (_a3 = macro2.args) == null ? void 0 : _a3[i];
          const defaultArg = (_b = arg2 == null ? void 0 : arg2._renderInfo) == null ? void 0 : _b.defaultArg;
          if (!arg2 || isEmptyArg(arg2) && defaultArg != null) {
            const content2 = cachedParse(defaultArg);
            const hashNumbers2 = parseHashNumbers(content2);
            return {
              content: content2,
              hashNumbers: hashNumbers2
            };
          }
          return { content: arg2.content, hashNumbers: [] };
        }
      );
      let numTimesExpanded = 0;
      while (expandCachedSubstitutions(cachedSubstitutions) && numTimesExpanded < cachedSubstitutions.length) {
        numTimesExpanded++;
      }
      for (const expanderArg of cachedSubstitutions) {
        if (expanderArg.hashNumbers.length > 0) {
          expanderArg.content = [
            // `xparse` seems to use `-No Value-` here.
            { type: "string", content: `-Circular-` }
          ];
        }
      }
      const retTree = structuredClone$2(cachedSubstitutionTree);
      replaceNode(retTree, (node2) => {
        const hashNumOrNode = node2;
        if (hashNumOrNode.type !== "hash_number") {
          return;
        }
        return cachedSubstitutions[hashNumOrNode.number - 1].content;
      });
      return retTree;
    };
  }
  function isEmptyArg(arg2) {
    return arg2.openMark === "" && arg2.closeMark === "" && arg2.content.length === 0;
  }
  function parseHashNumbers(tree) {
    let hashNumbers = /* @__PURE__ */ new Set();
    visit$3(
      tree,
      (nodes) => {
        const parsed = parseMacroSubstitutions(nodes);
        for (const node2 of parsed) {
          if (node2.type === "hash_number") {
            hashNumbers.add(node2.number);
          }
        }
        nodes.length = 0;
        nodes.push(...parsed);
      },
      {
        includeArrays: true,
        test: Array.isArray
      }
    );
    return Array.from(hashNumbers);
  }
  function hashNumbersReferenced(tree) {
    let hashNumbers = /* @__PURE__ */ new Set();
    visit$3(tree, (node2) => {
      const n = node2;
      if (n.type === "hash_number") {
        hashNumbers.add(n.number);
      }
    });
    return Array.from(hashNumbers);
  }
  const parseCache = /* @__PURE__ */ new Map();
  function cachedParse(source) {
    const cached = parseCache.get(source);
    if (cached) {
      return structuredClone$2(cached);
    }
    const parsed = parseMinimal(source).content;
    parseCache.set(source, structuredClone$2(parsed));
    return parsed;
  }
  function expandCachedSubstitutions(expanderArgs) {
    let didExpand = false;
    for (const expanderArg of expanderArgs) {
      if (expanderArg.hashNumbers.length === 0) {
        continue;
      }
      replaceNode(expanderArg.content, (node2) => {
        const hashNumOrNode = node2;
        if (hashNumOrNode.type !== "hash_number") {
          return;
        }
        didExpand = true;
        return expanderArgs[hashNumOrNode.number - 1].content;
      });
      expanderArg.hashNumbers = hashNumbersReferenced(expanderArg.content);
    }
    return didExpand;
  }
  const newcommandMatcher = match.createMacroMatcher([
    ...LATEX_NEWCOMMAND,
    ...XPARSE_NEWCOMMAND
  ]);
  function listNewcommands(tree) {
    const ret = [];
    visit$3(
      tree,
      (node2) => {
        const name2 = newcommandMacroToName(node2);
        const signature = newcommandMacroToSpec(node2);
        const body2 = newcommandMacroToSubstitutionAst(node2);
        ret.push({ name: name2, signature, body: body2, definition: node2 });
      },
      { test: newcommandMatcher }
    );
    return ret;
  }
  function expandMacrosExcludingDefinitions(tree, macros2) {
    const expanderCache = new Map(
      macros2.map((spec) => [spec.name, createMacroExpander(spec.body)])
    );
    replaceNode(tree, (node2, info) => {
      if (!match.anyMacro(node2)) {
        return;
      }
      const macroName = node2.content;
      const expander = expanderCache.get(macroName);
      if (!expander) {
        return;
      }
      if (info.parents.some((n) => newcommandMatcher(n))) {
        return;
      }
      return expander(node2);
    });
  }
  const noncharacter = /[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g;
  function escape(value2, subset2, unsafe2) {
    const result = clean(value2);
    return unsafe2 ? result.replace(unsafe2, encode) : encode(result);
    function encode(value3) {
      return stringifyEntitiesLight(value3, { subset: subset2 });
    }
  }
  function clean(value2) {
    return String(value2 || "").replace(noncharacter, "");
  }
  const unsafe$3 = /]]>/g;
  const subset$3 = [">"];
  function cdata(node2) {
    return "<![CDATA[" + escape(node2.value, subset$3, unsafe$3) + "]]>";
  }
  function comment$1(node2) {
    return "<!--" + escape(node2.value, ["-"]) + "-->";
  }
  const subset$2 = ["	", "\n", " ", '"', "&", "'", "/", "<", "=", ">"];
  function name(value2) {
    return escape(value2, subset$2);
  }
  function value(value2, state) {
    const result = String(value2);
    let quote = state.options.quote || '"';
    if (state.options.quoteSmart) {
      const other = quote === '"' ? "'" : '"';
      if (ccount(result, quote) > ccount(result, other)) {
        quote = other;
      }
    }
    return quote + escape(result, ["<", "&", quote]) + quote;
  }
  function doctype(node2, state) {
    const nodeName = name(node2.name);
    const pub = node2.public;
    const sys = node2.system;
    let result = "<!DOCTYPE";
    if (nodeName !== "") {
      result += " " + nodeName;
    }
    if (pub) {
      result += " PUBLIC " + value(pub, state);
    } else if (sys) {
      result += " SYSTEM";
    }
    if (sys) {
      result += " " + value(sys, state);
    }
    return result + ">";
  }
  const own$5 = {}.hasOwnProperty;
  function element$1(node2, state) {
    const nodeName = name(node2.name);
    const content2 = all$6(node2, state);
    const attributes2 = node2.attributes || {};
    const close = content2 ? false : state.options.closeEmptyElements;
    const attrs = [];
    let key2;
    for (key2 in attributes2) {
      if (own$5.call(attributes2, key2)) {
        const result = attributes2[key2];
        if (result !== null && result !== void 0) {
          attrs.push(name(key2) + "=" + value(result, state));
        }
      }
    }
    return "<" + nodeName + (attrs.length === 0 ? "" : " " + attrs.join(" ")) + (close ? (state.options.tightClose ? "" : " ") + "/" : "") + ">" + content2 + (close ? "" : "</" + nodeName + ">");
  }
  const unsafe$2 = /\?>/g;
  const subset$1 = [">"];
  function instruction(node2) {
    const nodeName = name(node2.name) || "x";
    const result = escape(node2.value, subset$1, unsafe$2);
    return "<?" + nodeName + (result ? " " + result : "") + "?>";
  }
  const subset = ["&", "<"];
  function text$3(node2) {
    return escape(node2.value, subset);
  }
  function raw(node2, state) {
    return state.options.allowDangerousXml ? node2.value : text$3(node2);
  }
  const own$4 = {}.hasOwnProperty;
  const handlers$1 = {
    cdata,
    comment: comment$1,
    doctype,
    element: element$1,
    instruction,
    raw,
    root: all$6,
    text: text$3
  };
  function one$4(node2, state) {
    const type = node2 && node2.type;
    if (!type) {
      throw new Error("Expected node, not `" + node2 + "`");
    }
    if (!own$4.call(handlers$1, type)) {
      throw new Error("Cannot compile unknown node `" + type + "`");
    }
    const handle2 = handlers$1[type];
    const result = handle2(node2, state);
    return result;
  }
  function all$6(parent, state) {
    const children = parent && parent.children || [];
    let index2 = -1;
    const results = [];
    while (++index2 < children.length) {
      results[index2] = one$4(children[index2], state);
    }
    return results.join("");
  }
  function toXml(tree, options2) {
    const state = { options: options2 || {} };
    if (typeof state.options.quote === "string" && state.options.quote !== '"' && state.options.quote !== "'") {
      throw new Error(
        "Invalid quote `" + state.options.quote + "`, expected `'` or `\"`"
      );
    }
    const node2 = Array.isArray(tree) ? { type: "root", children: tree } : tree;
    return one$4(node2, state);
  }
  function makeWarningMessage(node2, message, warningType) {
    const newMessage = new VFileMessage(message, node2);
    newMessage.source = `unified-latex-to-pretext:${warningType}`;
    return newMessage;
  }
  function emptyStringWithWarningFactory(warningMessage) {
    return (node2, info, file) => {
      if (file) {
        const message = makeWarningMessage(
          node2,
          warningMessage,
          "macro-subs"
        );
        file.message(
          message,
          message.place,
          `unified-latex-to-pretext:macro-subs`
        );
      }
      return s$1("");
    };
  }
  const divisions = [
    { division: "part", mappedEnviron: "_part" },
    { division: "chapter", mappedEnviron: "_chapter" },
    { division: "section", mappedEnviron: "_section" },
    { division: "subsection", mappedEnviron: "_subsection" },
    { division: "subsubsection", mappedEnviron: "_subsubsection" },
    { division: "paragraph", mappedEnviron: "_paragraph" },
    { division: "subparagraph", mappedEnviron: "_subparagraph" }
  ];
  const isDivisionMacro = match.createMacroMatcher(
    divisions.map((x2) => x2.division)
  );
  const isMappedEnviron = match.createEnvironmentMatcher(
    divisions.map((x2) => x2.mappedEnviron)
  );
  function breakOnBoundaries(ast2) {
    const messagesLst = { messages: [] };
    replaceNode(ast2, (node2) => {
      if (match.group(node2)) {
        if (node2.content.some((child) => {
          return anyMacro(child) && isDivisionMacro(child);
        })) {
          messagesLst.messages.push(
            makeWarningMessage(
              node2,
              "Warning: hoisted out of a group, which might break the LaTeX code.",
              "break-on-boundaries"
            )
          );
          return node2.content;
        }
      }
    });
    visit$3(ast2, (node2, info) => {
      if (!(anyEnvironment(node2) || node2.type === "root" || match.group(node2)) || // skip math mode
      info.context.hasMathModeAncestor) {
        return;
      } else if (anyEnvironment(node2) && isMappedEnviron(node2)) {
        return;
      }
      node2.content = breakUp(node2.content, 0);
    });
    replaceNode(ast2, (node2) => {
      if (anyMacro(node2) && isDivisionMacro(node2)) {
        return null;
      }
    });
    return messagesLst;
  }
  function breakUp(content2, depth) {
    if (depth > 6) {
      return content2;
    }
    const splits = splitOnMacro(content2, divisions[depth].division);
    for (let i = 0; i < splits.segments.length; i++) {
      splits.segments[i] = breakUp(splits.segments[i], depth + 1);
    }
    createEnvironments(splits, divisions[depth].mappedEnviron);
    return unsplitOnMacro(splits);
  }
  function createEnvironments(splits, newEnviron) {
    for (let i = 1; i < splits.segments.length; i++) {
      const title = getNamedArgsContent(splits.macros[i - 1])["title"];
      const titleArg = [];
      if (title) {
        titleArg.push(arg(title, { braces: "[]" }));
      }
      splits.segments[i] = [env$1(newEnviron, splits.segments[i], titleArg)];
    }
  }
  function formatNodeForError(node2) {
    try {
      return printRaw(node2);
    } catch {
    }
    return JSON.stringify(node2);
  }
  function toPretextWithLoggerFactory(logger) {
    return function toPretext2(node2) {
      var _a3;
      const htmlNode = node2;
      if (isHtmlLikeTag(htmlNode)) {
        const extracted = extractFromHtmlLike(htmlNode);
        const attributes2 = extracted.attributes;
        return x(
          extracted.tag,
          attributes2,
          extracted.content.flatMap(toPretext2)
        );
      }
      switch (node2.type) {
        case "string":
          return {
            type: "text",
            value: node2.content,
            position: node2.position
          };
        case "comment":
          return {
            type: "comment",
            value: node2.content,
            position: node2.position
          };
        case "inlinemath":
          return x("m", printRaw(node2.content));
        case "mathenv":
        case "displaymath":
          return x("me", printRaw(node2.content));
        case "verb":
        case "verbatim":
          return x("pre", node2.content);
        case "whitespace":
          return { type: "text", value: " ", position: node2.position };
        case "parbreak":
          logger(
            `There is no equivalent for parbreak, so it was replaced with an empty string.`,
            node2
          );
          return {
            type: "text",
            value: "",
            position: node2.position
          };
        case "group":
          return node2.content.flatMap(toPretext2);
        case "environment":
          if (isMappedEnviron(node2)) {
            let divisionName = (_a3 = divisions.find(
              (x2) => x2.mappedEnviron === node2.env
            )) == null ? void 0 : _a3.division;
            if (divisionName === "subparagraph") {
              logger(
                `Warning: There is no equivalent tag for "subparagraph", "paragraphs" was used as a replacement.`,
                node2
              );
            }
            if (divisionName === "paragraph" || divisionName === "subparagraph") {
              divisionName = "paragraphs";
            }
            const title = getArgsContent(node2)[0];
            if (!title) {
              logger(
                `Warning: No title was given, so an empty title tag was used.`,
                node2
              );
            }
            const titleTag = x("title", title == null ? void 0 : title.flatMap(toPretext2));
            if (divisionName) {
              return x(divisionName, [
                titleTag,
                ...node2.content.flatMap(toPretext2)
              ]);
            }
          }
          logger(
            `Unknown environment when converting to XML \`${formatNodeForError(
              node2.env
            )}\``,
            node2
          );
          return node2.content.flatMap(toPretext2);
        case "macro":
          logger(
            `Unknown macro when converting to XML \`${formatNodeForError(
              node2
            )}\``,
            node2
          );
          return (node2.args || []).map(toPretext2).flat();
        case "argument":
          logger(
            `Unknown argument when converting to XML \`${formatNodeForError(
              node2
            )}\``,
            node2
          );
          return {
            type: "text",
            value: printRaw(node2.content),
            position: node2.position
          };
        case "root":
          return node2.content.flatMap(toPretext2);
        default: {
          throw new Error(
            `Unknown node type; cannot convert to XAST ${JSON.stringify(
              node2
            )}`
          );
        }
      }
    };
  }
  function splitForPars(nodes, options2) {
    const ret = [];
    let currBody = [];
    trim(nodes);
    const isParBreakingMacro = match.createMacroMatcher(
      options2.macrosThatBreakPars
    );
    const isEnvThatShouldNotBreakPar = match.createEnvironmentMatcher(
      options2.environmentsThatDontBreakPars
    );
    function pushBody() {
      if (currBody.length > 0) {
        trim(currBody);
        ret.push({ content: currBody, wrapInPar: true });
        currBody = [];
      }
    }
    for (const node2 of nodes) {
      if (isParBreakingMacro(node2)) {
        pushBody();
        ret.push({ content: [node2], wrapInPar: false });
        continue;
      }
      if (match.anyEnvironment(node2) && !isEnvThatShouldNotBreakPar(node2)) {
        pushBody();
        ret.push({ content: [node2], wrapInPar: false });
        continue;
      }
      if (match.parbreak(node2) || match.macro(node2, "par")) {
        pushBody();
        continue;
      }
      currBody.push(node2);
    }
    pushBody();
    return ret;
  }
  function wrapPars(nodes, options2) {
    const {
      macrosThatBreakPars = [
        "part",
        "chapter",
        "section",
        "subsection",
        "subsubsection",
        "paragraph",
        "subparagraph",
        "vspace",
        "smallskip",
        "medskip",
        "bigskip",
        "hfill"
      ],
      environmentsThatDontBreakPars = []
    } = options2 || {};
    const parSplits = splitForPars(nodes, {
      macrosThatBreakPars,
      environmentsThatDontBreakPars
    });
    return parSplits.flatMap((part) => {
      if (part.wrapInPar) {
        return htmlLike({ tag: "p", content: part.content });
      } else {
        return part.content;
      }
    });
  }
  function createTableFromTabular(env2) {
    const tabularBody = parseAlignEnvironment(env2.content);
    const args = getArgsContent(env2);
    let columnSpecs = [];
    try {
      columnSpecs = parseTabularSpec(args[1] || []);
    } catch (e) {
    }
    const attributes2 = {};
    let notLeftAligned = false;
    const columnRightBorder = {};
    const tableBody = tabularBody.map((row2) => {
      const content2 = row2.cells.map((cell2, i) => {
        const columnSpec = columnSpecs[i];
        if (columnSpec) {
          const { alignment } = columnSpec;
          if (columnSpec.pre_dividers.some(
            (div) => div.type === "vert_divider"
          )) {
            attributes2["left"] = "minor";
          }
          if (columnSpec.post_dividers.some(
            (div) => div.type === "vert_divider"
          )) {
            columnRightBorder[i] = true;
          }
          if (alignment.alignment !== "left") {
            notLeftAligned = true;
          }
        }
        trim(cell2);
        return htmlLike({
          tag: "cell",
          content: cell2
        });
      });
      return htmlLike({ tag: "row", content: content2 });
    });
    if (notLeftAligned || Object.values(columnRightBorder).some((b) => b)) {
      for (let i = columnSpecs.length; i >= 0; i--) {
        const columnSpec = columnSpecs[i];
        if (!columnSpec) {
          continue;
        }
        const colAttributes = {};
        const { alignment } = columnSpec;
        if (alignment.alignment !== "left") {
          colAttributes["halign"] = alignment.alignment;
        }
        if (columnRightBorder[i] === true) {
          colAttributes["right"] = "minor";
        }
        tableBody.unshift(
          htmlLike({ tag: "col", attributes: colAttributes })
        );
      }
    }
    return htmlLike({
      tag: "tabular",
      content: tableBody,
      attributes: attributes2
    });
  }
  const ITEM_ARG_NAMES_REG = ["label"];
  const ITEM_ARG_NAMES_BEAMER = [null, "label", null];
  function getItemArgs(node2) {
    if (!Array.isArray(node2.args)) {
      throw new Error(
        `Cannot find \\item macros arguments; you must attach the \\item body to the macro before calling this function ${JSON.stringify(
          node2
        )}`
      );
    }
    const argNames = node2.args.length - 1 === ITEM_ARG_NAMES_BEAMER.length ? ITEM_ARG_NAMES_BEAMER : ITEM_ARG_NAMES_REG;
    const ret = Object.assign(
      { body: node2.args[node2.args.length - 1].content },
      getNamedArgsContent(node2, argNames)
    );
    return ret;
  }
  function enumerateFactory(parentTag = "ol") {
    return function enumerateToHtml(env2) {
      const items = env2.content.filter((node2) => match.macro(node2, "item"));
      let isDescriptionList = false;
      const content2 = items.flatMap((node2) => {
        if (!match.macro(node2) || !node2.args) {
          return [];
        }
        const namedArgs = getItemArgs(node2);
        namedArgs.body = wrapPars(namedArgs.body);
        if (namedArgs.label != null) {
          isDescriptionList = true;
          namedArgs.body.unshift(
            htmlLike({
              tag: "title",
              content: namedArgs.label
            })
          );
        }
        const body2 = namedArgs.body;
        return htmlLike({
          tag: "li",
          content: body2
        });
      });
      return htmlLike({
        tag: isDescriptionList ? "dl" : parentTag,
        content: content2
      });
    };
  }
  function envFactory(tag, requiresStatementTag = false, warningMessage = "", attributes2) {
    return (env2, info, file) => {
      if (warningMessage && file) {
        const message = makeWarningMessage(env2, warningMessage, "env-subs");
        file.message(message, message.place, message.source);
      }
      let content2 = wrapPars(env2.content);
      if (requiresStatementTag) {
        content2 = [
          htmlLike({
            tag: "statement",
            content: content2
          })
        ];
      }
      const args = getArgsContent(env2);
      if (args[0]) {
        content2.unshift(
          htmlLike({
            tag: "title",
            content: args[0] || []
          })
        );
      }
      return htmlLike({
        tag,
        content: content2
      });
    };
  }
  function removeEnv(env2, info, file) {
    file == null ? void 0 : file.message(
      makeWarningMessage(
        env2,
        `Warning: There is no equivalent tag for "${env2.env}", so the ${env2.env} environment was removed.`,
        "environment-subs"
      )
    );
    return env2.content;
  }
  const environmentReplacements = {
    // TODO: add additional envs like theorem, etc.
    enumerate: enumerateFactory("ol"),
    itemize: enumerateFactory("ul"),
    center: removeEnv,
    tabular: createTableFromTabular,
    quote: (env2) => {
      return htmlLike({
        tag: "blockquote",
        content: env2.content
      });
    },
    ...genEnvironmentReplacements()
  };
  function genEnvironmentReplacements() {
    const envAliases = {
      abstract: { requiresStatment: false, aliases: ["abs", "abstr"] },
      acknowledgement: { requiresStatment: false, aliases: ["ack"] },
      algorithm: { requiresStatment: true, aliases: ["algo", "alg"] },
      assumption: { requiresStatment: true, aliases: ["assu", "ass"] },
      axiom: { requiresStatment: true, aliases: ["axm"] },
      claim: { requiresStatment: true, aliases: ["cla"] },
      conjecture: {
        requiresStatment: true,
        aliases: ["con", "conj", "conjec"]
      },
      construction: { requiresStatment: false, aliases: [] },
      convention: { requiresStatment: false, aliases: ["conv"] },
      corollary: {
        requiresStatment: true,
        aliases: ["cor", "corr", "coro", "corol", "corss"]
      },
      definition: {
        requiresStatment: true,
        aliases: ["def", "defn", "dfn", "defi", "defin", "de"]
      },
      example: {
        requiresStatment: true,
        aliases: ["exam", "exa", "eg", "exmp", "expl", "exm"]
      },
      exercise: { requiresStatment: true, aliases: ["exer", "exers"] },
      exploration: { requiresStatment: false, aliases: [] },
      fact: { requiresStatment: true, aliases: [] },
      heuristic: { requiresStatment: true, aliases: [] },
      hypothesis: { requiresStatment: true, aliases: ["hyp"] },
      identity: { requiresStatment: true, aliases: ["idnty"] },
      insight: { requiresStatment: false, aliases: [] },
      investigation: { requiresStatment: false, aliases: [] },
      lemma: {
        requiresStatment: true,
        aliases: ["lem", "lma", "lemm", "lm"]
      },
      notation: {
        requiresStatment: false,
        aliases: ["no", "nota", "ntn", "nt", "notn", "notat"]
      },
      note: { requiresStatment: false, aliases: ["notes"] },
      observation: { requiresStatment: false, aliases: ["obs"] },
      principle: { requiresStatment: true, aliases: [] },
      problem: { requiresStatment: true, aliases: ["prob", "prb"] },
      project: { requiresStatment: false, aliases: [] },
      proof: { requiresStatment: false, aliases: ["pf", "prf", "demo"] },
      proposition: {
        requiresStatment: true,
        aliases: ["prop", "pro", "prp", "props"]
      },
      question: {
        requiresStatment: true,
        aliases: ["qu", "ques", "quest", "qsn"]
      },
      remark: {
        requiresStatment: false,
        aliases: ["rem", "rmk", "rema", "bem", "subrem"]
      },
      task: { requiresStatment: true, aliases: [] },
      theorem: {
        requiresStatment: true,
        aliases: ["thm", "theo", "theor", "thmss", "thrm"]
      },
      warning: { requiresStatment: false, aliases: ["warn", "wrn"] }
    };
    const exapandedEnvAliases = Object.entries(envAliases).flatMap(
      ([env2, spec]) => [
        [env2, envFactory(env2, spec.requiresStatment)],
        ...spec.aliases.map((name2) => [
          name2,
          envFactory(env2, spec.requiresStatment)
        ])
      ]
    );
    return Object.fromEntries(exapandedEnvAliases);
  }
  const KATEX_MACROS = /* @__PURE__ */ JSON.parse('[" ","!","\\"","#","&","\'","*",",",".",":",";","=",">","AA","AE","Alpha","And","Arrowvert","Bbb","Bbbk","Beta","Big","Bigg","Biggl","Biggm","Biggr","Bigl","Bigm","Bigr","Box","Bra","Bumpeq","C","Cap","Chi","Colonapprox","Coloneq","Coloneqq","Colonsim","Complex","Coppa","Cup","Dagger","Darr","DeclareMathOperator","Delta","Diamond","Digamma","Doteq","Downarrow","Epsilon","Eqcolon","Eqqcolon","Eta","Finv","Game","Gamma","H","Harr","Huge","Im","Iota","Join","KaTeX","Kappa","Ket","Koppa","L","LARGE","LaTeX","Lambda","Large","Larr","LeftArrow","Leftarrow","Leftrightarrow","Lleftarrow","Longleftarrow","Longleftrightarrow","Longrightarrow","Lrarr","Lsh","Mu","N","Newextarrow","Nu","O","OE","Omega","Omicron","Overrightarrow","P","Phi","Pi","Pr","Psi","Q","R","Rarr","Re","Reals","Rho","Rightarrow","Rrightarrow","Rsh","Rule","S","Sampi","Sigma","Space","Stigma","Subset","Supset","Tau","TeX","Theta","Tiny","Uarr","Uparrow","Updownarrow","Upsilon","Vdash","Vert","Vvdash","Xi","Z","Zeta","\\\\","^","_","`","aa","above","abovewithdelims","acute","add","ae","alef","alefsym","aleph","allowbreak","alpha","amalg","and","ang","angl","angle","angln","approx","approxcolon","approxcoloncolon","approxeq","arccos","arcctg","arcsin","arctan","arctg","arg","argmax","argmin","array","arraystretch","arrowvert","ast","asymp","atop","atopwithdelims","backepsilon","backprime","backsim","backsimeq","backslash","bar","barwedge","bbox","bcancel","because","begin","begingroup","beta","beth","between","bf","bfseries","big","bigcap","bigcirc","bigcup","bigg","biggl","biggm","biggr","bigl","bigm","bigodot","bigominus","bigoplus","bigoslash","bigotimes","bigr","bigsqcap","bigsqcup","bigstar","bigtriangledown","bigtriangleup","biguplus","bigvee","bigwedge","binom","blacklozenge","blacksquare","blacktriangle","blacktriangledown","blacktriangleleft","blacktriangleright","bm","bmod","bold","boldsymbol","bot","bowtie","boxdot","boxed","boxminus","boxplus","boxtimes","bra","brace","bracevert","brack","braket","breve","buildrel","bull","bullet","bumpeq","cal","cancel","cancelto","cap","cases","cdot","cdotp","cdots","ce","cee","centerdot","cf","cfrac","ch","char","check","checkmark","chi","chk","choose","circ","circeq","circlearrowleft","circlearrowright","circledR","circledS","circledast","circledcirc","circleddash","class","cline","clubs","clubsuit","cnums","colon","colonapprox","coloncolon","coloncolonapprox","coloncolonequals","coloncolonminus","coloncolonsim","coloneq","coloneqq","colonequals","colonminus","colonsim","color","colorbox","complement","cong","coppa","coprod","copyright","cos","cosec","cosh","cot","cotg","coth","cr","csc","cssId","ctg","cth","cup","curlyeqprec","curlyeqsucc","curlyvee","curlywedge","curvearrowleft","curvearrowright","dArr","dag","dagger","daleth","darr","dashleftarrow","dashrightarrow","dashv","dbinom","dblcolon","ddag","ddagger","ddddot","dddot","ddot","ddots","def","definecolor","deg","degree","delta","det","dfrac","diagdown","diagup","diamond","diamonds","diamondsuit","digamma","dim","displaylines","displaystyle","div","divideontimes","dot","doteq","doteqdot","dotplus","dots","dotsb","dotsc","dotsi","dotsm","dotso","doublebarwedge","doublecap","doublecup","downarrow","downdownarrows","downharpoonleft","downharpoonright","edef","ell","else","em","emph","empty","emptyset","enclose","end","endgroup","enspace","epsilon","eqalign","eqalignno","eqcirc","eqcolon","eqqcolon","eqref","eqsim","eqslantgtr","eqslantless","equalscolon","equalscoloncolon","equiv","eta","eth","euro","exist","exists","exp","expandafter","fallingdotseq","fbox","fcolorbox","fi","flat","foo","footnotesize","forall","frac","frak","frown","futurelet","gamma","gcd","gdef","ge","geneuro","geneuronarrow","geneurowide","genfrac","geq","geqq","geqslant","gets","gg","ggg","gggtr","gimel","global","gnapprox","gneq","gneqq","gnsim","grave","greet","gt","gtrapprox","gtrdot","gtreqless","gtreqqless","gtrless","gtrsim","gvertneqq","hArr","hail","harr","hat","hbar","hbox","hdashline","hearts","heartsuit","hfil","hfill","hline","hom","hookleftarrow","hookrightarrow","hphantom","href","hskip","hslash","hspace","htmlClass","htmlData","htmlId","htmlStyle","huge","i","iddots","idotsint","if","iff","ifmode","ifx","iiiint","iiint","iint","image","imageof","imath","impliedby","implies","in","includegraphics","inf","infin","infty","injlim","int","intercal","intop","iota","isin","it","itshape","j","jmath","kappa","ker","kern","ket","koppa","l","lArr","lBrace","lVert","label","lambda","land","lang","langle","large","larr","lbrace","lbrack","lceil","ldotp","ldots","le","leadsto","left","leftarrow","leftarrowtail","leftharpoondown","leftharpoonup","leftleftarrows","leftrightarrow","leftrightarrows","leftrightharpoons","leftrightsquigarrow","leftroot","leftthreetimes","leq","leqalignno","leqq","leqslant","lessapprox","lessdot","lesseqgtr","lesseqqgtr","lessgtr","lesssim","let","lfloor","lg","lgroup","lhd","lim","liminf","limits","limsup","ll","llap","llbracket","llcorner","lll","llless","lmoustache","ln","lnapprox","lneq","lneqq","lnot","lnsim","log","long","longleftarrow","longleftrightarrow","longmapsto","longrightarrow","looparrowleft","looparrowright","lor","lower","lozenge","lparen","lq","lrArr","lrarr","lrcorner","lt","ltimes","lvert","lvertneqq","maltese","mapsto","mathbb","mathbf","mathbin","mathcal","mathchoice","mathclap","mathclose","mathellipsis","mathfrak","mathinner","mathit","mathllap","mathnormal","mathop","mathopen","mathord","mathpunct","mathrel","mathring","mathrlap","mathrm","mathscr","mathsf","mathsterling","mathstrut","mathtip","mathtt","matrix","max","mbox","md","mdseries","measuredangle","medspace","mho","mid","middle","min","minuscolon","minuscoloncolon","minuso","mit","mkern","mmlToken","mod","models","moveleft","moveright","mp","mskip","mspace","mu","multicolumn","multimap","nLeftarrow","nLeftrightarrow","nRightarrow","nVDash","nVdash","nabla","natnums","natural","ncong","ne","nearrow","neg","negmedspace","negthickspace","negthinspace","neq","newcommand","newenvironment","newline","nexists","ngeq","ngeqq","ngeqslant","ngtr","ni","nleftarrow","nleftrightarrow","nleq","nleqq","nleqslant","nless","nmid","nobreak","nobreakspace","noexpand","nolimits","nonumber","normalfont","normalsize","not","notag","notin","notni","nparallel","nprec","npreceq","nrightarrow","nshortmid","nshortparallel","nsim","nsubseteq","nsubseteqq","nsucc","nsucceq","nsupseteq","nsupseteqq","ntriangleleft","ntrianglelefteq","ntriangleright","ntrianglerighteq","nu","nvDash","nvdash","nwarrow","o","odot","oe","officialeuro","oiiint","oiint","oint","oldstyle","omega","omicron","ominus","operatorname","operatornamewithlimits","oplus","or","origof","oslash","otimes","over","overbrace","overbracket","overgroup","overleftarrow","overleftharpoon","overleftrightarrow","overline","overlinesegment","overparen","overrightarrow","overrightharpoon","overset","overwithdelims","owns","pagecolor","parallel","part","partial","perp","phantom","phase","phi","pi","pitchfork","plim","plusmn","pm","pmatrix","pmb","pmod","pod","pounds","prec","precapprox","preccurlyeq","preceq","precnapprox","precneqq","precnsim","precsim","prime","prod","projlim","propto","providecommand","psi","pu","qquad","quad","r","rArr","rBrace","rVert","raise","raisebox","rang","rangle","rarr","ratio","rbrace","rbrack","rceil","real","reals","ref","relax","renewcommand","renewenvironment","require","restriction","rfloor","rgroup","rhd","rho","right","rightarrow","rightarrowtail","rightharpoondown","rightharpoonup","rightleftarrows","rightleftharpoons","rightrightarrows","rightsquigarrow","rightthreetimes","risingdotseq","rlap","rm","rmoustache","root","rotatebox","rparen","rq","rrbracket","rtimes","rule","rvert","sampi","sc","scalebox","scr","scriptscriptstyle","scriptsize","scriptstyle","sdot","searrow","sec","sect","setlength","setminus","sf","sh","sharp","shortmid","shortparallel","shoveleft","shoveright","sideset","sigma","sim","simcolon","simcoloncolon","simeq","sin","sinh","sixptsize","skew","skip","sl","small","smallfrown","smallint","smallsetminus","smallsmile","smash","smile","smiley","sout","space","spades","spadesuit","sphericalangle","sqcap","sqcup","sqrt","sqsubset","sqsubseteq","sqsupset","sqsupseteq","square","ss","stackrel","star","stigma","strut","style","sub","sube","subset","subseteq","subseteqq","subsetneq","subsetneqq","substack","succ","succapprox","succcurlyeq","succeq","succnapprox","succneqq","succnsim","succsim","sum","sup","supe","supset","supseteq","supseteqq","supsetneq","supsetneqq","surd","swarrow","tag","tan","tanh","tau","tbinom","text","textasciicircum","textasciitilde","textbackslash","textbar","textbardbl","textbf","textbraceleft","textbraceright","textcircled","textcolor","textdagger","textdaggerdbl","textdegree","textdollar","textellipsis","textemdash","textendash","textgreater","textit","textless","textmd","textnormal","textquotedblleft","textquotedblright","textquoteleft","textquoteright","textregistered","textrm","textsc","textsf","textsl","textsterling","textstyle","texttip","texttt","textunderscore","textup","textvisiblespace","tfrac","tg","th","therefore","theta","thetasym","thickapprox","thicksim","thickspace","thinspace","tilde","times","tiny","to","toggle","top","triangle","triangledown","triangleleft","trianglelefteq","triangleq","triangleright","trianglerighteq","tt","twoheadleftarrow","twoheadrightarrow","u","uArr","uarr","ulcorner","underbar","underbrace","underbracket","undergroup","underleftarrow","underleftrightarrow","underline","underlinesegment","underparen","underrightarrow","underset","unicode","unlhd","unrhd","up","uparrow","updownarrow","upharpoonleft","upharpoonright","uplus","uproot","upshape","upsilon","upuparrows","urcorner","url","utilde","v","vDash","varDelta","varGamma","varLambda","varOmega","varPhi","varPi","varPsi","varSigma","varTheta","varUpsilon","varXi","varcoppa","varepsilon","varinjlim","varkappa","varliminf","varlimsup","varnothing","varphi","varpi","varprojlim","varpropto","varrho","varsigma","varstigma","varsubsetneq","varsubsetneqq","varsupsetneq","varsupsetneqq","vartheta","vartriangle","vartriangleleft","vartriangleright","vcentcolon","vcenter","vdash","vdots","vec","vee","veebar","vert","vfil","vfill","vline","vphantom","wedge","weierp","widecheck","widehat","wideparen","widetilde","wp","wr","xLeftarrow","xLeftrightarrow","xRightarrow","xcancel","xdef","xhookleftarrow","xhookrightarrow","xi","xleftarrow","xleftharpoondown","xleftharpoonup","xleftrightarrow","xleftrightharpoons","xlongequal","xmapsto","xrightarrow","xrightharpoondown","xrightharpoonup","xrightleftharpoons","xtofrom","xtwoheadleftarrow","xtwoheadrightarrow","yen","zeta","{","|","}","~"]');
  const KATEX_ENVIRONMENTS = ["align", "align*", "alignat", "alignat*", "aligned", "alignedat", "array", "Bmatrix", "bmatrix", "Bmatrix*", "bmatrix*", "cases", "CD", "darray", "dcases", "drcases", "equation", "equation*", "gather", "gathered", "matrix", "matrix*", "pmatrix", "pmatrix*", "rcases", "smallmatrix", "split", "Vmatrix", "vmatrix", "Vmatrix*", "vmatrix*"];
  const KATEX_SUPPORT_LIST = {
    KATEX_MACROS,
    KATEX_ENVIRONMENTS
  };
  const LEFT = { type: "macro", content: "left" };
  const RIGHT = { type: "macro", content: "right" };
  const DEFAULT_LEFT_DELIM = { type: "macro", content: "{" };
  const DEFAULT_RIGHT_DELIM = { type: "string", content: "." };
  const katexSpecificMacroReplacements = {
    systeme: (node2) => {
      var _a3, _b;
      try {
        const args = getArgsContent(node2);
        const whitelistedVariables = args[1] || void 0;
        const equations = args[3] || [];
        const ret = systemeContentsToArray(equations, {
          properSpacing: false,
          whitelistedVariables
        });
        if ((_a3 = node2 == null ? void 0 : node2._renderInfo) == null ? void 0 : _a3.sysdelims) {
          const [frontDelim, backDelim] = (_b = node2._renderInfo) == null ? void 0 : _b.sysdelims;
          return [
            LEFT,
            ...frontDelim || [],
            ret,
            RIGHT,
            ...backDelim || []
          ];
        }
        return [LEFT, DEFAULT_LEFT_DELIM, ret, RIGHT, DEFAULT_RIGHT_DELIM];
      } catch (e) {
        return node2;
      }
    },
    sysdelim: () => []
  };
  function wrapInDisplayMath(ast2) {
    const content2 = Array.isArray(ast2) ? ast2 : [ast2];
    return { type: "displaymath", content: content2 };
  }
  const katexSpecificEnvironmentReplacements = {
    // katex supports the align environments, but it will only render them
    // if you are already in math mode. Warning: these will produce invalid latex!
    align: wrapInDisplayMath,
    "align*": wrapInDisplayMath,
    alignat: wrapInDisplayMath,
    "alignat*": wrapInDisplayMath,
    equation: wrapInDisplayMath,
    "equation*": wrapInDisplayMath
  };
  function attachNeededRenderInfo(ast2) {
    attachSystemeSettingsAsRenderInfo(ast2);
  }
  const KATEX_SUPPORT = {
    macros: KATEX_SUPPORT_LIST["KATEX_MACROS"],
    environments: KATEX_SUPPORT_LIST["KATEX_ENVIRONMENTS"]
  };
  function factory$1(tag, warningMessage = "", attributes2) {
    return (macro2, info, file) => {
      if (!macro2.args) {
        throw new Error(
          `Found macro to replace but couldn't find content ${printRaw(
            macro2
          )}`
        );
      }
      if (warningMessage && file) {
        const message = makeWarningMessage(
          macro2,
          `Warning: There is no equivalent tag for "${macro2.content}", "${tag}" was used as a replacement.`,
          "macro-subs"
        );
        file.message(message, message.place, message.source);
      }
      const args = getArgsContent(macro2);
      const content2 = args[args.length - 1] || [];
      return htmlLike({ tag, content: content2, attributes: attributes2 });
    };
  }
  function createHeading(tag, attrs = {}) {
    return (macro2) => {
      const args = getArgsContent(macro2);
      const attributes2 = {};
      if (attrs) {
        Object.assign(attributes2, attrs);
      }
      return htmlLike({
        tag,
        content: args[args.length - 1] || [],
        attributes: attributes2
      });
    };
  }
  const macroReplacements = {
    emph: factory$1("em"),
    textrm: factory$1(
      "em",
      `Warning: There is no equivalent tag for "textrm", "em" was used as a replacement.`
    ),
    textsf: factory$1(
      "em",
      `Warning: There is no equivalent tag for "textsf", "em" was used as a replacement.`
    ),
    texttt: factory$1(
      "em",
      `Warning: There is no equivalent tag for "textsf", "em" was used as a replacement.`
    ),
    textsl: factory$1(
      "em",
      `Warning: There is no equivalent tag for "textsl", "em" was used as a replacement.`
    ),
    textit: factory$1("em"),
    textbf: factory$1("alert"),
    underline: factory$1(
      "em",
      `Warning: There is no equivalent tag for "underline", "em" was used as a replacement.`
    ),
    mbox: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "mbox", an empty Ast.String was used as a replacement.`
    ),
    phantom: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "phantom", an empty Ast.String was used as a replacement.`
    ),
    appendix: createHeading("appendix"),
    url: (node2) => {
      const args = getArgsContent(node2);
      const url = printRaw(args[0] || "#");
      return htmlLike({
        tag: "url",
        attributes: {
          href: url
        },
        content: [{ type: "string", content: url }]
      });
    },
    href: (node2) => {
      const args = getArgsContent(node2);
      const url = printRaw(args[1] || "#");
      return htmlLike({
        tag: "url",
        attributes: {
          href: url
        },
        content: args[2] || []
      });
    },
    hyperref: (node2) => {
      const args = getArgsContent(node2);
      const url = "#" + printRaw(args[0] || "");
      return htmlLike({
        tag: "url",
        attributes: {
          href: url
        },
        content: args[1] || []
      });
    },
    ref: (node2) => {
      const args = getArgsContent(node2);
      const ref = printRaw(args[1] || "");
      return htmlLike({
        tag: "xref",
        attributes: {
          ref: ref || "",
          text: "global"
        }
      });
    },
    cref: (node2) => {
      const args = getArgsContent(node2);
      const ref = printRaw(args[1] || "");
      return htmlLike({
        tag: "xref",
        attributes: {
          ref: ref || ""
        }
      });
    },
    Cref: (node2) => {
      const args = getArgsContent(node2);
      const ref = printRaw(args[1] || "");
      return htmlLike({
        tag: "xref",
        attributes: {
          ref: ref || ""
        }
      });
    },
    cite: (node2) => {
      const args = getArgsContent(node2);
      const ref = printRaw(args[1] || "");
      return htmlLike({
        tag: "xref",
        attributes: {
          ref: ref || ""
        }
      });
    },
    "\\": emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "\\", an empty Ast.String was used as a replacement.`
    ),
    vspace: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "vspace", an empty Ast.String was used as a replacement.`
    ),
    hspace: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "hspace", an empty Ast.String was used as a replacement.`
    ),
    textcolor: factory$1(
      "em",
      `Warning: There is no equivalent tag for "textcolor", "em" was used as a replacement.`
    ),
    textsize: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "textsize", an empty Ast.String was used as a replacement.`
    ),
    makebox: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "makebox", an empty Ast.String was used as a replacement.`
    ),
    noindent: emptyStringWithWarningFactory(
      `Warning: There is no equivalent tag for "noindent", an empty Ast.String was used as a replacement.`
    ),
    latex: (node2) => {
      return htmlLike({ tag: "latex" });
    },
    latexe: (node2) => {
      return htmlLike({ tag: "latex" });
    },
    today: (node2) => {
      return htmlLike({ tag: "today" });
    },
    tex: (node2) => {
      return htmlLike({ tag: "tex" });
    },
    //tex: factory("tex"),
    includegraphics: (node2) => {
      const args = getArgsContent(node2);
      const source = printRaw(args[args.length - 1] || []);
      return htmlLike({
        tag: "image",
        attributes: {
          source
        },
        content: []
      });
    }
  };
  function factory(macroName, ...boundArgs) {
    return (content2, originalCommand) => {
      return m(macroName, boundArgs.map((a2) => arg(a2)).concat(arg(content2)));
    };
  }
  const streamingMacroReplacements = {
    color: colorToTextcolorMacro,
    bfseries: factory("textbf"),
    itshape: factory("textit"),
    rmfamily: factory("textrm"),
    scshape: factory("textsc"),
    sffamily: factory("textsf"),
    slshape: factory("textsl"),
    ttfamily: factory("texttt"),
    Huge: factory("textsize", "Huge"),
    huge: factory("textsize", "huge"),
    LARGE: factory("textsize", "LARGE"),
    Large: factory("textsize", "Large"),
    large: factory("textsize", "large"),
    normalsize: factory("textsize", "normalsize"),
    small: factory("textsize", "small"),
    footnotesize: factory("textsize", "footnotesize"),
    scriptsize: factory("textsize", "scriptsize"),
    tiny: factory("textsize", "tiny")
  };
  const unifiedLatexWrapPars = function unifiedLatexWrapPars2(options2) {
    const { macrosThatBreakPars, environmentsThatDontBreakPars } = options2 || {};
    return (tree) => {
      let hasDocumentEnv = false;
      visit$3(
        tree,
        (env2) => {
          if (match.environment(env2, "document") || isMappedEnviron(env2)) {
            if (match.environment(env2, "document")) {
              hasDocumentEnv = true;
            }
            env2.content = wrapPars(env2.content, {
              macrosThatBreakPars,
              environmentsThatDontBreakPars
            });
          }
        },
        { test: match.anyEnvironment }
      );
      if (!hasDocumentEnv) {
        tree.content = wrapPars(tree.content, {
          macrosThatBreakPars,
          environmentsThatDontBreakPars
        });
      }
    };
  };
  function reportMacrosUnsupportedByKatex(ast2) {
    const unsupported = { messages: [] };
    const isSupported = match.createMacroMatcher(KATEX_SUPPORT.macros);
    visit$3(ast2, (node2, info) => {
      if (anyMacro(node2) && info.context.hasMathModeAncestor) {
        if (!isSupported(node2)) {
          unsupported.messages.push(
            makeWarningMessage(
              node2,
              `Warning: "${node2.content}" is unsupported by Katex.`,
              "report-unsupported-macro-katex"
            )
          );
        }
      }
    });
    return unsupported;
  }
  const unifiedLatexToPretextLike = function unifiedLatexToHtmlLike2(options2) {
    const macroReplacements$12 = Object.assign(
      {},
      macroReplacements,
      (options2 == null ? void 0 : options2.macroReplacements) || {}
    );
    const environmentReplacements$12 = Object.assign(
      {},
      environmentReplacements,
      (options2 == null ? void 0 : options2.environmentReplacements) || {}
    );
    const producePretextFragment = (options2 == null ? void 0 : options2.producePretextFragment) ? options2 == null ? void 0 : options2.producePretextFragment : false;
    const isReplaceableMacro = match.createMacroMatcher(macroReplacements$12);
    const isReplaceableEnvironment = match.createEnvironmentMatcher(
      environmentReplacements$12
    );
    const isKatexMacro = match.createMacroMatcher(
      katexSpecificMacroReplacements
    );
    const isKatexEnvironment = match.createEnvironmentMatcher(
      katexSpecificEnvironmentReplacements
    );
    return (tree, file) => {
      const originalTree = tree;
      deleteComments(tree);
      let processor = unified().use(unifiedLatexLintNoTexFontShapingCommands, { fix: true }).use(unifiedLatexReplaceStreamingCommands, {
        replacers: streamingMacroReplacements
      });
      const warningMessages = breakOnBoundaries(tree);
      for (const warningMessage of warningMessages.messages) {
        file.message(
          warningMessage,
          warningMessage.place,
          "unified-latex-to-pretext:break-on-boundaries"
        );
      }
      if (shouldBeWrappedInPars(tree)) {
        processor = processor.use(unifiedLatexWrapPars);
      }
      tree = processor.runSync(tree, file);
      replaceNode(tree, (node2, info) => {
        if (info.context.hasMathModeAncestor) {
          return;
        }
        if (isReplaceableEnvironment(node2)) {
          return environmentReplacements$12[printRaw(node2.env)](
            node2,
            info,
            file
          );
        }
      });
      replaceNode(tree, (node2, info) => {
        if (info.context.hasMathModeAncestor) {
          return;
        }
        if (isReplaceableMacro(node2)) {
          const replacement = macroReplacements$12[node2.content](
            node2,
            info,
            file
          );
          return replacement;
        }
      });
      const unsupportedByKatex = reportMacrosUnsupportedByKatex(tree);
      for (const warningMessage of unsupportedByKatex.messages) {
        file.message(
          warningMessage,
          warningMessage.place,
          "unified-latex-to-pretext:report-unsupported-macro-katex"
        );
      }
      attachNeededRenderInfo(tree);
      replaceNode(tree, (node2) => {
        if (isKatexMacro(node2)) {
          return katexSpecificMacroReplacements[node2.content](node2);
        }
        if (isKatexEnvironment(node2)) {
          return katexSpecificEnvironmentReplacements[printRaw(node2.env)](
            node2
          );
        }
      });
      if (!producePretextFragment) {
        createValidPretextDoc(tree);
        tree.content = [
          htmlLike({ tag: "pretext", content: tree.content })
        ];
      }
      originalTree.content = tree.content;
    };
  };
  function shouldBeWrappedInPars(tree) {
    let content2 = tree.content;
    visit$3(
      tree,
      (env2) => {
        if (match.anyEnvironment(env2)) {
          content2 = env2.content;
          return EXIT$2;
        }
      },
      { test: (node2) => match.environment(node2, "document") }
    );
    return containsPar(content2);
  }
  function containsPar(content2) {
    return content2.some((node2) => {
      if (isMappedEnviron(node2)) {
        return containsPar(node2.content);
      }
      return match.parbreak(node2) || match.macro(node2, "par");
    });
  }
  function createValidPretextDoc(tree) {
    let isBook = false;
    const docClass = findMacro(tree, "documentclass");
    if (docClass) {
      const docClassArg = getArgsContent(docClass)[0];
      if (docClassArg) {
        const docClassTitle = docClassArg[0];
        if (docClassTitle.content == "book" || docClassTitle.content == "memoir") {
          isBook = true;
        }
      }
    }
    if (!isBook) {
      visit$3(tree, (node2) => {
        if (anyEnvironment(node2) && node2.env == "_chapter") {
          isBook = true;
          return EXIT$2;
        }
      });
    }
    const title = findMacro(tree, "title");
    if (title) {
      const titleArg = getArgsContent(title)[1];
      if (titleArg) {
        const titleString = titleArg[0];
        tree.content.unshift(
          htmlLike({ tag: "title", content: titleString })
        );
      } else {
        tree.content.unshift(htmlLike({ tag: "title", content: s$1("") }));
      }
    } else {
      tree.content.unshift(htmlLike({ tag: "title", content: s$1("") }));
    }
    if (isBook) {
      tree.content = [htmlLike({ tag: "book", content: tree.content })];
    } else {
      tree.content = [htmlLike({ tag: "article", content: tree.content })];
    }
  }
  function findMacro(tree, content2) {
    let macro2 = null;
    visit$3(tree, (node2) => {
      if (anyEnvironment(node2)) {
        return SKIP$2;
      }
      if (anyMacro(node2) && node2.content === content2) {
        macro2 = node2;
        return EXIT$2;
      }
    });
    return macro2;
  }
  function expandUserDefinedMacros(ast2) {
    const newcommands = listNewcommands(ast2);
    const macrosToExpand = new Set(newcommands.map((command) => command.name));
    const macroInfo2 = Object.fromEntries(
      newcommands.map((m2) => [m2.name, { signature: m2.signature }])
    );
    for (let i = 0; i < 100; i++) {
      if (!needToExpand(ast2, macrosToExpand)) {
        break;
      }
      attachMacroArgs(ast2, macroInfo2);
      expandMacrosExcludingDefinitions(ast2, newcommands);
    }
  }
  function needToExpand(ast2, macros2) {
    let needExpand = false;
    visit$3(ast2, (node2) => {
      if (anyMacro(node2) && macros2.has(node2.content)) {
        needExpand = true;
      }
    });
    return needExpand;
  }
  const unifiedLatexToPretext = function unifiedLatexAttachMacroArguments(options2) {
    return (tree, file) => {
      const producePretextFragment = (options2 == null ? void 0 : options2.producePretextFragment) ? options2 == null ? void 0 : options2.producePretextFragment : false;
      expandUserDefinedMacros(tree);
      let content2 = tree.content;
      visit$3(
        tree,
        (env2) => {
          content2 = env2.content;
          return EXIT$2;
        },
        {
          test: (node2) => match.environment(
            node2,
            "document"
          )
        }
      );
      tree.content = content2;
      unified().use(unifiedLatexToPretextLike, options2).run(tree, file);
      expandUnicodeLigatures(tree);
      content2 = tree.content;
      const toXast = toPretextWithLoggerFactory(file.message.bind(file));
      let converted = toXast({ type: "root", content: content2 });
      if (!Array.isArray(converted)) {
        converted = [converted];
      }
      let ret = x();
      ret.children = converted;
      if (!producePretextFragment) {
        ret.children.unshift({
          type: "instruction",
          name: "xml",
          value: "version='1.0' encoding='utf-8'"
        });
      }
      return ret;
    };
  };
  const xmlCompilePlugin = function() {
    this.Compiler = (tree) => toXml(tree, { closeEmptyElements: true });
  };
  processLatexViaUnified().use(unifiedLatexToPretext).use(xmlCompilePlugin);
  const VOID = -1;
  const PRIMITIVE = 0;
  const ARRAY = 1;
  const OBJECT = 2;
  const DATE = 3;
  const REGEXP = 4;
  const MAP = 5;
  const SET = 6;
  const ERROR = 7;
  const BIGINT = 8;
  const env = typeof self === "object" ? self : globalThis;
  const deserializer = ($2, _) => {
    const as = (out, index2) => {
      $2.set(index2, out);
      return out;
    };
    const unpair = (index2) => {
      if ($2.has(index2))
        return $2.get(index2);
      const [type, value2] = _[index2];
      switch (type) {
        case PRIMITIVE:
        case VOID:
          return as(value2, index2);
        case ARRAY: {
          const arr = as([], index2);
          for (const index3 of value2)
            arr.push(unpair(index3));
          return arr;
        }
        case OBJECT: {
          const object2 = as({}, index2);
          for (const [key2, index3] of value2)
            object2[unpair(key2)] = unpair(index3);
          return object2;
        }
        case DATE:
          return as(new Date(value2), index2);
        case REGEXP: {
          const { source, flags } = value2;
          return as(new RegExp(source, flags), index2);
        }
        case MAP: {
          const map2 = as(/* @__PURE__ */ new Map(), index2);
          for (const [key2, index3] of value2)
            map2.set(unpair(key2), unpair(index3));
          return map2;
        }
        case SET: {
          const set = as(/* @__PURE__ */ new Set(), index2);
          for (const index3 of value2)
            set.add(unpair(index3));
          return set;
        }
        case ERROR: {
          const { name: name2, message } = value2;
          return as(new env[name2](message), index2);
        }
        case BIGINT:
          return as(BigInt(value2), index2);
        case "BigInt":
          return as(Object(BigInt(value2)), index2);
      }
      return as(new env[type](value2), index2);
    };
    return unpair;
  };
  const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
  const EMPTY = "";
  const { toString: toString$3 } = {};
  const { keys } = Object;
  const typeOf = (value2) => {
    const type = typeof value2;
    if (type !== "object" || !value2)
      return [PRIMITIVE, type];
    const asString = toString$3.call(value2).slice(8, -1);
    switch (asString) {
      case "Array":
        return [ARRAY, EMPTY];
      case "Object":
        return [OBJECT, EMPTY];
      case "Date":
        return [DATE, EMPTY];
      case "RegExp":
        return [REGEXP, EMPTY];
      case "Map":
        return [MAP, EMPTY];
      case "Set":
        return [SET, EMPTY];
    }
    if (asString.includes("Array"))
      return [ARRAY, asString];
    if (asString.includes("Error"))
      return [ERROR, asString];
    return [OBJECT, asString];
  };
  const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
  const serializer = (strict, json, $2, _) => {
    const as = (out, value2) => {
      const index2 = _.push(out) - 1;
      $2.set(value2, index2);
      return index2;
    };
    const pair = (value2) => {
      if ($2.has(value2))
        return $2.get(value2);
      let [TYPE, type] = typeOf(value2);
      switch (TYPE) {
        case PRIMITIVE: {
          let entry = value2;
          switch (type) {
            case "bigint":
              TYPE = BIGINT;
              entry = value2.toString();
              break;
            case "function":
            case "symbol":
              if (strict)
                throw new TypeError("unable to serialize " + type);
              entry = null;
              break;
            case "undefined":
              return as([VOID], value2);
          }
          return as([TYPE, entry], value2);
        }
        case ARRAY: {
          if (type)
            return as([type, [...value2]], value2);
          const arr = [];
          const index2 = as([TYPE, arr], value2);
          for (const entry of value2)
            arr.push(pair(entry));
          return index2;
        }
        case OBJECT: {
          if (type) {
            switch (type) {
              case "BigInt":
                return as([type, value2.toString()], value2);
              case "Boolean":
              case "Number":
              case "String":
                return as([type, value2.valueOf()], value2);
            }
          }
          if (json && "toJSON" in value2)
            return pair(value2.toJSON());
          const entries = [];
          const index2 = as([TYPE, entries], value2);
          for (const key2 of keys(value2)) {
            if (strict || !shouldSkip(typeOf(value2[key2])))
              entries.push([pair(key2), pair(value2[key2])]);
          }
          return index2;
        }
        case DATE:
          return as([TYPE, value2.toISOString()], value2);
        case REGEXP: {
          const { source, flags } = value2;
          return as([TYPE, { source, flags }], value2);
        }
        case MAP: {
          const entries = [];
          const index2 = as([TYPE, entries], value2);
          for (const [key2, entry] of value2) {
            if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
              entries.push([pair(key2), pair(entry)]);
          }
          return index2;
        }
        case SET: {
          const entries = [];
          const index2 = as([TYPE, entries], value2);
          for (const entry of value2) {
            if (strict || !shouldSkip(typeOf(entry)))
              entries.push(pair(entry));
          }
          return index2;
        }
      }
      const { message } = value2;
      return as([TYPE, { name: type, message }], value2);
    };
    return pair;
  };
  const serialize = (value2, { json, lossy } = {}) => {
    const _ = [];
    return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value2), _;
  };
  var structuredClone$1 = typeof structuredClone === "function" ? (
    /* c8 ignore start */
    (any, options2) => options2 && ("json" in options2 || "lossy" in options2) ? deserialize(serialize(any, options2)) : structuredClone(any)
  ) : (any, options2) => deserialize(serialize(any, options2));
  const isElement = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
     *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
     *   ((element?: null | undefined) => false) &
     *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
     *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
     * )}
     */
    /**
     * @param {unknown} [element]
     * @param {Test | undefined} [test]
     * @param {number | null | undefined} [index]
     * @param {Parents | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function(element2, test, index2, parent, context) {
      const check = convertElement(test);
      if (index2 !== null && index2 !== void 0 && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
        throw new Error("Expected positive finite `index`");
      }
      if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
        throw new Error("Expected valid `parent`");
      }
      if ((index2 === null || index2 === void 0) !== (parent === null || parent === void 0)) {
        throw new Error("Expected both `index` and `parent`");
      }
      return looksLikeAnElement(element2) ? check.call(context, element2, index2, parent) : false;
    }
  );
  const convertElement = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
     *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
     *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test | null | undefined} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return element;
      }
      if (typeof test === "string") {
        return tagNameFactory(test);
      }
      if (typeof test === "object") {
        return anyFactory$4(test);
      }
      if (typeof test === "function") {
        return castFactory$4(test);
      }
      throw new Error("Expected function, string, or array as `test`");
    }
  );
  function anyFactory$4(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convertElement(tests[index2]);
    }
    return castFactory$4(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function tagNameFactory(check) {
    return castFactory$4(tagName2);
    function tagName2(element2) {
      return element2.tagName === check;
    }
  }
  function castFactory$4(testFunction) {
    return check;
    function check(value2, index2, parent) {
      return Boolean(
        looksLikeAnElement(value2) && testFunction.call(
          this,
          value2,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function element(element2) {
    return Boolean(
      element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
    );
  }
  function looksLikeAnElement(value2) {
    return value2 !== null && typeof value2 === "object" && "type" in value2 && "tagName" in value2;
  }
  const embedded = convertElement(
    /**
     * @param element
     * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
     */
    function(element2) {
      return element2.tagName === "audio" || element2.tagName === "canvas" || element2.tagName === "embed" || element2.tagName === "iframe" || element2.tagName === "img" || element2.tagName === "math" || element2.tagName === "object" || element2.tagName === "picture" || element2.tagName === "svg" || element2.tagName === "video";
    }
  );
  const re$1 = /[ \t\n\f\r]/g;
  function whitespace$1(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty$2(thing.value) : false : empty$2(thing);
  }
  function empty$2(value2) {
    return value2.replace(re$1, "") === "";
  }
  const convert$3 = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok$3;
      }
      if (typeof test === "function") {
        return castFactory$3(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$3(test) : propsFactory$3(test);
      }
      if (typeof test === "string") {
        return typeFactory$3(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$3(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$3(tests[index2]);
    }
    return castFactory$3(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$3(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory$3(all2);
    function all2(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$3(check) {
    return castFactory$3(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$3(testFunction) {
    return check;
    function check(value2, index2, parent) {
      return Boolean(
        looksLikeANode$3(value2) && testFunction.call(
          this,
          value2,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok$3() {
    return true;
  }
  function looksLikeANode$3(value2) {
    return value2 !== null && typeof value2 === "object" && "type" in value2;
  }
  const blocks = [
    "address",
    // Flow content.
    "article",
    // Sections and headings.
    "aside",
    // Sections and headings.
    "blockquote",
    // Flow content.
    "body",
    // Page.
    "br",
    // Contribute whitespace intrinsically.
    "caption",
    // Similar to block.
    "center",
    // Flow content, legacy.
    "col",
    // Similar to block.
    "colgroup",
    // Similar to block.
    "dd",
    // Lists.
    "dialog",
    // Flow content.
    "dir",
    // Lists, legacy.
    "div",
    // Flow content.
    "dl",
    // Lists.
    "dt",
    // Lists.
    "figcaption",
    // Flow content.
    "figure",
    // Flow content.
    "footer",
    // Flow content.
    "form",
    // Flow content.
    "h1",
    // Sections and headings.
    "h2",
    // Sections and headings.
    "h3",
    // Sections and headings.
    "h4",
    // Sections and headings.
    "h5",
    // Sections and headings.
    "h6",
    // Sections and headings.
    "head",
    // Page.
    "header",
    // Flow content.
    "hgroup",
    // Sections and headings.
    "hr",
    // Flow content.
    "html",
    // Page.
    "legend",
    // Flow content.
    "li",
    // Block-like.
    "li",
    // Similar to block.
    "listing",
    // Flow content, legacy
    "main",
    // Flow content.
    "menu",
    // Lists.
    "nav",
    // Sections and headings.
    "ol",
    // Lists.
    "optgroup",
    // Similar to block.
    "option",
    // Similar to block.
    "p",
    // Flow content.
    "plaintext",
    // Flow content, legacy
    "pre",
    // Flow content.
    "section",
    // Sections and headings.
    "summary",
    // Similar to block.
    "table",
    // Similar to block.
    "tbody",
    // Similar to block.
    "td",
    // Block-like.
    "td",
    // Similar to block.
    "tfoot",
    // Similar to block.
    "th",
    // Block-like.
    "th",
    // Similar to block.
    "thead",
    // Similar to block.
    "tr",
    // Similar to block.
    "ul",
    // Lists.
    "wbr",
    // Contribute whitespace intrinsically.
    "xmp"
    // Flow content, legacy
  ];
  const content$1 = [
    // Form.
    "button",
    "input",
    "select",
    "textarea"
  ];
  const skippable$1 = [
    "area",
    "base",
    "basefont",
    "dialog",
    "datalist",
    "head",
    "link",
    "meta",
    "noembed",
    "noframes",
    "param",
    "rp",
    "script",
    "source",
    "style",
    "template",
    "track",
    "title"
  ];
  const emptyOptions$3 = {};
  const ignorableNode = convert$3(["doctype", "comment"]);
  function rehypeMinifyWhitespace(options2) {
    const settings = options2 || emptyOptions$3;
    const collapse = collapseFactory(
      settings.newlines ? replaceNewlines : replaceWhitespace
    );
    return function(tree) {
      minify(tree, { collapse, whitespace: "normal" });
    };
  }
  function minify(node2, state) {
    if ("children" in node2) {
      const settings = { ...state };
      if (node2.type === "root" || blocklike(node2)) {
        settings.before = true;
        settings.after = true;
      }
      settings.whitespace = inferWhiteSpace(node2, state);
      return all$5(node2, settings);
    }
    if (node2.type === "text") {
      if (state.whitespace === "normal") {
        return minifyText(node2, state);
      }
      if (state.whitespace === "nowrap") {
        node2.value = state.collapse(node2.value);
      }
    }
    return { ignore: ignorableNode(node2), stripAtStart: false, remove: false };
  }
  function minifyText(node2, state) {
    const value2 = state.collapse(node2.value);
    const result = { ignore: false, stripAtStart: false, remove: false };
    let start = 0;
    let end2 = value2.length;
    if (state.before && removable(value2.charAt(0))) {
      start++;
    }
    if (start !== end2 && removable(value2.charAt(end2 - 1))) {
      if (state.after) {
        end2--;
      } else {
        result.stripAtStart = true;
      }
    }
    if (start === end2) {
      result.remove = true;
    } else {
      node2.value = value2.slice(start, end2);
    }
    return result;
  }
  function all$5(parent, state) {
    let before = state.before;
    const after = state.after;
    const children = parent.children;
    let length = children.length;
    let index2 = -1;
    while (++index2 < length) {
      const result = minify(children[index2], {
        ...state,
        after: collapsableAfter(children, index2, after),
        before
      });
      if (result.remove) {
        children.splice(index2, 1);
        index2--;
        length--;
      } else if (!result.ignore) {
        before = result.stripAtStart;
      }
      if (content(children[index2])) {
        before = false;
      }
    }
    return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
  }
  function collapsableAfter(nodes, index2, after) {
    while (++index2 < nodes.length) {
      const node2 = nodes[index2];
      let result = inferBoundary(node2);
      if (result === void 0 && "children" in node2 && !skippable(node2)) {
        result = collapsableAfter(node2.children, -1);
      }
      if (typeof result === "boolean") {
        return result;
      }
    }
    return after;
  }
  function inferBoundary(node2) {
    if (node2.type === "element") {
      if (content(node2)) {
        return false;
      }
      if (blocklike(node2)) {
        return true;
      }
    } else if (node2.type === "text") {
      if (!whitespace$1(node2)) {
        return false;
      }
    } else if (!ignorableNode(node2)) {
      return false;
    }
  }
  function content(node2) {
    return embedded(node2) || isElement(node2, content$1);
  }
  function blocklike(node2) {
    return isElement(node2, blocks);
  }
  function skippable(node2) {
    return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode(node2) || isElement(node2, skippable$1);
  }
  function removable(character) {
    return character === " " || character === "\n";
  }
  function replaceNewlines(value2) {
    const match2 = /\r?\n|\r/.exec(value2);
    return match2 ? match2[0] : " ";
  }
  function replaceWhitespace() {
    return " ";
  }
  function collapseFactory(replace) {
    return collapse;
    function collapse(value2) {
      return String(value2).replace(/[\t\n\v\f\r ]+/g, replace);
    }
  }
  function inferWhiteSpace(node2, state) {
    if ("tagName" in node2 && node2.properties) {
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "script":
        case "style":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return node2.properties.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return node2.properties.noWrap ? "nowrap" : state.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
      }
    }
    return state.whitespace;
  }
  const convert$2 = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok$2;
      }
      if (typeof test === "function") {
        return castFactory$2(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$2(test) : propsFactory$2(test);
      }
      if (typeof test === "string") {
        return typeFactory$2(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$2(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$2(tests[index2]);
    }
    return castFactory$2(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$2(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory$2(all2);
    function all2(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$2(check) {
    return castFactory$2(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$2(testFunction) {
    return check;
    function check(value2, index2, parent) {
      return Boolean(
        looksLikeANode$2(value2) && testFunction.call(
          this,
          value2,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok$2() {
    return true;
  }
  function looksLikeANode$2(value2) {
    return value2 !== null && typeof value2 === "object" && "type" in value2;
  }
  function color(d) {
    return d;
  }
  const empty$1 = [];
  const CONTINUE = true;
  const EXIT = false;
  const SKIP = "skip";
  function visitParents(tree, test, visitor2, reverse) {
    let check;
    if (typeof test === "function" && typeof visitor2 !== "function") {
      reverse = visitor2;
      visitor2 = test;
    } else {
      check = test;
    }
    const is = convert$2(check);
    const step = reverse ? -1 : 1;
    factory3(tree, void 0, [])();
    function factory3(node2, index2, parents) {
      const value2 = (
        /** @type {Record<string, unknown>} */
        node2 && typeof node2 === "object" ? node2 : {}
      );
      if (typeof value2.type === "string") {
        const name2 = (
          // `hast`
          typeof value2.tagName === "string" ? value2.tagName : (
            // `xast`
            typeof value2.name === "string" ? value2.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = empty$1;
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node2, index2, parents[parents.length - 1] || void 0)) {
          result = toResult(visitor2(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if ("children" in node2 && node2.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node2
          );
          if (nodeAsParent.children && result[0] !== SKIP) {
            offset = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset > -1 && offset < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset];
              subresult = factory3(child, offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult(value2) {
    if (Array.isArray(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      return [CONTINUE, value2];
    }
    return value2 === null || value2 === void 0 ? empty$1 : [value2];
  }
  function visit$1(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test;
    let visitor2;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test = void 0;
      visitor2 = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test = testOrVisitor;
      visitor2 = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      const index2 = parent ? parent.children.indexOf(node2) : void 0;
      return visitor2(node2, index2, parent);
    }
  }
  const pointEnd = point("end");
  const pointStart = point("start");
  function point(type) {
    return point2;
    function point2(node2) {
      const point3 = node2 && node2.position && node2.position[type] || {};
      if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
        return {
          line: point3.line,
          column: point3.column,
          offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
        };
      }
    }
  }
  function position(node2) {
    const start = pointStart(node2);
    const end2 = pointEnd(node2);
    if (start && end2) {
      return { start, end: end2 };
    }
  }
  function a(state, node2) {
    const properties = node2.properties || {};
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = {
      type: "link",
      url: state.resolve(String(properties.href || "") || null),
      title: properties.title ? String(properties.title) : null,
      children
    };
    state.patch(node2, result);
    return result;
  }
  function base(state, node2) {
    if (!state.baseFound) {
      state.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || void 0;
      state.baseFound = true;
    }
  }
  function blockquote$2(state, node2) {
    const result = { type: "blockquote", children: state.toFlow(state.all(node2)) };
    state.patch(node2, result);
    return result;
  }
  function br$1(state, node2) {
    const result = { type: "break" };
    state.patch(node2, result);
    return result;
  }
  const convert$1 = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok$1;
      }
      if (typeof test === "function") {
        return castFactory$1(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$1(test) : propsFactory$1(test);
      }
      if (typeof test === "string") {
        return typeFactory$1(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$1(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$1(tests[index2]);
    }
    return castFactory$1(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$1(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory$1(all2);
    function all2(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$1(check) {
    return castFactory$1(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$1(testFunction) {
    return check;
    function check(value2, index2, parent) {
      return Boolean(
        looksLikeANode$1(value2) && testFunction.call(
          this,
          value2,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok$1() {
    return true;
  }
  function looksLikeANode$1(value2) {
    return value2 !== null && typeof value2 === "object" && "type" in value2;
  }
  const findAfter = (
    // Note: overloads like this are needed to support optional generics.
    /**
     * @type {(
     *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
     *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
     * )}
     */
    /**
     * @param {UnistParent} parent
     * @param {UnistNode | number} index
     * @param {Test} [test]
     * @returns {UnistNode | undefined}
     */
    function(parent, index2, test) {
      const is = convert$1(test);
      if (!parent || !parent.type || !parent.children) {
        throw new Error("Expected parent node");
      }
      if (typeof index2 === "number") {
        if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
          throw new Error("Expected positive finite number as index");
        }
      } else {
        index2 = parent.children.indexOf(index2);
        if (index2 < 0) {
          throw new Error("Expected child node or index");
        }
      }
      while (++index2 < parent.children.length) {
        if (is(parent.children[index2], index2, parent)) {
          return parent.children[index2];
        }
      }
      return void 0;
    }
  );
  const searchLineFeeds = /\n/g;
  const searchTabOrSpaces = /[\t ]+/g;
  const br = convertElement("br");
  const cell = convertElement(isCell);
  const p$1 = convertElement("p");
  const row = convertElement("tr");
  const notRendered = convertElement([
    // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
    "datalist",
    "head",
    "noembed",
    "noframes",
    "noscript",
    // Act as if we support scripting.
    "rp",
    "script",
    "style",
    "template",
    "title",
    // Hidden attribute.
    hidden,
    // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
    closedDialog
  ]);
  const blockOrCaption = convertElement([
    "address",
    // Flow content
    "article",
    // Sections and headings
    "aside",
    // Sections and headings
    "blockquote",
    // Flow content
    "body",
    // Page
    "caption",
    // `table-caption`
    "center",
    // Flow content (legacy)
    "dd",
    // Lists
    "dialog",
    // Flow content
    "dir",
    // Lists (legacy)
    "dl",
    // Lists
    "dt",
    // Lists
    "div",
    // Flow content
    "figure",
    // Flow content
    "figcaption",
    // Flow content
    "footer",
    // Flow content
    "form,",
    // Flow content
    "h1",
    // Sections and headings
    "h2",
    // Sections and headings
    "h3",
    // Sections and headings
    "h4",
    // Sections and headings
    "h5",
    // Sections and headings
    "h6",
    // Sections and headings
    "header",
    // Flow content
    "hgroup",
    // Sections and headings
    "hr",
    // Flow content
    "html",
    // Page
    "legend",
    // Flow content
    "listing",
    // Flow content (legacy)
    "main",
    // Flow content
    "menu",
    // Lists
    "nav",
    // Sections and headings
    "ol",
    // Lists
    "p",
    // Flow content
    "plaintext",
    // Flow content (legacy)
    "pre",
    // Flow content
    "section",
    // Sections and headings
    "ul",
    // Lists
    "xmp"
    // Flow content (legacy)
  ]);
  function toText(tree, options2 = {}) {
    const children = "children" in tree ? tree.children : [];
    const block = blockOrCaption(tree);
    const whitespace2 = inferWhitespace(tree, {
      whitespace: options2.whitespace || "normal",
      breakBefore: false,
      breakAfter: false
    });
    const results = [];
    if (tree.type === "text" || tree.type === "comment") {
      results.push(
        ...collectText(tree, {
          whitespace: whitespace2,
          breakBefore: true,
          breakAfter: true
        })
      );
    }
    let index2 = -1;
    while (++index2 < children.length) {
      results.push(
        ...renderedTextCollection(
          children[index2],
          // @ts-expect-error: `tree` is a parent if weâre here.
          tree,
          {
            whitespace: whitespace2,
            breakBefore: index2 ? void 0 : block,
            breakAfter: index2 < children.length - 1 ? br(children[index2 + 1]) : block
          }
        )
      );
    }
    const result = [];
    let count;
    index2 = -1;
    while (++index2 < results.length) {
      const value2 = results[index2];
      if (typeof value2 === "number") {
        if (count !== void 0 && value2 > count)
          count = value2;
      } else if (value2) {
        if (count !== void 0 && count > -1) {
          result.push("\n".repeat(count) || " ");
        }
        count = -1;
        result.push(value2);
      }
    }
    return result.join("");
  }
  function renderedTextCollection(node2, parent, info) {
    if (node2.type === "element") {
      return collectElement(node2, parent, info);
    }
    if (node2.type === "text") {
      return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
    }
    return [];
  }
  function collectElement(node2, parent, info) {
    const whitespace2 = inferWhitespace(node2, info);
    const children = node2.children || [];
    let index2 = -1;
    let items = [];
    if (notRendered(node2)) {
      return items;
    }
    let prefix2;
    let suffix;
    if (br(node2)) {
      suffix = "\n";
    } else if (row(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, row)) {
      suffix = "\n";
    } else if (p$1(node2)) {
      prefix2 = 2;
      suffix = 2;
    } else if (blockOrCaption(node2)) {
      prefix2 = 1;
      suffix = 1;
    }
    while (++index2 < children.length) {
      items = items.concat(
        renderedTextCollection(children[index2], node2, {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : prefix2,
          breakAfter: index2 < children.length - 1 ? br(children[index2 + 1]) : suffix
        })
      );
    }
    if (cell(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, cell)) {
      items.push("	");
    }
    if (prefix2)
      items.unshift(prefix2);
    if (suffix)
      items.push(suffix);
    return items;
  }
  function collectText(node2, info) {
    const value2 = String(node2.value);
    const lines = [];
    const result = [];
    let start = 0;
    while (start <= value2.length) {
      searchLineFeeds.lastIndex = start;
      const match2 = searchLineFeeds.exec(value2);
      const end2 = match2 && "index" in match2 ? match2.index : value2.length;
      lines.push(
        // Any sequence of collapsible spaces and tabs immediately preceding or
        // following a segment break is removed.
        trimAndCollapseSpacesAndTabs(
          // [â¦] ignoring bidi formatting characters (characters with the
          // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
          // they were not there.
          value2.slice(start, end2).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
          start === 0 ? info.breakBefore : true,
          end2 === value2.length ? info.breakAfter : true
        )
      );
      start = end2 + 1;
    }
    let index2 = -1;
    let join2;
    while (++index2 < lines.length) {
      if (lines[index2].charCodeAt(lines[index2].length - 1) === 8203 || index2 < lines.length - 1 && lines[index2 + 1].charCodeAt(0) === 8203) {
        result.push(lines[index2]);
        join2 = void 0;
      } else if (lines[index2]) {
        if (typeof join2 === "number")
          result.push(join2);
        result.push(lines[index2]);
        join2 = 0;
      } else if (index2 === 0 || index2 === lines.length - 1) {
        result.push(0);
      }
    }
    return result;
  }
  function collectPreText(node2) {
    return [String(node2.value)];
  }
  function trimAndCollapseSpacesAndTabs(value2, breakBefore, breakAfter) {
    const result = [];
    let start = 0;
    let end2;
    while (start < value2.length) {
      searchTabOrSpaces.lastIndex = start;
      const match2 = searchTabOrSpaces.exec(value2);
      end2 = match2 ? match2.index : value2.length;
      if (!start && !end2 && match2 && !breakBefore) {
        result.push("");
      }
      if (start !== end2) {
        result.push(value2.slice(start, end2));
      }
      start = match2 ? end2 + match2[0].length : end2;
    }
    if (start !== end2 && !breakAfter) {
      result.push("");
    }
    return result.join(" ");
  }
  function inferWhitespace(node2, info) {
    if (node2.type === "element") {
      const props = node2.properties || {};
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return props.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return props.noWrap ? "nowrap" : info.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
      }
    }
    return info.whitespace;
  }
  function hidden(node2) {
    return Boolean((node2.properties || {}).hidden);
  }
  function isCell(node2) {
    return node2.tagName === "td" || node2.tagName === "th";
  }
  function closedDialog(node2) {
    return node2.tagName === "dialog" && !(node2.properties || {}).open;
  }
  function trimTrailingLines(value2) {
    const input2 = String(value2);
    let end2 = input2.length;
    while (end2 > 0) {
      const code2 = input2.codePointAt(end2 - 1);
      if (code2 !== void 0 && (code2 === 10 || code2 === 13)) {
        end2--;
      } else {
        break;
      }
    }
    return input2.slice(0, end2);
  }
  const prefix = "language-";
  function code$2(state, node2) {
    const children = node2.children;
    let index2 = -1;
    let classList;
    let lang;
    if (node2.tagName === "pre") {
      while (++index2 < children.length) {
        const child = children[index2];
        if (child.type === "element" && child.tagName === "code" && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
          classList = child.properties.className;
          break;
        }
      }
    }
    if (classList) {
      index2 = -1;
      while (++index2 < classList.length) {
        if (String(classList[index2]).slice(0, prefix.length) === prefix) {
          lang = String(classList[index2]).slice(prefix.length);
          break;
        }
      }
    }
    const result = {
      type: "code",
      lang: lang || null,
      meta: null,
      value: trimTrailingLines(toText(node2))
    };
    state.patch(node2, result);
    return result;
  }
  function comment(state, node2) {
    const result = {
      type: "html",
      value: "<!--" + node2.value + "-->"
    };
    state.patch(node2, result);
    return result;
  }
  function del(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "delete", children };
    state.patch(node2, result);
    return result;
  }
  function listItemsSpread(children) {
    let index2 = -1;
    if (children.length > 1) {
      while (++index2 < children.length) {
        if (children[index2].spread) {
          return true;
        }
      }
    }
    return false;
  }
  function dl(state, node2) {
    const clean2 = [];
    const groups = [];
    let index2 = -1;
    while (++index2 < node2.children.length) {
      const child = node2.children[index2];
      if (child.type === "element" && child.tagName === "div") {
        clean2.push(...child.children);
      } else {
        clean2.push(child);
      }
    }
    let group2 = { definitions: [], titles: [] };
    index2 = -1;
    while (++index2 < clean2.length) {
      const child = clean2[index2];
      if (child.type === "element" && child.tagName === "dt") {
        const previous = clean2[index2 - 1];
        if (previous && previous.type === "element" && previous.tagName === "dd") {
          groups.push(group2);
          group2 = { definitions: [], titles: [] };
        }
        group2.titles.push(child);
      } else {
        group2.definitions.push(child);
      }
    }
    groups.push(group2);
    index2 = -1;
    const content2 = [];
    while (++index2 < groups.length) {
      const result = [
        ...handle$2(state, groups[index2].titles),
        ...handle$2(state, groups[index2].definitions)
      ];
      if (result.length > 0) {
        content2.push({
          type: "listItem",
          spread: result.length > 1,
          checked: null,
          children: result
        });
      }
    }
    if (content2.length > 0) {
      const result = {
        type: "list",
        ordered: false,
        start: null,
        spread: listItemsSpread(content2),
        children: content2
      };
      state.patch(node2, result);
      return result;
    }
  }
  function handle$2(state, children) {
    const nodes = state.all({ type: "root", children });
    const listItems = state.toSpecificContent(nodes, create$2);
    if (listItems.length === 0) {
      return [];
    }
    if (listItems.length === 1) {
      return listItems[0].children;
    }
    return [
      {
        type: "list",
        ordered: false,
        start: null,
        spread: listItemsSpread(listItems),
        children: listItems
      }
    ];
  }
  function create$2() {
    return { type: "listItem", spread: false, checked: null, children: [] };
  }
  function em(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "emphasis", children };
    state.patch(node2, result);
    return result;
  }
  function heading$2(state, node2) {
    const depth = (
      /** @type {Heading['depth']} */
      /* c8 ignore next */
      Number(node2.tagName.charAt(1)) || 1
    );
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "heading", depth, children };
    state.patch(node2, result);
    return result;
  }
  function hr(state, node2) {
    const result = { type: "thematicBreak" };
    state.patch(node2, result);
    return result;
  }
  function iframe(state, node2) {
    const properties = node2.properties || {};
    const src = String(properties.src || "");
    const title = String(properties.title || "");
    if (src && title) {
      const result = {
        type: "link",
        title: null,
        url: state.resolve(src),
        children: [{ type: "text", value: title }]
      };
      state.patch(node2, result);
      return result;
    }
  }
  function img(state, node2) {
    const properties = node2.properties || {};
    const result = {
      type: "image",
      url: state.resolve(String(properties.src || "") || null),
      title: properties.title ? String(properties.title) : null,
      alt: properties.alt ? String(properties.alt) : ""
    };
    state.patch(node2, result);
    return result;
  }
  function inlineCode$2(state, node2) {
    const result = { type: "inlineCode", value: toText(node2) };
    state.patch(node2, result);
    return result;
  }
  function findSelectedOptions(node2, properties) {
    const selectedOptions = [];
    const values = [];
    const props = properties || node2.properties || {};
    const options2 = findOptions(node2);
    const size = Math.min(Number.parseInt(String(props.size), 10), 0) || (props.multiple ? 4 : 1);
    let index2 = -1;
    while (++index2 < options2.length) {
      const option2 = options2[index2];
      if (option2 && option2.properties && option2.properties.selected) {
        selectedOptions.push(option2);
      }
    }
    const list2 = selectedOptions.length > 0 ? selectedOptions : options2;
    const max = list2.length > size ? size : list2.length;
    index2 = -1;
    while (++index2 < max) {
      const option2 = list2[index2];
      const props2 = option2.properties || {};
      const content2 = toText(option2);
      const label2 = content2 || String(props2.label || "");
      const value2 = String(props2.value || "") || content2;
      values.push([value2, label2 === value2 ? void 0 : label2]);
    }
    return values;
  }
  function findOptions(node2) {
    const results = [];
    let index2 = -1;
    while (++index2 < node2.children.length) {
      const child = node2.children[index2];
      if ("children" in child && Array.isArray(child.children)) {
        results.push(...findOptions(child));
      }
      if (child.type === "element" && child.tagName === "option" && (!child.properties || !child.properties.disabled)) {
        results.push(child);
      }
    }
    return results;
  }
  const defaultChecked = "[x]";
  const defaultUnchecked = "[ ]";
  function input(state, node2) {
    const properties = node2.properties || {};
    const value2 = String(properties.value || properties.placeholder || "");
    if (properties.disabled || properties.type === "hidden" || properties.type === "file") {
      return;
    }
    if (properties.type === "checkbox" || properties.type === "radio") {
      const result2 = {
        type: "text",
        value: properties.checked ? state.options.checked || defaultChecked : state.options.unchecked || defaultUnchecked
      };
      state.patch(node2, result2);
      return result2;
    }
    if (properties.type === "image") {
      const alt = properties.alt || value2;
      if (alt) {
        const result2 = {
          type: "image",
          url: state.resolve(String(properties.src || "") || null),
          title: String(properties.title || "") || null,
          alt: String(alt)
        };
        state.patch(node2, result2);
        return result2;
      }
      return;
    }
    let values = [];
    if (value2) {
      values = [[value2, void 0]];
    } else if (
      // `list` is not supported on these types:
      properties.type !== "button" && properties.type !== "file" && properties.type !== "password" && properties.type !== "reset" && properties.type !== "submit" && properties.list
    ) {
      const list2 = String(properties.list);
      const datalist = state.elementById.get(list2);
      if (datalist && datalist.tagName === "datalist") {
        values = findSelectedOptions(datalist, properties);
      }
    }
    if (values.length === 0) {
      return;
    }
    if (properties.type === "password") {
      values[0] = ["â¢".repeat(values[0][0].length), void 0];
    }
    if (properties.type === "email" || properties.type === "url") {
      const results = [];
      let index3 = -1;
      while (++index3 < values.length) {
        const value3 = state.resolve(values[index3][0]);
        const result2 = {
          type: "link",
          title: null,
          url: properties.type === "email" ? "mailto:" + value3 : value3,
          children: [{ type: "text", value: values[index3][1] || value3 }]
        };
        results.push(result2);
        if (index3 !== values.length - 1) {
          results.push({ type: "text", value: ", " });
        }
      }
      return results;
    }
    const texts = [];
    let index2 = -1;
    while (++index2 < values.length) {
      texts.push(
        values[index2][1] ? values[index2][1] + " (" + values[index2][0] + ")" : values[index2][0]
      );
    }
    const result = { type: "text", value: texts.join(", ") };
    state.patch(node2, result);
    return result;
  }
  const own$3 = {}.hasOwnProperty;
  function hasProperty(node2, name2) {
    const value2 = node2.type === "element" && own$3.call(node2.properties, name2) && node2.properties[name2];
    return value2 !== null && value2 !== void 0 && value2 !== false;
  }
  const list$4 = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
  function isBodyOkLink(node2) {
    if (node2.type !== "element" || node2.tagName !== "link") {
      return false;
    }
    if (node2.properties.itemProp) {
      return true;
    }
    const rel = node2.properties.rel;
    let index2 = -1;
    if (!Array.isArray(rel) || rel.length === 0) {
      return false;
    }
    while (++index2 < rel.length) {
      if (!list$4.has(String(rel[index2]))) {
        return false;
      }
    }
    return true;
  }
  const basic = convertElement([
    "a",
    "abbr",
    // `area` is in fact only phrasing if it is inside a `map` element.
    // However, since `area`s are required to be inside a `map` element, and itâs
    // a rather involved check, itâs ignored here for now.
    "area",
    "b",
    "bdi",
    "bdo",
    "br",
    "button",
    "cite",
    "code",
    "data",
    "datalist",
    "del",
    "dfn",
    "em",
    "i",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "map",
    "mark",
    "meter",
    "noscript",
    "output",
    "progress",
    "q",
    "ruby",
    "s",
    "samp",
    "script",
    "select",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "template",
    "textarea",
    "time",
    "u",
    "var",
    "wbr"
  ]);
  const meta = convertElement("meta");
  function phrasing$3(value2) {
    return Boolean(
      value2.type === "text" || basic(value2) || embedded(value2) || isBodyOkLink(value2) || meta(value2) && hasProperty(value2, "itemProp")
    );
  }
  function li(state, node2) {
    const { rest, checkbox } = extractLeadingCheckbox(node2);
    const checked = checkbox ? Boolean(checkbox.properties.checked) : null;
    const spread = spreadout(rest);
    const children = state.toFlow(state.all(rest));
    const result = { type: "listItem", spread, checked, children };
    state.patch(node2, result);
    return result;
  }
  function spreadout(node2) {
    let index2 = -1;
    let seenFlow = false;
    while (++index2 < node2.children.length) {
      const child = node2.children[index2];
      if (child.type === "element") {
        if (phrasing$3(child))
          continue;
        if (child.tagName === "p" || seenFlow || spreadout(child)) {
          return true;
        }
        seenFlow = true;
      }
    }
    return false;
  }
  function extractLeadingCheckbox(node2) {
    const head2 = node2.children[0];
    if (head2 && head2.type === "element" && head2.tagName === "input" && head2.properties && (head2.properties.type === "checkbox" || head2.properties.type === "radio")) {
      const rest = { ...node2, children: node2.children.slice(1) };
      return { checkbox: head2, rest };
    }
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      const { checkbox, rest: restHead } = extractLeadingCheckbox(head2);
      if (checkbox) {
        const rest = { ...node2, children: [restHead, ...node2.children.slice(1)] };
        return { checkbox, rest };
      }
    }
    return { checkbox: void 0, rest: node2 };
  }
  function list$3(state, node2) {
    const ordered = node2.tagName === "ol";
    const children = state.toSpecificContent(state.all(node2), create$1);
    let start = null;
    if (ordered) {
      start = node2.properties && node2.properties.start ? Number.parseInt(String(node2.properties.start), 10) : 1;
    }
    const result = {
      type: "list",
      ordered,
      start,
      spread: listItemsSpread(children),
      children
    };
    state.patch(node2, result);
    return result;
  }
  function create$1() {
    return { type: "listItem", spread: false, checked: null, children: [] };
  }
  const emptyOptions$2 = {};
  function toString$2(value2, options2) {
    const settings = options2 || emptyOptions$2;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one$3(value2, includeImageAlt, includeHtml);
  }
  function one$3(value2, includeImageAlt, includeHtml) {
    if (node$1(value2)) {
      if ("value" in value2) {
        return value2.type === "html" && !includeHtml ? "" : value2.value;
      }
      if (includeImageAlt && "alt" in value2 && value2.alt) {
        return value2.alt;
      }
      if ("children" in value2) {
        return all$4(value2.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value2)) {
      return all$4(value2, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all$4(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one$3(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node$1(value2) {
    return Boolean(value2 && typeof value2 === "object");
  }
  const re = /[ \t\n\f\r]/g;
  function whitespace(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
  }
  function empty(value2) {
    return value2.replace(re, "") === "";
  }
  const convert = (
    // Note: overloads in JSDoc canât yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok;
      }
      if (typeof test === "function") {
        return castFactory(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert(tests[index2]);
    }
    return castFactory(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory(all2);
    function all2(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value2, index2, parent) {
      return Boolean(
        looksLikeANode(value2) && testFunction.call(
          this,
          value2,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok() {
    return true;
  }
  function looksLikeANode(value2) {
    return value2 !== null && typeof value2 === "object" && "type" in value2;
  }
  const phrasing$2 = (
    /** @type {(node?: unknown) => node is PhrasingContent} */
    convert([
      "break",
      "delete",
      "emphasis",
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      "link",
      "linkReference",
      "strong",
      "text"
    ])
  );
  function wrapNeeded(nodes) {
    let index2 = -1;
    while (++index2 < nodes.length) {
      const node2 = nodes[index2];
      if (!phrasing$1(node2) || "children" in node2 && wrapNeeded(node2.children)) {
        return true;
      }
    }
    return false;
  }
  function wrap(nodes) {
    return runs(nodes, onphrasing, function(d) {
      return d;
    });
    function onphrasing(nodes2) {
      return nodes2.every(function(d) {
        return d.type === "text" ? whitespace(d.value) : false;
      }) ? [] : [{ type: "paragraph", children: nodes2 }];
    }
  }
  function split(node2) {
    return runs(node2.children, onphrasing, onnonphrasing);
    function onphrasing(nodes) {
      const newParent = cloneWithoutChildren(node2);
      newParent.children = nodes;
      return [newParent];
    }
    function onnonphrasing(child) {
      if ("children" in child && "children" in node2) {
        const newParent = cloneWithoutChildren(node2);
        const newChild = cloneWithoutChildren(child);
        newParent.children = child.children;
        newChild.children.push(newParent);
        return newChild;
      }
      return { ...child };
    }
  }
  function runs(nodes, onphrasing, onnonphrasing) {
    const flattened = flatten(nodes);
    const result = [];
    let queue = [];
    let index2 = -1;
    while (++index2 < flattened.length) {
      const node2 = flattened[index2];
      if (phrasing$1(node2)) {
        queue.push(node2);
      } else {
        if (queue.length > 0) {
          result.push(...onphrasing(queue));
          queue = [];
        }
        result.push(onnonphrasing(node2));
      }
    }
    if (queue.length > 0) {
      result.push(...onphrasing(queue));
      queue = [];
    }
    return result;
  }
  function flatten(nodes) {
    const flattened = [];
    let index2 = -1;
    while (++index2 < nodes.length) {
      const node2 = nodes[index2];
      if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
        flattened.push(...split(node2));
      } else {
        flattened.push(node2);
      }
    }
    return flattened;
  }
  function phrasing$1(node2) {
    const tagName2 = node2.data && node2.data.hName;
    return tagName2 ? phrasing$3({ type: "element", tagName: tagName2, properties: {}, children: [] }) : phrasing$2(node2);
  }
  function cloneWithoutChildren(node2) {
    return structuredClone$1({ ...node2, children: [] });
  }
  function media(state, node2) {
    const properties = node2.properties || {};
    const poster = node2.tagName === "video" ? String(properties.poster || "") : "";
    let src = String(properties.src || "");
    let index2 = -1;
    let linkInFallbackContent = false;
    let nodes = state.all(node2);
    const fragment2 = { type: "root", children: nodes };
    visit$1(fragment2, function(node3) {
      if (node3.type === "link") {
        linkInFallbackContent = true;
        return EXIT;
      }
    });
    if (linkInFallbackContent || wrapNeeded(nodes)) {
      return nodes;
    }
    while (!src && ++index2 < node2.children.length) {
      const child = node2.children[index2];
      if (child.type === "element" && child.tagName === "source" && child.properties) {
        src = String(child.properties.src || "");
      }
    }
    if (poster) {
      const image2 = {
        type: "image",
        title: null,
        url: state.resolve(poster),
        alt: toString$2(nodes)
      };
      state.patch(node2, image2);
      nodes = [image2];
    }
    const children = (
      /** @type {Array<PhrasingContent>} */
      nodes
    );
    const result = {
      type: "link",
      title: properties.title ? String(properties.title) : null,
      url: state.resolve(src),
      children
    };
    state.patch(node2, result);
    return result;
  }
  function p(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    if (children.length > 0) {
      const result = { type: "paragraph", children };
      state.patch(node2, result);
      return result;
    }
  }
  const defaultQuotes = ['"'];
  function q(state, node2) {
    const quotes = state.options.quotes || defaultQuotes;
    state.qNesting++;
    const contents = state.all(node2);
    state.qNesting--;
    const quote = quotes[state.qNesting % quotes.length];
    const head2 = contents[0];
    const tail = contents[contents.length - 1];
    const open = quote.charAt(0);
    const close = quote.length > 1 ? quote.charAt(1) : quote;
    if (head2 && head2.type === "text") {
      head2.value = open + head2.value;
    } else {
      contents.unshift({ type: "text", value: open });
    }
    if (tail && tail.type === "text") {
      tail.value += close;
    } else {
      contents.push({ type: "text", value: close });
    }
    return contents;
  }
  function root$2(state, node2) {
    let children = state.all(node2);
    if (state.options.document || wrapNeeded(children)) {
      children = wrap(children);
    }
    const result = { type: "root", children };
    state.patch(node2, result);
    return result;
  }
  function select(state, node2) {
    const values = findSelectedOptions(node2);
    let index2 = -1;
    const results = [];
    while (++index2 < values.length) {
      const value2 = values[index2];
      results.push(value2[1] ? value2[1] + " (" + value2[0] + ")" : value2[0]);
    }
    if (results.length > 0) {
      const result = { type: "text", value: results.join(", ") };
      state.patch(node2, result);
      return result;
    }
  }
  function strong$2(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "strong", children };
    state.patch(node2, result);
    return result;
  }
  function tableCell(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "tableCell", children };
    state.patch(node2, result);
    if (node2.properties) {
      const rowSpan = node2.properties.rowSpan;
      const colSpan = node2.properties.colSpan;
      if (rowSpan || colSpan) {
        const data = (
          /** @type {Record<string, unknown>} */
          result.data || (result.data = {})
        );
        if (rowSpan)
          data.hastUtilToMdastTemporaryRowSpan = rowSpan;
        if (colSpan)
          data.hastUtilToMdastTemporaryColSpan = colSpan;
      }
    }
    return result;
  }
  function tableRow(state, node2) {
    const children = state.toSpecificContent(state.all(node2), create);
    const result = { type: "tableRow", children };
    state.patch(node2, result);
    return result;
  }
  function create() {
    return { type: "tableCell", children: [] };
  }
  function table(state, node2) {
    if (state.inTable) {
      const result2 = { type: "text", value: toText(node2) };
      state.patch(node2, result2);
      return result2;
    }
    state.inTable = true;
    const { align: align2, headless } = inspect(node2);
    const rows = state.toSpecificContent(state.all(node2), createRow);
    if (headless) {
      rows.unshift(createRow());
    }
    let rowIndex = -1;
    while (++rowIndex < rows.length) {
      const row2 = rows[rowIndex];
      const cells2 = state.toSpecificContent(row2.children, createCell);
      row2.children = cells2;
    }
    let columns = 1;
    rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = -1;
      while (++cellIndex < cells2.length) {
        const cell2 = cells2[cellIndex];
        if (cell2.data) {
          const data = (
            /** @type {Record<string, unknown>} */
            cell2.data
          );
          const colSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1;
          const rowSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1;
          if (colSpan > 1 || rowSpan > 1) {
            let otherRowIndex = rowIndex - 1;
            while (++otherRowIndex < rowIndex + rowSpan) {
              let colIndex = cellIndex - 1;
              while (++colIndex < cellIndex + colSpan) {
                if (!rows[otherRowIndex]) {
                  break;
                }
                const newCells = [];
                if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                  newCells.push({ type: "tableCell", children: [] });
                }
                rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
              }
            }
          }
          if ("hastUtilToMdastTemporaryColSpan" in cell2.data)
            delete cell2.data.hastUtilToMdastTemporaryColSpan;
          if ("hastUtilToMdastTemporaryRowSpan" in cell2.data)
            delete cell2.data.hastUtilToMdastTemporaryRowSpan;
          if (Object.keys(cell2.data).length === 0)
            delete cell2.data;
        }
      }
      if (cells2.length > columns)
        columns = cells2.length;
    }
    rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = cells2.length - 1;
      while (++cellIndex < columns) {
        cells2.push({ type: "tableCell", children: [] });
      }
    }
    let alignIndex = align2.length - 1;
    while (++alignIndex < columns) {
      align2.push(null);
    }
    state.inTable = false;
    const result = { type: "table", align: align2, children: rows };
    state.patch(node2, result);
    return result;
  }
  function inspect(node2) {
    const info = { align: [null], headless: true };
    let rowIndex = 0;
    let cellIndex = 0;
    visit$1(node2, function(child) {
      if (child.type === "element") {
        if (child.tagName === "table" && node2 !== child) {
          return SKIP;
        }
        if ((child.tagName === "th" || child.tagName === "td") && child.properties) {
          if (!info.align[cellIndex]) {
            const value2 = String(child.properties.align || "") || null;
            if (value2 === "center" || value2 === "left" || value2 === "right" || value2 === null) {
              info.align[cellIndex] = value2;
            }
          }
          if (info.headless && rowIndex < 2 && child.tagName === "th") {
            info.headless = false;
          }
          cellIndex++;
        } else if (child.tagName === "thead") {
          info.headless = false;
        } else if (child.tagName === "tr") {
          rowIndex++;
          cellIndex = 0;
        }
      }
    });
    return info;
  }
  function createCell() {
    return { type: "tableCell", children: [] };
  }
  function createRow() {
    return { type: "tableRow", children: [] };
  }
  function text$2(state, node2) {
    const result = { type: "text", value: node2.value };
    state.patch(node2, result);
    return result;
  }
  function textarea(state, node2) {
    const result = { type: "text", value: toText(node2) };
    state.patch(node2, result);
    return result;
  }
  function wbr(state, node2) {
    const result = { type: "text", value: "â" };
    state.patch(node2, result);
    return result;
  }
  const nodeHandlers = {
    comment,
    doctype: ignore,
    root: root$2,
    text: text$2
  };
  const handlers = {
    // Ignore:
    applet: ignore,
    area: ignore,
    basefont: ignore,
    bgsound: ignore,
    caption: ignore,
    col: ignore,
    colgroup: ignore,
    command: ignore,
    content: ignore,
    datalist: ignore,
    dialog: ignore,
    element: ignore,
    embed: ignore,
    frame: ignore,
    frameset: ignore,
    isindex: ignore,
    keygen: ignore,
    link: ignore,
    math: ignore,
    menu: ignore,
    menuitem: ignore,
    meta: ignore,
    nextid: ignore,
    noembed: ignore,
    noframes: ignore,
    optgroup: ignore,
    option: ignore,
    param: ignore,
    script: ignore,
    shadow: ignore,
    source: ignore,
    spacer: ignore,
    style: ignore,
    svg: ignore,
    template: ignore,
    title: ignore,
    track: ignore,
    // Use children:
    abbr: all$3,
    acronym: all$3,
    bdi: all$3,
    bdo: all$3,
    big: all$3,
    blink: all$3,
    button: all$3,
    canvas: all$3,
    cite: all$3,
    data: all$3,
    details: all$3,
    dfn: all$3,
    font: all$3,
    ins: all$3,
    label: all$3,
    map: all$3,
    marquee: all$3,
    meter: all$3,
    nobr: all$3,
    noscript: all$3,
    object: all$3,
    output: all$3,
    progress: all$3,
    rb: all$3,
    rbc: all$3,
    rp: all$3,
    rt: all$3,
    rtc: all$3,
    ruby: all$3,
    slot: all$3,
    small: all$3,
    span: all$3,
    sup: all$3,
    sub: all$3,
    tbody: all$3,
    tfoot: all$3,
    thead: all$3,
    time: all$3,
    // Use children as flow.
    address: flow,
    article: flow,
    aside: flow,
    body: flow,
    center: flow,
    div: flow,
    fieldset: flow,
    figcaption: flow,
    figure: flow,
    form: flow,
    footer: flow,
    header: flow,
    hgroup: flow,
    html: flow,
    legend: flow,
    main: flow,
    multicol: flow,
    nav: flow,
    picture: flow,
    section: flow,
    // Handle.
    a,
    audio: media,
    b: strong$2,
    base,
    blockquote: blockquote$2,
    br: br$1,
    code: inlineCode$2,
    dir: list$3,
    dl,
    dt: li,
    dd: li,
    del,
    em,
    h1: heading$2,
    h2: heading$2,
    h3: heading$2,
    h4: heading$2,
    h5: heading$2,
    h6: heading$2,
    hr,
    i: em,
    iframe,
    img,
    image: img,
    input,
    kbd: inlineCode$2,
    li,
    listing: code$2,
    mark: em,
    ol: list$3,
    p,
    plaintext: code$2,
    pre: code$2,
    q,
    s: del,
    samp: inlineCode$2,
    select,
    strike: del,
    strong: strong$2,
    summary: p,
    table,
    td: tableCell,
    textarea,
    th: tableCell,
    tr: tableRow,
    tt: inlineCode$2,
    u: em,
    ul: list$3,
    var: inlineCode$2,
    video: media,
    wbr,
    xmp: code$2
  };
  function all$3(state, node2) {
    return state.all(node2);
  }
  function flow(state, node2) {
    return state.toFlow(state.all(node2));
  }
  function ignore() {
  }
  const own$2 = {}.hasOwnProperty;
  function createState(options2) {
    return {
      all: all$2,
      baseFound: false,
      elementById: /* @__PURE__ */ new Map(),
      frozenBaseUrl: void 0,
      handlers: { ...handlers, ...options2.handlers },
      inTable: false,
      nodeHandlers: { ...nodeHandlers, ...options2.nodeHandlers },
      one: one$2,
      options: options2,
      patch,
      qNesting: 0,
      resolve,
      toFlow,
      toSpecificContent
    };
  }
  function all$2(parent) {
    const children = parent.children || [];
    const results = [];
    let index2 = -1;
    while (++index2 < children.length) {
      const child = children[index2];
      const result = (
        /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */
        this.one(child, parent)
      );
      if (Array.isArray(result)) {
        results.push(...result);
      } else if (result) {
        results.push(result);
      }
    }
    let start = 0;
    let end2 = results.length;
    while (start < end2 && results[start].type === "break") {
      start++;
    }
    while (end2 > start && results[end2 - 1].type === "break") {
      end2--;
    }
    return start === 0 && end2 === results.length ? results : results.slice(start, end2);
  }
  function one$2(node2, parent) {
    if (node2.type === "element") {
      if (node2.properties && node2.properties.dataMdast === "ignore") {
        return;
      }
      if (own$2.call(this.handlers, node2.tagName)) {
        return this.handlers[node2.tagName](this, node2, parent) || void 0;
      }
    } else if (own$2.call(this.nodeHandlers, node2.type)) {
      return this.nodeHandlers[node2.type](this, node2, parent) || void 0;
    }
    if ("value" in node2 && typeof node2.value === "string") {
      const result = { type: "text", value: node2.value };
      this.patch(node2, result);
      return result;
    }
    if ("children" in node2) {
      return this.all(node2);
    }
  }
  function patch(origin, node2) {
    if (origin.position)
      node2.position = position(origin);
  }
  function resolve(url) {
    const base2 = this.frozenBaseUrl;
    if (url === null || url === void 0) {
      return "";
    }
    if (base2) {
      return String(new URL(url, base2));
    }
    return url;
  }
  function toFlow(nodes) {
    return wrap(nodes);
  }
  function toSpecificContent(nodes, build) {
    const reference = build();
    const results = [];
    let queue = [];
    let index2 = -1;
    while (++index2 < nodes.length) {
      const node2 = nodes[index2];
      if (expectedParent(node2)) {
        if (queue.length > 0) {
          node2.children.unshift(...queue);
          queue = [];
        }
        results.push(node2);
      } else {
        const child = (
          /** @type {ChildType} */
          node2
        );
        queue.push(child);
      }
    }
    if (queue.length > 0) {
      let node2 = results[results.length - 1];
      if (!node2) {
        node2 = build();
        results.push(node2);
      }
      node2.children.push(...queue);
      queue = [];
    }
    return results;
    function expectedParent(node2) {
      return node2.type === reference.type;
    }
  }
  const emptyOptions$1 = {};
  function toMdast(tree, options2) {
    const cleanTree = structuredClone$1(tree);
    const settings = options2 || emptyOptions$1;
    const transformWhitespace = rehypeMinifyWhitespace({
      newlines: settings.newlines === true
    });
    const state = createState(settings);
    let mdast;
    transformWhitespace(cleanTree);
    visit$1(cleanTree, function(node2) {
      if (node2 && node2.type === "element" && node2.properties) {
        const id2 = String(node2.properties.id || "") || void 0;
        if (id2 && !state.elementById.has(id2)) {
          state.elementById.set(id2, node2);
        }
      }
    });
    const result = state.one(cleanTree, void 0);
    if (!result) {
      mdast = { type: "root", children: [] };
    } else if (Array.isArray(result)) {
      const children = (
        /** @type {Array<MdastRootContent>} */
        result
      );
      mdast = { type: "root", children };
    } else {
      mdast = result;
    }
    visit$1(mdast, function(node2, index2, parent) {
      if (node2.type === "text" && index2 !== void 0 && parent) {
        const previous = parent.children[index2 - 1];
        if (previous && previous.type === node2.type) {
          previous.value += node2.value;
          parent.children.splice(index2, 1);
          if (previous.position && node2.position) {
            previous.position.end = node2.position.end;
          }
          return index2 - 1;
        }
        node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
        if (parent && (parent.type === "heading" || parent.type === "paragraph" || parent.type === "root")) {
          if (!index2) {
            node2.value = node2.value.replace(/^[\t ]+/, "");
          }
          if (index2 === parent.children.length - 1) {
            node2.value = node2.value.replace(/[\t ]+$/, "");
          }
        }
        if (!node2.value) {
          parent.children.splice(index2, 1);
          return index2;
        }
      }
    });
    return mdast;
  }
  const defaults = { document: true };
  function rehypeRemark(destination, options2) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const mdastTree = toMdast(tree, { ...defaults, ...options2 });
        await destination.run(mdastTree, file);
      };
    }
    return function(tree) {
      return (
        /** @type {MdastRoot} */
        toMdast(tree, { ...defaults, ...destination })
      );
    };
  }
  function toString$1(node2) {
    if ("children" in node2) {
      return all$1(node2);
    }
    return "value" in node2 ? node2.value : "";
  }
  function one$1(node2) {
    if (node2.type === "text") {
      return node2.value;
    }
    return "children" in node2 ? all$1(node2) : "";
  }
  function all$1(node2) {
    let index2 = -1;
    const result = [];
    while (++index2 < node2.children.length) {
      result[index2] = one$1(node2.children[index2]);
    }
    return result.join("");
  }
  function configure$1(base2, extension) {
    let index2 = -1;
    let key2;
    if (extension.extensions) {
      while (++index2 < extension.extensions.length) {
        configure$1(base2, extension.extensions[index2]);
      }
    }
    for (key2 in extension) {
      if (key2 === "extensions")
        ;
      else if (key2 === "unsafe" || key2 === "join") {
        base2[key2] = [...base2[key2] || [], ...extension[key2] || []];
      } else if (key2 === "handlers") {
        base2[key2] = Object.assign(base2[key2], extension[key2] || {});
      } else {
        base2.options[key2] = extension[key2];
      }
    }
    return base2;
  }
  function blockquote$1(node2, _, state, info) {
    const exit = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value2 = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map$4
    );
    exit();
    return value2;
  }
  function map$4(line2, _, blank) {
    return ">" + (blank ? "" : " ") + line2;
  }
  function patternInScope$1(stack2, pattern) {
    return listInScope$1(stack2, pattern.inConstruct, true) && !listInScope$1(stack2, pattern.notInConstruct, false);
  }
  function listInScope$1(stack2, list2, none) {
    if (typeof list2 === "string") {
      list2 = [list2];
    }
    if (!list2 || list2.length === 0) {
      return none;
    }
    let index2 = -1;
    while (++index2 < list2.length) {
      if (stack2.includes(list2[index2])) {
        return true;
      }
    }
    return false;
  }
  function hardBreak$1(_, _1, state, info) {
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      if (state.unsafe[index2].character === "\n" && patternInScope$1(state.stack, state.unsafe[index2])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
  function longestStreak(value2, substring) {
    const source = String(value2);
    let index2 = source.indexOf(substring);
    let expected = index2;
    let count = 0;
    let max = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index2 !== -1) {
      if (index2 === expected) {
        if (++count > max) {
          max = count;
        }
      } else {
        count = 1;
      }
      expected = index2 + substring.length;
      index2 = source.indexOf(substring, expected);
    }
    return max;
  }
  function formatCodeAsIndented$1(node2, state) {
    return Boolean(
      !state.options.fences && node2.value && // If thereâs no infoâ¦
      !node2.lang && // And thereâs a non-whitespace characterâ¦
      /[^ \r\n]/.test(node2.value) && // And the value doesnât start or end in a blankâ¦
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
    );
  }
  function checkFence$1(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }
  function code$1(node2, _, state, info) {
    const marker = checkFence$1(state);
    const raw2 = node2.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented$1(node2, state)) {
      const exit2 = state.enter("codeIndented");
      const value3 = state.indentLines(raw2, map$3);
      exit2();
      return value3;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
    const exit = state.enter("codeFenced");
    let value2 = tracker.move(sequence);
    if (node2.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value2 += tracker.move(
        state.safe(node2.lang, {
          before: value2,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node2.lang && node2.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value2 += tracker.move(" ");
      value2 += tracker.move(
        state.safe(node2.meta, {
          before: value2,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value2 += tracker.move("\n");
    if (raw2) {
      value2 += tracker.move(raw2 + "\n");
    }
    value2 += tracker.move(sequence);
    exit();
    return value2;
  }
  function map$3(line2, _, blank) {
    return (blank ? "" : "    ") + line2;
  }
  function checkQuote$1(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }
  function definition$1(node2, _, state, info) {
    const quote = checkQuote$1(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("[");
    value2 += tracker.move(
      state.safe(state.associationId(node2), {
        before: value2,
        after: "]",
        ...tracker.current()
      })
    );
    value2 += tracker.move("]: ");
    subexit();
    if (
      // If thereâs no url, orâ¦
      !node2.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    exit();
    return value2;
  }
  function checkEmphasis$1(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  emphasis$1.peek = emphasisPeek$1;
  function emphasis$1(node2, _, state, info) {
    const marker = checkEmphasis$1(state);
    const exit = state.enter("emphasis");
    const tracker = state.createTracker(info);
    let value2 = tracker.move(marker);
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: marker,
        ...tracker.current()
      })
    );
    value2 += tracker.move(marker);
    exit();
    return value2;
  }
  function emphasisPeek$1(_, _1, state) {
    return state.options.emphasis || "*";
  }
  const emptyOptions = {};
  function toString(value2, options2) {
    const settings = options2 || emptyOptions;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one(value2, includeImageAlt, includeHtml);
  }
  function one(value2, includeImageAlt, includeHtml) {
    if (node(value2)) {
      if ("value" in value2) {
        return value2.type === "html" && !includeHtml ? "" : value2.value;
      }
      if (includeImageAlt && "alt" in value2 && value2.alt) {
        return value2.alt;
      }
      if ("children" in value2) {
        return all(value2.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value2)) {
      return all(value2, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value2) {
    return Boolean(value2 && typeof value2 === "object");
  }
  function formatHeadingAsSetext$1(node2, state) {
    let literalWithBreak = false;
    visit$2(node2, (node3) => {
      if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
        literalWithBreak = true;
        return EXIT$1;
      }
    });
    return Boolean(
      (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
    );
  }
  function heading$1(node2, _, state, info) {
    const rank = Math.max(Math.min(6, node2.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext$1(node2, state)) {
      const exit2 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value3 = state.containerPhrasing(node2, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit2();
      return value3 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole sizeâ¦
        value3.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)â¦
        (Math.max(value3.lastIndexOf("\r"), value3.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value2 = state.containerPhrasing(node2, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value2)) {
      value2 = "&#x" + value2.charCodeAt(0).toString(16).toUpperCase() + ";" + value2.slice(1);
    }
    value2 = value2 ? sequence + " " + value2 : sequence;
    if (state.options.closeAtx) {
      value2 += " " + sequence;
    }
    subexit();
    exit();
    return value2;
  }
  html$1.peek = htmlPeek$1;
  function html$1(node2) {
    return node2.value || "";
  }
  function htmlPeek$1() {
    return "<";
  }
  image$1.peek = imagePeek$1;
  function image$1(node2, _, state, info) {
    const quote = checkQuote$1(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("![");
    value2 += tracker.move(
      state.safe(node2.alt, { before: value2, after: "]", ...tracker.current() })
    );
    value2 += tracker.move("](");
    subexit();
    if (
      // If thereâs no url but there is a titleâ¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    value2 += tracker.move(")");
    exit();
    return value2;
  }
  function imagePeek$1() {
    return "!";
  }
  imageReference$1.peek = imageReferencePeek$1;
  function imageReference$1(node2, _, state, info) {
    const type = node2.referenceType;
    const exit = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("![");
    const alt = state.safe(node2.alt, {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    value2 += tracker.move(alt + "][");
    subexit();
    const stack2 = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack2;
    exit();
    if (type === "full" || !alt || alt !== reference) {
      value2 += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value2 = value2.slice(0, -1);
    } else {
      value2 += tracker.move("]");
    }
    return value2;
  }
  function imageReferencePeek$1() {
    return "!";
  }
  function patternCompile(pattern) {
    if (!pattern._compiled) {
      const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
      pattern._compiled = new RegExp(
        (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
        "g"
      );
    }
    return pattern._compiled;
  }
  inlineCode$1.peek = inlineCodePeek$1;
  function inlineCode$1(node2, _, state) {
    let value2 = node2.value || "";
    let sequence = "`";
    let index2 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value2)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value2) && (/^[ \r\n]/.test(value2) && /[ \r\n]$/.test(value2) || /^`|`$/.test(value2))) {
      value2 = " " + value2 + " ";
    }
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      const expression = patternCompile(pattern);
      let match2;
      if (!pattern.atBreak)
        continue;
      while (match2 = expression.exec(value2)) {
        let position2 = match2.index;
        if (value2.charCodeAt(position2) === 10 && value2.charCodeAt(position2 - 1) === 13) {
          position2--;
        }
        value2 = value2.slice(0, position2) + " " + value2.slice(match2.index + 1);
      }
    }
    return sequence + value2 + sequence;
  }
  function inlineCodePeek$1() {
    return "`";
  }
  function formatLinkAsAutolink$1(node2, state) {
    const raw2 = toString(node2);
    return Boolean(
      !state.options.resourceLink && // If thereâs a urlâ¦
      node2.url && // And thereâs a no titleâ¦
      !node2.title && // And the content of `node` is a single text nodeâ¦
      node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the contentâ¦
      (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocolâ¦
      /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnât contain ASCII control codes (character escapes and
      // references donât work), space, or angle bracketsâ¦
      !/[\0- <>\u007F]/.test(node2.url)
    );
  }
  link$1.peek = linkPeek$1;
  function link$1(node2, _, state, info) {
    const quote = checkQuote$1(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit;
    let subexit;
    if (formatLinkAsAutolink$1(node2, state)) {
      const stack2 = state.stack;
      state.stack = [];
      exit = state.enter("autolink");
      let value3 = tracker.move("<");
      value3 += tracker.move(
        state.containerPhrasing(node2, {
          before: value3,
          after: ">",
          ...tracker.current()
        })
      );
      value3 += tracker.move(">");
      exit();
      state.stack = stack2;
      return value3;
    }
    exit = state.enter("link");
    subexit = state.enter("label");
    let value2 = tracker.move("[");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: "](",
        ...tracker.current()
      })
    );
    value2 += tracker.move("](");
    subexit();
    if (
      // If thereâs no url but there is a titleâ¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    value2 += tracker.move(")");
    exit();
    return value2;
  }
  function linkPeek$1(node2, _, state) {
    return formatLinkAsAutolink$1(node2, state) ? "<" : "[";
  }
  linkReference$1.peek = linkReferencePeek$1;
  function linkReference$1(node2, _, state, info) {
    const type = node2.referenceType;
    const exit = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("[");
    const text2 = state.containerPhrasing(node2, {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    value2 += tracker.move(text2 + "][");
    subexit();
    const stack2 = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack2;
    exit();
    if (type === "full" || !text2 || text2 !== reference) {
      value2 += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value2 = value2.slice(0, -1);
    } else {
      value2 += tracker.move("]");
    }
    return value2;
  }
  function linkReferencePeek$1() {
    return "[";
  }
  function checkBullet$1(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }
  function checkBulletOther$1(state) {
    const bullet = checkBullet$1(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }
  function checkBulletOrdered$1(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }
  function checkBulletOrderedOther(state) {
    const bulletOrdered = checkBulletOrdered$1(state);
    const bulletOrderedOther = state.options.bulletOrderedOther;
    if (!bulletOrderedOther) {
      return bulletOrdered === "." ? ")" : ".";
    }
    if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
      throw new Error(
        "Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOrderedOther === bulletOrdered) {
      throw new Error(
        "Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different"
      );
    }
    return bulletOrderedOther;
  }
  function checkRule$1(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }
  function list$2(node2, parent, state, info) {
    const exit = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node2.ordered ? checkBulletOrdered$1(state) : checkBullet$1(state);
    const bulletOther = node2.ordered ? checkBulletOrderedOther(state) : checkBulletOther$1(state);
    const bulletLastUsed = state.bulletLastUsed;
    let useDifferentMarker = false;
    if (parent && // Explicit `other` set.
    (node2.ordered ? state.options.bulletOrderedOther : state.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
      useDifferentMarker = true;
    }
    if (!node2.ordered) {
      const firstListItem = node2.children ? node2.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule$1(state) === bullet && firstListItem) {
        let index2 = -1;
        while (++index2 < node2.children.length) {
          const item = node2.children[index2];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value2 = state.containerFlow(node2, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit();
    return value2;
  }
  function checkListItemIndent$1(state) {
    const style2 = state.options.listItemIndent || "tab";
    if (style2 === 1 || style2 === "1") {
      return "one";
    }
    if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style2;
  }
  function listItem$1(node2, parent, state, info) {
    const listItemIndent = checkListItemIndent$1(state);
    let bullet = state.bulletCurrent || checkBullet$1(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size - bullet.length));
    tracker.shift(size);
    const exit = state.enter("listItem");
    const value2 = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map2
    );
    exit();
    return value2;
    function map2(line2, index2, blank) {
      if (index2) {
        return (blank ? "" : " ".repeat(size)) + line2;
      }
      return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
    }
  }
  function paragraph$1(node2, _, state, info) {
    const exit = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, info);
    subexit();
    exit();
    return value2;
  }
  const phrasing = (
    /** @type {AssertPredicatePhrasing} */
    convert$4([
      "break",
      "delete",
      "emphasis",
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      "link",
      "linkReference",
      "strong",
      "text"
    ])
  );
  function root$1(node2, _, state, info) {
    const hasPhrasing = node2.children.some((d) => phrasing(d));
    const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return fn.call(state, node2, info);
  }
  function checkStrong$1(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  strong$1.peek = strongPeek$1;
  function strong$1(node2, _, state, info) {
    const marker = checkStrong$1(state);
    const exit = state.enter("strong");
    const tracker = state.createTracker(info);
    let value2 = tracker.move(marker + marker);
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: marker,
        ...tracker.current()
      })
    );
    value2 += tracker.move(marker + marker);
    exit();
    return value2;
  }
  function strongPeek$1(_, _1, state) {
    return state.options.strong || "*";
  }
  function text$1(node2, _, state, info) {
    return state.safe(node2.value, info);
  }
  function checkRuleRepetition$1(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }
  function thematicBreak$1(_, _1, state) {
    const value2 = (checkRule$1(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition$1(state));
    return state.options.ruleSpaces ? value2.slice(0, -1) : value2;
  }
  const handle$1 = {
    blockquote: blockquote$1,
    break: hardBreak$1,
    code: code$1,
    definition: definition$1,
    emphasis: emphasis$1,
    hardBreak: hardBreak$1,
    heading: heading$1,
    html: html$1,
    image: image$1,
    imageReference: imageReference$1,
    inlineCode: inlineCode$1,
    link: link$1,
    linkReference: linkReference$1,
    list: list$2,
    listItem: listItem$1,
    paragraph: paragraph$1,
    root: root$1,
    strong: strong$1,
    text: text$1,
    thematicBreak: thematicBreak$1
  };
  const join$2 = [joinDefaults$1];
  function joinDefaults$1(left, right, parent, state) {
    if (right.type === "code" && formatCodeAsIndented$1(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented$1(left, state))) {
      return false;
    }
    if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? state.options.bulletOrderedOther : state.options.bulletOther)) {
      return false;
    }
    if ("spread" in parent && typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && // Two paragraphs.
      (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
      right.type === "heading" && formatHeadingAsSetext$1(right, state))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }
  const fullPhrasingSpans$1 = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  const unsafe$1 = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: "	",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: "\n",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: " ",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    // An exclamation mark can start an image, if it is followed by a link or
    // a link reference.
    {
      character: "!",
      after: "\\[",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans$1
    },
    // A quote can break out of a title.
    { character: '"', inConstruct: "titleQuote" },
    // A number sign could start an ATX heading if it starts a line.
    { atBreak: true, character: "#" },
    { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
    // Dollar sign and percentage are not used in markdown.
    // An ampersand could start a character reference.
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    // An apostrophe can break out of a title.
    { character: "'", inConstruct: "titleApostrophe" },
    // A left paren could break out of a destination raw.
    { character: "(", inConstruct: "destinationRaw" },
    // A left paren followed by `]` could make something into a link or image.
    {
      before: "\\]",
      character: "(",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans$1
    },
    // A right paren could start a list item or break out of a destination
    // raw.
    { atBreak: true, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    // An asterisk can start thematic breaks, list items, emphasis, strong.
    { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
    { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans$1 },
    // A plus sign could start a list item.
    { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
    // A dash can start thematic breaks, list items, and setext heading
    // underlines.
    { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
    // A dot could start a list item.
    { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
    // Slash, colon, and semicolon are not used in markdown for constructs.
    // A less than can start html (flow or text) or an autolink.
    // HTML could start with an exclamation mark (declaration, cdata, comment),
    // slash (closing tag), question mark (instruction), or a letter (tag).
    // An autolink also starts with a letter.
    // Finally, it could break out of a destination literal.
    { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
    {
      character: "<",
      after: "[!/?A-Za-z]",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans$1
    },
    { character: "<", inConstruct: "destinationLiteral" },
    // An equals to can start setext heading underlines.
    { atBreak: true, character: "=" },
    // A greater than can start block quotes and it can break out of a
    // destination literal.
    { atBreak: true, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    // Question mark and at sign are not used in markdown for constructs.
    // A left bracket can start definitions, references, labels,
    { atBreak: true, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans$1 },
    { character: "[", inConstruct: ["label", "reference"] },
    // A backslash can start an escape (when followed by punctuation) or a
    // hard break (when followed by an eol).
    // Note: typical escapes are handled in `safe`!
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    // A right bracket can exit labels.
    { character: "]", inConstruct: ["label", "reference"] },
    // Caret is not used in markdown for constructs.
    // An underscore can start emphasis, strong, or a thematic break.
    { atBreak: true, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans$1 },
    // A grave accent can start code (fenced or text), or it can break out of
    // a grave accent code fence.
    { atBreak: true, character: "`" },
    {
      character: "`",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
    },
    { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans$1 },
    // Left brace, vertical bar, right brace are not used in markdown for
    // constructs.
    // A tilde can start code (fenced).
    { atBreak: true, character: "~" }
  ];
  const characterEntities = {
    AElig: "Ã",
    AMP: "&",
    Aacute: "Ã",
    Abreve: "Ä",
    Acirc: "Ã",
    Acy: "Ð",
    Afr: "ð",
    Agrave: "Ã",
    Alpha: "Î",
    Amacr: "Ä",
    And: "â©",
    Aogon: "Ä",
    Aopf: "ð¸",
    ApplyFunction: "â¡",
    Aring: "Ã",
    Ascr: "ð",
    Assign: "â",
    Atilde: "Ã",
    Auml: "Ã",
    Backslash: "â",
    Barv: "â«§",
    Barwed: "â",
    Bcy: "Ð",
    Because: "âµ",
    Bernoullis: "â¬",
    Beta: "Î",
    Bfr: "ð",
    Bopf: "ð¹",
    Breve: "Ë",
    Bscr: "â¬",
    Bumpeq: "â",
    CHcy: "Ð§",
    COPY: "Â©",
    Cacute: "Ä",
    Cap: "â",
    CapitalDifferentialD: "â",
    Cayleys: "â­",
    Ccaron: "Ä",
    Ccedil: "Ã",
    Ccirc: "Ä",
    Cconint: "â°",
    Cdot: "Ä",
    Cedilla: "Â¸",
    CenterDot: "Â·",
    Cfr: "â­",
    Chi: "Î§",
    CircleDot: "â",
    CircleMinus: "â",
    CirclePlus: "â",
    CircleTimes: "â",
    ClockwiseContourIntegral: "â²",
    CloseCurlyDoubleQuote: "â",
    CloseCurlyQuote: "â",
    Colon: "â·",
    Colone: "â©´",
    Congruent: "â¡",
    Conint: "â¯",
    ContourIntegral: "â®",
    Copf: "â",
    Coproduct: "â",
    CounterClockwiseContourIntegral: "â³",
    Cross: "â¨¯",
    Cscr: "ð",
    Cup: "â",
    CupCap: "â",
    DD: "â",
    DDotrahd: "â¤",
    DJcy: "Ð",
    DScy: "Ð",
    DZcy: "Ð",
    Dagger: "â¡",
    Darr: "â¡",
    Dashv: "â«¤",
    Dcaron: "Ä",
    Dcy: "Ð",
    Del: "â",
    Delta: "Î",
    Dfr: "ð",
    DiacriticalAcute: "Â´",
    DiacriticalDot: "Ë",
    DiacriticalDoubleAcute: "Ë",
    DiacriticalGrave: "`",
    DiacriticalTilde: "Ë",
    Diamond: "â",
    DifferentialD: "â",
    Dopf: "ð»",
    Dot: "Â¨",
    DotDot: "â",
    DotEqual: "â",
    DoubleContourIntegral: "â¯",
    DoubleDot: "Â¨",
    DoubleDownArrow: "â",
    DoubleLeftArrow: "â",
    DoubleLeftRightArrow: "â",
    DoubleLeftTee: "â«¤",
    DoubleLongLeftArrow: "â¸",
    DoubleLongLeftRightArrow: "âº",
    DoubleLongRightArrow: "â¹",
    DoubleRightArrow: "â",
    DoubleRightTee: "â¨",
    DoubleUpArrow: "â",
    DoubleUpDownArrow: "â",
    DoubleVerticalBar: "â¥",
    DownArrow: "â",
    DownArrowBar: "â¤",
    DownArrowUpArrow: "âµ",
    DownBreve: "Ì",
    DownLeftRightVector: "â¥",
    DownLeftTeeVector: "â¥",
    DownLeftVector: "â½",
    DownLeftVectorBar: "â¥",
    DownRightTeeVector: "â¥",
    DownRightVector: "â",
    DownRightVectorBar: "â¥",
    DownTee: "â¤",
    DownTeeArrow: "â§",
    Downarrow: "â",
    Dscr: "ð",
    Dstrok: "Ä",
    ENG: "Å",
    ETH: "Ã",
    Eacute: "Ã",
    Ecaron: "Ä",
    Ecirc: "Ã",
    Ecy: "Ð­",
    Edot: "Ä",
    Efr: "ð",
    Egrave: "Ã",
    Element: "â",
    Emacr: "Ä",
    EmptySmallSquare: "â»",
    EmptyVerySmallSquare: "â«",
    Eogon: "Ä",
    Eopf: "ð¼",
    Epsilon: "Î",
    Equal: "â©µ",
    EqualTilde: "â",
    Equilibrium: "â",
    Escr: "â°",
    Esim: "â©³",
    Eta: "Î",
    Euml: "Ã",
    Exists: "â",
    ExponentialE: "â",
    Fcy: "Ð¤",
    Ffr: "ð",
    FilledSmallSquare: "â¼",
    FilledVerySmallSquare: "âª",
    Fopf: "ð½",
    ForAll: "â",
    Fouriertrf: "â±",
    Fscr: "â±",
    GJcy: "Ð",
    GT: ">",
    Gamma: "Î",
    Gammad: "Ï",
    Gbreve: "Ä",
    Gcedil: "Ä¢",
    Gcirc: "Ä",
    Gcy: "Ð",
    Gdot: "Ä ",
    Gfr: "ð",
    Gg: "â",
    Gopf: "ð¾",
    GreaterEqual: "â¥",
    GreaterEqualLess: "â",
    GreaterFullEqual: "â§",
    GreaterGreater: "âª¢",
    GreaterLess: "â·",
    GreaterSlantEqual: "â©¾",
    GreaterTilde: "â³",
    Gscr: "ð¢",
    Gt: "â«",
    HARDcy: "Ðª",
    Hacek: "Ë",
    Hat: "^",
    Hcirc: "Ä¤",
    Hfr: "â",
    HilbertSpace: "â",
    Hopf: "â",
    HorizontalLine: "â",
    Hscr: "â",
    Hstrok: "Ä¦",
    HumpDownHump: "â",
    HumpEqual: "â",
    IEcy: "Ð",
    IJlig: "Ä²",
    IOcy: "Ð",
    Iacute: "Ã",
    Icirc: "Ã",
    Icy: "Ð",
    Idot: "Ä°",
    Ifr: "â",
    Igrave: "Ã",
    Im: "â",
    Imacr: "Äª",
    ImaginaryI: "â",
    Implies: "â",
    Int: "â¬",
    Integral: "â«",
    Intersection: "â",
    InvisibleComma: "â£",
    InvisibleTimes: "â¢",
    Iogon: "Ä®",
    Iopf: "ð",
    Iota: "Î",
    Iscr: "â",
    Itilde: "Ä¨",
    Iukcy: "Ð",
    Iuml: "Ã",
    Jcirc: "Ä´",
    Jcy: "Ð",
    Jfr: "ð",
    Jopf: "ð",
    Jscr: "ð¥",
    Jsercy: "Ð",
    Jukcy: "Ð",
    KHcy: "Ð¥",
    KJcy: "Ð",
    Kappa: "Î",
    Kcedil: "Ä¶",
    Kcy: "Ð",
    Kfr: "ð",
    Kopf: "ð",
    Kscr: "ð¦",
    LJcy: "Ð",
    LT: "<",
    Lacute: "Ä¹",
    Lambda: "Î",
    Lang: "âª",
    Laplacetrf: "â",
    Larr: "â",
    Lcaron: "Ä½",
    Lcedil: "Ä»",
    Lcy: "Ð",
    LeftAngleBracket: "â¨",
    LeftArrow: "â",
    LeftArrowBar: "â¤",
    LeftArrowRightArrow: "â",
    LeftCeiling: "â",
    LeftDoubleBracket: "â¦",
    LeftDownTeeVector: "â¥¡",
    LeftDownVector: "â",
    LeftDownVectorBar: "â¥",
    LeftFloor: "â",
    LeftRightArrow: "â",
    LeftRightVector: "â¥",
    LeftTee: "â£",
    LeftTeeArrow: "â¤",
    LeftTeeVector: "â¥",
    LeftTriangle: "â²",
    LeftTriangleBar: "â§",
    LeftTriangleEqual: "â´",
    LeftUpDownVector: "â¥",
    LeftUpTeeVector: "â¥ ",
    LeftUpVector: "â¿",
    LeftUpVectorBar: "â¥",
    LeftVector: "â¼",
    LeftVectorBar: "â¥",
    Leftarrow: "â",
    Leftrightarrow: "â",
    LessEqualGreater: "â",
    LessFullEqual: "â¦",
    LessGreater: "â¶",
    LessLess: "âª¡",
    LessSlantEqual: "â©½",
    LessTilde: "â²",
    Lfr: "ð",
    Ll: "â",
    Lleftarrow: "â",
    Lmidot: "Ä¿",
    LongLeftArrow: "âµ",
    LongLeftRightArrow: "â·",
    LongRightArrow: "â¶",
    Longleftarrow: "â¸",
    Longleftrightarrow: "âº",
    Longrightarrow: "â¹",
    Lopf: "ð",
    LowerLeftArrow: "â",
    LowerRightArrow: "â",
    Lscr: "â",
    Lsh: "â°",
    Lstrok: "Å",
    Lt: "âª",
    Map: "â¤",
    Mcy: "Ð",
    MediumSpace: "â",
    Mellintrf: "â³",
    Mfr: "ð",
    MinusPlus: "â",
    Mopf: "ð",
    Mscr: "â³",
    Mu: "Î",
    NJcy: "Ð",
    Nacute: "Å",
    Ncaron: "Å",
    Ncedil: "Å",
    Ncy: "Ð",
    NegativeMediumSpace: "â",
    NegativeThickSpace: "â",
    NegativeThinSpace: "â",
    NegativeVeryThinSpace: "â",
    NestedGreaterGreater: "â«",
    NestedLessLess: "âª",
    NewLine: "\n",
    Nfr: "ð",
    NoBreak: "â ",
    NonBreakingSpace: "Â ",
    Nopf: "â",
    Not: "â«¬",
    NotCongruent: "â¢",
    NotCupCap: "â­",
    NotDoubleVerticalBar: "â¦",
    NotElement: "â",
    NotEqual: "â ",
    NotEqualTilde: "âÌ¸",
    NotExists: "â",
    NotGreater: "â¯",
    NotGreaterEqual: "â±",
    NotGreaterFullEqual: "â§Ì¸",
    NotGreaterGreater: "â«Ì¸",
    NotGreaterLess: "â¹",
    NotGreaterSlantEqual: "â©¾Ì¸",
    NotGreaterTilde: "âµ",
    NotHumpDownHump: "âÌ¸",
    NotHumpEqual: "âÌ¸",
    NotLeftTriangle: "âª",
    NotLeftTriangleBar: "â§Ì¸",
    NotLeftTriangleEqual: "â¬",
    NotLess: "â®",
    NotLessEqual: "â°",
    NotLessGreater: "â¸",
    NotLessLess: "âªÌ¸",
    NotLessSlantEqual: "â©½Ì¸",
    NotLessTilde: "â´",
    NotNestedGreaterGreater: "âª¢Ì¸",
    NotNestedLessLess: "âª¡Ì¸",
    NotPrecedes: "â",
    NotPrecedesEqual: "âª¯Ì¸",
    NotPrecedesSlantEqual: "â ",
    NotReverseElement: "â",
    NotRightTriangle: "â«",
    NotRightTriangleBar: "â§Ì¸",
    NotRightTriangleEqual: "â­",
    NotSquareSubset: "âÌ¸",
    NotSquareSubsetEqual: "â¢",
    NotSquareSuperset: "âÌ¸",
    NotSquareSupersetEqual: "â£",
    NotSubset: "ââ",
    NotSubsetEqual: "â",
    NotSucceeds: "â",
    NotSucceedsEqual: "âª°Ì¸",
    NotSucceedsSlantEqual: "â¡",
    NotSucceedsTilde: "â¿Ì¸",
    NotSuperset: "ââ",
    NotSupersetEqual: "â",
    NotTilde: "â",
    NotTildeEqual: "â",
    NotTildeFullEqual: "â",
    NotTildeTilde: "â",
    NotVerticalBar: "â¤",
    Nscr: "ð©",
    Ntilde: "Ã",
    Nu: "Î",
    OElig: "Å",
    Oacute: "Ã",
    Ocirc: "Ã",
    Ocy: "Ð",
    Odblac: "Å",
    Ofr: "ð",
    Ograve: "Ã",
    Omacr: "Å",
    Omega: "Î©",
    Omicron: "Î",
    Oopf: "ð",
    OpenCurlyDoubleQuote: "â",
    OpenCurlyQuote: "â",
    Or: "â©",
    Oscr: "ðª",
    Oslash: "Ã",
    Otilde: "Ã",
    Otimes: "â¨·",
    Ouml: "Ã",
    OverBar: "â¾",
    OverBrace: "â",
    OverBracket: "â´",
    OverParenthesis: "â",
    PartialD: "â",
    Pcy: "Ð",
    Pfr: "ð",
    Phi: "Î¦",
    Pi: "Î ",
    PlusMinus: "Â±",
    Poincareplane: "â",
    Popf: "â",
    Pr: "âª»",
    Precedes: "âº",
    PrecedesEqual: "âª¯",
    PrecedesSlantEqual: "â¼",
    PrecedesTilde: "â¾",
    Prime: "â³",
    Product: "â",
    Proportion: "â·",
    Proportional: "â",
    Pscr: "ð«",
    Psi: "Î¨",
    QUOT: '"',
    Qfr: "ð",
    Qopf: "â",
    Qscr: "ð¬",
    RBarr: "â¤",
    REG: "Â®",
    Racute: "Å",
    Rang: "â«",
    Rarr: "â ",
    Rarrtl: "â¤",
    Rcaron: "Å",
    Rcedil: "Å",
    Rcy: "Ð ",
    Re: "â",
    ReverseElement: "â",
    ReverseEquilibrium: "â",
    ReverseUpEquilibrium: "â¥¯",
    Rfr: "â",
    Rho: "Î¡",
    RightAngleBracket: "â©",
    RightArrow: "â",
    RightArrowBar: "â¥",
    RightArrowLeftArrow: "â",
    RightCeiling: "â",
    RightDoubleBracket: "â§",
    RightDownTeeVector: "â¥",
    RightDownVector: "â",
    RightDownVectorBar: "â¥",
    RightFloor: "â",
    RightTee: "â¢",
    RightTeeArrow: "â¦",
    RightTeeVector: "â¥",
    RightTriangle: "â³",
    RightTriangleBar: "â§",
    RightTriangleEqual: "âµ",
    RightUpDownVector: "â¥",
    RightUpTeeVector: "â¥",
    RightUpVector: "â¾",
    RightUpVectorBar: "â¥",
    RightVector: "â",
    RightVectorBar: "â¥",
    Rightarrow: "â",
    Ropf: "â",
    RoundImplies: "â¥°",
    Rrightarrow: "â",
    Rscr: "â",
    Rsh: "â±",
    RuleDelayed: "â§´",
    SHCHcy: "Ð©",
    SHcy: "Ð¨",
    SOFTcy: "Ð¬",
    Sacute: "Å",
    Sc: "âª¼",
    Scaron: "Å ",
    Scedil: "Å",
    Scirc: "Å",
    Scy: "Ð¡",
    Sfr: "ð",
    ShortDownArrow: "â",
    ShortLeftArrow: "â",
    ShortRightArrow: "â",
    ShortUpArrow: "â",
    Sigma: "Î£",
    SmallCircle: "â",
    Sopf: "ð",
    Sqrt: "â",
    Square: "â¡",
    SquareIntersection: "â",
    SquareSubset: "â",
    SquareSubsetEqual: "â",
    SquareSuperset: "â",
    SquareSupersetEqual: "â",
    SquareUnion: "â",
    Sscr: "ð®",
    Star: "â",
    Sub: "â",
    Subset: "â",
    SubsetEqual: "â",
    Succeeds: "â»",
    SucceedsEqual: "âª°",
    SucceedsSlantEqual: "â½",
    SucceedsTilde: "â¿",
    SuchThat: "â",
    Sum: "â",
    Sup: "â",
    Superset: "â",
    SupersetEqual: "â",
    Supset: "â",
    THORN: "Ã",
    TRADE: "â¢",
    TSHcy: "Ð",
    TScy: "Ð¦",
    Tab: "	",
    Tau: "Î¤",
    Tcaron: "Å¤",
    Tcedil: "Å¢",
    Tcy: "Ð¢",
    Tfr: "ð",
    Therefore: "â´",
    Theta: "Î",
    ThickSpace: "ââ",
    ThinSpace: "â",
    Tilde: "â¼",
    TildeEqual: "â",
    TildeFullEqual: "â",
    TildeTilde: "â",
    Topf: "ð",
    TripleDot: "â",
    Tscr: "ð¯",
    Tstrok: "Å¦",
    Uacute: "Ã",
    Uarr: "â",
    Uarrocir: "â¥",
    Ubrcy: "Ð",
    Ubreve: "Å¬",
    Ucirc: "Ã",
    Ucy: "Ð£",
    Udblac: "Å°",
    Ufr: "ð",
    Ugrave: "Ã",
    Umacr: "Åª",
    UnderBar: "_",
    UnderBrace: "â",
    UnderBracket: "âµ",
    UnderParenthesis: "â",
    Union: "â",
    UnionPlus: "â",
    Uogon: "Å²",
    Uopf: "ð",
    UpArrow: "â",
    UpArrowBar: "â¤",
    UpArrowDownArrow: "â",
    UpDownArrow: "â",
    UpEquilibrium: "â¥®",
    UpTee: "â¥",
    UpTeeArrow: "â¥",
    Uparrow: "â",
    Updownarrow: "â",
    UpperLeftArrow: "â",
    UpperRightArrow: "â",
    Upsi: "Ï",
    Upsilon: "Î¥",
    Uring: "Å®",
    Uscr: "ð°",
    Utilde: "Å¨",
    Uuml: "Ã",
    VDash: "â«",
    Vbar: "â««",
    Vcy: "Ð",
    Vdash: "â©",
    Vdashl: "â«¦",
    Vee: "â",
    Verbar: "â",
    Vert: "â",
    VerticalBar: "â£",
    VerticalLine: "|",
    VerticalSeparator: "â",
    VerticalTilde: "â",
    VeryThinSpace: "â",
    Vfr: "ð",
    Vopf: "ð",
    Vscr: "ð±",
    Vvdash: "âª",
    Wcirc: "Å´",
    Wedge: "â",
    Wfr: "ð",
    Wopf: "ð",
    Wscr: "ð²",
    Xfr: "ð",
    Xi: "Î",
    Xopf: "ð",
    Xscr: "ð³",
    YAcy: "Ð¯",
    YIcy: "Ð",
    YUcy: "Ð®",
    Yacute: "Ã",
    Ycirc: "Å¶",
    Ycy: "Ð«",
    Yfr: "ð",
    Yopf: "ð",
    Yscr: "ð´",
    Yuml: "Å¸",
    ZHcy: "Ð",
    Zacute: "Å¹",
    Zcaron: "Å½",
    Zcy: "Ð",
    Zdot: "Å»",
    ZeroWidthSpace: "â",
    Zeta: "Î",
    Zfr: "â¨",
    Zopf: "â¤",
    Zscr: "ðµ",
    aacute: "Ã¡",
    abreve: "Ä",
    ac: "â¾",
    acE: "â¾Ì³",
    acd: "â¿",
    acirc: "Ã¢",
    acute: "Â´",
    acy: "Ð°",
    aelig: "Ã¦",
    af: "â¡",
    afr: "ð",
    agrave: "Ã ",
    alefsym: "âµ",
    aleph: "âµ",
    alpha: "Î±",
    amacr: "Ä",
    amalg: "â¨¿",
    amp: "&",
    and: "â§",
    andand: "â©",
    andd: "â©",
    andslope: "â©",
    andv: "â©",
    ang: "â ",
    ange: "â¦¤",
    angle: "â ",
    angmsd: "â¡",
    angmsdaa: "â¦¨",
    angmsdab: "â¦©",
    angmsdac: "â¦ª",
    angmsdad: "â¦«",
    angmsdae: "â¦¬",
    angmsdaf: "â¦­",
    angmsdag: "â¦®",
    angmsdah: "â¦¯",
    angrt: "â",
    angrtvb: "â¾",
    angrtvbd: "â¦",
    angsph: "â¢",
    angst: "Ã",
    angzarr: "â¼",
    aogon: "Ä",
    aopf: "ð",
    ap: "â",
    apE: "â©°",
    apacir: "â©¯",
    ape: "â",
    apid: "â",
    apos: "'",
    approx: "â",
    approxeq: "â",
    aring: "Ã¥",
    ascr: "ð¶",
    ast: "*",
    asymp: "â",
    asympeq: "â",
    atilde: "Ã£",
    auml: "Ã¤",
    awconint: "â³",
    awint: "â¨",
    bNot: "â«­",
    backcong: "â",
    backepsilon: "Ï¶",
    backprime: "âµ",
    backsim: "â½",
    backsimeq: "â",
    barvee: "â½",
    barwed: "â",
    barwedge: "â",
    bbrk: "âµ",
    bbrktbrk: "â¶",
    bcong: "â",
    bcy: "Ð±",
    bdquo: "â",
    becaus: "âµ",
    because: "âµ",
    bemptyv: "â¦°",
    bepsi: "Ï¶",
    bernou: "â¬",
    beta: "Î²",
    beth: "â¶",
    between: "â¬",
    bfr: "ð",
    bigcap: "â",
    bigcirc: "â¯",
    bigcup: "â",
    bigodot: "â¨",
    bigoplus: "â¨",
    bigotimes: "â¨",
    bigsqcup: "â¨",
    bigstar: "â",
    bigtriangledown: "â½",
    bigtriangleup: "â³",
    biguplus: "â¨",
    bigvee: "â",
    bigwedge: "â",
    bkarow: "â¤",
    blacklozenge: "â§«",
    blacksquare: "âª",
    blacktriangle: "â´",
    blacktriangledown: "â¾",
    blacktriangleleft: "â",
    blacktriangleright: "â¸",
    blank: "â£",
    blk12: "â",
    blk14: "â",
    blk34: "â",
    block: "â",
    bne: "=â¥",
    bnequiv: "â¡â¥",
    bnot: "â",
    bopf: "ð",
    bot: "â¥",
    bottom: "â¥",
    bowtie: "â",
    boxDL: "â",
    boxDR: "â",
    boxDl: "â",
    boxDr: "â",
    boxH: "â",
    boxHD: "â¦",
    boxHU: "â©",
    boxHd: "â¤",
    boxHu: "â§",
    boxUL: "â",
    boxUR: "â",
    boxUl: "â",
    boxUr: "â",
    boxV: "â",
    boxVH: "â¬",
    boxVL: "â£",
    boxVR: "â ",
    boxVh: "â«",
    boxVl: "â¢",
    boxVr: "â",
    boxbox: "â§",
    boxdL: "â",
    boxdR: "â",
    boxdl: "â",
    boxdr: "â",
    boxh: "â",
    boxhD: "â¥",
    boxhU: "â¨",
    boxhd: "â¬",
    boxhu: "â´",
    boxminus: "â",
    boxplus: "â",
    boxtimes: "â ",
    boxuL: "â",
    boxuR: "â",
    boxul: "â",
    boxur: "â",
    boxv: "â",
    boxvH: "âª",
    boxvL: "â¡",
    boxvR: "â",
    boxvh: "â¼",
    boxvl: "â¤",
    boxvr: "â",
    bprime: "âµ",
    breve: "Ë",
    brvbar: "Â¦",
    bscr: "ð·",
    bsemi: "â",
    bsim: "â½",
    bsime: "â",
    bsol: "\\",
    bsolb: "â§",
    bsolhsub: "â",
    bull: "â¢",
    bullet: "â¢",
    bump: "â",
    bumpE: "âª®",
    bumpe: "â",
    bumpeq: "â",
    cacute: "Ä",
    cap: "â©",
    capand: "â©",
    capbrcup: "â©",
    capcap: "â©",
    capcup: "â©",
    capdot: "â©",
    caps: "â©ï¸",
    caret: "â",
    caron: "Ë",
    ccaps: "â©",
    ccaron: "Ä",
    ccedil: "Ã§",
    ccirc: "Ä",
    ccups: "â©",
    ccupssm: "â©",
    cdot: "Ä",
    cedil: "Â¸",
    cemptyv: "â¦²",
    cent: "Â¢",
    centerdot: "Â·",
    cfr: "ð ",
    chcy: "Ñ",
    check: "â",
    checkmark: "â",
    chi: "Ï",
    cir: "â",
    cirE: "â§",
    circ: "Ë",
    circeq: "â",
    circlearrowleft: "âº",
    circlearrowright: "â»",
    circledR: "Â®",
    circledS: "â",
    circledast: "â",
    circledcirc: "â",
    circleddash: "â",
    cire: "â",
    cirfnint: "â¨",
    cirmid: "â«¯",
    cirscir: "â§",
    clubs: "â£",
    clubsuit: "â£",
    colon: ":",
    colone: "â",
    coloneq: "â",
    comma: ",",
    commat: "@",
    comp: "â",
    compfn: "â",
    complement: "â",
    complexes: "â",
    cong: "â",
    congdot: "â©­",
    conint: "â®",
    copf: "ð",
    coprod: "â",
    copy: "Â©",
    copysr: "â",
    crarr: "âµ",
    cross: "â",
    cscr: "ð¸",
    csub: "â«",
    csube: "â«",
    csup: "â«",
    csupe: "â«",
    ctdot: "â¯",
    cudarrl: "â¤¸",
    cudarrr: "â¤µ",
    cuepr: "â",
    cuesc: "â",
    cularr: "â¶",
    cularrp: "â¤½",
    cup: "âª",
    cupbrcap: "â©",
    cupcap: "â©",
    cupcup: "â©",
    cupdot: "â",
    cupor: "â©",
    cups: "âªï¸",
    curarr: "â·",
    curarrm: "â¤¼",
    curlyeqprec: "â",
    curlyeqsucc: "â",
    curlyvee: "â",
    curlywedge: "â",
    curren: "Â¤",
    curvearrowleft: "â¶",
    curvearrowright: "â·",
    cuvee: "â",
    cuwed: "â",
    cwconint: "â²",
    cwint: "â±",
    cylcty: "â­",
    dArr: "â",
    dHar: "â¥¥",
    dagger: "â ",
    daleth: "â¸",
    darr: "â",
    dash: "â",
    dashv: "â£",
    dbkarow: "â¤",
    dblac: "Ë",
    dcaron: "Ä",
    dcy: "Ð´",
    dd: "â",
    ddagger: "â¡",
    ddarr: "â",
    ddotseq: "â©·",
    deg: "Â°",
    delta: "Î´",
    demptyv: "â¦±",
    dfisht: "â¥¿",
    dfr: "ð¡",
    dharl: "â",
    dharr: "â",
    diam: "â",
    diamond: "â",
    diamondsuit: "â¦",
    diams: "â¦",
    die: "Â¨",
    digamma: "Ï",
    disin: "â²",
    div: "Ã·",
    divide: "Ã·",
    divideontimes: "â",
    divonx: "â",
    djcy: "Ñ",
    dlcorn: "â",
    dlcrop: "â",
    dollar: "$",
    dopf: "ð",
    dot: "Ë",
    doteq: "â",
    doteqdot: "â",
    dotminus: "â¸",
    dotplus: "â",
    dotsquare: "â¡",
    doublebarwedge: "â",
    downarrow: "â",
    downdownarrows: "â",
    downharpoonleft: "â",
    downharpoonright: "â",
    drbkarow: "â¤",
    drcorn: "â",
    drcrop: "â",
    dscr: "ð¹",
    dscy: "Ñ",
    dsol: "â§¶",
    dstrok: "Ä",
    dtdot: "â±",
    dtri: "â¿",
    dtrif: "â¾",
    duarr: "âµ",
    duhar: "â¥¯",
    dwangle: "â¦¦",
    dzcy: "Ñ",
    dzigrarr: "â¿",
    eDDot: "â©·",
    eDot: "â",
    eacute: "Ã©",
    easter: "â©®",
    ecaron: "Ä",
    ecir: "â",
    ecirc: "Ãª",
    ecolon: "â",
    ecy: "Ñ",
    edot: "Ä",
    ee: "â",
    efDot: "â",
    efr: "ð¢",
    eg: "âª",
    egrave: "Ã¨",
    egs: "âª",
    egsdot: "âª",
    el: "âª",
    elinters: "â§",
    ell: "â",
    els: "âª",
    elsdot: "âª",
    emacr: "Ä",
    empty: "â",
    emptyset: "â",
    emptyv: "â",
    emsp13: "â",
    emsp14: "â",
    emsp: "â",
    eng: "Å",
    ensp: "â",
    eogon: "Ä",
    eopf: "ð",
    epar: "â",
    eparsl: "â§£",
    eplus: "â©±",
    epsi: "Îµ",
    epsilon: "Îµ",
    epsiv: "Ïµ",
    eqcirc: "â",
    eqcolon: "â",
    eqsim: "â",
    eqslantgtr: "âª",
    eqslantless: "âª",
    equals: "=",
    equest: "â",
    equiv: "â¡",
    equivDD: "â©¸",
    eqvparsl: "â§¥",
    erDot: "â",
    erarr: "â¥±",
    escr: "â¯",
    esdot: "â",
    esim: "â",
    eta: "Î·",
    eth: "Ã°",
    euml: "Ã«",
    euro: "â¬",
    excl: "!",
    exist: "â",
    expectation: "â°",
    exponentiale: "â",
    fallingdotseq: "â",
    fcy: "Ñ",
    female: "â",
    ffilig: "ï¬",
    fflig: "ï¬",
    ffllig: "ï¬",
    ffr: "ð£",
    filig: "ï¬",
    fjlig: "fj",
    flat: "â­",
    fllig: "ï¬",
    fltns: "â±",
    fnof: "Æ",
    fopf: "ð",
    forall: "â",
    fork: "â",
    forkv: "â«",
    fpartint: "â¨",
    frac12: "Â½",
    frac13: "â",
    frac14: "Â¼",
    frac15: "â",
    frac16: "â",
    frac18: "â",
    frac23: "â",
    frac25: "â",
    frac34: "Â¾",
    frac35: "â",
    frac38: "â",
    frac45: "â",
    frac56: "â",
    frac58: "â",
    frac78: "â",
    frasl: "â",
    frown: "â¢",
    fscr: "ð»",
    gE: "â§",
    gEl: "âª",
    gacute: "Çµ",
    gamma: "Î³",
    gammad: "Ï",
    gap: "âª",
    gbreve: "Ä",
    gcirc: "Ä",
    gcy: "Ð³",
    gdot: "Ä¡",
    ge: "â¥",
    gel: "â",
    geq: "â¥",
    geqq: "â§",
    geqslant: "â©¾",
    ges: "â©¾",
    gescc: "âª©",
    gesdot: "âª",
    gesdoto: "âª",
    gesdotol: "âª",
    gesl: "âï¸",
    gesles: "âª",
    gfr: "ð¤",
    gg: "â«",
    ggg: "â",
    gimel: "â·",
    gjcy: "Ñ",
    gl: "â·",
    glE: "âª",
    gla: "âª¥",
    glj: "âª¤",
    gnE: "â©",
    gnap: "âª",
    gnapprox: "âª",
    gne: "âª",
    gneq: "âª",
    gneqq: "â©",
    gnsim: "â§",
    gopf: "ð",
    grave: "`",
    gscr: "â",
    gsim: "â³",
    gsime: "âª",
    gsiml: "âª",
    gt: ">",
    gtcc: "âª§",
    gtcir: "â©º",
    gtdot: "â",
    gtlPar: "â¦",
    gtquest: "â©¼",
    gtrapprox: "âª",
    gtrarr: "â¥¸",
    gtrdot: "â",
    gtreqless: "â",
    gtreqqless: "âª",
    gtrless: "â·",
    gtrsim: "â³",
    gvertneqq: "â©ï¸",
    gvnE: "â©ï¸",
    hArr: "â",
    hairsp: "â",
    half: "Â½",
    hamilt: "â",
    hardcy: "Ñ",
    harr: "â",
    harrcir: "â¥",
    harrw: "â­",
    hbar: "â",
    hcirc: "Ä¥",
    hearts: "â¥",
    heartsuit: "â¥",
    hellip: "â¦",
    hercon: "â¹",
    hfr: "ð¥",
    hksearow: "â¤¥",
    hkswarow: "â¤¦",
    hoarr: "â¿",
    homtht: "â»",
    hookleftarrow: "â©",
    hookrightarrow: "âª",
    hopf: "ð",
    horbar: "â",
    hscr: "ð½",
    hslash: "â",
    hstrok: "Ä§",
    hybull: "â",
    hyphen: "â",
    iacute: "Ã­",
    ic: "â£",
    icirc: "Ã®",
    icy: "Ð¸",
    iecy: "Ðµ",
    iexcl: "Â¡",
    iff: "â",
    ifr: "ð¦",
    igrave: "Ã¬",
    ii: "â",
    iiiint: "â¨",
    iiint: "â­",
    iinfin: "â§",
    iiota: "â©",
    ijlig: "Ä³",
    imacr: "Ä«",
    image: "â",
    imagline: "â",
    imagpart: "â",
    imath: "Ä±",
    imof: "â·",
    imped: "Æµ",
    in: "â",
    incare: "â",
    infin: "â",
    infintie: "â§",
    inodot: "Ä±",
    int: "â«",
    intcal: "âº",
    integers: "â¤",
    intercal: "âº",
    intlarhk: "â¨",
    intprod: "â¨¼",
    iocy: "Ñ",
    iogon: "Ä¯",
    iopf: "ð",
    iota: "Î¹",
    iprod: "â¨¼",
    iquest: "Â¿",
    iscr: "ð¾",
    isin: "â",
    isinE: "â¹",
    isindot: "âµ",
    isins: "â´",
    isinsv: "â³",
    isinv: "â",
    it: "â¢",
    itilde: "Ä©",
    iukcy: "Ñ",
    iuml: "Ã¯",
    jcirc: "Äµ",
    jcy: "Ð¹",
    jfr: "ð§",
    jmath: "È·",
    jopf: "ð",
    jscr: "ð¿",
    jsercy: "Ñ",
    jukcy: "Ñ",
    kappa: "Îº",
    kappav: "Ï°",
    kcedil: "Ä·",
    kcy: "Ðº",
    kfr: "ð¨",
    kgreen: "Ä¸",
    khcy: "Ñ",
    kjcy: "Ñ",
    kopf: "ð",
    kscr: "ð",
    lAarr: "â",
    lArr: "â",
    lAtail: "â¤",
    lBarr: "â¤",
    lE: "â¦",
    lEg: "âª",
    lHar: "â¥¢",
    lacute: "Äº",
    laemptyv: "â¦´",
    lagran: "â",
    lambda: "Î»",
    lang: "â¨",
    langd: "â¦",
    langle: "â¨",
    lap: "âª",
    laquo: "Â«",
    larr: "â",
    larrb: "â¤",
    larrbfs: "â¤",
    larrfs: "â¤",
    larrhk: "â©",
    larrlp: "â«",
    larrpl: "â¤¹",
    larrsim: "â¥³",
    larrtl: "â¢",
    lat: "âª«",
    latail: "â¤",
    late: "âª­",
    lates: "âª­ï¸",
    lbarr: "â¤",
    lbbrk: "â²",
    lbrace: "{",
    lbrack: "[",
    lbrke: "â¦",
    lbrksld: "â¦",
    lbrkslu: "â¦",
    lcaron: "Ä¾",
    lcedil: "Ä¼",
    lceil: "â",
    lcub: "{",
    lcy: "Ð»",
    ldca: "â¤¶",
    ldquo: "â",
    ldquor: "â",
    ldrdhar: "â¥§",
    ldrushar: "â¥",
    ldsh: "â²",
    le: "â¤",
    leftarrow: "â",
    leftarrowtail: "â¢",
    leftharpoondown: "â½",
    leftharpoonup: "â¼",
    leftleftarrows: "â",
    leftrightarrow: "â",
    leftrightarrows: "â",
    leftrightharpoons: "â",
    leftrightsquigarrow: "â­",
    leftthreetimes: "â",
    leg: "â",
    leq: "â¤",
    leqq: "â¦",
    leqslant: "â©½",
    les: "â©½",
    lescc: "âª¨",
    lesdot: "â©¿",
    lesdoto: "âª",
    lesdotor: "âª",
    lesg: "âï¸",
    lesges: "âª",
    lessapprox: "âª",
    lessdot: "â",
    lesseqgtr: "â",
    lesseqqgtr: "âª",
    lessgtr: "â¶",
    lesssim: "â²",
    lfisht: "â¥¼",
    lfloor: "â",
    lfr: "ð©",
    lg: "â¶",
    lgE: "âª",
    lhard: "â½",
    lharu: "â¼",
    lharul: "â¥ª",
    lhblk: "â",
    ljcy: "Ñ",
    ll: "âª",
    llarr: "â",
    llcorner: "â",
    llhard: "â¥«",
    lltri: "âº",
    lmidot: "Å",
    lmoust: "â°",
    lmoustache: "â°",
    lnE: "â¨",
    lnap: "âª",
    lnapprox: "âª",
    lne: "âª",
    lneq: "âª",
    lneqq: "â¨",
    lnsim: "â¦",
    loang: "â¬",
    loarr: "â½",
    lobrk: "â¦",
    longleftarrow: "âµ",
    longleftrightarrow: "â·",
    longmapsto: "â¼",
    longrightarrow: "â¶",
    looparrowleft: "â«",
    looparrowright: "â¬",
    lopar: "â¦",
    lopf: "ð",
    loplus: "â¨­",
    lotimes: "â¨´",
    lowast: "â",
    lowbar: "_",
    loz: "â",
    lozenge: "â",
    lozf: "â§«",
    lpar: "(",
    lparlt: "â¦",
    lrarr: "â",
    lrcorner: "â",
    lrhar: "â",
    lrhard: "â¥­",
    lrm: "â",
    lrtri: "â¿",
    lsaquo: "â¹",
    lscr: "ð",
    lsh: "â°",
    lsim: "â²",
    lsime: "âª",
    lsimg: "âª",
    lsqb: "[",
    lsquo: "â",
    lsquor: "â",
    lstrok: "Å",
    lt: "<",
    ltcc: "âª¦",
    ltcir: "â©¹",
    ltdot: "â",
    lthree: "â",
    ltimes: "â",
    ltlarr: "â¥¶",
    ltquest: "â©»",
    ltrPar: "â¦",
    ltri: "â",
    ltrie: "â´",
    ltrif: "â",
    lurdshar: "â¥",
    luruhar: "â¥¦",
    lvertneqq: "â¨ï¸",
    lvnE: "â¨ï¸",
    mDDot: "âº",
    macr: "Â¯",
    male: "â",
    malt: "â ",
    maltese: "â ",
    map: "â¦",
    mapsto: "â¦",
    mapstodown: "â§",
    mapstoleft: "â¤",
    mapstoup: "â¥",
    marker: "â®",
    mcomma: "â¨©",
    mcy: "Ð¼",
    mdash: "â",
    measuredangle: "â¡",
    mfr: "ðª",
    mho: "â§",
    micro: "Âµ",
    mid: "â£",
    midast: "*",
    midcir: "â«°",
    middot: "Â·",
    minus: "â",
    minusb: "â",
    minusd: "â¸",
    minusdu: "â¨ª",
    mlcp: "â«",
    mldr: "â¦",
    mnplus: "â",
    models: "â§",
    mopf: "ð",
    mp: "â",
    mscr: "ð",
    mstpos: "â¾",
    mu: "Î¼",
    multimap: "â¸",
    mumap: "â¸",
    nGg: "âÌ¸",
    nGt: "â«â",
    nGtv: "â«Ì¸",
    nLeftarrow: "â",
    nLeftrightarrow: "â",
    nLl: "âÌ¸",
    nLt: "âªâ",
    nLtv: "âªÌ¸",
    nRightarrow: "â",
    nVDash: "â¯",
    nVdash: "â®",
    nabla: "â",
    nacute: "Å",
    nang: "â â",
    nap: "â",
    napE: "â©°Ì¸",
    napid: "âÌ¸",
    napos: "Å",
    napprox: "â",
    natur: "â®",
    natural: "â®",
    naturals: "â",
    nbsp: "Â ",
    nbump: "âÌ¸",
    nbumpe: "âÌ¸",
    ncap: "â©",
    ncaron: "Å",
    ncedil: "Å",
    ncong: "â",
    ncongdot: "â©­Ì¸",
    ncup: "â©",
    ncy: "Ð½",
    ndash: "â",
    ne: "â ",
    neArr: "â",
    nearhk: "â¤¤",
    nearr: "â",
    nearrow: "â",
    nedot: "âÌ¸",
    nequiv: "â¢",
    nesear: "â¤¨",
    nesim: "âÌ¸",
    nexist: "â",
    nexists: "â",
    nfr: "ð«",
    ngE: "â§Ì¸",
    nge: "â±",
    ngeq: "â±",
    ngeqq: "â§Ì¸",
    ngeqslant: "â©¾Ì¸",
    nges: "â©¾Ì¸",
    ngsim: "âµ",
    ngt: "â¯",
    ngtr: "â¯",
    nhArr: "â",
    nharr: "â®",
    nhpar: "â«²",
    ni: "â",
    nis: "â¼",
    nisd: "âº",
    niv: "â",
    njcy: "Ñ",
    nlArr: "â",
    nlE: "â¦Ì¸",
    nlarr: "â",
    nldr: "â¥",
    nle: "â°",
    nleftarrow: "â",
    nleftrightarrow: "â®",
    nleq: "â°",
    nleqq: "â¦Ì¸",
    nleqslant: "â©½Ì¸",
    nles: "â©½Ì¸",
    nless: "â®",
    nlsim: "â´",
    nlt: "â®",
    nltri: "âª",
    nltrie: "â¬",
    nmid: "â¤",
    nopf: "ð",
    not: "Â¬",
    notin: "â",
    notinE: "â¹Ì¸",
    notindot: "âµÌ¸",
    notinva: "â",
    notinvb: "â·",
    notinvc: "â¶",
    notni: "â",
    notniva: "â",
    notnivb: "â¾",
    notnivc: "â½",
    npar: "â¦",
    nparallel: "â¦",
    nparsl: "â«½â¥",
    npart: "âÌ¸",
    npolint: "â¨",
    npr: "â",
    nprcue: "â ",
    npre: "âª¯Ì¸",
    nprec: "â",
    npreceq: "âª¯Ì¸",
    nrArr: "â",
    nrarr: "â",
    nrarrc: "â¤³Ì¸",
    nrarrw: "âÌ¸",
    nrightarrow: "â",
    nrtri: "â«",
    nrtrie: "â­",
    nsc: "â",
    nsccue: "â¡",
    nsce: "âª°Ì¸",
    nscr: "ð",
    nshortmid: "â¤",
    nshortparallel: "â¦",
    nsim: "â",
    nsime: "â",
    nsimeq: "â",
    nsmid: "â¤",
    nspar: "â¦",
    nsqsube: "â¢",
    nsqsupe: "â£",
    nsub: "â",
    nsubE: "â«Ì¸",
    nsube: "â",
    nsubset: "ââ",
    nsubseteq: "â",
    nsubseteqq: "â«Ì¸",
    nsucc: "â",
    nsucceq: "âª°Ì¸",
    nsup: "â",
    nsupE: "â«Ì¸",
    nsupe: "â",
    nsupset: "ââ",
    nsupseteq: "â",
    nsupseteqq: "â«Ì¸",
    ntgl: "â¹",
    ntilde: "Ã±",
    ntlg: "â¸",
    ntriangleleft: "âª",
    ntrianglelefteq: "â¬",
    ntriangleright: "â«",
    ntrianglerighteq: "â­",
    nu: "Î½",
    num: "#",
    numero: "â",
    numsp: "â",
    nvDash: "â­",
    nvHarr: "â¤",
    nvap: "ââ",
    nvdash: "â¬",
    nvge: "â¥â",
    nvgt: ">â",
    nvinfin: "â§",
    nvlArr: "â¤",
    nvle: "â¤â",
    nvlt: "<â",
    nvltrie: "â´â",
    nvrArr: "â¤",
    nvrtrie: "âµâ",
    nvsim: "â¼â",
    nwArr: "â",
    nwarhk: "â¤£",
    nwarr: "â",
    nwarrow: "â",
    nwnear: "â¤§",
    oS: "â",
    oacute: "Ã³",
    oast: "â",
    ocir: "â",
    ocirc: "Ã´",
    ocy: "Ð¾",
    odash: "â",
    odblac: "Å",
    odiv: "â¨¸",
    odot: "â",
    odsold: "â¦¼",
    oelig: "Å",
    ofcir: "â¦¿",
    ofr: "ð¬",
    ogon: "Ë",
    ograve: "Ã²",
    ogt: "â§",
    ohbar: "â¦µ",
    ohm: "Î©",
    oint: "â®",
    olarr: "âº",
    olcir: "â¦¾",
    olcross: "â¦»",
    oline: "â¾",
    olt: "â§",
    omacr: "Å",
    omega: "Ï",
    omicron: "Î¿",
    omid: "â¦¶",
    ominus: "â",
    oopf: "ð ",
    opar: "â¦·",
    operp: "â¦¹",
    oplus: "â",
    or: "â¨",
    orarr: "â»",
    ord: "â©",
    order: "â´",
    orderof: "â´",
    ordf: "Âª",
    ordm: "Âº",
    origof: "â¶",
    oror: "â©",
    orslope: "â©",
    orv: "â©",
    oscr: "â´",
    oslash: "Ã¸",
    osol: "â",
    otilde: "Ãµ",
    otimes: "â",
    otimesas: "â¨¶",
    ouml: "Ã¶",
    ovbar: "â½",
    par: "â¥",
    para: "Â¶",
    parallel: "â¥",
    parsim: "â«³",
    parsl: "â«½",
    part: "â",
    pcy: "Ð¿",
    percnt: "%",
    period: ".",
    permil: "â°",
    perp: "â¥",
    pertenk: "â±",
    pfr: "ð­",
    phi: "Ï",
    phiv: "Ï",
    phmmat: "â³",
    phone: "â",
    pi: "Ï",
    pitchfork: "â",
    piv: "Ï",
    planck: "â",
    planckh: "â",
    plankv: "â",
    plus: "+",
    plusacir: "â¨£",
    plusb: "â",
    pluscir: "â¨¢",
    plusdo: "â",
    plusdu: "â¨¥",
    pluse: "â©²",
    plusmn: "Â±",
    plussim: "â¨¦",
    plustwo: "â¨§",
    pm: "Â±",
    pointint: "â¨",
    popf: "ð¡",
    pound: "Â£",
    pr: "âº",
    prE: "âª³",
    prap: "âª·",
    prcue: "â¼",
    pre: "âª¯",
    prec: "âº",
    precapprox: "âª·",
    preccurlyeq: "â¼",
    preceq: "âª¯",
    precnapprox: "âª¹",
    precneqq: "âªµ",
    precnsim: "â¨",
    precsim: "â¾",
    prime: "â²",
    primes: "â",
    prnE: "âªµ",
    prnap: "âª¹",
    prnsim: "â¨",
    prod: "â",
    profalar: "â®",
    profline: "â",
    profsurf: "â",
    prop: "â",
    propto: "â",
    prsim: "â¾",
    prurel: "â°",
    pscr: "ð",
    psi: "Ï",
    puncsp: "â",
    qfr: "ð®",
    qint: "â¨",
    qopf: "ð¢",
    qprime: "â",
    qscr: "ð",
    quaternions: "â",
    quatint: "â¨",
    quest: "?",
    questeq: "â",
    quot: '"',
    rAarr: "â",
    rArr: "â",
    rAtail: "â¤",
    rBarr: "â¤",
    rHar: "â¥¤",
    race: "â½Ì±",
    racute: "Å",
    radic: "â",
    raemptyv: "â¦³",
    rang: "â©",
    rangd: "â¦",
    range: "â¦¥",
    rangle: "â©",
    raquo: "Â»",
    rarr: "â",
    rarrap: "â¥µ",
    rarrb: "â¥",
    rarrbfs: "â¤ ",
    rarrc: "â¤³",
    rarrfs: "â¤",
    rarrhk: "âª",
    rarrlp: "â¬",
    rarrpl: "â¥",
    rarrsim: "â¥´",
    rarrtl: "â£",
    rarrw: "â",
    ratail: "â¤",
    ratio: "â¶",
    rationals: "â",
    rbarr: "â¤",
    rbbrk: "â³",
    rbrace: "}",
    rbrack: "]",
    rbrke: "â¦",
    rbrksld: "â¦",
    rbrkslu: "â¦",
    rcaron: "Å",
    rcedil: "Å",
    rceil: "â",
    rcub: "}",
    rcy: "Ñ",
    rdca: "â¤·",
    rdldhar: "â¥©",
    rdquo: "â",
    rdquor: "â",
    rdsh: "â³",
    real: "â",
    realine: "â",
    realpart: "â",
    reals: "â",
    rect: "â­",
    reg: "Â®",
    rfisht: "â¥½",
    rfloor: "â",
    rfr: "ð¯",
    rhard: "â",
    rharu: "â",
    rharul: "â¥¬",
    rho: "Ï",
    rhov: "Ï±",
    rightarrow: "â",
    rightarrowtail: "â£",
    rightharpoondown: "â",
    rightharpoonup: "â",
    rightleftarrows: "â",
    rightleftharpoons: "â",
    rightrightarrows: "â",
    rightsquigarrow: "â",
    rightthreetimes: "â",
    ring: "Ë",
    risingdotseq: "â",
    rlarr: "â",
    rlhar: "â",
    rlm: "â",
    rmoust: "â±",
    rmoustache: "â±",
    rnmid: "â«®",
    roang: "â­",
    roarr: "â¾",
    robrk: "â§",
    ropar: "â¦",
    ropf: "ð£",
    roplus: "â¨®",
    rotimes: "â¨µ",
    rpar: ")",
    rpargt: "â¦",
    rppolint: "â¨",
    rrarr: "â",
    rsaquo: "âº",
    rscr: "ð",
    rsh: "â±",
    rsqb: "]",
    rsquo: "â",
    rsquor: "â",
    rthree: "â",
    rtimes: "â",
    rtri: "â¹",
    rtrie: "âµ",
    rtrif: "â¸",
    rtriltri: "â§",
    ruluhar: "â¥¨",
    rx: "â",
    sacute: "Å",
    sbquo: "â",
    sc: "â»",
    scE: "âª´",
    scap: "âª¸",
    scaron: "Å¡",
    sccue: "â½",
    sce: "âª°",
    scedil: "Å",
    scirc: "Å",
    scnE: "âª¶",
    scnap: "âªº",
    scnsim: "â©",
    scpolint: "â¨",
    scsim: "â¿",
    scy: "Ñ",
    sdot: "â",
    sdotb: "â¡",
    sdote: "â©¦",
    seArr: "â",
    searhk: "â¤¥",
    searr: "â",
    searrow: "â",
    sect: "Â§",
    semi: ";",
    seswar: "â¤©",
    setminus: "â",
    setmn: "â",
    sext: "â¶",
    sfr: "ð°",
    sfrown: "â¢",
    sharp: "â¯",
    shchcy: "Ñ",
    shcy: "Ñ",
    shortmid: "â£",
    shortparallel: "â¥",
    shy: "Â­",
    sigma: "Ï",
    sigmaf: "Ï",
    sigmav: "Ï",
    sim: "â¼",
    simdot: "â©ª",
    sime: "â",
    simeq: "â",
    simg: "âª",
    simgE: "âª ",
    siml: "âª",
    simlE: "âª",
    simne: "â",
    simplus: "â¨¤",
    simrarr: "â¥²",
    slarr: "â",
    smallsetminus: "â",
    smashp: "â¨³",
    smeparsl: "â§¤",
    smid: "â£",
    smile: "â£",
    smt: "âªª",
    smte: "âª¬",
    smtes: "âª¬ï¸",
    softcy: "Ñ",
    sol: "/",
    solb: "â§",
    solbar: "â¿",
    sopf: "ð¤",
    spades: "â ",
    spadesuit: "â ",
    spar: "â¥",
    sqcap: "â",
    sqcaps: "âï¸",
    sqcup: "â",
    sqcups: "âï¸",
    sqsub: "â",
    sqsube: "â",
    sqsubset: "â",
    sqsubseteq: "â",
    sqsup: "â",
    sqsupe: "â",
    sqsupset: "â",
    sqsupseteq: "â",
    squ: "â¡",
    square: "â¡",
    squarf: "âª",
    squf: "âª",
    srarr: "â",
    sscr: "ð",
    ssetmn: "â",
    ssmile: "â£",
    sstarf: "â",
    star: "â",
    starf: "â",
    straightepsilon: "Ïµ",
    straightphi: "Ï",
    strns: "Â¯",
    sub: "â",
    subE: "â«",
    subdot: "âª½",
    sube: "â",
    subedot: "â«",
    submult: "â«",
    subnE: "â«",
    subne: "â",
    subplus: "âª¿",
    subrarr: "â¥¹",
    subset: "â",
    subseteq: "â",
    subseteqq: "â«",
    subsetneq: "â",
    subsetneqq: "â«",
    subsim: "â«",
    subsub: "â«",
    subsup: "â«",
    succ: "â»",
    succapprox: "âª¸",
    succcurlyeq: "â½",
    succeq: "âª°",
    succnapprox: "âªº",
    succneqq: "âª¶",
    succnsim: "â©",
    succsim: "â¿",
    sum: "â",
    sung: "âª",
    sup1: "Â¹",
    sup2: "Â²",
    sup3: "Â³",
    sup: "â",
    supE: "â«",
    supdot: "âª¾",
    supdsub: "â«",
    supe: "â",
    supedot: "â«",
    suphsol: "â",
    suphsub: "â«",
    suplarr: "â¥»",
    supmult: "â«",
    supnE: "â«",
    supne: "â",
    supplus: "â«",
    supset: "â",
    supseteq: "â",
    supseteqq: "â«",
    supsetneq: "â",
    supsetneqq: "â«",
    supsim: "â«",
    supsub: "â«",
    supsup: "â«",
    swArr: "â",
    swarhk: "â¤¦",
    swarr: "â",
    swarrow: "â",
    swnwar: "â¤ª",
    szlig: "Ã",
    target: "â",
    tau: "Ï",
    tbrk: "â´",
    tcaron: "Å¥",
    tcedil: "Å£",
    tcy: "Ñ",
    tdot: "â",
    telrec: "â",
    tfr: "ð±",
    there4: "â´",
    therefore: "â´",
    theta: "Î¸",
    thetasym: "Ï",
    thetav: "Ï",
    thickapprox: "â",
    thicksim: "â¼",
    thinsp: "â",
    thkap: "â",
    thksim: "â¼",
    thorn: "Ã¾",
    tilde: "Ë",
    times: "Ã",
    timesb: "â ",
    timesbar: "â¨±",
    timesd: "â¨°",
    tint: "â­",
    toea: "â¤¨",
    top: "â¤",
    topbot: "â¶",
    topcir: "â«±",
    topf: "ð¥",
    topfork: "â«",
    tosa: "â¤©",
    tprime: "â´",
    trade: "â¢",
    triangle: "âµ",
    triangledown: "â¿",
    triangleleft: "â",
    trianglelefteq: "â´",
    triangleq: "â",
    triangleright: "â¹",
    trianglerighteq: "âµ",
    tridot: "â¬",
    trie: "â",
    triminus: "â¨º",
    triplus: "â¨¹",
    trisb: "â§",
    tritime: "â¨»",
    trpezium: "â¢",
    tscr: "ð",
    tscy: "Ñ",
    tshcy: "Ñ",
    tstrok: "Å§",
    twixt: "â¬",
    twoheadleftarrow: "â",
    twoheadrightarrow: "â ",
    uArr: "â",
    uHar: "â¥£",
    uacute: "Ãº",
    uarr: "â",
    ubrcy: "Ñ",
    ubreve: "Å­",
    ucirc: "Ã»",
    ucy: "Ñ",
    udarr: "â",
    udblac: "Å±",
    udhar: "â¥®",
    ufisht: "â¥¾",
    ufr: "ð²",
    ugrave: "Ã¹",
    uharl: "â¿",
    uharr: "â¾",
    uhblk: "â",
    ulcorn: "â",
    ulcorner: "â",
    ulcrop: "â",
    ultri: "â¸",
    umacr: "Å«",
    uml: "Â¨",
    uogon: "Å³",
    uopf: "ð¦",
    uparrow: "â",
    updownarrow: "â",
    upharpoonleft: "â¿",
    upharpoonright: "â¾",
    uplus: "â",
    upsi: "Ï",
    upsih: "Ï",
    upsilon: "Ï",
    upuparrows: "â",
    urcorn: "â",
    urcorner: "â",
    urcrop: "â",
    uring: "Å¯",
    urtri: "â¹",
    uscr: "ð",
    utdot: "â°",
    utilde: "Å©",
    utri: "âµ",
    utrif: "â´",
    uuarr: "â",
    uuml: "Ã¼",
    uwangle: "â¦§",
    vArr: "â",
    vBar: "â«¨",
    vBarv: "â«©",
    vDash: "â¨",
    vangrt: "â¦",
    varepsilon: "Ïµ",
    varkappa: "Ï°",
    varnothing: "â",
    varphi: "Ï",
    varpi: "Ï",
    varpropto: "â",
    varr: "â",
    varrho: "Ï±",
    varsigma: "Ï",
    varsubsetneq: "âï¸",
    varsubsetneqq: "â«ï¸",
    varsupsetneq: "âï¸",
    varsupsetneqq: "â«ï¸",
    vartheta: "Ï",
    vartriangleleft: "â²",
    vartriangleright: "â³",
    vcy: "Ð²",
    vdash: "â¢",
    vee: "â¨",
    veebar: "â»",
    veeeq: "â",
    vellip: "â®",
    verbar: "|",
    vert: "|",
    vfr: "ð³",
    vltri: "â²",
    vnsub: "ââ",
    vnsup: "ââ",
    vopf: "ð§",
    vprop: "â",
    vrtri: "â³",
    vscr: "ð",
    vsubnE: "â«ï¸",
    vsubne: "âï¸",
    vsupnE: "â«ï¸",
    vsupne: "âï¸",
    vzigzag: "â¦",
    wcirc: "Åµ",
    wedbar: "â©",
    wedge: "â§",
    wedgeq: "â",
    weierp: "â",
    wfr: "ð´",
    wopf: "ð¨",
    wp: "â",
    wr: "â",
    wreath: "â",
    wscr: "ð",
    xcap: "â",
    xcirc: "â¯",
    xcup: "â",
    xdtri: "â½",
    xfr: "ðµ",
    xhArr: "âº",
    xharr: "â·",
    xi: "Î¾",
    xlArr: "â¸",
    xlarr: "âµ",
    xmap: "â¼",
    xnis: "â»",
    xodot: "â¨",
    xopf: "ð©",
    xoplus: "â¨",
    xotime: "â¨",
    xrArr: "â¹",
    xrarr: "â¶",
    xscr: "ð",
    xsqcup: "â¨",
    xuplus: "â¨",
    xutri: "â³",
    xvee: "â",
    xwedge: "â",
    yacute: "Ã½",
    yacy: "Ñ",
    ycirc: "Å·",
    ycy: "Ñ",
    yen: "Â¥",
    yfr: "ð¶",
    yicy: "Ñ",
    yopf: "ðª",
    yscr: "ð",
    yucy: "Ñ",
    yuml: "Ã¿",
    zacute: "Åº",
    zcaron: "Å¾",
    zcy: "Ð·",
    zdot: "Å¼",
    zeetrf: "â¨",
    zeta: "Î¶",
    zfr: "ð·",
    zhcy: "Ð¶",
    zigrarr: "â",
    zopf: "ð«",
    zscr: "ð",
    zwj: "â",
    zwnj: "â"
  };
  const own$1 = {}.hasOwnProperty;
  function decodeNamedCharacterReference(value2) {
    return own$1.call(characterEntities, value2) ? characterEntities[value2] : false;
  }
  function decodeNumericCharacterReference$1(value2, base2) {
    const code2 = Number.parseInt(value2, base2);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
      code2 > 1114111
    ) {
      return "ï¿½";
    }
    return String.fromCharCode(code2);
  }
  const characterEscapeOrReference$1 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString$1(value2) {
    return value2.replace(characterEscapeOrReference$1, decode$1);
  }
  function decode$1($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head2 = $2.charCodeAt(0);
    if (head2 === 35) {
      const head3 = $2.charCodeAt(1);
      const hex2 = head3 === 120 || head3 === 88;
      return decodeNumericCharacterReference$1($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  function association$1(node2) {
    if (node2.label || !node2.identifier) {
      return node2.label || "";
    }
    return decodeString$1(node2.identifier);
  }
  function containerPhrasing$1(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const results = [];
    let index2 = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while (++index2 < children.length) {
      const child = children[index2];
      let after;
      indexStack[indexStack.length - 1] = index2;
      if (index2 + 1 < children.length) {
        let handle2 = state.handle.handlers[children[index2 + 1].type];
        if (handle2 && handle2.peek)
          handle2 = handle2.peek;
        after = handle2 ? handle2(children[index2 + 1], parent, state, {
          before: "",
          after: "",
          ...tracker.current()
        }).charAt(0) : "";
      } else {
        after = info.after;
      }
      if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(
          /(\r?\n|\r)$/,
          " "
        );
        before = " ";
        tracker = state.createTracker(info);
        tracker.move(results.join(""));
      }
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            ...tracker.current(),
            before,
            after
          })
        )
      );
      before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join("");
  }
  function containerFlow$1(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    const results = [];
    let index2 = -1;
    indexStack.push(-1);
    while (++index2 < children.length) {
      const child = children[index2];
      indexStack[indexStack.length - 1] = index2;
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            before: "\n",
            after: "\n",
            ...tracker.current()
          })
        )
      );
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index2 < children.length - 1) {
        results.push(
          tracker.move(between$1(child, children[index2 + 1], parent, state))
        );
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function between$1(left, right, parent, state) {
    let index2 = state.join.length;
    while (index2--) {
      const result = state.join[index2](left, right, parent, state);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
  const eol$1 = /\r?\n|\r/g;
  function indentLines$1(value2, map2) {
    const result = [];
    let start = 0;
    let line2 = 0;
    let match2;
    while (match2 = eol$1.exec(value2)) {
      one2(value2.slice(start, match2.index));
      result.push(match2[0]);
      start = match2.index + match2[0].length;
      line2++;
    }
    one2(value2.slice(start));
    return result.join("");
    function one2(value3) {
      result.push(map2(value3, line2, !value3));
    }
  }
  function safe$1(state, input2, config2) {
    const value2 = (config2.before || "") + (input2 || "") + (config2.after || "");
    const positions = [];
    const result = [];
    const infos = {};
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      if (!patternInScope$1(state.stack, pattern)) {
        continue;
      }
      const expression = patternCompile(pattern);
      let match2;
      while (match2 = expression.exec(value2)) {
        const before = "before" in pattern || Boolean(pattern.atBreak);
        const after = "after" in pattern;
        const position2 = match2.index + (before ? match2[1].length : 0);
        if (positions.includes(position2)) {
          if (infos[position2].before && !before) {
            infos[position2].before = false;
          }
          if (infos[position2].after && !after) {
            infos[position2].after = false;
          }
        } else {
          positions.push(position2);
          infos[position2] = { before, after };
        }
      }
    }
    positions.sort(numerical$1);
    let start = config2.before ? config2.before.length : 0;
    const end2 = value2.length - (config2.after ? config2.after.length : 0);
    index2 = -1;
    while (++index2 < positions.length) {
      const position2 = positions[index2];
      if (position2 < start || position2 >= end2) {
        continue;
      }
      if (position2 + 1 < end2 && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
        continue;
      }
      if (start !== position2) {
        result.push(escapeBackslashes$1(value2.slice(start, position2), "\\"));
      }
      start = position2;
      if (/[!-/:-@[-`{-~]/.test(value2.charAt(position2)) && (!config2.encode || !config2.encode.includes(value2.charAt(position2)))) {
        result.push("\\");
      } else {
        result.push(
          "&#x" + value2.charCodeAt(position2).toString(16).toUpperCase() + ";"
        );
        start++;
      }
    }
    result.push(escapeBackslashes$1(value2.slice(start, end2), config2.after));
    return result.join("");
  }
  function numerical$1(a2, b) {
    return a2 - b;
  }
  function escapeBackslashes$1(value2, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    const positions = [];
    const results = [];
    const whole = value2 + after;
    let index2 = -1;
    let start = 0;
    let match2;
    while (match2 = expression.exec(whole)) {
      positions.push(match2.index);
    }
    while (++index2 < positions.length) {
      if (start !== positions[index2]) {
        results.push(value2.slice(start, positions[index2]));
      }
      results.push("\\");
      start = positions[index2];
    }
    results.push(value2.slice(start));
    return results.join("");
  }
  function track$1(config2) {
    const options2 = config2 || {};
    const now = options2.now || {};
    let lineShift = options2.lineShift || 0;
    let line2 = now.line || 1;
    let column = now.column || 1;
    return { move, current, shift };
    function current() {
      return { now: { line: line2, column }, lineShift };
    }
    function shift(value2) {
      lineShift += value2;
    }
    function move(input2) {
      const value2 = input2 || "";
      const chunks = value2.split(/\r?\n|\r/g);
      const tail = chunks[chunks.length - 1];
      line2 += chunks.length - 1;
      column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
      return value2;
    }
  }
  function toMarkdown$1(tree, options2 = {}) {
    const state = {
      enter,
      indentLines: indentLines$1,
      associationId: association$1,
      containerPhrasing: containerPhrasingBound$1,
      containerFlow: containerFlowBound$1,
      createTracker: track$1,
      safe: safeBound$1,
      stack: [],
      unsafe: [],
      join: [],
      // @ts-expect-error: weâll fill it next.
      handlers: {},
      options: {},
      indexStack: [],
      // @ts-expect-error: weâll add `handle` later.
      handle: void 0
    };
    configure$1(state, { unsafe: unsafe$1, join: join$2, handlers: handle$1 });
    configure$1(state, options2);
    if (state.options.tightDefinitions) {
      configure$1(state, { join: [joinDefinition$1] });
    }
    state.handle = zwitch("type", {
      invalid: invalid$1,
      unknown: unknown$1,
      handlers: state.handlers
    });
    let result = state.handle(tree, void 0, state, {
      before: "\n",
      after: "\n",
      now: { line: 1, column: 1 },
      lineShift: 0
    });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += "\n";
    }
    return result;
    function enter(name2) {
      state.stack.push(name2);
      return exit;
      function exit() {
        state.stack.pop();
      }
    }
  }
  function invalid$1(value2) {
    throw new Error("Cannot handle value `" + value2 + "`, expected node");
  }
  function unknown$1(node2) {
    throw new Error("Cannot handle unknown node `" + node2.type + "`");
  }
  function joinDefinition$1(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
  function containerPhrasingBound$1(parent, info) {
    return containerPhrasing$1(parent, this, info);
  }
  function containerFlowBound$1(parent, info) {
    return containerFlow$1(parent, this, info);
  }
  function safeBound$1(value2, config2) {
    return safe$1(this, value2, config2);
  }
  function remarkStringify(options2) {
    const compiler2 = (tree) => {
      const settings = (
        /** @type {Options} */
        this.data("settings")
      );
      return toMarkdown$1(
        tree,
        Object.assign({}, settings, options2, {
          // Note: this option is not in the readme.
          // The goal is for it to be set by plugins on `data` instead of being
          // passed by users.
          extensions: (
            /** @type {ToMarkdownOptions['extensions']} */
            this.data("toMarkdownExtensions") || []
          )
        })
      );
    };
    Object.assign(this, { Compiler: compiler2 });
  }
  var defaultHandlers = {
    span(state, node2, parent) {
      const className = node2.properties.className || [];
      if (className.includes("inline-math")) {
        return { type: "html", value: `$${toString$1(node2)}$` };
      }
      return state.all(node2);
    },
    div(state, node2, parent) {
      const className = node2.properties.className || [];
      if (className.includes("display-math")) {
        return { type: "code", lang: "math", value: toString$1(node2) };
      }
      return state.all(node2);
    }
  };
  var unifiedLatexToMdast = function unifiedLatexToMdast2(options2) {
    const handlers2 = Object.assign({}, defaultHandlers, options2 == null ? void 0 : options2.handlers);
    options2 = Object.assign({}, options2, { handlers: handlers2 });
    return (tree, file) => {
      const mdast = unified().use(unifiedLatexToHast, options2).use(rehypeRemark, options2).runSync(tree, file);
      return mdast;
    };
  };
  processLatexViaUnified().use(unifiedLatexToMdast).use(remarkStringify);
  const own = {}.hasOwnProperty;
  function configure(base2, extension) {
    let index2 = -1;
    let key2;
    if (extension.extensions) {
      while (++index2 < extension.extensions.length) {
        configure(base2, extension.extensions[index2]);
      }
    }
    for (key2 in extension) {
      if (own.call(extension, key2)) {
        switch (key2) {
          case "extensions": {
            break;
          }
          case "unsafe": {
            list$1(base2[key2], extension[key2]);
            break;
          }
          case "join": {
            list$1(base2[key2], extension[key2]);
            break;
          }
          case "handlers": {
            map$2(base2[key2], extension[key2]);
            break;
          }
          default: {
            base2.options[key2] = extension[key2];
          }
        }
      }
    }
    return base2;
  }
  function list$1(left, right) {
    if (right) {
      left.push(...right);
    }
  }
  function map$2(left, right) {
    if (right) {
      Object.assign(left, right);
    }
  }
  function blockquote(node2, _, state, info) {
    const exit = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value2 = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map$1
    );
    exit();
    return value2;
  }
  function map$1(line2, _, blank) {
    return ">" + (blank ? "" : " ") + line2;
  }
  function patternInScope(stack2, pattern) {
    return listInScope(stack2, pattern.inConstruct, true) && !listInScope(stack2, pattern.notInConstruct, false);
  }
  function listInScope(stack2, list2, none) {
    if (typeof list2 === "string") {
      list2 = [list2];
    }
    if (!list2 || list2.length === 0) {
      return none;
    }
    let index2 = -1;
    while (++index2 < list2.length) {
      if (stack2.includes(list2[index2])) {
        return true;
      }
    }
    return false;
  }
  function hardBreak(_, _1, state, info) {
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
  function formatCodeAsIndented(node2, state) {
    return Boolean(
      state.options.fences === false && node2.value && // If thereâs no infoâ¦
      !node2.lang && // And thereâs a non-whitespace characterâ¦
      /[^ \r\n]/.test(node2.value) && // And the value doesnât start or end in a blankâ¦
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
    );
  }
  function checkFence(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }
  function code(node2, _, state, info) {
    const marker = checkFence(state);
    const raw2 = node2.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node2, state)) {
      const exit2 = state.enter("codeIndented");
      const value3 = state.indentLines(raw2, map);
      exit2();
      return value3;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
    const exit = state.enter("codeFenced");
    let value2 = tracker.move(sequence);
    if (node2.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value2 += tracker.move(
        state.safe(node2.lang, {
          before: value2,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node2.lang && node2.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value2 += tracker.move(" ");
      value2 += tracker.move(
        state.safe(node2.meta, {
          before: value2,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value2 += tracker.move("\n");
    if (raw2) {
      value2 += tracker.move(raw2 + "\n");
    }
    value2 += tracker.move(sequence);
    exit();
    return value2;
  }
  function map(line2, _, blank) {
    return (blank ? "" : "    ") + line2;
  }
  function checkQuote(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }
  function definition(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("[");
    value2 += tracker.move(
      state.safe(state.associationId(node2), {
        before: value2,
        after: "]",
        ...tracker.current()
      })
    );
    value2 += tracker.move("]: ");
    subexit();
    if (
      // If thereâs no url, orâ¦
      !node2.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    exit();
    return value2;
  }
  function checkEmphasis(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  emphasis.peek = emphasisPeek;
  function emphasis(node2, _, state, info) {
    const marker = checkEmphasis(state);
    const exit = state.enter("emphasis");
    const tracker = state.createTracker(info);
    let value2 = tracker.move(marker);
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: marker,
        ...tracker.current()
      })
    );
    value2 += tracker.move(marker);
    exit();
    return value2;
  }
  function emphasisPeek(_, _1, state) {
    return state.options.emphasis || "*";
  }
  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test;
    let visitor2;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test = void 0;
      visitor2 = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test = testOrVisitor;
      visitor2 = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      const index2 = parent ? parent.children.indexOf(node2) : void 0;
      return visitor2(node2, index2, parent);
    }
  }
  function formatHeadingAsSetext(node2, state) {
    let literalWithBreak = false;
    visit(node2, function(node3) {
      if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
        literalWithBreak = true;
        return EXIT;
      }
    });
    return Boolean(
      (!node2.depth || node2.depth < 3) && toString$2(node2) && (state.options.setext || literalWithBreak)
    );
  }
  function heading(node2, _, state, info) {
    const rank = Math.max(Math.min(6, node2.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node2, state)) {
      const exit2 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value3 = state.containerPhrasing(node2, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit2();
      return value3 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole sizeâ¦
        value3.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)â¦
        (Math.max(value3.lastIndexOf("\r"), value3.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value2 = state.containerPhrasing(node2, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value2)) {
      value2 = "&#x" + value2.charCodeAt(0).toString(16).toUpperCase() + ";" + value2.slice(1);
    }
    value2 = value2 ? sequence + " " + value2 : sequence;
    if (state.options.closeAtx) {
      value2 += " " + sequence;
    }
    subexit();
    exit();
    return value2;
  }
  html.peek = htmlPeek;
  function html(node2) {
    return node2.value || "";
  }
  function htmlPeek() {
    return "<";
  }
  image.peek = imagePeek;
  function image(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("![");
    value2 += tracker.move(
      state.safe(node2.alt, { before: value2, after: "]", ...tracker.current() })
    );
    value2 += tracker.move("](");
    subexit();
    if (
      // If thereâs no url but there is a titleâ¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    value2 += tracker.move(")");
    exit();
    return value2;
  }
  function imagePeek() {
    return "!";
  }
  imageReference.peek = imageReferencePeek;
  function imageReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("![");
    const alt = state.safe(node2.alt, {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    value2 += tracker.move(alt + "][");
    subexit();
    const stack2 = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack2;
    exit();
    if (type === "full" || !alt || alt !== reference) {
      value2 += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value2 = value2.slice(0, -1);
    } else {
      value2 += tracker.move("]");
    }
    return value2;
  }
  function imageReferencePeek() {
    return "!";
  }
  inlineCode.peek = inlineCodePeek;
  function inlineCode(node2, _, state) {
    let value2 = node2.value || "";
    let sequence = "`";
    let index2 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value2)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value2) && (/^[ \r\n]/.test(value2) && /[ \r\n]$/.test(value2) || /^`|`$/.test(value2))) {
      value2 = " " + value2 + " ";
    }
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      const expression = state.compilePattern(pattern);
      let match2;
      if (!pattern.atBreak)
        continue;
      while (match2 = expression.exec(value2)) {
        let position2 = match2.index;
        if (value2.charCodeAt(position2) === 10 && value2.charCodeAt(position2 - 1) === 13) {
          position2--;
        }
        value2 = value2.slice(0, position2) + " " + value2.slice(match2.index + 1);
      }
    }
    return sequence + value2 + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }
  function formatLinkAsAutolink(node2, state) {
    const raw2 = toString$2(node2);
    return Boolean(
      !state.options.resourceLink && // If thereâs a urlâ¦
      node2.url && // And thereâs a no titleâ¦
      !node2.title && // And the content of `node` is a single text nodeâ¦
      node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the contentâ¦
      (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocolâ¦
      /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnât contain ASCII control codes (character escapes and
      // references donât work), space, or angle bracketsâ¦
      !/[\0- <>\u007F]/.test(node2.url)
    );
  }
  link.peek = linkPeek;
  function link(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit;
    let subexit;
    if (formatLinkAsAutolink(node2, state)) {
      const stack2 = state.stack;
      state.stack = [];
      exit = state.enter("autolink");
      let value3 = tracker.move("<");
      value3 += tracker.move(
        state.containerPhrasing(node2, {
          before: value3,
          after: ">",
          ...tracker.current()
        })
      );
      value3 += tracker.move(">");
      exit();
      state.stack = stack2;
      return value3;
    }
    exit = state.enter("link");
    subexit = state.enter("label");
    let value2 = tracker.move("[");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: "](",
        ...tracker.current()
      })
    );
    value2 += tracker.move("](");
    subexit();
    if (
      // If thereâs no url but there is a titleâ¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value2 += tracker.move("<");
      value2 += tracker.move(
        state.safe(node2.url, { before: value2, after: ">", ...tracker.current() })
      );
      value2 += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value2 += tracker.move(
        state.safe(node2.url, {
          before: value2,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value2 += tracker.move(" " + quote);
      value2 += tracker.move(
        state.safe(node2.title, {
          before: value2,
          after: quote,
          ...tracker.current()
        })
      );
      value2 += tracker.move(quote);
      subexit();
    }
    value2 += tracker.move(")");
    exit();
    return value2;
  }
  function linkPeek(node2, _, state) {
    return formatLinkAsAutolink(node2, state) ? "<" : "[";
  }
  linkReference.peek = linkReferencePeek;
  function linkReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value2 = tracker.move("[");
    const text2 = state.containerPhrasing(node2, {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    value2 += tracker.move(text2 + "][");
    subexit();
    const stack2 = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value2,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack2;
    exit();
    if (type === "full" || !text2 || text2 !== reference) {
      value2 += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value2 = value2.slice(0, -1);
    } else {
      value2 += tracker.move("]");
    }
    return value2;
  }
  function linkReferencePeek() {
    return "[";
  }
  function checkBullet(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }
  function checkBulletOrdered(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }
  function checkRule(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }
  function list(node2, parent, state, info) {
    const exit = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
    let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
    if (!node2.ordered) {
      const firstListItem = node2.children ? node2.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index2 = -1;
        while (++index2 < node2.children.length) {
          const item = node2.children[index2];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value2 = state.containerFlow(node2, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit();
    return value2;
  }
  function checkListItemIndent(state) {
    const style2 = state.options.listItemIndent || "one";
    if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style2;
  }
  function listItem(node2, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size - bullet.length));
    tracker.shift(size);
    const exit = state.enter("listItem");
    const value2 = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map2
    );
    exit();
    return value2;
    function map2(line2, index2, blank) {
      if (index2) {
        return (blank ? "" : " ".repeat(size)) + line2;
      }
      return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
    }
  }
  function paragraph(node2, _, state, info) {
    const exit = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, info);
    subexit();
    exit();
    return value2;
  }
  function root(node2, _, state, info) {
    const hasPhrasing = node2.children.some(function(d) {
      return phrasing$2(d);
    });
    const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return fn.call(state, node2, info);
  }
  function checkStrong(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  strong.peek = strongPeek;
  function strong(node2, _, state, info) {
    const marker = checkStrong(state);
    const exit = state.enter("strong");
    const tracker = state.createTracker(info);
    let value2 = tracker.move(marker + marker);
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: marker,
        ...tracker.current()
      })
    );
    value2 += tracker.move(marker + marker);
    exit();
    return value2;
  }
  function strongPeek(_, _1, state) {
    return state.options.strong || "*";
  }
  function text(node2, _, state, info) {
    return state.safe(node2.value, info);
  }
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }
  function thematicBreak(_, _1, state) {
    const value2 = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value2.slice(0, -1) : value2;
  }
  const handle = {
    blockquote,
    break: hardBreak,
    code,
    definition,
    emphasis,
    hardBreak,
    heading,
    html,
    image,
    imageReference,
    inlineCode,
    link,
    linkReference,
    list,
    listItem,
    paragraph,
    root,
    strong,
    text,
    thematicBreak
  };
  const join$1 = [joinDefaults];
  function joinDefaults(left, right, parent, state) {
    if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
      return false;
    }
    if ("spread" in parent && typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && // Two paragraphs.
      (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
      right.type === "heading" && formatHeadingAsSetext(right, state))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }
  const fullPhrasingSpans = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  const unsafe = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: "	",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: "\n",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: " ",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    // An exclamation mark can start an image, if it is followed by a link or
    // a link reference.
    {
      character: "!",
      after: "\\[",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A quote can break out of a title.
    { character: '"', inConstruct: "titleQuote" },
    // A number sign could start an ATX heading if it starts a line.
    { atBreak: true, character: "#" },
    { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
    // Dollar sign and percentage are not used in markdown.
    // An ampersand could start a character reference.
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    // An apostrophe can break out of a title.
    { character: "'", inConstruct: "titleApostrophe" },
    // A left paren could break out of a destination raw.
    { character: "(", inConstruct: "destinationRaw" },
    // A left paren followed by `]` could make something into a link or image.
    {
      before: "\\]",
      character: "(",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A right paren could start a list item or break out of a destination
    // raw.
    { atBreak: true, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    // An asterisk can start thematic breaks, list items, emphasis, strong.
    { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
    { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A plus sign could start a list item.
    { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
    // A dash can start thematic breaks, list items, and setext heading
    // underlines.
    { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
    // A dot could start a list item.
    { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
    // Slash, colon, and semicolon are not used in markdown for constructs.
    // A less than can start html (flow or text) or an autolink.
    // HTML could start with an exclamation mark (declaration, cdata, comment),
    // slash (closing tag), question mark (instruction), or a letter (tag).
    // An autolink also starts with a letter.
    // Finally, it could break out of a destination literal.
    { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
    {
      character: "<",
      after: "[!/?A-Za-z]",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    { character: "<", inConstruct: "destinationLiteral" },
    // An equals to can start setext heading underlines.
    { atBreak: true, character: "=" },
    // A greater than can start block quotes and it can break out of a
    // destination literal.
    { atBreak: true, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    // Question mark and at sign are not used in markdown for constructs.
    // A left bracket can start definitions, references, labels,
    { atBreak: true, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    { character: "[", inConstruct: ["label", "reference"] },
    // A backslash can start an escape (when followed by punctuation) or a
    // hard break (when followed by an eol).
    // Note: typical escapes are handled in `safe`!
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    // A right bracket can exit labels.
    { character: "]", inConstruct: ["label", "reference"] },
    // Caret is not used in markdown for constructs.
    // An underscore can start emphasis, strong, or a thematic break.
    { atBreak: true, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A grave accent can start code (fenced or text), or it can break out of
    // a grave accent code fence.
    { atBreak: true, character: "`" },
    {
      character: "`",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
    },
    { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // Left brace, vertical bar, right brace are not used in markdown for
    // constructs.
    // A tilde can start code (fenced).
    { atBreak: true, character: "~" }
  ];
  function decodeNumericCharacterReference(value2, base2) {
    const code2 = Number.parseInt(value2, base2);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
      code2 > 1114111
    ) {
      return "ï¿½";
    }
    return String.fromCharCode(code2);
  }
  const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(value2) {
    return value2.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head2 = $2.charCodeAt(0);
    if (head2 === 35) {
      const head3 = $2.charCodeAt(1);
      const hex2 = head3 === 120 || head3 === 88;
      return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  function association(node2) {
    if (node2.label || !node2.identifier) {
      return node2.label || "";
    }
    return decodeString(node2.identifier);
  }
  function compilePattern(pattern) {
    if (!pattern._compiled) {
      const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
      pattern._compiled = new RegExp(
        (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
        "g"
      );
    }
    return pattern._compiled;
  }
  function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const results = [];
    let index2 = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while (++index2 < children.length) {
      const child = children[index2];
      let after;
      indexStack[indexStack.length - 1] = index2;
      if (index2 + 1 < children.length) {
        let handle2 = state.handle.handlers[children[index2 + 1].type];
        if (handle2 && handle2.peek)
          handle2 = handle2.peek;
        after = handle2 ? handle2(children[index2 + 1], parent, state, {
          before: "",
          after: "",
          ...tracker.current()
        }).charAt(0) : "";
      } else {
        after = info.after;
      }
      if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(
          /(\r?\n|\r)$/,
          " "
        );
        before = " ";
        tracker = state.createTracker(info);
        tracker.move(results.join(""));
      }
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            ...tracker.current(),
            before,
            after
          })
        )
      );
      before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join("");
  }
  function containerFlow(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    const results = [];
    let index2 = -1;
    indexStack.push(-1);
    while (++index2 < children.length) {
      const child = children[index2];
      indexStack[indexStack.length - 1] = index2;
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            before: "\n",
            after: "\n",
            ...tracker.current()
          })
        )
      );
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index2 < children.length - 1) {
        results.push(
          tracker.move(between(child, children[index2 + 1], parent, state))
        );
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function between(left, right, parent, state) {
    let index2 = state.join.length;
    while (index2--) {
      const result = state.join[index2](left, right, parent, state);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
  const eol = /\r?\n|\r/g;
  function indentLines(value2, map2) {
    const result = [];
    let start = 0;
    let line2 = 0;
    let match2;
    while (match2 = eol.exec(value2)) {
      one2(value2.slice(start, match2.index));
      result.push(match2[0]);
      start = match2.index + match2[0].length;
      line2++;
    }
    one2(value2.slice(start));
    return result.join("");
    function one2(value3) {
      result.push(map2(value3, line2, !value3));
    }
  }
  function safe(state, input2, config2) {
    const value2 = (config2.before || "") + (input2 || "") + (config2.after || "");
    const positions = [];
    const result = [];
    const infos = {};
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      if (!patternInScope(state.stack, pattern)) {
        continue;
      }
      const expression = state.compilePattern(pattern);
      let match2;
      while (match2 = expression.exec(value2)) {
        const before = "before" in pattern || Boolean(pattern.atBreak);
        const after = "after" in pattern;
        const position2 = match2.index + (before ? match2[1].length : 0);
        if (positions.includes(position2)) {
          if (infos[position2].before && !before) {
            infos[position2].before = false;
          }
          if (infos[position2].after && !after) {
            infos[position2].after = false;
          }
        } else {
          positions.push(position2);
          infos[position2] = { before, after };
        }
      }
    }
    positions.sort(numerical);
    let start = config2.before ? config2.before.length : 0;
    const end2 = value2.length - (config2.after ? config2.after.length : 0);
    index2 = -1;
    while (++index2 < positions.length) {
      const position2 = positions[index2];
      if (position2 < start || position2 >= end2) {
        continue;
      }
      if (position2 + 1 < end2 && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
        continue;
      }
      if (start !== position2) {
        result.push(escapeBackslashes(value2.slice(start, position2), "\\"));
      }
      start = position2;
      if (/[!-/:-@[-`{-~]/.test(value2.charAt(position2)) && (!config2.encode || !config2.encode.includes(value2.charAt(position2)))) {
        result.push("\\");
      } else {
        result.push(
          "&#x" + value2.charCodeAt(position2).toString(16).toUpperCase() + ";"
        );
        start++;
      }
    }
    result.push(escapeBackslashes(value2.slice(start, end2), config2.after));
    return result.join("");
  }
  function numerical(a2, b) {
    return a2 - b;
  }
  function escapeBackslashes(value2, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    const positions = [];
    const results = [];
    const whole = value2 + after;
    let index2 = -1;
    let start = 0;
    let match2;
    while (match2 = expression.exec(whole)) {
      positions.push(match2.index);
    }
    while (++index2 < positions.length) {
      if (start !== positions[index2]) {
        results.push(value2.slice(start, positions[index2]));
      }
      results.push("\\");
      start = positions[index2];
    }
    results.push(value2.slice(start));
    return results.join("");
  }
  function track(config2) {
    const options2 = config2 || {};
    const now = options2.now || {};
    let lineShift = options2.lineShift || 0;
    let line2 = now.line || 1;
    let column = now.column || 1;
    return { move, current, shift };
    function current() {
      return { now: { line: line2, column }, lineShift };
    }
    function shift(value2) {
      lineShift += value2;
    }
    function move(input2) {
      const value2 = input2 || "";
      const chunks = value2.split(/\r?\n|\r/g);
      const tail = chunks[chunks.length - 1];
      line2 += chunks.length - 1;
      column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
      return value2;
    }
  }
  function toMarkdown(tree, options2 = {}) {
    const state = {
      enter,
      indentLines,
      associationId: association,
      containerPhrasing: containerPhrasingBound,
      containerFlow: containerFlowBound,
      createTracker: track,
      compilePattern,
      safe: safeBound,
      stack: [],
      unsafe: [...unsafe],
      join: [...join$1],
      // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
      // here.
      handlers: { ...handle },
      options: {},
      indexStack: [],
      // @ts-expect-error: add `handle` in a second.
      handle: void 0
    };
    configure(state, options2);
    if (state.options.tightDefinitions) {
      state.join.push(joinDefinition);
    }
    state.handle = zwitch("type", {
      invalid,
      unknown,
      handlers: state.handlers
    });
    let result = state.handle(tree, void 0, state, {
      before: "\n",
      after: "\n",
      now: { line: 1, column: 1 },
      lineShift: 0
    });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += "\n";
    }
    return result;
    function enter(name2) {
      state.stack.push(name2);
      return exit;
      function exit() {
        state.stack.pop();
      }
    }
  }
  function invalid(value2) {
    throw new Error("Cannot handle value `" + value2 + "`, expected node");
  }
  function unknown(value2) {
    const node2 = (
      /** @type {Nodes} */
      value2
    );
    throw new Error("Cannot handle unknown node `" + node2.type + "`");
  }
  function joinDefinition(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
  function containerPhrasingBound(parent, info) {
    return containerPhrasing(parent, this, info);
  }
  function containerFlowBound(parent, info) {
    return containerFlow(parent, this, info);
  }
  function safeBound(value2, config2) {
    return safe(this, value2, config2);
  }
  var arrays$9 = {
    range: function(start, stop) {
      var length = stop - start, result = new Array(length), i, j;
      for (i = 0, j = start; i < length; i++, j++) {
        result[i] = j;
      }
      return result;
    },
    find: function(array, valueOrPredicate) {
      var length = array.length, i;
      if (typeof valueOrPredicate === "function") {
        for (i = 0; i < length; i++) {
          if (valueOrPredicate(array[i])) {
            return array[i];
          }
        }
      } else {
        for (i = 0; i < length; i++) {
          if (array[i] === valueOrPredicate) {
            return array[i];
          }
        }
      }
    },
    indexOf: function(array, valueOrPredicate) {
      var length = array.length, i;
      if (typeof valueOrPredicate === "function") {
        for (i = 0; i < length; i++) {
          if (valueOrPredicate(array[i])) {
            return i;
          }
        }
      } else {
        for (i = 0; i < length; i++) {
          if (array[i] === valueOrPredicate) {
            return i;
          }
        }
      }
      return -1;
    },
    contains: function(array, valueOrPredicate) {
      return arrays$9.indexOf(array, valueOrPredicate) !== -1;
    },
    each: function(array, iterator) {
      var length = array.length, i;
      for (i = 0; i < length; i++) {
        iterator(array[i], i);
      }
    },
    map: function(array, iterator) {
      var length = array.length, result = new Array(length), i;
      for (i = 0; i < length; i++) {
        result[i] = iterator(array[i], i);
      }
      return result;
    },
    pluck: function(array, key2) {
      return arrays$9.map(array, function(e) {
        return e[key2];
      });
    },
    every: function(array, predicate) {
      var length = array.length, i;
      for (i = 0; i < length; i++) {
        if (!predicate(array[i])) {
          return false;
        }
      }
      return true;
    },
    some: function(array, predicate) {
      var length = array.length, i;
      for (i = 0; i < length; i++) {
        if (predicate(array[i])) {
          return true;
        }
      }
      return false;
    }
  };
  var arrays_1 = arrays$9;
  var objects$6 = {
    keys: function(object2) {
      var result = [], key2;
      for (key2 in object2) {
        if (object2.hasOwnProperty(key2)) {
          result.push(key2);
        }
      }
      return result;
    },
    values: function(object2) {
      var result = [], key2;
      for (key2 in object2) {
        if (object2.hasOwnProperty(key2)) {
          result.push(object2[key2]);
        }
      }
      return result;
    },
    clone: function(object2) {
      var result = {}, key2;
      for (key2 in object2) {
        if (object2.hasOwnProperty(key2)) {
          result[key2] = object2[key2];
        }
      }
      return result;
    },
    defaults: function(object2, defaults2) {
      var key2;
      for (key2 in defaults2) {
        if (defaults2.hasOwnProperty(key2)) {
          if (!(key2 in object2)) {
            object2[key2] = defaults2[key2];
          }
        }
      }
    }
  };
  var objects_1 = objects$6;
  var classes$1 = {
    subclass: function(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
  };
  var classes_1 = classes$1;
  var classes = classes_1;
  function GrammarError$5(message, location2) {
    this.name = "GrammarError";
    this.message = message;
    this.location = location2;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GrammarError$5);
    }
  }
  classes.subclass(GrammarError$5, Error);
  var grammarError = GrammarError$5;
  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
  function peg$SyntaxError(message, expected, found, location2) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location2;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }
  peg$subclass(peg$SyntaxError, Error);
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      "class": function(expectation) {
        var escapedParts = "", i;
        for (i = 0; i < expectation.parts.length; i++) {
          escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
        }
        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
      },
      any: function(expectation) {
        return "any character";
      },
      end: function(expectation) {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex2(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex2(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex2(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex2(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex2(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = new Array(expected2.length), i, j;
      for (i = 0; i < expected2.length; i++) {
        descriptions[i] = describeExpectation(expected2[i]);
      }
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input2, options2) {
    options2 = options2 !== void 0 ? options2 : {};
    var peg$FAILED = {}, peg$startRuleFunctions = { Grammar: peg$parseGrammar }, peg$startRuleFunction = peg$parseGrammar, peg$c0 = function(initializer, rules) {
      return {
        type: "grammar",
        initializer: extractOptional(initializer, 0),
        rules: extractList(rules, 0),
        location: location2()
      };
    }, peg$c1 = function(code2) {
      return { type: "initializer", code: code2, location: location2() };
    }, peg$c2 = "=", peg$c3 = peg$literalExpectation("=", false), peg$c4 = function(name2, displayName, expression) {
      return {
        type: "rule",
        name: name2,
        expression: displayName !== null ? {
          type: "named",
          name: displayName[0],
          expression,
          location: location2()
        } : expression,
        location: location2()
      };
    }, peg$c5 = "/", peg$c6 = peg$literalExpectation("/", false), peg$c7 = function(head2, tail) {
      return tail.length > 0 ? {
        type: "choice",
        alternatives: buildList(head2, tail, 3),
        location: location2()
      } : head2;
    }, peg$c8 = function(expression, code2) {
      return code2 !== null ? {
        type: "action",
        expression,
        code: code2[1],
        location: location2()
      } : expression;
    }, peg$c9 = function(head2, tail) {
      return tail.length > 0 ? {
        type: "sequence",
        elements: buildList(head2, tail, 1),
        location: location2()
      } : head2;
    }, peg$c10 = ":", peg$c11 = peg$literalExpectation(":", false), peg$c12 = function(label2, expression) {
      return {
        type: "labeled",
        label: label2,
        expression,
        location: location2()
      };
    }, peg$c13 = function(operator, expression) {
      return {
        type: OPS_TO_PREFIXED_TYPES[operator],
        expression,
        location: location2()
      };
    }, peg$c14 = "$", peg$c15 = peg$literalExpectation("$", false), peg$c16 = "&", peg$c17 = peg$literalExpectation("&", false), peg$c18 = "!", peg$c19 = peg$literalExpectation("!", false), peg$c20 = function(expression, operator) {
      return {
        type: OPS_TO_SUFFIXED_TYPES[operator],
        expression,
        location: location2()
      };
    }, peg$c21 = "?", peg$c22 = peg$literalExpectation("?", false), peg$c23 = "*", peg$c24 = peg$literalExpectation("*", false), peg$c25 = "+", peg$c26 = peg$literalExpectation("+", false), peg$c27 = "(", peg$c28 = peg$literalExpectation("(", false), peg$c29 = ")", peg$c30 = peg$literalExpectation(")", false), peg$c31 = function(expression) {
      return expression.type === "labeled" || expression.type === "sequence" ? { type: "group", expression } : expression;
    }, peg$c32 = function(name2) {
      return { type: "rule_ref", name: name2, location: location2() };
    }, peg$c33 = function(operator, code2) {
      return {
        type: OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],
        code: code2,
        location: location2()
      };
    }, peg$c34 = peg$anyExpectation(), peg$c35 = peg$otherExpectation("whitespace"), peg$c36 = "	", peg$c37 = peg$literalExpectation("	", false), peg$c38 = "\v", peg$c39 = peg$literalExpectation("\v", false), peg$c40 = "\f", peg$c41 = peg$literalExpectation("\f", false), peg$c42 = " ", peg$c43 = peg$literalExpectation(" ", false), peg$c44 = "Â ", peg$c45 = peg$literalExpectation("Â ", false), peg$c46 = "\uFEFF", peg$c47 = peg$literalExpectation("\uFEFF", false), peg$c48 = /^[\n\r\u2028\u2029]/, peg$c49 = peg$classExpectation(["\n", "\r", "\u2028", "\u2029"], false, false), peg$c50 = peg$otherExpectation("end of line"), peg$c51 = "\n", peg$c52 = peg$literalExpectation("\n", false), peg$c53 = "\r\n", peg$c54 = peg$literalExpectation("\r\n", false), peg$c55 = "\r", peg$c56 = peg$literalExpectation("\r", false), peg$c57 = "\u2028", peg$c58 = peg$literalExpectation("\u2028", false), peg$c59 = "\u2029", peg$c60 = peg$literalExpectation("\u2029", false), peg$c61 = peg$otherExpectation("comment"), peg$c62 = "/*", peg$c63 = peg$literalExpectation("/*", false), peg$c64 = "*/", peg$c65 = peg$literalExpectation("*/", false), peg$c66 = "//", peg$c67 = peg$literalExpectation("//", false), peg$c68 = function(name2) {
      return name2;
    }, peg$c69 = peg$otherExpectation("identifier"), peg$c70 = function(head2, tail) {
      return head2 + tail.join("");
    }, peg$c71 = "_", peg$c72 = peg$literalExpectation("_", false), peg$c73 = "\\", peg$c74 = peg$literalExpectation("\\", false), peg$c75 = function(sequence) {
      return sequence;
    }, peg$c76 = "â", peg$c77 = peg$literalExpectation("â", false), peg$c78 = "â", peg$c79 = peg$literalExpectation("â", false), peg$c80 = peg$otherExpectation("literal"), peg$c81 = "i", peg$c82 = peg$literalExpectation("i", false), peg$c83 = function(value2, ignoreCase) {
      return {
        type: "literal",
        value: value2,
        ignoreCase: ignoreCase !== null,
        location: location2()
      };
    }, peg$c84 = peg$otherExpectation("string"), peg$c85 = '"', peg$c86 = peg$literalExpectation('"', false), peg$c87 = function(chars) {
      return chars.join("");
    }, peg$c88 = "'", peg$c89 = peg$literalExpectation("'", false), peg$c90 = function() {
      return text2();
    }, peg$c91 = peg$otherExpectation("character class"), peg$c92 = "[", peg$c93 = peg$literalExpectation("[", false), peg$c94 = "^", peg$c95 = peg$literalExpectation("^", false), peg$c96 = "]", peg$c97 = peg$literalExpectation("]", false), peg$c98 = function(inverted, parts2, ignoreCase) {
      return {
        type: "class",
        parts: filterEmptyStrings(parts2),
        inverted: inverted !== null,
        ignoreCase: ignoreCase !== null,
        location: location2()
      };
    }, peg$c99 = "-", peg$c100 = peg$literalExpectation("-", false), peg$c101 = function(begin, end2) {
      if (begin.charCodeAt(0) > end2.charCodeAt(0)) {
        error(
          "Invalid character range: " + text2() + "."
        );
      }
      return [begin, end2];
    }, peg$c102 = function() {
      return "";
    }, peg$c103 = "0", peg$c104 = peg$literalExpectation("0", false), peg$c105 = function() {
      return "\0";
    }, peg$c106 = "b", peg$c107 = peg$literalExpectation("b", false), peg$c108 = function() {
      return "\b";
    }, peg$c109 = "f", peg$c110 = peg$literalExpectation("f", false), peg$c111 = function() {
      return "\f";
    }, peg$c112 = "n", peg$c113 = peg$literalExpectation("n", false), peg$c114 = function() {
      return "\n";
    }, peg$c115 = "r", peg$c116 = peg$literalExpectation("r", false), peg$c117 = function() {
      return "\r";
    }, peg$c118 = "t", peg$c119 = peg$literalExpectation("t", false), peg$c120 = function() {
      return "	";
    }, peg$c121 = "v", peg$c122 = peg$literalExpectation("v", false), peg$c123 = function() {
      return "\v";
    }, peg$c124 = "x", peg$c125 = peg$literalExpectation("x", false), peg$c126 = "u", peg$c127 = peg$literalExpectation("u", false), peg$c128 = function(digits) {
      return String.fromCharCode(parseInt(digits, 16));
    }, peg$c129 = /^[0-9]/, peg$c130 = peg$classExpectation([["0", "9"]], false, false), peg$c131 = /^[0-9a-f]/i, peg$c132 = peg$classExpectation([["0", "9"], ["a", "f"]], false, true), peg$c133 = ".", peg$c134 = peg$literalExpectation(".", false), peg$c135 = function() {
      return { type: "any", location: location2() };
    }, peg$c136 = peg$otherExpectation("code block"), peg$c137 = "{", peg$c138 = peg$literalExpectation("{", false), peg$c139 = "}", peg$c140 = peg$literalExpectation("}", false), peg$c141 = function(code2) {
      return code2;
    }, peg$c142 = /^[{}]/, peg$c143 = peg$classExpectation(["{", "}"], false, false), peg$c144 = /^[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137-\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148-\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C-\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA-\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9-\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC-\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF-\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F-\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0-\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB-\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE-\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6-\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FC7\u1FD0-\u1FD3\u1FD6-\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6-\u1FF7\u210A\u210E-\u210F\u2113\u212F\u2134\u2139\u213C-\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65-\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73-\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3-\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]/, peg$c145 = peg$classExpectation([["a", "z"], "Âµ", ["Ã", "Ã¶"], ["Ã¸", "Ã¿"], "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä¡", "Ä£", "Ä¥", "Ä§", "Ä©", "Ä«", "Ä­", "Ä¯", "Ä±", "Ä³", "Äµ", ["Ä·", "Ä¸"], "Äº", "Ä¼", "Ä¾", "Å", "Å", "Å", "Å", ["Å", "Å"], "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å¡", "Å£", "Å¥", "Å§", "Å©", "Å«", "Å­", "Å¯", "Å±", "Å³", "Åµ", "Å·", "Åº", "Å¼", ["Å¾", "Æ"], "Æ", "Æ", "Æ", ["Æ", "Æ"], "Æ", "Æ", ["Æ", "Æ"], "Æ", "Æ¡", "Æ£", "Æ¥", "Æ¨", ["Æª", "Æ«"], "Æ­", "Æ°", "Æ´", "Æ¶", ["Æ¹", "Æº"], ["Æ½", "Æ¿"], "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", ["Ç", "Ç"], "Ç", "Ç¡", "Ç£", "Ç¥", "Ç§", "Ç©", "Ç«", "Ç­", ["Ç¯", "Ç°"], "Ç³", "Çµ", "Ç¹", "Ç»", "Ç½", "Ç¿", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È¡", "È£", "È¥", "È§", "È©", "È«", "È­", "È¯", "È±", ["È³", "È¹"], "È¼", ["È¿", "É"], "É", "É", "É", "É", "É", ["É", "Ê"], ["Ê", "Ê¯"], "Í±", "Í³", "Í·", ["Í»", "Í½"], "Î", ["Î¬", "Ï"], ["Ï", "Ï"], ["Ï", "Ï"], "Ï", "Ï", "Ï", "Ï", "Ï¡", "Ï£", "Ï¥", "Ï§", "Ï©", "Ï«", "Ï­", ["Ï¯", "Ï³"], "Ïµ", "Ï¸", ["Ï»", "Ï¼"], ["Ð°", "Ñ"], "Ñ¡", "Ñ£", "Ñ¥", "Ñ§", "Ñ©", "Ñ«", "Ñ­", "Ñ¯", "Ñ±", "Ñ³", "Ñµ", "Ñ·", "Ñ¹", "Ñ»", "Ñ½", "Ñ¿", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò¡", "Ò£", "Ò¥", "Ò§", "Ò©", "Ò«", "Ò­", "Ò¯", "Ò±", "Ò³", "Òµ", "Ò·", "Ò¹", "Ò»", "Ò½", "Ò¿", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", ["Ó", "Ó"], "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó¡", "Ó£", "Ó¥", "Ó§", "Ó©", "Ó«", "Ó­", "Ó¯", "Ó±", "Ó³", "Óµ", "Ó·", "Ó¹", "Ó»", "Ó½", "Ó¿", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô¡", "Ô£", "Ô¥", "Ô§", "Ô©", "Ô«", "Ô­", "Ô¯", ["Õ¡", "Ö"], ["á¸", "á½"], ["á´", "á´«"], ["áµ«", "áµ·"], ["áµ¹", "á¶"], "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸¡", "á¸£", "á¸¥", "á¸§", "á¸©", "á¸«", "á¸­", "á¸¯", "á¸±", "á¸³", "á¸µ", "á¸·", "á¸¹", "á¸»", "á¸½", "á¸¿", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹¡", "á¹£", "á¹¥", "á¹§", "á¹©", "á¹«", "á¹­", "á¹¯", "á¹±", "á¹³", "á¹µ", "á¹·", "á¹¹", "á¹»", "á¹½", "á¹¿", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", ["áº", "áº"], "áº", "áº¡", "áº£", "áº¥", "áº§", "áº©", "áº«", "áº­", "áº¯", "áº±", "áº³", "áºµ", "áº·", "áº¹", "áº»", "áº½", "áº¿", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»¡", "á»£", "á»¥", "á»§", "á»©", "á»«", "á»­", "á»¯", "á»±", "á»³", "á»µ", "á»·", "á»¹", "á»»", "á»½", ["á»¿", "á¼"], ["á¼", "á¼"], ["á¼ ", "á¼§"], ["á¼°", "á¼·"], ["á½", "á½"], ["á½", "á½"], ["á½ ", "á½§"], ["á½°", "á½½"], ["á¾", "á¾"], ["á¾", "á¾"], ["á¾ ", "á¾§"], ["á¾°", "á¾´"], ["á¾¶", "á¾·"], "á¾¾", ["á¿", "á¿"], ["á¿", "á¿"], ["á¿", "á¿"], ["á¿", "á¿"], ["á¿ ", "á¿§"], ["á¿²", "á¿´"], ["á¿¶", "á¿·"], "â", ["â", "â"], "â", "â¯", "â´", "â¹", ["â¼", "â½"], ["â", "â"], "â", "â", ["â°°", "â±"], "â±¡", ["â±¥", "â±¦"], "â±¨", "â±ª", "â±¬", "â±±", ["â±³", "â±´"], ["â±¶", "â±»"], "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²¡", "â²£", "â²¥", "â²§", "â²©", "â²«", "â²­", "â²¯", "â²±", "â²³", "â²µ", "â²·", "â²¹", "â²»", "â²½", "â²¿", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³¡", ["â³£", "â³¤"], "â³¬", "â³®", "â³³", ["â´", "â´¥"], "â´§", "â´­", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê¡", "ê£", "ê¥", "ê§", "ê©", "ê«", "ê­", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê£", "ê¥", "ê§", "ê©", "ê«", "ê­", ["ê¯", "ê±"], "ê³", "êµ", "ê·", "ê¹", "ê»", "ê½", "ê¿", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê¡", "ê£", "ê¥", "ê§", "ê©", "ê«", "ê­", "ê¯", ["ê±", "ê¸"], "êº", "ê¼", "ê¿", "ê", "ê", "ê", "ê", "ê", "ê", "ê", ["ê", "ê"], "ê", "ê", "ê", "ê", "ê", "ê¡", "ê£", "ê¥", "ê§", "ê©", "êµ", "ê·", "êº", ["ê¬°", "ê­"], ["ê­ ", "ê­¥"], ["ê­°", "ê®¿"], ["ï¬", "ï¬"], ["ï¬", "ï¬"], ["ï½", "ï½"]], false, false), peg$c146 = /^[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5-\u06E6\u07F4-\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C-\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D-\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C-\uA69D\uA717-\uA71F\uA770\uA788\uA7F8-\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3-\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E-\uFF9F]/, peg$c147 = peg$classExpectation([["Ê°", "Ë"], ["Ë", "Ë"], ["Ë ", "Ë¤"], "Ë¬", "Ë®", "Í´", "Íº", "Õ", "Ù", ["Û¥", "Û¦"], ["ß´", "ßµ"], "ßº", "à ", "à ¤", "à ¨", "à¥±", "à¹", "à»", "á¼", "á", "á¡", "áª§", ["á±¸", "á±½"], ["á´¬", "áµª"], "áµ¸", ["á¶", "á¶¿"], "â±", "â¿", ["â", "â"], ["â±¼", "â±½"], "âµ¯", "â¸¯", "ã", ["ã±", "ãµ"], "ã»", ["ã", "ã"], ["ã¼", "ã¾"], "ê", ["ê¸", "ê½"], "ê", "ê¿", ["ê", "ê"], ["ê", "ê"], "ê°", "ê", ["ê¸", "ê¹"], "ê§", "ê§¦", "ê©°", "ê«", ["ê«³", "ê«´"], ["ê­", "ê­"], "ï½°", ["ï¾", "ï¾"]], false, false), peg$c148 = /^[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0CF1-\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065-\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE-\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5-\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A-\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, peg$c149 = peg$classExpectation(["Âª", "Âº", "Æ»", ["Ç", "Ç"], "Ê", ["×", "×ª"], ["×°", "×²"], ["Ø ", "Ø¿"], ["Ù", "Ù"], ["Ù®", "Ù¯"], ["Ù±", "Û"], "Û", ["Û®", "Û¯"], ["Ûº", "Û¼"], "Û¿", "Ü", ["Ü", "Ü¯"], ["Ý", "Þ¥"], "Þ±", ["ß", "ßª"], ["à ", "à "], ["à¡", "à¡"], ["à¢ ", "à¢´"], ["à¤", "à¤¹"], "à¤½", "à¥", ["à¥", "à¥¡"], ["à¥²", "à¦"], ["à¦", "à¦"], ["à¦", "à¦"], ["à¦", "à¦¨"], ["à¦ª", "à¦°"], "à¦²", ["à¦¶", "à¦¹"], "à¦½", "à§", ["à§", "à§"], ["à§", "à§¡"], ["à§°", "à§±"], ["à¨", "à¨"], ["à¨", "à¨"], ["à¨", "à¨¨"], ["à¨ª", "à¨°"], ["à¨²", "à¨³"], ["à¨µ", "à¨¶"], ["à¨¸", "à¨¹"], ["à©", "à©"], "à©", ["à©²", "à©´"], ["àª", "àª"], ["àª", "àª"], ["àª", "àª¨"], ["àªª", "àª°"], ["àª²", "àª³"], ["àªµ", "àª¹"], "àª½", "à«", ["à« ", "à«¡"], "à«¹", ["à¬", "à¬"], ["à¬", "à¬"], ["à¬", "à¬¨"], ["à¬ª", "à¬°"], ["à¬²", "à¬³"], ["à¬µ", "à¬¹"], "à¬½", ["à­", "à­"], ["à­", "à­¡"], "à­±", "à®", ["à®", "à®"], ["à®", "à®"], ["à®", "à®"], ["à®", "à®"], "à®", ["à®", "à®"], ["à®£", "à®¤"], ["à®¨", "à®ª"], ["à®®", "à®¹"], "à¯", ["à°", "à°"], ["à°", "à°"], ["à°", "à°¨"], ["à°ª", "à°¹"], "à°½", ["à±", "à±"], ["à± ", "à±¡"], ["à²", "à²"], ["à²", "à²"], ["à²", "à²¨"], ["à²ª", "à²³"], ["à²µ", "à²¹"], "à²½", "à³", ["à³ ", "à³¡"], ["à³±", "à³²"], ["à´", "à´"], ["à´", "à´"], ["à´", "à´º"], "à´½", "àµ", ["àµ", "àµ¡"], ["àµº", "àµ¿"], ["à¶", "à¶"], ["à¶", "à¶±"], ["à¶³", "à¶»"], "à¶½", ["à·", "à·"], ["à¸", "à¸°"], ["à¸²", "à¸³"], ["à¹", "à¹"], ["àº", "àº"], "àº", ["àº", "àº"], "àº", "àº", ["àº", "àº"], ["àº", "àº"], ["àº¡", "àº£"], "àº¥", "àº§", ["àºª", "àº«"], ["àº­", "àº°"], ["àº²", "àº³"], "àº½", ["à»", "à»"], ["à»", "à»"], "à¼", ["à½", "à½"], ["à½", "à½¬"], ["à¾", "à¾"], ["á", "áª"], "á¿", ["á", "á"], ["á", "á"], "á¡", ["á¥", "á¦"], ["á®", "á°"], ["áµ", "á"], "á", ["á", "áº"], ["á½", "á"], ["á", "á"], ["á", "á"], "á", ["á", "á"], ["á ", "á"], ["á", "á"], ["á", "á°"], ["á²", "áµ"], ["á¸", "á¾"], "á", ["á", "á"], ["á", "á"], ["á", "á"], ["á", "á"], ["á", "á"], ["á", "á"], ["á", "á¬"], ["á¯", "á¿"], ["á", "á"], ["á ", "áª"], ["á±", "á¸"], ["á", "á"], ["á", "á"], ["á ", "á±"], ["á", "á"], ["á ", "á¬"], ["á®", "á°"], ["á", "á³"], "á", ["á  ", "á¡"], ["á¡", "á¡·"], ["á¢", "á¢¨"], "á¢ª", ["á¢°", "á£µ"], ["á¤", "á¤"], ["á¥", "á¥­"], ["á¥°", "á¥´"], ["á¦", "á¦«"], ["á¦°", "á§"], ["á¨", "á¨"], ["á¨ ", "á©"], ["á¬", "á¬³"], ["á­", "á­"], ["á®", "á® "], ["á®®", "á®¯"], ["á®º", "á¯¥"], ["á°", "á°£"], ["á±", "á±"], ["á±", "á±·"], ["á³©", "á³¬"], ["á³®", "á³±"], ["á³µ", "á³¶"], ["âµ", "â¸"], ["â´°", "âµ§"], ["â¶", "â¶"], ["â¶ ", "â¶¦"], ["â¶¨", "â¶®"], ["â¶°", "â¶¶"], ["â¶¸", "â¶¾"], ["â·", "â·"], ["â·", "â·"], ["â·", "â·"], ["â·", "â·"], "ã", "ã¼", ["ã", "ã"], "ã", ["ã¡", "ãº"], "ã¿", ["ã", "ã­"], ["ã±", "ã"], ["ã ", "ãº"], ["ã°", "ã¿"], ["ã", "ä¶µ"], ["ä¸", "é¿"], ["ê", "ê"], ["ê", "ê"], ["ê", "ê·"], ["ê", "ê"], ["ê", "ê"], ["êª", "ê«"], "ê®", ["ê ", "ê¥"], "ê", "ê·", ["ê»", "ê "], ["ê ", "ê "], ["ê ", "ê "], ["ê ", "ê ¢"], ["ê¡", "ê¡³"], ["ê¢", "ê¢³"], ["ê£²", "ê£·"], "ê£»", "ê£½", ["ê¤", "ê¤¥"], ["ê¤°", "ê¥"], ["ê¥ ", "ê¥¼"], ["ê¦", "ê¦²"], ["ê§ ", "ê§¤"], ["ê§§", "ê§¯"], ["ê§º", "ê§¾"], ["ê¨", "ê¨¨"], ["ê©", "ê©"], ["ê©", "ê©"], ["ê© ", "ê©¯"], ["ê©±", "ê©¶"], "ê©º", ["ê©¾", "êª¯"], "êª±", ["êªµ", "êª¶"], ["êª¹", "êª½"], "ê«", "ê«", ["ê«", "ê«"], ["ê« ", "ê«ª"], "ê«²", ["ê¬", "ê¬"], ["ê¬", "ê¬"], ["ê¬", "ê¬"], ["ê¬ ", "ê¬¦"], ["ê¬¨", "ê¬®"], ["ê¯", "ê¯¢"], ["ê°", "í£"], ["í°", "í"], ["í", "í»"], ["ï¤", "ï©­"], ["ï©°", "ï«"], "ï¬", ["ï¬", "ï¬¨"], ["ï¬ª", "ï¬¶"], ["ï¬¸", "ï¬¼"], "ï¬¾", ["ï­", "ï­"], ["ï­", "ï­"], ["ï­", "ï®±"], ["ï¯", "ï´½"], ["ïµ", "ï¶"], ["ï¶", "ï·"], ["ï·°", "ï·»"], ["ï¹°", "ï¹´"], ["ï¹¶", "ï»¼"], ["ï½¦", "ï½¯"], ["ï½±", "ï¾"], ["ï¾ ", "ï¾¾"], ["ï¿", "ï¿"], ["ï¿", "ï¿"], ["ï¿", "ï¿"], ["ï¿", "ï¿"]], false, false), peg$c150 = /^[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/, peg$c151 = peg$classExpectation(["Ç", "Ç", "Ç", "Ç²", ["á¾", "á¾"], ["á¾", "á¾"], ["á¾¨", "á¾¯"], "á¾¼", "á¿", "á¿¼"], false, false), peg$c152 = /^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178-\u0179\u017B\u017D\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018B\u018E-\u0191\u0193-\u0194\u0196-\u0198\u019C-\u019D\u019F-\u01A0\u01A2\u01A4\u01A6-\u01A7\u01A9\u01AC\u01AE-\u01AF\u01B1-\u01B3\u01B5\u01B7-\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A-\u023B\u023D-\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9-\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0-\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E-\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D-\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]/, peg$c153 = peg$classExpectation([["A", "Z"], ["Ã", "Ã"], ["Ã", "Ã"], "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä", "Ä ", "Ä¢", "Ä¤", "Ä¦", "Ä¨", "Äª", "Ä¬", "Ä®", "Ä°", "Ä²", "Ä´", "Ä¶", "Ä¹", "Ä»", "Ä½", "Ä¿", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å", "Å ", "Å¢", "Å¤", "Å¦", "Å¨", "Åª", "Å¬", "Å®", "Å°", "Å²", "Å´", "Å¶", ["Å¸", "Å¹"], "Å»", "Å½", ["Æ", "Æ"], "Æ", ["Æ", "Æ"], ["Æ", "Æ"], ["Æ", "Æ"], ["Æ", "Æ"], ["Æ", "Æ"], ["Æ", "Æ"], ["Æ", "Æ "], "Æ¢", "Æ¤", ["Æ¦", "Æ§"], "Æ©", "Æ¬", ["Æ®", "Æ¯"], ["Æ±", "Æ³"], "Æµ", ["Æ·", "Æ¸"], "Æ¼", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç", "Ç ", "Ç¢", "Ç¤", "Ç¦", "Ç¨", "Çª", "Ç¬", "Ç®", "Ç±", "Ç´", ["Ç¶", "Ç¸"], "Çº", "Ç¼", "Ç¾", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È", "È ", "È¢", "È¤", "È¦", "È¨", "Èª", "È¬", "È®", "È°", "È²", ["Èº", "È»"], ["È½", "È¾"], "É", ["É", "É"], "É", "É", "É", "É", "Í°", "Í²", "Í¶", "Í¿", "Î", ["Î", "Î"], "Î", ["Î", "Î"], ["Î", "Î¡"], ["Î£", "Î«"], "Ï", ["Ï", "Ï"], "Ï", "Ï", "Ï", "Ï", "Ï ", "Ï¢", "Ï¤", "Ï¦", "Ï¨", "Ïª", "Ï¬", "Ï®", "Ï´", "Ï·", ["Ï¹", "Ïº"], ["Ï½", "Ð¯"], "Ñ ", "Ñ¢", "Ñ¤", "Ñ¦", "Ñ¨", "Ñª", "Ñ¬", "Ñ®", "Ñ°", "Ñ²", "Ñ´", "Ñ¶", "Ñ¸", "Ñº", "Ñ¼", "Ñ¾", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò", "Ò ", "Ò¢", "Ò¤", "Ò¦", "Ò¨", "Òª", "Ò¬", "Ò®", "Ò°", "Ò²", "Ò´", "Ò¶", "Ò¸", "Òº", "Ò¼", "Ò¾", ["Ó", "Ó"], "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó", "Ó ", "Ó¢", "Ó¤", "Ó¦", "Ó¨", "Óª", "Ó¬", "Ó®", "Ó°", "Ó²", "Ó´", "Ó¶", "Ó¸", "Óº", "Ó¼", "Ó¾", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô", "Ô ", "Ô¢", "Ô¤", "Ô¦", "Ô¨", "Ôª", "Ô¬", "Ô®", ["Ô±", "Õ"], ["á ", "á"], "á", "á", ["á ", "áµ"], "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸", "á¸ ", "á¸¢", "á¸¤", "á¸¦", "á¸¨", "á¸ª", "á¸¬", "á¸®", "á¸°", "á¸²", "á¸´", "á¸¶", "á¸¸", "á¸º", "á¸¼", "á¸¾", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹", "á¹ ", "á¹¢", "á¹¤", "á¹¦", "á¹¨", "á¹ª", "á¹¬", "á¹®", "á¹°", "á¹²", "á¹´", "á¹¶", "á¹¸", "á¹º", "á¹¼", "á¹¾", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº", "áº ", "áº¢", "áº¤", "áº¦", "áº¨", "áºª", "áº¬", "áº®", "áº°", "áº²", "áº´", "áº¶", "áº¸", "áºº", "áº¼", "áº¾", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á»", "á» ", "á»¢", "á»¤", "á»¦", "á»¨", "á»ª", "á»¬", "á»®", "á»°", "á»²", "á»´", "á»¶", "á»¸", "á»º", "á»¼", "á»¾", ["á¼", "á¼"], ["á¼", "á¼"], ["á¼¨", "á¼¯"], ["á¼¸", "á¼¿"], ["á½", "á½"], "á½", "á½", "á½", "á½", ["á½¨", "á½¯"], ["á¾¸", "á¾»"], ["á¿", "á¿"], ["á¿", "á¿"], ["á¿¨", "á¿¬"], ["á¿¸", "á¿»"], "â", "â", ["â", "â"], ["â", "â"], "â", ["â", "â"], "â¤", "â¦", "â¨", ["âª", "â­"], ["â°", "â³"], ["â¾", "â¿"], "â", "â", ["â°", "â°®"], "â± ", ["â±¢", "â±¤"], "â±§", "â±©", "â±«", ["â±­", "â±°"], "â±²", "â±µ", ["â±¾", "â²"], "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â²", "â² ", "â²¢", "â²¤", "â²¦", "â²¨", "â²ª", "â²¬", "â²®", "â²°", "â²²", "â²´", "â²¶", "â²¸", "â²º", "â²¼", "â²¾", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³", "â³ ", "â³¢", "â³«", "â³­", "â³²", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê ", "ê¢", "ê¤", "ê¦", "ê¨", "êª", "ê¬", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê¢", "ê¤", "ê¦", "ê¨", "êª", "ê¬", "ê®", "ê²", "ê´", "ê¶", "ê¸", "êº", "ê¼", "ê¾", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê ", "ê¢", "ê¤", "ê¦", "ê¨", "êª", "ê¬", "ê®", "ê¹", "ê»", ["ê½", "ê¾"], "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê", "ê ", "ê¢", "ê¤", "ê¦", "ê¨", ["êª", "ê­"], ["ê°", "ê´"], "ê¶", ["ï¼¡", "ï¼º"]], false, false), peg$c154 = /^[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0982-\u0983\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0B02-\u0B03\u0B3E\u0B40\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82-\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82-\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2-\u0DF3\u0F3E-\u0F3F\u0F7F\u102B-\u102C\u1031\u1038\u103B-\u103C\u1056-\u1057\u1062-\u1064\u1067-\u106D\u1083-\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7-\u17C8\u1923-\u1926\u1929-\u192B\u1930-\u1931\u1933-\u1938\u1A19-\u1A1A\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B82\u1BA1\u1BA6-\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1C24-\u1C2B\u1C34-\u1C35\u1CE1\u1CF2-\u1CF3\u302E-\u302F\uA823-\uA824\uA827\uA880-\uA881\uA8B4-\uA8C3\uA952-\uA953\uA983\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uAA2F-\uAA30\uAA33-\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE-\uAAEF\uAAF5\uABE3-\uABE4\uABE6-\uABE7\uABE9-\uABEA\uABEC]/, peg$c155 = peg$classExpectation(["à¤", "à¤»", ["à¤¾", "à¥"], ["à¥", "à¥"], ["à¥", "à¥"], ["à¦", "à¦"], ["à¦¾", "à§"], ["à§", "à§"], ["à§", "à§"], "à§", "à¨", ["à¨¾", "à©"], "àª", ["àª¾", "à«"], "à«", ["à«", "à«"], ["à¬", "à¬"], "à¬¾", "à­", ["à­", "à­"], ["à­", "à­"], "à­", ["à®¾", "à®¿"], ["à¯", "à¯"], ["à¯", "à¯"], ["à¯", "à¯"], "à¯", ["à°", "à°"], ["à±", "à±"], ["à²", "à²"], "à²¾", ["à³", "à³"], ["à³", "à³"], ["à³", "à³"], ["à³", "à³"], ["à´", "à´"], ["à´¾", "àµ"], ["àµ", "àµ"], ["àµ", "àµ"], "àµ", ["à¶", "à¶"], ["à·", "à·"], ["à·", "à·"], ["à·²", "à·³"], ["à¼¾", "à¼¿"], "à½¿", ["á«", "á¬"], "á±", "á¸", ["á»", "á¼"], ["á", "á"], ["á¢", "á¤"], ["á§", "á­"], ["á", "á"], ["á", "á"], "á", ["á", "á"], "á¶", ["á¾", "á"], ["á", "á"], ["á¤£", "á¤¦"], ["á¤©", "á¤«"], ["á¤°", "á¤±"], ["á¤³", "á¤¸"], ["á¨", "á¨"], "á©", "á©", "á©¡", ["á©£", "á©¤"], ["á©­", "á©²"], "á¬", "á¬µ", "á¬»", ["á¬½", "á­"], ["á­", "á­"], "á®", "á®¡", ["á®¦", "á®§"], "á®ª", "á¯§", ["á¯ª", "á¯¬"], "á¯®", ["á¯²", "á¯³"], ["á°¤", "á°«"], ["á°´", "á°µ"], "á³¡", ["á³²", "á³³"], ["ã®", "ã¯"], ["ê £", "ê ¤"], "ê §", ["ê¢", "ê¢"], ["ê¢´", "ê£"], ["ê¥", "ê¥"], "ê¦", ["ê¦´", "ê¦µ"], ["ê¦º", "ê¦»"], ["ê¦½", "ê§"], ["ê¨¯", "ê¨°"], ["ê¨³", "ê¨´"], "ê©", "ê©»", "ê©½", "ê««", ["ê«®", "ê«¯"], "ê«µ", ["ê¯£", "ê¯¤"], ["ê¯¦", "ê¯§"], ["ê¯©", "ê¯ª"], "ê¯¬"], false, false), peg$c156 = /^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62-\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC-\u0CCD\u0CE2-\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62-\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099-\u309A\uA66F\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/, peg$c157 = peg$classExpectation([["Ì", "Í¯"], ["Ò", "Ò"], ["Ö", "Ö½"], "Ö¿", ["×", "×"], ["×", "×"], "×", ["Ø", "Ø"], ["Ù", "Ù"], "Ù°", ["Û", "Û"], ["Û", "Û¤"], ["Û§", "Û¨"], ["Ûª", "Û­"], "Ü", ["Ü°", "Ý"], ["Þ¦", "Þ°"], ["ß«", "ß³"], ["à ", "à "], ["à ", "à £"], ["à ¥", "à §"], ["à ©", "à ­"], ["à¡", "à¡"], ["à££", "à¤"], "à¤º", "à¤¼", ["à¥", "à¥"], "à¥", ["à¥", "à¥"], ["à¥¢", "à¥£"], "à¦", "à¦¼", ["à§", "à§"], "à§", ["à§¢", "à§£"], ["à¨", "à¨"], "à¨¼", ["à©", "à©"], ["à©", "à©"], ["à©", "à©"], "à©", ["à©°", "à©±"], "à©µ", ["àª", "àª"], "àª¼", ["à«", "à«"], ["à«", "à«"], "à«", ["à«¢", "à«£"], "à¬", "à¬¼", "à¬¿", ["à­", "à­"], "à­", "à­", ["à­¢", "à­£"], "à®", "à¯", "à¯", "à°", ["à°¾", "à±"], ["à±", "à±"], ["à±", "à±"], ["à±", "à±"], ["à±¢", "à±£"], "à²", "à²¼", "à²¿", "à³", ["à³", "à³"], ["à³¢", "à³£"], "à´", ["àµ", "àµ"], "àµ", ["àµ¢", "àµ£"], "à·", ["à·", "à·"], "à·", "à¸±", ["à¸´", "à¸º"], ["à¹", "à¹"], "àº±", ["àº´", "àº¹"], ["àº»", "àº¼"], ["à»", "à»"], ["à¼", "à¼"], "à¼µ", "à¼·", "à¼¹", ["à½±", "à½¾"], ["à¾", "à¾"], ["à¾", "à¾"], ["à¾", "à¾"], ["à¾", "à¾¼"], "à¿", ["á­", "á°"], ["á²", "á·"], ["á¹", "áº"], ["á½", "á¾"], ["á", "á"], ["á", "á "], ["á±", "á´"], "á", ["á", "á"], "á", "á", ["á", "á"], ["á", "á"], ["á²", "á´"], ["á", "á"], ["á²", "á³"], ["á´", "áµ"], ["á·", "á½"], "á", ["á", "á"], "á", ["á ", "á "], "á¢©", ["á¤ ", "á¤¢"], ["á¤§", "á¤¨"], "á¤²", ["á¤¹", "á¤»"], ["á¨", "á¨"], "á¨", "á©", ["á©", "á©"], "á© ", "á©¢", ["á©¥", "á©¬"], ["á©³", "á©¼"], "á©¿", ["áª°", "áª½"], ["á¬", "á¬"], "á¬´", ["á¬¶", "á¬º"], "á¬¼", "á­", ["á­«", "á­³"], ["á®", "á®"], ["á®¢", "á®¥"], ["á®¨", "á®©"], ["á®«", "á®­"], "á¯¦", ["á¯¨", "á¯©"], "á¯­", ["á¯¯", "á¯±"], ["á°¬", "á°³"], ["á°¶", "á°·"], ["á³", "á³"], ["á³", "á³ "], ["á³¢", "á³¨"], "á³­", "á³´", ["á³¸", "á³¹"], ["á·", "á·µ"], ["á·¼", "á·¿"], ["â", "â"], "â¡", ["â¥", "â°"], ["â³¯", "â³±"], "âµ¿", ["â· ", "â·¿"], ["ãª", "ã­"], ["ã", "ã"], "ê¯", ["ê´", "ê½"], ["ê", "ê"], ["ê°", "ê±"], "ê ", "ê ", "ê ", ["ê ¥", "ê ¦"], "ê£", ["ê£ ", "ê£±"], ["ê¤¦", "ê¤­"], ["ê¥", "ê¥"], ["ê¦", "ê¦"], "ê¦³", ["ê¦¶", "ê¦¹"], "ê¦¼", "ê§¥", ["ê¨©", "ê¨®"], ["ê¨±", "ê¨²"], ["ê¨µ", "ê¨¶"], "ê©", "ê©", "ê©¼", "êª°", ["êª²", "êª´"], ["êª·", "êª¸"], ["êª¾", "êª¿"], "ê«", ["ê«¬", "ê«­"], "ê«¶", "ê¯¥", "ê¯¨", "ê¯­", "ï¬", ["ï¸", "ï¸"], ["ï¸ ", "ï¸¯"]], false, false), peg$c158 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/, peg$c159 = peg$classExpectation([["0", "9"], ["Ù ", "Ù©"], ["Û°", "Û¹"], ["ß", "ß"], ["à¥¦", "à¥¯"], ["à§¦", "à§¯"], ["à©¦", "à©¯"], ["à«¦", "à«¯"], ["à­¦", "à­¯"], ["à¯¦", "à¯¯"], ["à±¦", "à±¯"], ["à³¦", "à³¯"], ["àµ¦", "àµ¯"], ["à·¦", "à·¯"], ["à¹", "à¹"], ["à»", "à»"], ["à¼ ", "à¼©"], ["á", "á"], ["á", "á"], ["á ", "á©"], ["á ", "á "], ["á¥", "á¥"], ["á§", "á§"], ["áª", "áª"], ["áª", "áª"], ["á­", "á­"], ["á®°", "á®¹"], ["á±", "á±"], ["á±", "á±"], ["ê ", "ê©"], ["ê£", "ê£"], ["ê¤", "ê¤"], ["ê§", "ê§"], ["ê§°", "ê§¹"], ["ê©", "ê©"], ["ê¯°", "ê¯¹"], ["ï¼", "ï¼"]], false, false), peg$c160 = /^[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/, peg$c161 = peg$classExpectation([["á®", "á°"], ["â ", "â"], ["â", "â"], "ã", ["ã¡", "ã©"], ["ã¸", "ãº"], ["ê¦", "ê¯"]], false, false), peg$c162 = /^[_\u203F-\u2040\u2054\uFE33-\uFE34\uFE4D-\uFE4F\uFF3F]/, peg$c163 = peg$classExpectation(["_", ["â¿", "â"], "â", ["ï¸³", "ï¸´"], ["ï¹", "ï¹"], "ï¼¿"], false, false), peg$c164 = /^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/, peg$c165 = peg$classExpectation([" ", "Â ", "á", ["â", "â"], "â¯", "â", "ã"], false, false), peg$c166 = "break", peg$c167 = peg$literalExpectation("break", false), peg$c168 = "case", peg$c169 = peg$literalExpectation("case", false), peg$c170 = "catch", peg$c171 = peg$literalExpectation("catch", false), peg$c172 = "class", peg$c173 = peg$literalExpectation("class", false), peg$c174 = "const", peg$c175 = peg$literalExpectation("const", false), peg$c176 = "continue", peg$c177 = peg$literalExpectation("continue", false), peg$c178 = "debugger", peg$c179 = peg$literalExpectation("debugger", false), peg$c180 = "default", peg$c181 = peg$literalExpectation("default", false), peg$c182 = "delete", peg$c183 = peg$literalExpectation("delete", false), peg$c184 = "do", peg$c185 = peg$literalExpectation("do", false), peg$c186 = "else", peg$c187 = peg$literalExpectation("else", false), peg$c188 = "enum", peg$c189 = peg$literalExpectation("enum", false), peg$c190 = "export", peg$c191 = peg$literalExpectation("export", false), peg$c192 = "extends", peg$c193 = peg$literalExpectation("extends", false), peg$c194 = "false", peg$c195 = peg$literalExpectation("false", false), peg$c196 = "finally", peg$c197 = peg$literalExpectation("finally", false), peg$c198 = "for", peg$c199 = peg$literalExpectation("for", false), peg$c200 = "function", peg$c201 = peg$literalExpectation("function", false), peg$c202 = "if", peg$c203 = peg$literalExpectation("if", false), peg$c204 = "import", peg$c205 = peg$literalExpectation("import", false), peg$c206 = "instanceof", peg$c207 = peg$literalExpectation("instanceof", false), peg$c208 = "in", peg$c209 = peg$literalExpectation("in", false), peg$c210 = "new", peg$c211 = peg$literalExpectation("new", false), peg$c212 = "null", peg$c213 = peg$literalExpectation("null", false), peg$c214 = "return", peg$c215 = peg$literalExpectation("return", false), peg$c216 = "super", peg$c217 = peg$literalExpectation("super", false), peg$c218 = "switch", peg$c219 = peg$literalExpectation("switch", false), peg$c220 = "this", peg$c221 = peg$literalExpectation("this", false), peg$c222 = "throw", peg$c223 = peg$literalExpectation("throw", false), peg$c224 = "true", peg$c225 = peg$literalExpectation("true", false), peg$c226 = "try", peg$c227 = peg$literalExpectation("try", false), peg$c228 = "typeof", peg$c229 = peg$literalExpectation("typeof", false), peg$c230 = "var", peg$c231 = peg$literalExpectation("var", false), peg$c232 = "void", peg$c233 = peg$literalExpectation("void", false), peg$c234 = "while", peg$c235 = peg$literalExpectation("while", false), peg$c236 = "with", peg$c237 = peg$literalExpectation("with", false), peg$c238 = ";", peg$c239 = peg$literalExpectation(";", false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function text2() {
      return input2.substring(peg$savedPos, peg$currPos);
    }
    function location2() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function error(message, location3) {
      location3 = location3 !== void 0 ? location3 : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildSimpleError(message, location3);
    }
    function peg$literalExpectation(text3, ignoreCase) {
      return { type: "literal", text: text3, ignoreCase };
    }
    function peg$classExpectation(parts2, inverted, ignoreCase) {
      return { type: "class", parts: parts2, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p2;
      if (details) {
        return details;
      } else {
        p2 = pos - 1;
        while (!peg$posDetailsCache[p2]) {
          p2--;
        }
        details = peg$posDetailsCache[p2];
        details = {
          line: details.line,
          column: details.column
        };
        while (p2 < pos) {
          if (input2.charCodeAt(p2) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p2++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }
    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location3) {
      return new peg$SyntaxError(message, null, null, location3);
    }
    function peg$buildStructuredError(expected, found, location3) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location3
      );
    }
    function peg$parseGrammar() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseInitializer();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseRule();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$parseRule();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseInitializer() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseCodeBlock();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOS();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseRule() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = peg$parseIdentifierName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseStringLiteral();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c2;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseChoiceExpression();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseEOS();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s1, s3, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseChoiceExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = peg$parseActionExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 47) {
            s5 = peg$c5;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseActionExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseActionExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseActionExpression() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parseSequenceExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse__();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCodeBlock();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSequenceExpression() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parseLabeledExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseLabeledExpression();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseLabeledExpression();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c9(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseLabeledExpression() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c10;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsePrefixedExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsePrefixedExpression();
      }
      return s0;
    }
    function peg$parsePrefixedExpression() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsePrefixedOperator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseSuffixedExpression();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c13(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseSuffixedExpression();
      }
      return s0;
    }
    function peg$parsePrefixedOperator() {
      var s0;
      if (input2.charCodeAt(peg$currPos) === 36) {
        s0 = peg$c14;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c15);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 38) {
          s0 = peg$c16;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 33) {
            s0 = peg$c18;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c19);
            }
          }
        }
      }
      return s0;
    }
    function peg$parseSuffixedExpression() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsePrimaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseSuffixedOperator();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsePrimaryExpression();
      }
      return s0;
    }
    function peg$parseSuffixedOperator() {
      var s0;
      if (input2.charCodeAt(peg$currPos) === 63) {
        s0 = peg$c21;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c22);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 42) {
          s0 = peg$c23;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 43) {
            s0 = peg$c25;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
        }
      }
      return s0;
    }
    function peg$parsePrimaryExpression() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$parseLiteralMatcher();
      if (s0 === peg$FAILED) {
        s0 = peg$parseCharacterClassMatcher();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnyMatcher();
          if (s0 === peg$FAILED) {
            s0 = peg$parseRuleReferenceExpression();
            if (s0 === peg$FAILED) {
              s0 = peg$parseSemanticPredicateExpression();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input2.charCodeAt(peg$currPos) === 40) {
                  s1 = peg$c27;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c28);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse__();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseChoiceExpression();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parse__();
                      if (s4 !== peg$FAILED) {
                        if (input2.charCodeAt(peg$currPos) === 41) {
                          s5 = peg$c29;
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c30);
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c31(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseRuleReferenceExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = peg$parseIdentifierName();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parseStringLiteral();
          if (s6 !== peg$FAILED) {
            s7 = peg$parse__();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 61) {
              s6 = peg$c2;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSemanticPredicateExpression() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseSemanticPredicateOperator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseCodeBlock();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSemanticPredicateOperator() {
      var s0;
      if (input2.charCodeAt(peg$currPos) === 38) {
        s0 = peg$c16;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c17);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 33) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c19);
          }
        }
      }
      return s0;
    }
    function peg$parseSourceCharacter() {
      var s0;
      if (input2.length > peg$currPos) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c34);
        }
      }
      return s0;
    }
    function peg$parseWhiteSpace() {
      var s0;
      peg$silentFails++;
      if (input2.charCodeAt(peg$currPos) === 9) {
        s0 = peg$c36;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c37);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 11) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 12) {
            s0 = peg$c40;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c41);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 32) {
              s0 = peg$c42;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 160) {
                s0 = peg$c44;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }
              if (s0 === peg$FAILED) {
                if (input2.charCodeAt(peg$currPos) === 65279) {
                  s0 = peg$c46;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c47);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseZs();
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c35);
        }
      }
      return s0;
    }
    function peg$parseLineTerminator() {
      var s0;
      if (peg$c48.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c49);
        }
      }
      return s0;
    }
    function peg$parseLineTerminatorSequence() {
      var s0;
      peg$silentFails++;
      if (input2.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c51;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c52);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.substr(peg$currPos, 2) === peg$c53) {
          s0 = peg$c53;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c55;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c57;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c58);
              }
            }
            if (s0 === peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c59;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c60);
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c50);
        }
      }
      return s0;
    }
    function peg$parseComment() {
      var s0;
      peg$silentFails++;
      s0 = peg$parseMultiLineComment();
      if (s0 === peg$FAILED) {
        s0 = peg$parseSingleLineComment();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c61);
        }
      }
      return s0;
    }
    function peg$parseMultiLineComment() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c62) {
        s1 = peg$c62;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c63);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input2.substr(peg$currPos, 2) === peg$c64) {
          s5 = peg$c64;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input2.substr(peg$currPos, 2) === peg$c64) {
            s5 = peg$c64;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input2.substr(peg$currPos, 2) === peg$c64) {
            s3 = peg$c64;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseMultiLineCommentNoLineTerminator() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c62) {
        s1 = peg$c62;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c63);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input2.substr(peg$currPos, 2) === peg$c64) {
          s5 = peg$c64;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s5 === peg$FAILED) {
          s5 = peg$parseLineTerminator();
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input2.substr(peg$currPos, 2) === peg$c64) {
            s5 = peg$c64;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseLineTerminator();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input2.substr(peg$currPos, 2) === peg$c64) {
            s3 = peg$c64;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSingleLineComment() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c66) {
        s1 = peg$c66;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseLineTerminator();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseIdentifier() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseReservedWord();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifierName();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c68(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseIdentifierName() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseIdentifierStart();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseIdentifierPart();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseIdentifierPart();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c70(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c69);
        }
      }
      return s0;
    }
    function peg$parseIdentifierStart() {
      var s0, s1, s2;
      s0 = peg$parseUnicodeLetter();
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 36) {
          s0 = peg$c14;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 95) {
            s0 = peg$c71;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 92) {
              s1 = peg$c73;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c74);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseUnicodeEscapeSequence();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c75(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
      return s0;
    }
    function peg$parseIdentifierPart() {
      var s0;
      s0 = peg$parseIdentifierStart();
      if (s0 === peg$FAILED) {
        s0 = peg$parseUnicodeCombiningMark();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNd();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePc();
            if (s0 === peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 8204) {
                s0 = peg$c76;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c77);
                }
              }
              if (s0 === peg$FAILED) {
                if (input2.charCodeAt(peg$currPos) === 8205) {
                  s0 = peg$c78;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c79);
                  }
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseUnicodeLetter() {
      var s0;
      s0 = peg$parseLu();
      if (s0 === peg$FAILED) {
        s0 = peg$parseLl();
        if (s0 === peg$FAILED) {
          s0 = peg$parseLt();
          if (s0 === peg$FAILED) {
            s0 = peg$parseLm();
            if (s0 === peg$FAILED) {
              s0 = peg$parseLo();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNl();
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseUnicodeCombiningMark() {
      var s0;
      s0 = peg$parseMn();
      if (s0 === peg$FAILED) {
        s0 = peg$parseMc();
      }
      return s0;
    }
    function peg$parseReservedWord() {
      var s0;
      s0 = peg$parseKeyword();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFutureReservedWord();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNullToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseBooleanLiteral();
          }
        }
      }
      return s0;
    }
    function peg$parseKeyword() {
      var s0;
      s0 = peg$parseBreakToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseCaseToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseCatchToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseContinueToken();
            if (s0 === peg$FAILED) {
              s0 = peg$parseDebuggerToken();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDefaultToken();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseDeleteToken();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseDoToken();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseElseToken();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseFinallyToken();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseForToken();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseFunctionToken();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseIfToken();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseInstanceofToken();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseInToken();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseNewToken();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parseReturnToken();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseSwitchToken();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseThisToken();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseThrowToken();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$parseTryToken();
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$parseTypeofToken();
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$parseVarToken();
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$parseVoidToken();
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$parseWhileToken();
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$parseWithToken();
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseFutureReservedWord() {
      var s0;
      s0 = peg$parseClassToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseConstToken();
        if (s0 === peg$FAILED) {
          s0 = peg$parseEnumToken();
          if (s0 === peg$FAILED) {
            s0 = peg$parseExportToken();
            if (s0 === peg$FAILED) {
              s0 = peg$parseExtendsToken();
              if (s0 === peg$FAILED) {
                s0 = peg$parseImportToken();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseSuperToken();
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseBooleanLiteral() {
      var s0;
      s0 = peg$parseTrueToken();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFalseToken();
      }
      return s0;
    }
    function peg$parseLiteralMatcher() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseStringLiteral();
      if (s1 !== peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c81;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c83(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c80);
        }
      }
      return s0;
    }
    function peg$parseStringLiteral() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c85;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c86);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDoubleStringCharacter();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseDoubleStringCharacter();
        }
        if (s2 !== peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c85;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c88;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseSingleStringCharacter();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseSingleStringCharacter();
          }
          if (s2 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c88;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c89);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c84);
        }
      }
      return s0;
    }
    function peg$parseDoubleStringCharacter() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input2.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c85;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c86);
        }
      }
      if (s2 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c73;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c75(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseLineContinuation();
        }
      }
      return s0;
    }
    function peg$parseSingleStringCharacter() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input2.charCodeAt(peg$currPos) === 39) {
        s2 = peg$c88;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c89);
        }
      }
      if (s2 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c73;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c75(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseLineContinuation();
        }
      }
      return s0;
    }
    function peg$parseCharacterClassMatcher() {
      var s0, s1, s2, s3, s4, s5;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c92;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c93);
        }
      }
      if (s1 !== peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 94) {
          s2 = peg$c94;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseClassCharacterRange();
          if (s4 === peg$FAILED) {
            s4 = peg$parseClassCharacter();
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseClassCharacterRange();
            if (s4 === peg$FAILED) {
              s4 = peg$parseClassCharacter();
            }
          }
          if (s3 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c96;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c97);
              }
            }
            if (s4 !== peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 105) {
                s5 = peg$c81;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c82);
                }
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c98(s2, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c91);
        }
      }
      return s0;
    }
    function peg$parseClassCharacterRange() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseClassCharacter();
      if (s1 !== peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c99;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c100);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseClassCharacter();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c101(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseClassCharacter() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input2.charCodeAt(peg$currPos) === 93) {
        s2 = peg$c96;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c97);
        }
      }
      if (s2 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c73;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c75(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseLineContinuation();
        }
      }
      return s0;
    }
    function peg$parseLineContinuation() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLineTerminatorSequence();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c102();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEscapeSequence() {
      var s0, s1, s2, s3;
      s0 = peg$parseCharacterEscapeSequence();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c103;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parseDecimalDigit();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c105();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseHexEscapeSequence();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUnicodeEscapeSequence();
          }
        }
      }
      return s0;
    }
    function peg$parseCharacterEscapeSequence() {
      var s0;
      s0 = peg$parseSingleEscapeCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNonEscapeCharacter();
      }
      return s0;
    }
    function peg$parseSingleEscapeCharacter() {
      var s0, s1;
      if (input2.charCodeAt(peg$currPos) === 39) {
        s0 = peg$c88;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c89);
        }
      }
      if (s0 === peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 34) {
          s0 = peg$c85;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 92) {
            s0 = peg$c73;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input2.charCodeAt(peg$currPos) === 98) {
              s1 = peg$c106;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c107);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c108();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input2.charCodeAt(peg$currPos) === 102) {
                s1 = peg$c109;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c110);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c111();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input2.charCodeAt(peg$currPos) === 110) {
                  s1 = peg$c112;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c113);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c114();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input2.charCodeAt(peg$currPos) === 114) {
                    s1 = peg$c115;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c116);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c117();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input2.charCodeAt(peg$currPos) === 116) {
                      s1 = peg$c118;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c119);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c120();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input2.charCodeAt(peg$currPos) === 118) {
                        s1 = peg$c121;
                        peg$currPos++;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c122);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c123();
                      }
                      s0 = s1;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseNonEscapeCharacter() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseEscapeCharacter();
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminator();
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEscapeCharacter() {
      var s0;
      s0 = peg$parseSingleEscapeCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseDecimalDigit();
        if (s0 === peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 120) {
            s0 = peg$c124;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c125);
            }
          }
          if (s0 === peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 117) {
              s0 = peg$c126;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c127);
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parseHexEscapeSequence() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 120) {
        s1 = peg$c124;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c125);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parseHexDigit();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseHexDigit();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input2.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c128(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseUnicodeEscapeSequence() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 117) {
        s1 = peg$c126;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c127);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parseHexDigit();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseHexDigit();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseHexDigit();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseHexDigit();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input2.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c128(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseDecimalDigit() {
      var s0;
      if (peg$c129.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c130);
        }
      }
      return s0;
    }
    function peg$parseHexDigit() {
      var s0;
      if (peg$c131.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c132);
        }
      }
      return s0;
    }
    function peg$parseAnyMatcher() {
      var s0, s1;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c133;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c134);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c135();
      }
      s0 = s1;
      return s0;
    }
    function peg$parseCodeBlock() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input2.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c137;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c138);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseCode();
        if (s2 !== peg$FAILED) {
          if (input2.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c139;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c141(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c136);
        }
      }
      return s0;
    }
    function peg$parseCode() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = [];
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (peg$c142.test(input2.charAt(peg$currPos))) {
        s5 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c143);
        }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parseSourceCharacter();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (peg$c142.test(input2.charAt(peg$currPos))) {
            s5 = input2.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c143);
            }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        if (input2.charCodeAt(peg$currPos) === 123) {
          s3 = peg$c137;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c138);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCode();
          if (s4 !== peg$FAILED) {
            if (input2.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c139;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c140);
              }
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$c142.test(input2.charAt(peg$currPos))) {
          s5 = input2.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c143);
          }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (peg$c142.test(input2.charAt(peg$currPos))) {
              s5 = input2.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c143);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSourceCharacter();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          if (input2.charCodeAt(peg$currPos) === 123) {
            s3 = peg$c137;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c138);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCode();
            if (s4 !== peg$FAILED) {
              if (input2.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c139;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c140);
                }
              }
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s0 = input2.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      return s0;
    }
    function peg$parseLl() {
      var s0;
      if (peg$c144.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c145);
        }
      }
      return s0;
    }
    function peg$parseLm() {
      var s0;
      if (peg$c146.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c147);
        }
      }
      return s0;
    }
    function peg$parseLo() {
      var s0;
      if (peg$c148.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c149);
        }
      }
      return s0;
    }
    function peg$parseLt() {
      var s0;
      if (peg$c150.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c151);
        }
      }
      return s0;
    }
    function peg$parseLu() {
      var s0;
      if (peg$c152.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c153);
        }
      }
      return s0;
    }
    function peg$parseMc() {
      var s0;
      if (peg$c154.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c155);
        }
      }
      return s0;
    }
    function peg$parseMn() {
      var s0;
      if (peg$c156.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c157);
        }
      }
      return s0;
    }
    function peg$parseNd() {
      var s0;
      if (peg$c158.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c159);
        }
      }
      return s0;
    }
    function peg$parseNl() {
      var s0;
      if (peg$c160.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c161);
        }
      }
      return s0;
    }
    function peg$parsePc() {
      var s0;
      if (peg$c162.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c163);
        }
      }
      return s0;
    }
    function peg$parseZs() {
      var s0;
      if (peg$c164.test(input2.charAt(peg$currPos))) {
        s0 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c165);
        }
      }
      return s0;
    }
    function peg$parseBreakToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c166) {
        s1 = peg$c166;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c167);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseCaseToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c168) {
        s1 = peg$c168;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c169);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseCatchToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c170) {
        s1 = peg$c170;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c171);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseClassToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c172) {
        s1 = peg$c172;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c173);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseConstToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c174) {
        s1 = peg$c174;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c175);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseContinueToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 8) === peg$c176) {
        s1 = peg$c176;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c177);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseDebuggerToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 8) === peg$c178) {
        s1 = peg$c178;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c179);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseDefaultToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 7) === peg$c180) {
        s1 = peg$c180;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c181);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseDeleteToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c182) {
        s1 = peg$c182;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c183);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseDoToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c184) {
        s1 = peg$c184;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c185);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseElseToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c186) {
        s1 = peg$c186;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c187);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEnumToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c188) {
        s1 = peg$c188;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c189);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseExportToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c190) {
        s1 = peg$c190;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c191);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseExtendsToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 7) === peg$c192) {
        s1 = peg$c192;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c193);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseFalseToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c194) {
        s1 = peg$c194;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c195);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseFinallyToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 7) === peg$c196) {
        s1 = peg$c196;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c197);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseForToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 3) === peg$c198) {
        s1 = peg$c198;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c199);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseFunctionToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 8) === peg$c200) {
        s1 = peg$c200;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c201);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseIfToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c202) {
        s1 = peg$c202;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c203);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseImportToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c204) {
        s1 = peg$c204;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c205);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseInstanceofToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 10) === peg$c206) {
        s1 = peg$c206;
        peg$currPos += 10;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c207);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseInToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 2) === peg$c208) {
        s1 = peg$c208;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c209);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseNewToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 3) === peg$c210) {
        s1 = peg$c210;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c211);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseNullToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c212) {
        s1 = peg$c212;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c213);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseReturnToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c214) {
        s1 = peg$c214;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c215);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSuperToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c216) {
        s1 = peg$c216;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c217);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseSwitchToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c218) {
        s1 = peg$c218;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c219);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseThisToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c220) {
        s1 = peg$c220;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c221);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseThrowToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c222) {
        s1 = peg$c222;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c223);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseTrueToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c224) {
        s1 = peg$c224;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c225);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseTryToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 3) === peg$c226) {
        s1 = peg$c226;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c227);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseTypeofToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 6) === peg$c228) {
        s1 = peg$c228;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c229);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseVarToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 3) === peg$c230) {
        s1 = peg$c230;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c231);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseVoidToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c232) {
        s1 = peg$c232;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c233);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseWhileToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 5) === peg$c234) {
        s1 = peg$c234;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c235);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseWithToken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input2.substr(peg$currPos, 4) === peg$c236) {
        s1 = peg$c236;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c237);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseIdentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parse__() {
      var s0, s1;
      s0 = [];
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseLineTerminatorSequence();
        if (s1 === peg$FAILED) {
          s1 = peg$parseComment();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseWhiteSpace();
        if (s1 === peg$FAILED) {
          s1 = peg$parseLineTerminatorSequence();
          if (s1 === peg$FAILED) {
            s1 = peg$parseComment();
          }
        }
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1;
      s0 = [];
      s1 = peg$parseWhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseMultiLineCommentNoLineTerminator();
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseWhiteSpace();
        if (s1 === peg$FAILED) {
          s1 = peg$parseMultiLineCommentNoLineTerminator();
        }
      }
      return s0;
    }
    function peg$parseEOS() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        if (input2.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c238;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c239);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSingleLineComment();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseLineTerminatorSequence();
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse__();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseEOF();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
      return s0;
    }
    function peg$parseEOF() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input2.length > peg$currPos) {
        s1 = input2.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c34);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = void 0;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    var OPS_TO_PREFIXED_TYPES = {
      "$": "text",
      "&": "simple_and",
      "!": "simple_not"
    };
    var OPS_TO_SUFFIXED_TYPES = {
      "?": "optional",
      "*": "zero_or_more",
      "+": "one_or_more"
    };
    var OPS_TO_SEMANTIC_PREDICATE_TYPES = {
      "&": "semantic_and",
      "!": "semantic_not"
    };
    function filterEmptyStrings(array) {
      var result = [], i;
      for (i = 0; i < array.length; i++) {
        if (array[i] !== "") {
          result.push(array[i]);
        }
      }
      return result;
    }
    function extractOptional(optional, index2) {
      return optional ? optional[index2] : null;
    }
    function extractList(list2, index2) {
      var result = new Array(list2.length), i;
      for (i = 0; i < list2.length; i++) {
        result[i] = list2[i][index2];
      }
      return result;
    }
    function buildList(head2, tail, index2) {
      return [head2].concat(extractList(tail, index2));
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input2.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input2.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input2.length ? input2.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input2.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }
  var parser = {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
  var objects$5 = objects_1, arrays$8 = arrays_1;
  var visitor$8 = {
    build: function(functions) {
      function visit2(node2) {
        return functions[node2.type].apply(null, arguments);
      }
      function visitNop() {
      }
      function visitExpression(node2) {
        var extraArgs = Array.prototype.slice.call(arguments, 1);
        visit2.apply(null, [node2.expression].concat(extraArgs));
      }
      function visitChildren(property) {
        return function(node2) {
          var extraArgs = Array.prototype.slice.call(arguments, 1);
          arrays$8.each(node2[property], function(child) {
            visit2.apply(null, [child].concat(extraArgs));
          });
        };
      }
      var DEFAULT_FUNCTIONS = {
        grammar: function(node2) {
          var extraArgs = Array.prototype.slice.call(arguments, 1);
          if (node2.initializer) {
            visit2.apply(null, [node2.initializer].concat(extraArgs));
          }
          arrays$8.each(node2.rules, function(rule2) {
            visit2.apply(null, [rule2].concat(extraArgs));
          });
        },
        initializer: visitNop,
        rule: visitExpression,
        named: visitExpression,
        choice: visitChildren("alternatives"),
        action: visitExpression,
        sequence: visitChildren("elements"),
        labeled: visitExpression,
        text: visitExpression,
        simple_and: visitExpression,
        simple_not: visitExpression,
        optional: visitExpression,
        zero_or_more: visitExpression,
        one_or_more: visitExpression,
        group: visitExpression,
        semantic_and: visitNop,
        semantic_not: visitNop,
        rule_ref: visitNop,
        literal: visitNop,
        "class": visitNop,
        any: visitNop
      };
      objects$5.defaults(functions, DEFAULT_FUNCTIONS);
      return visit2;
    }
  };
  var visitor_1 = visitor$8;
  var arrays$7 = arrays_1, visitor$7 = visitor_1;
  var asts$5 = {
    findRule: function(ast2, name2) {
      return arrays$7.find(ast2.rules, function(r) {
        return r.name === name2;
      });
    },
    indexOfRule: function(ast2, name2) {
      return arrays$7.indexOf(ast2.rules, function(r) {
        return r.name === name2;
      });
    },
    alwaysConsumesOnSuccess: function(ast2, node2) {
      function consumesTrue() {
        return true;
      }
      function consumesFalse() {
        return false;
      }
      function consumesExpression(node3) {
        return consumes(node3.expression);
      }
      var consumes = visitor$7.build({
        rule: consumesExpression,
        named: consumesExpression,
        choice: function(node3) {
          return arrays$7.every(node3.alternatives, consumes);
        },
        action: consumesExpression,
        sequence: function(node3) {
          return arrays$7.some(node3.elements, consumes);
        },
        labeled: consumesExpression,
        text: consumesExpression,
        simple_and: consumesFalse,
        simple_not: consumesFalse,
        optional: consumesFalse,
        zero_or_more: consumesFalse,
        one_or_more: consumesExpression,
        group: consumesExpression,
        semantic_and: consumesFalse,
        semantic_not: consumesFalse,
        rule_ref: function(node3) {
          return consumes(asts$5.findRule(ast2, node3.name));
        },
        literal: function(node3) {
          return node3.value !== "";
        },
        "class": consumesTrue,
        any: consumesTrue
      });
      return consumes(node2);
    }
  };
  var asts_1 = asts$5;
  var GrammarError$4 = grammarError, asts$4 = asts_1, visitor$6 = visitor_1;
  function reportUndefinedRules(ast2) {
    var check = visitor$6.build({
      rule_ref: function(node2) {
        if (!asts$4.findRule(ast2, node2.name)) {
          throw new GrammarError$4(
            'Rule "' + node2.name + '" is not defined.',
            node2.location
          );
        }
      }
    });
    check(ast2);
  }
  var reportUndefinedRules_1 = reportUndefinedRules;
  var GrammarError$3 = grammarError, visitor$5 = visitor_1;
  function reportDuplicateRules(ast2) {
    var rules = {};
    var check = visitor$5.build({
      rule: function(node2) {
        if (rules.hasOwnProperty(node2.name)) {
          throw new GrammarError$3(
            'Rule "' + node2.name + '" is already defined at line ' + rules[node2.name].start.line + ", column " + rules[node2.name].start.column + ".",
            node2.location
          );
        }
        rules[node2.name] = node2.location;
      }
    });
    check(ast2);
  }
  var reportDuplicateRules_1 = reportDuplicateRules;
  var GrammarError$2 = grammarError, arrays$6 = arrays_1, objects$4 = objects_1, visitor$4 = visitor_1;
  function reportDuplicateLabels(ast2) {
    function checkExpressionWithClonedEnv(node2, env2) {
      check(node2.expression, objects$4.clone(env2));
    }
    var check = visitor$4.build({
      rule: function(node2) {
        check(node2.expression, {});
      },
      choice: function(node2, env2) {
        arrays$6.each(node2.alternatives, function(alternative) {
          check(alternative, objects$4.clone(env2));
        });
      },
      action: checkExpressionWithClonedEnv,
      labeled: function(node2, env2) {
        if (env2.hasOwnProperty(node2.label)) {
          throw new GrammarError$2(
            'Label "' + node2.label + '" is already defined at line ' + env2[node2.label].start.line + ", column " + env2[node2.label].start.column + ".",
            node2.location
          );
        }
        check(node2.expression, env2);
        env2[node2.label] = node2.location;
      },
      text: checkExpressionWithClonedEnv,
      simple_and: checkExpressionWithClonedEnv,
      simple_not: checkExpressionWithClonedEnv,
      optional: checkExpressionWithClonedEnv,
      zero_or_more: checkExpressionWithClonedEnv,
      one_or_more: checkExpressionWithClonedEnv,
      group: checkExpressionWithClonedEnv
    });
    check(ast2);
  }
  var reportDuplicateLabels_1 = reportDuplicateLabels;
  var arrays$5 = arrays_1, GrammarError$1 = grammarError, asts$3 = asts_1, visitor$3 = visitor_1;
  function reportInfiniteRecursion(ast2) {
    var visitedRules = [];
    var check = visitor$3.build({
      rule: function(node2) {
        visitedRules.push(node2.name);
        check(node2.expression);
        visitedRules.pop(node2.name);
      },
      sequence: function(node2) {
        arrays$5.every(node2.elements, function(element2) {
          check(element2);
          return !asts$3.alwaysConsumesOnSuccess(ast2, element2);
        });
      },
      rule_ref: function(node2) {
        if (arrays$5.contains(visitedRules, node2.name)) {
          visitedRules.push(node2.name);
          throw new GrammarError$1(
            "Possible infinite loop when parsing (left recursion: " + visitedRules.join(" -> ") + ").",
            node2.location
          );
        }
        check(asts$3.findRule(ast2, node2.name));
      }
    });
    check(ast2);
  }
  var reportInfiniteRecursion_1 = reportInfiniteRecursion;
  var GrammarError = grammarError, asts$2 = asts_1, visitor$2 = visitor_1;
  function reportInfiniteRepetition(ast2) {
    var check = visitor$2.build({
      zero_or_more: function(node2) {
        if (!asts$2.alwaysConsumesOnSuccess(ast2, node2.expression)) {
          throw new GrammarError(
            "Possible infinite loop when parsing (repetition used with an expression that may not consume any input).",
            node2.location
          );
        }
      },
      one_or_more: function(node2) {
        if (!asts$2.alwaysConsumesOnSuccess(ast2, node2.expression)) {
          throw new GrammarError(
            "Possible infinite loop when parsing (repetition used with an expression that may not consume any input).",
            node2.location
          );
        }
      }
    });
    check(ast2);
  }
  var reportInfiniteRepetition_1 = reportInfiniteRepetition;
  var arrays$4 = arrays_1, visitor$1 = visitor_1;
  function removeProxyRules(ast2, options2) {
    function isProxyRule(node2) {
      return node2.type === "rule" && node2.expression.type === "rule_ref";
    }
    function replaceRuleRefs(ast3, from, to2) {
      var replace = visitor$1.build({
        rule_ref: function(node2) {
          if (node2.name === from) {
            node2.name = to2;
          }
        }
      });
      replace(ast3);
    }
    var indices = [];
    arrays$4.each(ast2.rules, function(rule2, i) {
      if (isProxyRule(rule2)) {
        replaceRuleRefs(ast2, rule2.name, rule2.expression.name);
        if (!arrays$4.contains(options2.allowedStartRules, rule2.name)) {
          indices.push(i);
        }
      }
    });
    indices.reverse();
    arrays$4.each(indices, function(i) {
      ast2.rules.splice(i, 1);
    });
  }
  var removeProxyRules_1 = removeProxyRules;
  var opcodes = {
    /* Stack Manipulation */
    PUSH: 0,
    // PUSH c
    PUSH_UNDEFINED: 1,
    // PUSH_UNDEFINED
    PUSH_NULL: 2,
    // PUSH_NULL
    PUSH_FAILED: 3,
    // PUSH_FAILED
    PUSH_EMPTY_ARRAY: 4,
    // PUSH_EMPTY_ARRAY
    PUSH_CURR_POS: 5,
    // PUSH_CURR_POS
    POP: 6,
    // POP
    POP_CURR_POS: 7,
    // POP_CURR_POS
    POP_N: 8,
    // POP_N n
    NIP: 9,
    // NIP
    APPEND: 10,
    // APPEND
    WRAP: 11,
    // WRAP n
    TEXT: 12,
    // TEXT
    /* Conditions and Loops */
    IF: 13,
    // IF t, f
    IF_ERROR: 14,
    // IF_ERROR t, f
    IF_NOT_ERROR: 15,
    // IF_NOT_ERROR t, f
    WHILE_NOT_ERROR: 16,
    // WHILE_NOT_ERROR b
    /* Matching */
    MATCH_ANY: 17,
    // MATCH_ANY a, f, ...
    MATCH_STRING: 18,
    // MATCH_STRING s, a, f, ...
    MATCH_STRING_IC: 19,
    // MATCH_STRING_IC s, a, f, ...
    MATCH_REGEXP: 20,
    // MATCH_REGEXP r, a, f, ...
    ACCEPT_N: 21,
    // ACCEPT_N n
    ACCEPT_STRING: 22,
    // ACCEPT_STRING s
    FAIL: 23,
    // FAIL e
    /* Calls */
    LOAD_SAVED_POS: 24,
    // LOAD_SAVED_POS p
    UPDATE_SAVED_POS: 25,
    // UPDATE_SAVED_POS
    CALL: 26,
    // CALL f, n, pc, p1, p2, ..., pN
    /* Rules */
    RULE: 27,
    // RULE r
    /* Failure Reporting */
    SILENT_FAILS_ON: 28,
    // SILENT_FAILS_ON
    SILENT_FAILS_OFF: 29
    // SILENT_FAILS_OFF
  };
  var opcodes_1 = opcodes;
  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  var js$2 = {
    stringEscape: function(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\xFF]/g, function(ch) {
        return "\\x" + hex(ch);
      }).replace(/[\u0100-\u0FFF]/g, function(ch) {
        return "\\u0" + hex(ch);
      }).replace(/[\u1000-\uFFFF]/g, function(ch) {
        return "\\u" + hex(ch);
      });
    },
    regexpClassEscape: function(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\//g, "\\/").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\v/g, "\\x0B").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\xFF]/g, function(ch) {
        return "\\x" + hex(ch);
      }).replace(/[\u0100-\u0FFF]/g, function(ch) {
        return "\\u0" + hex(ch);
      }).replace(/[\u1000-\uFFFF]/g, function(ch) {
        return "\\u" + hex(ch);
      });
    }
  };
  var js_1 = js$2;
  var arrays$3 = arrays_1, objects$3 = objects_1, asts$1 = asts_1, visitor = visitor_1, op$1 = opcodes_1, js$1 = js_1;
  function generateBytecode(ast2) {
    var consts = [];
    function addConst(value2) {
      var index2 = arrays$3.indexOf(consts, value2);
      return index2 === -1 ? consts.push(value2) - 1 : index2;
    }
    function addFunctionConst(params, code2) {
      return addConst(
        "function(" + params.join(", ") + ") {" + code2 + "}"
      );
    }
    function buildSequence() {
      return Array.prototype.concat.apply([], arguments);
    }
    function buildCondition(condCode, thenCode, elseCode) {
      return condCode.concat(
        [thenCode.length, elseCode.length],
        thenCode,
        elseCode
      );
    }
    function buildLoop(condCode, bodyCode) {
      return condCode.concat([bodyCode.length], bodyCode);
    }
    function buildCall(functionIndex, delta, env2, sp) {
      var params = arrays$3.map(objects$3.values(env2), function(p2) {
        return sp - p2;
      });
      return [op$1.CALL, functionIndex, delta, params.length].concat(params);
    }
    function buildSimplePredicate(expression, negative, context) {
      return buildSequence(
        [op$1.PUSH_CURR_POS],
        [op$1.SILENT_FAILS_ON],
        generate(expression, {
          sp: context.sp + 1,
          env: objects$3.clone(context.env),
          action: null
        }),
        [op$1.SILENT_FAILS_OFF],
        buildCondition(
          [negative ? op$1.IF_ERROR : op$1.IF_NOT_ERROR],
          buildSequence(
            [op$1.POP],
            [negative ? op$1.POP : op$1.POP_CURR_POS],
            [op$1.PUSH_UNDEFINED]
          ),
          buildSequence(
            [op$1.POP],
            [negative ? op$1.POP_CURR_POS : op$1.POP],
            [op$1.PUSH_FAILED]
          )
        )
      );
    }
    function buildSemanticPredicate(code2, negative, context) {
      var functionIndex = addFunctionConst(objects$3.keys(context.env), code2);
      return buildSequence(
        [op$1.UPDATE_SAVED_POS],
        buildCall(functionIndex, 0, context.env, context.sp),
        buildCondition(
          [op$1.IF],
          buildSequence(
            [op$1.POP],
            negative ? [op$1.PUSH_FAILED] : [op$1.PUSH_UNDEFINED]
          ),
          buildSequence(
            [op$1.POP],
            negative ? [op$1.PUSH_UNDEFINED] : [op$1.PUSH_FAILED]
          )
        )
      );
    }
    function buildAppendLoop(expressionCode) {
      return buildLoop(
        [op$1.WHILE_NOT_ERROR],
        buildSequence([op$1.APPEND], expressionCode)
      );
    }
    var generate = visitor.build({
      grammar: function(node2) {
        arrays$3.each(node2.rules, generate);
        node2.consts = consts;
      },
      rule: function(node2) {
        node2.bytecode = generate(node2.expression, {
          sp: -1,
          // stack pointer
          env: {},
          // mapping of label names to stack positions
          action: null
          // action nodes pass themselves to children here
        });
      },
      named: function(node2, context) {
        var nameIndex = addConst(
          'peg$otherExpectation("' + js$1.stringEscape(node2.name) + '")'
        );
        return buildSequence(
          [op$1.SILENT_FAILS_ON],
          generate(node2.expression, context),
          [op$1.SILENT_FAILS_OFF],
          buildCondition([op$1.IF_ERROR], [op$1.FAIL, nameIndex], [])
        );
      },
      choice: function(node2, context) {
        function buildAlternativesCode(alternatives, context2) {
          return buildSequence(
            generate(alternatives[0], {
              sp: context2.sp,
              env: objects$3.clone(context2.env),
              action: null
            }),
            alternatives.length > 1 ? buildCondition(
              [op$1.IF_ERROR],
              buildSequence(
                [op$1.POP],
                buildAlternativesCode(alternatives.slice(1), context2)
              ),
              []
            ) : []
          );
        }
        return buildAlternativesCode(node2.alternatives, context);
      },
      action: function(node2, context) {
        var env2 = objects$3.clone(context.env), emitCall = node2.expression.type !== "sequence" || node2.expression.elements.length === 0, expressionCode = generate(node2.expression, {
          sp: context.sp + (emitCall ? 1 : 0),
          env: env2,
          action: node2
        }), functionIndex = addFunctionConst(objects$3.keys(env2), node2.code);
        return emitCall ? buildSequence(
          [op$1.PUSH_CURR_POS],
          expressionCode,
          buildCondition(
            [op$1.IF_NOT_ERROR],
            buildSequence(
              [op$1.LOAD_SAVED_POS, 1],
              buildCall(functionIndex, 1, env2, context.sp + 2)
            ),
            []
          ),
          [op$1.NIP]
        ) : expressionCode;
      },
      sequence: function(node2, context) {
        function buildElementsCode(elements, context2) {
          var processedCount, functionIndex;
          if (elements.length > 0) {
            processedCount = node2.elements.length - elements.slice(1).length;
            return buildSequence(
              generate(elements[0], {
                sp: context2.sp,
                env: context2.env,
                action: null
              }),
              buildCondition(
                [op$1.IF_NOT_ERROR],
                buildElementsCode(elements.slice(1), {
                  sp: context2.sp + 1,
                  env: context2.env,
                  action: context2.action
                }),
                buildSequence(
                  processedCount > 1 ? [op$1.POP_N, processedCount] : [op$1.POP],
                  [op$1.POP_CURR_POS],
                  [op$1.PUSH_FAILED]
                )
              )
            );
          } else {
            if (context2.action) {
              functionIndex = addFunctionConst(
                objects$3.keys(context2.env),
                context2.action.code
              );
              return buildSequence(
                [op$1.LOAD_SAVED_POS, node2.elements.length],
                buildCall(
                  functionIndex,
                  node2.elements.length,
                  context2.env,
                  context2.sp
                ),
                [op$1.NIP]
              );
            } else {
              return buildSequence([op$1.WRAP, node2.elements.length], [op$1.NIP]);
            }
          }
        }
        return buildSequence(
          [op$1.PUSH_CURR_POS],
          buildElementsCode(node2.elements, {
            sp: context.sp + 1,
            env: context.env,
            action: context.action
          })
        );
      },
      labeled: function(node2, context) {
        var env2 = objects$3.clone(context.env);
        context.env[node2.label] = context.sp + 1;
        return generate(node2.expression, {
          sp: context.sp,
          env: env2,
          action: null
        });
      },
      text: function(node2, context) {
        return buildSequence(
          [op$1.PUSH_CURR_POS],
          generate(node2.expression, {
            sp: context.sp + 1,
            env: objects$3.clone(context.env),
            action: null
          }),
          buildCondition(
            [op$1.IF_NOT_ERROR],
            buildSequence([op$1.POP], [op$1.TEXT]),
            [op$1.NIP]
          )
        );
      },
      simple_and: function(node2, context) {
        return buildSimplePredicate(node2.expression, false, context);
      },
      simple_not: function(node2, context) {
        return buildSimplePredicate(node2.expression, true, context);
      },
      optional: function(node2, context) {
        return buildSequence(
          generate(node2.expression, {
            sp: context.sp,
            env: objects$3.clone(context.env),
            action: null
          }),
          buildCondition(
            [op$1.IF_ERROR],
            buildSequence([op$1.POP], [op$1.PUSH_NULL]),
            []
          )
        );
      },
      zero_or_more: function(node2, context) {
        var expressionCode = generate(node2.expression, {
          sp: context.sp + 1,
          env: objects$3.clone(context.env),
          action: null
        });
        return buildSequence(
          [op$1.PUSH_EMPTY_ARRAY],
          expressionCode,
          buildAppendLoop(expressionCode),
          [op$1.POP]
        );
      },
      one_or_more: function(node2, context) {
        var expressionCode = generate(node2.expression, {
          sp: context.sp + 1,
          env: objects$3.clone(context.env),
          action: null
        });
        return buildSequence(
          [op$1.PUSH_EMPTY_ARRAY],
          expressionCode,
          buildCondition(
            [op$1.IF_NOT_ERROR],
            buildSequence(buildAppendLoop(expressionCode), [op$1.POP]),
            buildSequence([op$1.POP], [op$1.POP], [op$1.PUSH_FAILED])
          )
        );
      },
      group: function(node2, context) {
        return generate(node2.expression, {
          sp: context.sp,
          env: objects$3.clone(context.env),
          action: null
        });
      },
      semantic_and: function(node2, context) {
        return buildSemanticPredicate(node2.code, false, context);
      },
      semantic_not: function(node2, context) {
        return buildSemanticPredicate(node2.code, true, context);
      },
      rule_ref: function(node2) {
        return [op$1.RULE, asts$1.indexOfRule(ast2, node2.name)];
      },
      literal: function(node2) {
        var stringIndex, expectedIndex;
        if (node2.value.length > 0) {
          stringIndex = addConst(
            '"' + js$1.stringEscape(
              node2.ignoreCase ? node2.value.toLowerCase() : node2.value
            ) + '"'
          );
          expectedIndex = addConst(
            'peg$literalExpectation("' + js$1.stringEscape(node2.value) + '", ' + node2.ignoreCase + ")"
          );
          return buildCondition(
            node2.ignoreCase ? [op$1.MATCH_STRING_IC, stringIndex] : [op$1.MATCH_STRING, stringIndex],
            node2.ignoreCase ? [op$1.ACCEPT_N, node2.value.length] : [op$1.ACCEPT_STRING, stringIndex],
            [op$1.FAIL, expectedIndex]
          );
        } else {
          stringIndex = addConst('""');
          return [op$1.PUSH, stringIndex];
        }
      },
      "class": function(node2) {
        var regexp, parts2, regexpIndex, expectedIndex;
        if (node2.parts.length > 0) {
          regexp = "/^[" + (node2.inverted ? "^" : "") + arrays$3.map(node2.parts, function(part) {
            return part instanceof Array ? js$1.regexpClassEscape(part[0]) + "-" + js$1.regexpClassEscape(part[1]) : js$1.regexpClassEscape(part);
          }).join("") + "]/" + (node2.ignoreCase ? "i" : "");
        } else {
          regexp = node2.inverted ? "/^[\\S\\s]/" : "/^(?!)/";
        }
        parts2 = "[" + arrays$3.map(node2.parts, function(part) {
          return part instanceof Array ? '["' + js$1.stringEscape(part[0]) + '", "' + js$1.stringEscape(part[1]) + '"]' : '"' + js$1.stringEscape(part) + '"';
        }).join(", ") + "]";
        regexpIndex = addConst(regexp);
        expectedIndex = addConst(
          "peg$classExpectation(" + parts2 + ", " + node2.inverted + ", " + node2.ignoreCase + ")"
        );
        return buildCondition(
          [op$1.MATCH_REGEXP, regexpIndex],
          [op$1.ACCEPT_N, 1],
          [op$1.FAIL, expectedIndex]
        );
      },
      any: function() {
        var expectedIndex = addConst("peg$anyExpectation()");
        return buildCondition(
          [op$1.MATCH_ANY],
          [op$1.ACCEPT_N, 1],
          [op$1.FAIL, expectedIndex]
        );
      }
    });
    generate(ast2);
  }
  var generateBytecode_1 = generateBytecode;
  var arrays$2 = arrays_1, objects$2 = objects_1, asts = asts_1, op = opcodes_1, js = js_1;
  function generateJS(ast, options) {
    function indent2(code2) {
      return code2.replace(/^(.+)$/gm, "  $1");
    }
    function indent6(code2) {
      return code2.replace(/^(.+)$/gm, "      $1");
    }
    function indent10(code2) {
      return code2.replace(/^(.+)$/gm, "          $1");
    }
    function generateTables() {
      if (options.optimize === "size") {
        return [
          "peg$consts = [",
          indent2(ast.consts.join(",\n")),
          "],",
          "",
          "peg$bytecode = [",
          indent2(arrays$2.map(ast.rules, function(rule2) {
            return 'peg$decode("' + js.stringEscape(arrays$2.map(
              rule2.bytecode,
              function(b) {
                return String.fromCharCode(b + 32);
              }
            ).join("")) + '")';
          }).join(",\n")),
          "],"
        ].join("\n");
      } else {
        return arrays$2.map(
          ast.consts,
          function(c2, i) {
            return "peg$c" + i + " = " + c2 + ",";
          }
        ).join("\n");
      }
    }
    function generateRuleHeader(ruleNameCode, ruleIndexCode) {
      var parts2 = [];
      parts2.push("");
      if (options.trace) {
        parts2.push([
          "peg$tracer.trace({",
          '  type:     "rule.enter",',
          "  rule:     " + ruleNameCode + ",",
          "  location: peg$computeLocation(startPos, startPos)",
          "});",
          ""
        ].join("\n"));
      }
      if (options.cache) {
        parts2.push([
          "var key    = peg$currPos * " + ast.rules.length + " + " + ruleIndexCode + ",",
          "    cached = peg$resultsCache[key];",
          "",
          "if (cached) {",
          "  peg$currPos = cached.nextPos;",
          ""
        ].join("\n"));
        if (options.trace) {
          parts2.push([
            "if (cached.result !== peg$FAILED) {",
            "  peg$tracer.trace({",
            '    type:   "rule.match",',
            "    rule:   " + ruleNameCode + ",",
            "    result: cached.result,",
            "    location: peg$computeLocation(startPos, peg$currPos)",
            "  });",
            "} else {",
            "  peg$tracer.trace({",
            '    type: "rule.fail",',
            "    rule: " + ruleNameCode + ",",
            "    location: peg$computeLocation(startPos, startPos)",
            "  });",
            "}",
            ""
          ].join("\n"));
        }
        parts2.push([
          "  return cached.result;",
          "}",
          ""
        ].join("\n"));
      }
      return parts2.join("\n");
    }
    function generateRuleFooter(ruleNameCode, resultCode) {
      var parts2 = [];
      if (options.cache) {
        parts2.push([
          "",
          "peg$resultsCache[key] = { nextPos: peg$currPos, result: " + resultCode + " };"
        ].join("\n"));
      }
      if (options.trace) {
        parts2.push([
          "",
          "if (" + resultCode + " !== peg$FAILED) {",
          "  peg$tracer.trace({",
          '    type:   "rule.match",',
          "    rule:   " + ruleNameCode + ",",
          "    result: " + resultCode + ",",
          "    location: peg$computeLocation(startPos, peg$currPos)",
          "  });",
          "} else {",
          "  peg$tracer.trace({",
          '    type: "rule.fail",',
          "    rule: " + ruleNameCode + ",",
          "    location: peg$computeLocation(startPos, startPos)",
          "  });",
          "}"
        ].join("\n"));
      }
      parts2.push([
        "",
        "return " + resultCode + ";"
      ].join("\n"));
      return parts2.join("\n");
    }
    function generateInterpreter() {
      var parts2 = [];
      function generateCondition(cond, argsLength) {
        var baseLength = argsLength + 3, thenLengthCode = "bc[ip + " + (baseLength - 2) + "]", elseLengthCode = "bc[ip + " + (baseLength - 1) + "]";
        return [
          "ends.push(end);",
          "ips.push(ip + " + baseLength + " + " + thenLengthCode + " + " + elseLengthCode + ");",
          "",
          "if (" + cond + ") {",
          "  end = ip + " + baseLength + " + " + thenLengthCode + ";",
          "  ip += " + baseLength + ";",
          "} else {",
          "  end = ip + " + baseLength + " + " + thenLengthCode + " + " + elseLengthCode + ";",
          "  ip += " + baseLength + " + " + thenLengthCode + ";",
          "}",
          "",
          "break;"
        ].join("\n");
      }
      function generateLoop(cond) {
        var baseLength = 2, bodyLengthCode = "bc[ip + " + (baseLength - 1) + "]";
        return [
          "if (" + cond + ") {",
          "  ends.push(end);",
          "  ips.push(ip);",
          "",
          "  end = ip + " + baseLength + " + " + bodyLengthCode + ";",
          "  ip += " + baseLength + ";",
          "} else {",
          "  ip += " + baseLength + " + " + bodyLengthCode + ";",
          "}",
          "",
          "break;"
        ].join("\n");
      }
      function generateCall() {
        var baseLength = 4, paramsLengthCode = "bc[ip + " + (baseLength - 1) + "]";
        return [
          "params = bc.slice(ip + " + baseLength + ", ip + " + baseLength + " + " + paramsLengthCode + ");",
          "for (i = 0; i < " + paramsLengthCode + "; i++) {",
          "  params[i] = stack[stack.length - 1 - params[i]];",
          "}",
          "",
          "stack.splice(",
          "  stack.length - bc[ip + 2],",
          "  bc[ip + 2],",
          "  peg$consts[bc[ip + 1]].apply(null, params)",
          ");",
          "",
          "ip += " + baseLength + " + " + paramsLengthCode + ";",
          "break;"
        ].join("\n");
      }
      parts2.push([
        "function peg$decode(s) {",
        "  var bc = new Array(s.length), i;",
        "",
        "  for (i = 0; i < s.length; i++) {",
        "    bc[i] = s.charCodeAt(i) - 32;",
        "  }",
        "",
        "  return bc;",
        "}",
        "",
        "function peg$parseRule(index) {"
      ].join("\n"));
      if (options.trace) {
        parts2.push([
          "  var bc       = peg$bytecode[index],",
          "      ip       = 0,",
          "      ips      = [],",
          "      end      = bc.length,",
          "      ends     = [],",
          "      stack    = [],",
          "      startPos = peg$currPos,",
          "      params, i;"
        ].join("\n"));
      } else {
        parts2.push([
          "  var bc    = peg$bytecode[index],",
          "      ip    = 0,",
          "      ips   = [],",
          "      end   = bc.length,",
          "      ends  = [],",
          "      stack = [],",
          "      params, i;"
        ].join("\n"));
      }
      parts2.push(indent2(generateRuleHeader("peg$ruleNames[index]", "index")));
      parts2.push([
        /*
         * The point of the outer loop and the |ips| & |ends| stacks is to avoid
         * recursive calls for interpreting parts of bytecode. In other words, we
         * implement the |interpret| operation of the abstract machine without
         * function calls. Such calls would likely slow the parser down and more
         * importantly cause stack overflows for complex grammars.
         */
        "  while (true) {",
        "    while (ip < end) {",
        "      switch (bc[ip]) {",
        "        case " + op.PUSH + ":",
        // PUSH c
        "          stack.push(peg$consts[bc[ip + 1]]);",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.PUSH_UNDEFINED + ":",
        // PUSH_UNDEFINED
        "          stack.push(void 0);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.PUSH_NULL + ":",
        // PUSH_NULL
        "          stack.push(null);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.PUSH_FAILED + ":",
        // PUSH_FAILED
        "          stack.push(peg$FAILED);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.PUSH_EMPTY_ARRAY + ":",
        // PUSH_EMPTY_ARRAY
        "          stack.push([]);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.PUSH_CURR_POS + ":",
        // PUSH_CURR_POS
        "          stack.push(peg$currPos);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.POP + ":",
        // POP
        "          stack.pop();",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.POP_CURR_POS + ":",
        // POP_CURR_POS
        "          peg$currPos = stack.pop();",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.POP_N + ":",
        // POP_N n
        "          stack.length -= bc[ip + 1];",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.NIP + ":",
        // NIP
        "          stack.splice(-2, 1);",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.APPEND + ":",
        // APPEND
        "          stack[stack.length - 2].push(stack.pop());",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.WRAP + ":",
        // WRAP n
        "          stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.TEXT + ":",
        // TEXT
        "          stack.push(input.substring(stack.pop(), peg$currPos));",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.IF + ":",
        // IF t, f
        indent10(generateCondition("stack[stack.length - 1]", 0)),
        "",
        "        case " + op.IF_ERROR + ":",
        // IF_ERROR t, f
        indent10(generateCondition(
          "stack[stack.length - 1] === peg$FAILED",
          0
        )),
        "",
        "        case " + op.IF_NOT_ERROR + ":",
        // IF_NOT_ERROR t, f
        indent10(
          generateCondition(
            "stack[stack.length - 1] !== peg$FAILED",
            0
          )
        ),
        "",
        "        case " + op.WHILE_NOT_ERROR + ":",
        // WHILE_NOT_ERROR b
        indent10(generateLoop("stack[stack.length - 1] !== peg$FAILED")),
        "",
        "        case " + op.MATCH_ANY + ":",
        // MATCH_ANY a, f, ...
        indent10(generateCondition("input.length > peg$currPos", 0)),
        "",
        "        case " + op.MATCH_STRING + ":",
        // MATCH_STRING s, a, f, ...
        indent10(generateCondition(
          "input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]",
          1
        )),
        "",
        "        case " + op.MATCH_STRING_IC + ":",
        // MATCH_STRING_IC s, a, f, ...
        indent10(generateCondition(
          "input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]",
          1
        )),
        "",
        "        case " + op.MATCH_REGEXP + ":",
        // MATCH_REGEXP r, a, f, ...
        indent10(generateCondition(
          "peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))",
          1
        )),
        "",
        "        case " + op.ACCEPT_N + ":",
        // ACCEPT_N n
        "          stack.push(input.substr(peg$currPos, bc[ip + 1]));",
        "          peg$currPos += bc[ip + 1];",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.ACCEPT_STRING + ":",
        // ACCEPT_STRING s
        "          stack.push(peg$consts[bc[ip + 1]]);",
        "          peg$currPos += peg$consts[bc[ip + 1]].length;",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.FAIL + ":",
        // FAIL e
        "          stack.push(peg$FAILED);",
        "          if (peg$silentFails === 0) {",
        "            peg$fail(peg$consts[bc[ip + 1]]);",
        "          }",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.LOAD_SAVED_POS + ":",
        // LOAD_SAVED_POS p
        "          peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.UPDATE_SAVED_POS + ":",
        // UPDATE_SAVED_POS
        "          peg$savedPos = peg$currPos;",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.CALL + ":",
        // CALL f, n, pc, p1, p2, ..., pN
        indent10(generateCall()),
        "",
        "        case " + op.RULE + ":",
        // RULE r
        "          stack.push(peg$parseRule(bc[ip + 1]));",
        "          ip += 2;",
        "          break;",
        "",
        "        case " + op.SILENT_FAILS_ON + ":",
        // SILENT_FAILS_ON
        "          peg$silentFails++;",
        "          ip++;",
        "          break;",
        "",
        "        case " + op.SILENT_FAILS_OFF + ":",
        // SILENT_FAILS_OFF
        "          peg$silentFails--;",
        "          ip++;",
        "          break;",
        "",
        "        default:",
        '          throw new Error("Invalid opcode: " + bc[ip] + ".");',
        "      }",
        "    }",
        "",
        "    if (ends.length > 0) {",
        "      end = ends.pop();",
        "      ip = ips.pop();",
        "    } else {",
        "      break;",
        "    }",
        "  }"
      ].join("\n"));
      parts2.push(indent2(generateRuleFooter("peg$ruleNames[index]", "stack[0]")));
      parts2.push("}");
      return parts2.join("\n");
    }
    function generateRuleFunction(rule) {
      var parts = [], code;
      function c(i) {
        return "peg$c" + i;
      }
      function s(i) {
        return "s" + i;
      }
      var stack = {
        sp: -1,
        maxSp: -1,
        push: function(exprCode) {
          var code2 = s(++this.sp) + " = " + exprCode + ";";
          if (this.sp > this.maxSp) {
            this.maxSp = this.sp;
          }
          return code2;
        },
        pop: function(n) {
          var values;
          if (n === void 0) {
            return s(this.sp--);
          } else {
            values = arrays$2.map(arrays$2.range(this.sp - n + 1, this.sp + 1), s);
            this.sp -= n;
            return values;
          }
        },
        top: function() {
          return s(this.sp);
        },
        index: function(i) {
          return s(this.sp - i);
        }
      };
      function compile(bc) {
        var ip = 0, end = bc.length, parts = [], value;
        function compileCondition(cond, argCount) {
          var baseLength = argCount + 3, thenLength = bc[ip + baseLength - 2], elseLength = bc[ip + baseLength - 1], baseSp = stack.sp, thenCode, elseCode, thenSp, elseSp;
          ip += baseLength;
          thenCode = compile(bc.slice(ip, ip + thenLength));
          thenSp = stack.sp;
          ip += thenLength;
          if (elseLength > 0) {
            stack.sp = baseSp;
            elseCode = compile(bc.slice(ip, ip + elseLength));
            elseSp = stack.sp;
            ip += elseLength;
            if (thenSp !== elseSp) {
              throw new Error(
                "Branches of a condition must move the stack pointer in the same way."
              );
            }
          }
          parts.push("if (" + cond + ") {");
          parts.push(indent2(thenCode));
          if (elseLength > 0) {
            parts.push("} else {");
            parts.push(indent2(elseCode));
          }
          parts.push("}");
        }
        function compileLoop(cond) {
          var baseLength = 2, bodyLength = bc[ip + baseLength - 1], baseSp = stack.sp, bodyCode, bodySp;
          ip += baseLength;
          bodyCode = compile(bc.slice(ip, ip + bodyLength));
          bodySp = stack.sp;
          ip += bodyLength;
          if (bodySp !== baseSp) {
            throw new Error("Body of a loop can't move the stack pointer.");
          }
          parts.push("while (" + cond + ") {");
          parts.push(indent2(bodyCode));
          parts.push("}");
        }
        function compileCall() {
          var baseLength = 4, paramsLength = bc[ip + baseLength - 1];
          var value2 = c(bc[ip + 1]) + "(" + arrays$2.map(
            bc.slice(ip + baseLength, ip + baseLength + paramsLength),
            function(p2) {
              return stack.index(p2);
            }
          ).join(", ") + ")";
          stack.pop(bc[ip + 2]);
          parts.push(stack.push(value2));
          ip += baseLength + paramsLength;
        }
        while (ip < end) {
          switch (bc[ip]) {
            case op.PUSH:
              parts.push(stack.push(c(bc[ip + 1])));
              ip += 2;
              break;
            case op.PUSH_CURR_POS:
              parts.push(stack.push("peg$currPos"));
              ip++;
              break;
            case op.PUSH_UNDEFINED:
              parts.push(stack.push("void 0"));
              ip++;
              break;
            case op.PUSH_NULL:
              parts.push(stack.push("null"));
              ip++;
              break;
            case op.PUSH_FAILED:
              parts.push(stack.push("peg$FAILED"));
              ip++;
              break;
            case op.PUSH_EMPTY_ARRAY:
              parts.push(stack.push("[]"));
              ip++;
              break;
            case op.POP:
              stack.pop();
              ip++;
              break;
            case op.POP_CURR_POS:
              parts.push("peg$currPos = " + stack.pop() + ";");
              ip++;
              break;
            case op.POP_N:
              stack.pop(bc[ip + 1]);
              ip += 2;
              break;
            case op.NIP:
              value = stack.pop();
              stack.pop();
              parts.push(stack.push(value));
              ip++;
              break;
            case op.APPEND:
              value = stack.pop();
              parts.push(stack.top() + ".push(" + value + ");");
              ip++;
              break;
            case op.WRAP:
              parts.push(
                stack.push("[" + stack.pop(bc[ip + 1]).join(", ") + "]")
              );
              ip += 2;
              break;
            case op.TEXT:
              parts.push(
                stack.push("input.substring(" + stack.pop() + ", peg$currPos)")
              );
              ip++;
              break;
            case op.IF:
              compileCondition(stack.top(), 0);
              break;
            case op.IF_ERROR:
              compileCondition(stack.top() + " === peg$FAILED", 0);
              break;
            case op.IF_NOT_ERROR:
              compileCondition(stack.top() + " !== peg$FAILED", 0);
              break;
            case op.WHILE_NOT_ERROR:
              compileLoop(stack.top() + " !== peg$FAILED");
              break;
            case op.MATCH_ANY:
              compileCondition("input.length > peg$currPos", 0);
              break;
            case op.MATCH_STRING:
              compileCondition(
                eval(ast.consts[bc[ip + 1]]).length > 1 ? "input.substr(peg$currPos, " + eval(ast.consts[bc[ip + 1]]).length + ") === " + c(bc[ip + 1]) : "input.charCodeAt(peg$currPos) === " + eval(ast.consts[bc[ip + 1]]).charCodeAt(0),
                1
              );
              break;
            case op.MATCH_STRING_IC:
              compileCondition(
                "input.substr(peg$currPos, " + eval(ast.consts[bc[ip + 1]]).length + ").toLowerCase() === " + c(bc[ip + 1]),
                1
              );
              break;
            case op.MATCH_REGEXP:
              compileCondition(
                c(bc[ip + 1]) + ".test(input.charAt(peg$currPos))",
                1
              );
              break;
            case op.ACCEPT_N:
              parts.push(stack.push(
                bc[ip + 1] > 1 ? "input.substr(peg$currPos, " + bc[ip + 1] + ")" : "input.charAt(peg$currPos)"
              ));
              parts.push(
                bc[ip + 1] > 1 ? "peg$currPos += " + bc[ip + 1] + ";" : "peg$currPos++;"
              );
              ip += 2;
              break;
            case op.ACCEPT_STRING:
              parts.push(stack.push(c(bc[ip + 1])));
              parts.push(
                eval(ast.consts[bc[ip + 1]]).length > 1 ? "peg$currPos += " + eval(ast.consts[bc[ip + 1]]).length + ";" : "peg$currPos++;"
              );
              ip += 2;
              break;
            case op.FAIL:
              parts.push(stack.push("peg$FAILED"));
              parts.push("if (peg$silentFails === 0) { peg$fail(" + c(bc[ip + 1]) + "); }");
              ip += 2;
              break;
            case op.LOAD_SAVED_POS:
              parts.push("peg$savedPos = " + stack.index(bc[ip + 1]) + ";");
              ip += 2;
              break;
            case op.UPDATE_SAVED_POS:
              parts.push("peg$savedPos = peg$currPos;");
              ip++;
              break;
            case op.CALL:
              compileCall();
              break;
            case op.RULE:
              parts.push(stack.push("peg$parse" + ast.rules[bc[ip + 1]].name + "()"));
              ip += 2;
              break;
            case op.SILENT_FAILS_ON:
              parts.push("peg$silentFails++;");
              ip++;
              break;
            case op.SILENT_FAILS_OFF:
              parts.push("peg$silentFails--;");
              ip++;
              break;
            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }
        return parts.join("\n");
      }
      code = compile(rule.bytecode);
      parts.push("function peg$parse" + rule.name + "() {");
      if (options.trace) {
        parts.push([
          "  var " + arrays$2.map(arrays$2.range(0, stack.maxSp + 1), s).join(", ") + ",",
          "      startPos = peg$currPos;"
        ].join("\n"));
      } else {
        parts.push(
          "  var " + arrays$2.map(arrays$2.range(0, stack.maxSp + 1), s).join(", ") + ";"
        );
      }
      parts.push(indent2(generateRuleHeader(
        '"' + js.stringEscape(rule.name) + '"',
        asts.indexOfRule(ast, rule.name)
      )));
      parts.push(indent2(code));
      parts.push(indent2(generateRuleFooter(
        '"' + js.stringEscape(rule.name) + '"',
        s(0)
      )));
      parts.push("}");
      return parts.join("\n");
    }
    function generateToplevel() {
      var parts2 = [], startRuleIndices, startRuleIndex, startRuleFunctions, startRuleFunction, ruleNames;
      parts2.push([
        "function peg$subclass(child, parent) {",
        "  function ctor() { this.constructor = child; }",
        "  ctor.prototype = parent.prototype;",
        "  child.prototype = new ctor();",
        "}",
        "",
        "function peg$SyntaxError(message, expected, found, location) {",
        "  this.message  = message;",
        "  this.expected = expected;",
        "  this.found    = found;",
        "  this.location = location;",
        '  this.name     = "SyntaxError";',
        "",
        '  if (typeof Error.captureStackTrace === "function") {',
        "    Error.captureStackTrace(this, peg$SyntaxError);",
        "  }",
        "}",
        "",
        "peg$subclass(peg$SyntaxError, Error);",
        "",
        "peg$SyntaxError.buildMessage = function(expected, found) {",
        "  var DESCRIBE_EXPECTATION_FNS = {",
        "        literal: function(expectation) {",
        '          return "\\"" + literalEscape(expectation.text) + "\\"";',
        "        },",
        "",
        '        "class": function(expectation) {',
        '          var escapedParts = "",',
        "              i;",
        "",
        "          for (i = 0; i < expectation.parts.length; i++) {",
        "            escapedParts += expectation.parts[i] instanceof Array",
        '              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])',
        "              : classEscape(expectation.parts[i]);",
        "          }",
        "",
        '          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";',
        "        },",
        "",
        "        any: function(expectation) {",
        '          return "any character";',
        "        },",
        "",
        "        end: function(expectation) {",
        '          return "end of input";',
        "        },",
        "",
        "        other: function(expectation) {",
        "          return expectation.description;",
        "        }",
        "      };",
        "",
        "  function hex(ch) {",
        "    return ch.charCodeAt(0).toString(16).toUpperCase();",
        "  }",
        "",
        "  function literalEscape(s) {",
        "    return s",
        "      .replace(/\\\\/g, '\\\\\\\\')",
        // backslash
        `      .replace(/"/g,  '\\\\"')`,
        // closing double quote
        "      .replace(/\\0/g, '\\\\0')",
        // null
        "      .replace(/\\t/g, '\\\\t')",
        // horizontal tab
        "      .replace(/\\n/g, '\\\\n')",
        // line feed
        "      .replace(/\\r/g, '\\\\r')",
        // carriage return
        "      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })",
        "      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });",
        "  }",
        "",
        "  function classEscape(s) {",
        "    return s",
        "      .replace(/\\\\/g, '\\\\\\\\')",
        // backslash
        "      .replace(/\\]/g, '\\\\]')",
        // closing bracket
        "      .replace(/\\^/g, '\\\\^')",
        // caret
        "      .replace(/-/g,  '\\\\-')",
        // dash
        "      .replace(/\\0/g, '\\\\0')",
        // null
        "      .replace(/\\t/g, '\\\\t')",
        // horizontal tab
        "      .replace(/\\n/g, '\\\\n')",
        // line feed
        "      .replace(/\\r/g, '\\\\r')",
        // carriage return
        "      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })",
        "      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });",
        "  }",
        "",
        "  function describeExpectation(expectation) {",
        "    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);",
        "  }",
        "",
        "  function describeExpected(expected) {",
        "    var descriptions = new Array(expected.length),",
        "        i, j;",
        "",
        "    for (i = 0; i < expected.length; i++) {",
        "      descriptions[i] = describeExpectation(expected[i]);",
        "    }",
        "",
        "    descriptions.sort();",
        "",
        "    if (descriptions.length > 0) {",
        "      for (i = 1, j = 1; i < descriptions.length; i++) {",
        "        if (descriptions[i - 1] !== descriptions[i]) {",
        "          descriptions[j] = descriptions[i];",
        "          j++;",
        "        }",
        "      }",
        "      descriptions.length = j;",
        "    }",
        "",
        "    switch (descriptions.length) {",
        "      case 1:",
        "        return descriptions[0];",
        "",
        "      case 2:",
        '        return descriptions[0] + " or " + descriptions[1];',
        "",
        "      default:",
        '        return descriptions.slice(0, -1).join(", ")',
        '          + ", or "',
        "          + descriptions[descriptions.length - 1];",
        "    }",
        "  }",
        "",
        "  function describeFound(found) {",
        '    return found ? "\\"" + literalEscape(found) + "\\"" : "end of input";',
        "  }",
        "",
        '  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";',
        "};",
        ""
      ].join("\n"));
      if (options.trace) {
        parts2.push([
          "function peg$DefaultTracer() {",
          "  this.indentLevel = 0;",
          "}",
          "",
          "peg$DefaultTracer.prototype.trace = function(event) {",
          "  var that = this;",
          "",
          "  function log(event) {",
          "    function repeat(string, n) {",
          '       var result = "", i;',
          "",
          "       for (i = 0; i < n; i++) {",
          "         result += string;",
          "       }",
          "",
          "       return result;",
          "    }",
          "",
          "    function pad(string, length) {",
          '      return string + repeat(" ", length - string.length);',
          "    }",
          "",
          '    if (typeof console === "object") {',
          // IE 8-10
          "      console.log(",
          '        event.location.start.line + ":" + event.location.start.column + "-"',
          '          + event.location.end.line + ":" + event.location.end.column + " "',
          '          + pad(event.type, 10) + " "',
          '          + repeat("  ", that.indentLevel) + event.rule',
          "      );",
          "    }",
          "  }",
          "",
          "  switch (event.type) {",
          '    case "rule.enter":',
          "      log(event);",
          "      this.indentLevel++;",
          "      break;",
          "",
          '    case "rule.match":',
          "      this.indentLevel--;",
          "      log(event);",
          "      break;",
          "",
          '    case "rule.fail":',
          "      this.indentLevel--;",
          "      log(event);",
          "      break;",
          "",
          "    default:",
          '      throw new Error("Invalid event type: " + event.type + ".");',
          "  }",
          "};",
          ""
        ].join("\n"));
      }
      parts2.push([
        "function peg$parse(input, options) {",
        "  options = options !== void 0 ? options : {};",
        "",
        "  var peg$FAILED = {},",
        ""
      ].join("\n"));
      if (options.optimize === "size") {
        startRuleIndices = "{ " + arrays$2.map(
          options.allowedStartRules,
          function(r) {
            return r + ": " + asts.indexOfRule(ast, r);
          }
        ).join(", ") + " }";
        startRuleIndex = asts.indexOfRule(ast, options.allowedStartRules[0]);
        parts2.push([
          "      peg$startRuleIndices = " + startRuleIndices + ",",
          "      peg$startRuleIndex   = " + startRuleIndex + ","
        ].join("\n"));
      } else {
        startRuleFunctions = "{ " + arrays$2.map(
          options.allowedStartRules,
          function(r) {
            return r + ": peg$parse" + r;
          }
        ).join(", ") + " }";
        startRuleFunction = "peg$parse" + options.allowedStartRules[0];
        parts2.push([
          "      peg$startRuleFunctions = " + startRuleFunctions + ",",
          "      peg$startRuleFunction  = " + startRuleFunction + ","
        ].join("\n"));
      }
      parts2.push("");
      parts2.push(indent6(generateTables()));
      parts2.push([
        "",
        "      peg$currPos          = 0,",
        "      peg$savedPos         = 0,",
        "      peg$posDetailsCache  = [{ line: 1, column: 1 }],",
        "      peg$maxFailPos       = 0,",
        "      peg$maxFailExpected  = [],",
        "      peg$silentFails      = 0,",
        // 0 = report failures, > 0 = silence failures
        ""
      ].join("\n"));
      if (options.cache) {
        parts2.push([
          "      peg$resultsCache = {},",
          ""
        ].join("\n"));
      }
      if (options.trace) {
        if (options.optimize === "size") {
          ruleNames = "[" + arrays$2.map(
            ast.rules,
            function(r) {
              return '"' + js.stringEscape(r.name) + '"';
            }
          ).join(", ") + "]";
          parts2.push([
            "      peg$ruleNames = " + ruleNames + ",",
            ""
          ].join("\n"));
        }
        parts2.push([
          '      peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer(),',
          ""
        ].join("\n"));
      }
      parts2.push([
        "      peg$result;",
        ""
      ].join("\n"));
      if (options.optimize === "size") {
        parts2.push([
          '  if ("startRule" in options) {',
          "    if (!(options.startRule in peg$startRuleIndices)) {",
          `      throw new Error("Can't start parsing from rule \\"" + options.startRule + "\\".");`,
          "    }",
          "",
          "    peg$startRuleIndex = peg$startRuleIndices[options.startRule];",
          "  }"
        ].join("\n"));
      } else {
        parts2.push([
          '  if ("startRule" in options) {',
          "    if (!(options.startRule in peg$startRuleFunctions)) {",
          `      throw new Error("Can't start parsing from rule \\"" + options.startRule + "\\".");`,
          "    }",
          "",
          "    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];",
          "  }"
        ].join("\n"));
      }
      parts2.push([
        "",
        "  function text() {",
        "    return input.substring(peg$savedPos, peg$currPos);",
        "  }",
        "",
        "  function location() {",
        "    return peg$computeLocation(peg$savedPos, peg$currPos);",
        "  }",
        "",
        "  function expected(description, location) {",
        "    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)",
        "",
        "    throw peg$buildStructuredError(",
        "      [peg$otherExpectation(description)],",
        "      input.substring(peg$savedPos, peg$currPos),",
        "      location",
        "    );",
        "  }",
        "",
        "  function error(message, location) {",
        "    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)",
        "",
        "    throw peg$buildSimpleError(message, location);",
        "  }",
        "",
        "  function peg$literalExpectation(text, ignoreCase) {",
        '    return { type: "literal", text: text, ignoreCase: ignoreCase };',
        "  }",
        "",
        "  function peg$classExpectation(parts, inverted, ignoreCase) {",
        '    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };',
        "  }",
        "",
        "  function peg$anyExpectation() {",
        '    return { type: "any" };',
        "  }",
        "",
        "  function peg$endExpectation() {",
        '    return { type: "end" };',
        "  }",
        "",
        "  function peg$otherExpectation(description) {",
        '    return { type: "other", description: description };',
        "  }",
        "",
        "  function peg$computePosDetails(pos) {",
        "    var details = peg$posDetailsCache[pos], p;",
        "",
        "    if (details) {",
        "      return details;",
        "    } else {",
        "      p = pos - 1;",
        "      while (!peg$posDetailsCache[p]) {",
        "        p--;",
        "      }",
        "",
        "      details = peg$posDetailsCache[p];",
        "      details = {",
        "        line:   details.line,",
        "        column: details.column",
        "      };",
        "",
        "      while (p < pos) {",
        "        if (input.charCodeAt(p) === 10) {",
        "          details.line++;",
        "          details.column = 1;",
        "        } else {",
        "          details.column++;",
        "        }",
        "",
        "        p++;",
        "      }",
        "",
        "      peg$posDetailsCache[pos] = details;",
        "      return details;",
        "    }",
        "  }",
        "",
        "  function peg$computeLocation(startPos, endPos) {",
        "    var startPosDetails = peg$computePosDetails(startPos),",
        "        endPosDetails   = peg$computePosDetails(endPos);",
        "",
        "    return {",
        "      start: {",
        "        offset: startPos,",
        "        line:   startPosDetails.line,",
        "        column: startPosDetails.column",
        "      },",
        "      end: {",
        "        offset: endPos,",
        "        line:   endPosDetails.line,",
        "        column: endPosDetails.column",
        "      }",
        "    };",
        "  }",
        "",
        "  function peg$fail(expected) {",
        "    if (peg$currPos < peg$maxFailPos) { return; }",
        "",
        "    if (peg$currPos > peg$maxFailPos) {",
        "      peg$maxFailPos = peg$currPos;",
        "      peg$maxFailExpected = [];",
        "    }",
        "",
        "    peg$maxFailExpected.push(expected);",
        "  }",
        "",
        "  function peg$buildSimpleError(message, location) {",
        "    return new peg$SyntaxError(message, null, null, location);",
        "  }",
        "",
        "  function peg$buildStructuredError(expected, found, location) {",
        "    return new peg$SyntaxError(",
        "      peg$SyntaxError.buildMessage(expected, found),",
        "      expected,",
        "      found,",
        "      location",
        "    );",
        "  }",
        ""
      ].join("\n"));
      if (options.optimize === "size") {
        parts2.push(indent2(generateInterpreter()));
        parts2.push("");
      } else {
        arrays$2.each(ast.rules, function(rule2) {
          parts2.push(indent2(generateRuleFunction(rule2)));
          parts2.push("");
        });
      }
      if (ast.initializer) {
        parts2.push(indent2(ast.initializer.code));
        parts2.push("");
      }
      if (options.optimize === "size") {
        parts2.push("  peg$result = peg$parseRule(peg$startRuleIndex);");
      } else {
        parts2.push("  peg$result = peg$startRuleFunction();");
      }
      parts2.push([
        "",
        "  if (peg$result !== peg$FAILED && peg$currPos === input.length) {",
        "    return peg$result;",
        "  } else {",
        "    if (peg$result !== peg$FAILED && peg$currPos < input.length) {",
        "      peg$fail(peg$endExpectation());",
        "    }",
        "",
        "    throw peg$buildStructuredError(",
        "      peg$maxFailExpected,",
        "      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,",
        "      peg$maxFailPos < input.length",
        "        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)",
        "        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)",
        "    );",
        "  }",
        "}"
      ].join("\n"));
      return parts2.join("\n");
    }
    function generateWrapper(toplevelCode) {
      function generateGeneratedByComment() {
        return [
          "/*",
          " * Generated by PEG.js 0.10.0.",
          " *",
          " * http://pegjs.org/",
          " */"
        ].join("\n");
      }
      function generateParserObject() {
        return options.trace ? [
          "{",
          "  SyntaxError:   peg$SyntaxError,",
          "  DefaultTracer: peg$DefaultTracer,",
          "  parse:         peg$parse",
          "}"
        ].join("\n") : [
          "{",
          "  SyntaxError: peg$SyntaxError,",
          "  parse:       peg$parse",
          "}"
        ].join("\n");
      }
      var generators = {
        bare: function() {
          return [
            generateGeneratedByComment(),
            "(function() {",
            '  "use strict";',
            "",
            indent2(toplevelCode),
            "",
            indent2("return " + generateParserObject() + ";"),
            "})()"
          ].join("\n");
        },
        commonjs: function() {
          var parts2 = [], dependencyVars = objects$2.keys(options.dependencies), requires = arrays$2.map(
            dependencyVars,
            function(variable) {
              return variable + ' = require("' + js.stringEscape(options.dependencies[variable]) + '")';
            }
          );
          parts2.push([
            generateGeneratedByComment(),
            "",
            '"use strict";',
            ""
          ].join("\n"));
          if (requires.length > 0) {
            parts2.push("var " + requires.join(", ") + ";");
            parts2.push("");
          }
          parts2.push([
            toplevelCode,
            "",
            "module.exports = " + generateParserObject() + ";",
            ""
          ].join("\n"));
          return parts2.join("\n");
        },
        amd: function() {
          var dependencyIds = objects$2.values(options.dependencies), dependencyVars = objects$2.keys(options.dependencies), dependencies = "[" + arrays$2.map(
            dependencyIds,
            function(id2) {
              return '"' + js.stringEscape(id2) + '"';
            }
          ).join(", ") + "]", params = dependencyVars.join(", ");
          return [
            generateGeneratedByComment(),
            "define(" + dependencies + ", function(" + params + ") {",
            '  "use strict";',
            "",
            indent2(toplevelCode),
            "",
            indent2("return " + generateParserObject() + ";"),
            "});",
            ""
          ].join("\n");
        },
        globals: function() {
          return [
            generateGeneratedByComment(),
            "(function(root) {",
            '  "use strict";',
            "",
            indent2(toplevelCode),
            "",
            indent2("root." + options.exportVar + " = " + generateParserObject() + ";"),
            "})(this);",
            ""
          ].join("\n");
        },
        umd: function() {
          var parts2 = [], dependencyIds = objects$2.values(options.dependencies), dependencyVars = objects$2.keys(options.dependencies), dependencies = "[" + arrays$2.map(
            dependencyIds,
            function(id2) {
              return '"' + js.stringEscape(id2) + '"';
            }
          ).join(", ") + "]", requires = arrays$2.map(
            dependencyIds,
            function(id2) {
              return 'require("' + js.stringEscape(id2) + '")';
            }
          ).join(", "), params = dependencyVars.join(", ");
          parts2.push([
            generateGeneratedByComment(),
            "(function(root, factory) {",
            '  if (typeof define === "function" && define.amd) {',
            "    define(" + dependencies + ", factory);",
            '  } else if (typeof module === "object" && module.exports) {',
            "    module.exports = factory(" + requires + ");"
          ].join("\n"));
          if (options.exportVar !== null) {
            parts2.push([
              "  } else {",
              "    root." + options.exportVar + " = factory();"
            ].join("\n"));
          }
          parts2.push([
            "  }",
            "})(this, function(" + params + ") {",
            '  "use strict";',
            "",
            indent2(toplevelCode),
            "",
            indent2("return " + generateParserObject() + ";"),
            "});",
            ""
          ].join("\n"));
          return parts2.join("\n");
        }
      };
      return generators[options.format]();
    }
    ast.code = generateWrapper(generateToplevel());
  }
  var generateJs = generateJS;
  var arrays$1 = arrays_1, objects$1 = objects_1;
  var compiler = {
    /*
     * AST node visitor builder. Useful mainly for plugins which manipulate the
     * AST.
     */
    visitor: visitor_1,
    /*
     * Compiler passes.
     *
     * Each pass is a function that is passed the AST. It can perform checks on it
     * or modify it as needed. If the pass encounters a semantic error, it throws
     * |peg.GrammarError|.
     */
    passes: {
      check: {
        reportUndefinedRules: reportUndefinedRules_1,
        reportDuplicateRules: reportDuplicateRules_1,
        reportDuplicateLabels: reportDuplicateLabels_1,
        reportInfiniteRecursion: reportInfiniteRecursion_1,
        reportInfiniteRepetition: reportInfiniteRepetition_1
      },
      transform: {
        removeProxyRules: removeProxyRules_1
      },
      generate: {
        generateBytecode: generateBytecode_1,
        generateJS: generateJs
      }
    },
    /*
     * Generates a parser from a specified grammar AST. Throws |peg.GrammarError|
     * if the AST contains a semantic error. Note that not all errors are detected
     * during the generation and some may protrude to the generated parser and
     * cause its malfunction.
     */
    compile: function(ast, passes, options) {
      options = options !== void 0 ? options : {};
      var stage;
      options = objects$1.clone(options);
      objects$1.defaults(options, {
        allowedStartRules: [ast.rules[0].name],
        cache: false,
        dependencies: {},
        exportVar: null,
        format: "bare",
        optimize: "speed",
        output: "parser",
        trace: false
      });
      for (stage in passes) {
        if (passes.hasOwnProperty(stage)) {
          arrays$1.each(passes[stage], function(p2) {
            p2(ast, options);
          });
        }
      }
      switch (options.output) {
        case "parser":
          return eval(ast.code);
        case "source":
          return ast.code;
      }
    }
  };
  var compiler_1 = compiler;
  var arrays = arrays_1, objects = objects_1;
  var peg = {
    /* PEG.js version (uses semantic versioning). */
    VERSION: "0.10.0",
    GrammarError: grammarError,
    parser,
    compiler: compiler_1,
    /*
     * Generates a parser from a specified grammar and returns it.
     *
     * The grammar must be a string in the format described by the metagramar in
     * the parser.pegjs file.
     *
     * Throws |peg.parser.SyntaxError| if the grammar contains a syntax error or
     * |peg.GrammarError| if it contains a semantic error. Note that not all
     * errors are detected during the generation and some may protrude to the
     * generated parser and cause its malfunction.
     */
    generate: function(grammar, options2) {
      options2 = options2 !== void 0 ? options2 : {};
      function convertPasses(passes2) {
        var converted = {}, stage2;
        for (stage2 in passes2) {
          if (passes2.hasOwnProperty(stage2)) {
            converted[stage2] = objects.values(passes2[stage2]);
          }
        }
        return converted;
      }
      options2 = objects.clone(options2);
      var plugins = "plugins" in options2 ? options2.plugins : [], config2 = {
        parser: peg.parser,
        passes: convertPasses(peg.compiler.passes)
      };
      arrays.each(plugins, function(p2) {
        p2.use(config2, options2);
      });
      return peg.compiler.compile(
        config2.parser.parse(grammar),
        config2.passes,
        options2
      );
    }
  };
  var peg_1 = peg;
  var peg$1 = /* @__PURE__ */ getDefaultExportFromCjs(peg_1);
  var parserBabel = { exports: {} };
  (function(module, exports) {
    (function(e) {
      module.exports = e();
    })(function() {
      var E = (l, h2) => () => (h2 || l((h2 = { exports: {} }).exports, h2), h2.exports);
      var re2 = E((xd2, Zr) => {
        var Ct2 = function(l) {
          return l && l.Math == Math && l;
        };
        Zr.exports = Ct2(typeof globalThis == "object" && globalThis) || Ct2(typeof window == "object" && window) || Ct2(typeof self == "object" && self) || Ct2(typeof commonjsGlobal == "object" && commonjsGlobal) || /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")();
      });
      var ie = E((gd2, ei) => {
        ei.exports = function(l) {
          try {
            return !!l();
          } catch {
            return true;
          }
        };
      });
      var ye = E((Pd2, ti) => {
        var kh = ie();
        ti.exports = !kh(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var bt2 = E((Ad2, si) => {
        var Dh = ie();
        si.exports = !Dh(function() {
          var l = (function() {
          }).bind();
          return typeof l != "function" || l.hasOwnProperty("prototype");
        });
      });
      var wt2 = E((Td2, ri2) => {
        var Fh = bt2(), St2 = Function.prototype.call;
        ri2.exports = Fh ? St2.bind(St2) : function() {
          return St2.apply(St2, arguments);
        };
      });
      var oi2 = E((ni) => {
        var ii = {}.propertyIsEnumerable, ai = Object.getOwnPropertyDescriptor, Lh = ai && !ii.call({ 1: 2 }, 1);
        ni.f = Lh ? function(h2) {
          var p2 = ai(this, h2);
          return !!p2 && p2.enumerable;
        } : ii;
      });
      var fs = E((Ed2, li2) => {
        li2.exports = function(l, h2) {
          return { enumerable: !(l & 1), configurable: !(l & 2), writable: !(l & 4), value: h2 };
        };
      });
      var ae = E((Cd2, ci) => {
        var hi = bt2(), ui2 = Function.prototype, ds = ui2.call, Oh = hi && ui2.bind.bind(ds, ds);
        ci.exports = hi ? Oh : function(l) {
          return function() {
            return ds.apply(l, arguments);
          };
        };
      });
      var Ye = E((bd2, fi) => {
        var pi2 = ae(), Bh = pi2({}.toString), Mh = pi2("".slice);
        fi.exports = function(l) {
          return Mh(Bh(l), 8, -1);
        };
      });
      var mi = E((Sd2, di2) => {
        var _h = ae(), Rh = ie(), jh = Ye(), ms = Object, qh = _h("".split);
        di2.exports = Rh(function() {
          return !ms("z").propertyIsEnumerable(0);
        }) ? function(l) {
          return jh(l) == "String" ? qh(l, "") : ms(l);
        } : ms;
      });
      var ys = E((wd2, yi2) => {
        yi2.exports = function(l) {
          return l == null;
        };
      });
      var xs = E((Id2, xi) => {
        var Uh = ys(), $h = TypeError;
        xi.exports = function(l) {
          if (Uh(l))
            throw $h("Can't call method on " + l);
          return l;
        };
      });
      var It2 = E((Nd2, gi) => {
        var Hh = mi(), zh = xs();
        gi.exports = function(l) {
          return Hh(zh(l));
        };
      });
      var Ps = E((kd2, Pi) => {
        var gs = typeof document == "object" && document.all, Vh = typeof gs > "u" && gs !== void 0;
        Pi.exports = { all: gs, IS_HTMLDDA: Vh };
      });
      var ee = E((Dd2, Ti) => {
        var Ai = Ps(), Kh = Ai.all;
        Ti.exports = Ai.IS_HTMLDDA ? function(l) {
          return typeof l == "function" || l === Kh;
        } : function(l) {
          return typeof l == "function";
        };
      });
      var Ie = E((Fd2, Ci) => {
        var vi2 = ee(), Ei = Ps(), Wh = Ei.all;
        Ci.exports = Ei.IS_HTMLDDA ? function(l) {
          return typeof l == "object" ? l !== null : vi2(l) || l === Wh;
        } : function(l) {
          return typeof l == "object" ? l !== null : vi2(l);
        };
      });
      var Qe = E((Ld2, bi) => {
        var As2 = re2(), Gh = ee(), Jh = function(l) {
          return Gh(l) ? l : void 0;
        };
        bi.exports = function(l, h2) {
          return arguments.length < 2 ? Jh(As2[l]) : As2[l] && As2[l][h2];
        };
      });
      var wi2 = E((Od2, Si2) => {
        var Xh = ae();
        Si2.exports = Xh({}.isPrototypeOf);
      });
      var Ni = E((Bd2, Ii) => {
        var Yh = Qe();
        Ii.exports = Yh("navigator", "userAgent") || "";
      });
      var Mi = E((Md2, Bi2) => {
        var Oi = re2(), Ts = Ni(), ki = Oi.process, Di2 = Oi.Deno, Fi2 = ki && ki.versions || Di2 && Di2.version, Li = Fi2 && Fi2.v8, ne2, Nt2;
        Li && (ne2 = Li.split("."), Nt2 = ne2[0] > 0 && ne2[0] < 4 ? 1 : +(ne2[0] + ne2[1]));
        !Nt2 && Ts && (ne2 = Ts.match(/Edge\/(\d+)/), (!ne2 || ne2[1] >= 74) && (ne2 = Ts.match(/Chrome\/(\d+)/), ne2 && (Nt2 = +ne2[1])));
        Bi2.exports = Nt2;
      });
      var vs2 = E((_d2, Ri) => {
        var _i = Mi(), Qh = ie();
        Ri.exports = !!Object.getOwnPropertySymbols && !Qh(function() {
          var l = Symbol();
          return !String(l) || !(Object(l) instanceof Symbol) || !Symbol.sham && _i && _i < 41;
        });
      });
      var Es = E((Rd2, ji2) => {
        var Zh = vs2();
        ji2.exports = Zh && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Cs = E((jd2, qi) => {
        var eu2 = Qe(), tu2 = ee(), su = wi2(), ru2 = Es(), iu = Object;
        qi.exports = ru2 ? function(l) {
          return typeof l == "symbol";
        } : function(l) {
          var h2 = eu2("Symbol");
          return tu2(h2) && su(h2.prototype, iu(l));
        };
      });
      var $i = E((qd2, Ui) => {
        var au = String;
        Ui.exports = function(l) {
          try {
            return au(l);
          } catch {
            return "Object";
          }
        };
      });
      var kt2 = E((Ud2, Hi2) => {
        var nu2 = ee(), ou = $i(), lu = TypeError;
        Hi2.exports = function(l) {
          if (nu2(l))
            return l;
          throw lu(ou(l) + " is not a function");
        };
      });
      var Vi = E(($d2, zi2) => {
        var hu = kt2(), uu2 = ys();
        zi2.exports = function(l, h2) {
          var p2 = l[h2];
          return uu2(p2) ? void 0 : hu(p2);
        };
      });
      var Wi = E((Hd2, Ki) => {
        var bs = wt2(), Ss = ee(), ws = Ie(), cu = TypeError;
        Ki.exports = function(l, h2) {
          var p2, d;
          if (h2 === "string" && Ss(p2 = l.toString) && !ws(d = bs(p2, l)) || Ss(p2 = l.valueOf) && !ws(d = bs(p2, l)) || h2 !== "string" && Ss(p2 = l.toString) && !ws(d = bs(p2, l)))
            return d;
          throw cu("Can't convert object to primitive value");
        };
      });
      var Ji = E((zd2, Gi) => {
        Gi.exports = false;
      });
      var Dt2 = E((Vd2, Yi) => {
        var Xi = re2(), pu = Object.defineProperty;
        Yi.exports = function(l, h2) {
          try {
            pu(Xi, l, { value: h2, configurable: true, writable: true });
          } catch {
            Xi[l] = h2;
          }
          return h2;
        };
      });
      var Ft2 = E((Kd2, Zi) => {
        var fu = re2(), du = Dt2(), Qi2 = "__core-js_shared__", mu = fu[Qi2] || du(Qi2, {});
        Zi.exports = mu;
      });
      var Is = E((Wd2, ta) => {
        var yu = Ji(), ea = Ft2();
        (ta.exports = function(l, h2) {
          return ea[l] || (ea[l] = h2 !== void 0 ? h2 : {});
        })("versions", []).push({ version: "3.26.1", mode: yu ? "pure" : "global", copyright: "Â© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Ns = E((Gd2, sa2) => {
        var xu = xs(), gu2 = Object;
        sa2.exports = function(l) {
          return gu2(xu(l));
        };
      });
      var ve = E((Jd2, ra2) => {
        var Pu = ae(), Au = Ns(), Tu = Pu({}.hasOwnProperty);
        ra2.exports = Object.hasOwn || function(h2, p2) {
          return Tu(Au(h2), p2);
        };
      });
      var ks = E((Xd2, ia) => {
        var vu = ae(), Eu = 0, Cu = Math.random(), bu = vu(1 .toString);
        ia.exports = function(l) {
          return "Symbol(" + (l === void 0 ? "" : l) + ")_" + bu(++Eu + Cu, 36);
        };
      });
      var Ze = E((Yd2, ha2) => {
        var Su2 = re2(), wu = Is(), aa = ve(), Iu = ks(), na = vs2(), la = Es(), qe2 = wu("wks"), Ne = Su2.Symbol, oa = Ne && Ne.for, Nu = la ? Ne : Ne && Ne.withoutSetter || Iu;
        ha2.exports = function(l) {
          if (!aa(qe2, l) || !(na || typeof qe2[l] == "string")) {
            var h2 = "Symbol." + l;
            na && aa(Ne, l) ? qe2[l] = Ne[l] : la && oa ? qe2[l] = oa(h2) : qe2[l] = Nu(h2);
          }
          return qe2[l];
        };
      });
      var fa2 = E((Qd2, pa) => {
        var ku = wt2(), ua = Ie(), ca2 = Cs(), Du = Vi(), Fu = Wi(), Lu = Ze(), Ou = TypeError, Bu = Lu("toPrimitive");
        pa.exports = function(l, h2) {
          if (!ua(l) || ca2(l))
            return l;
          var p2 = Du(l, Bu), d;
          if (p2) {
            if (h2 === void 0 && (h2 = "default"), d = ku(p2, l, h2), !ua(d) || ca2(d))
              return d;
            throw Ou("Can't convert object to primitive value");
          }
          return h2 === void 0 && (h2 = "number"), Fu(l, h2);
        };
      });
      var Ds = E((Zd2, da2) => {
        var Mu = fa2(), _u = Cs();
        da2.exports = function(l) {
          var h2 = Mu(l, "string");
          return _u(h2) ? h2 : h2 + "";
        };
      });
      var xa2 = E((em2, ya2) => {
        var Ru = re2(), ma = Ie(), Fs = Ru.document, ju2 = ma(Fs) && ma(Fs.createElement);
        ya2.exports = function(l) {
          return ju2 ? Fs.createElement(l) : {};
        };
      });
      var Ls2 = E((tm2, ga) => {
        var qu = ye(), Uu = ie(), $u = xa2();
        ga.exports = !qu && !Uu(function() {
          return Object.defineProperty($u("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Os = E((Aa2) => {
        var Hu2 = ye(), zu = wt2(), Vu = oi2(), Ku = fs(), Wu = It2(), Gu = Ds(), Ju = ve(), Xu = Ls2(), Pa2 = Object.getOwnPropertyDescriptor;
        Aa2.f = Hu2 ? Pa2 : function(h2, p2) {
          if (h2 = Wu(h2), p2 = Gu(p2), Xu)
            try {
              return Pa2(h2, p2);
            } catch {
            }
          if (Ju(h2, p2))
            return Ku(!zu(Vu.f, h2, p2), h2[p2]);
        };
      });
      var va2 = E((rm2, Ta2) => {
        var Yu = ye(), Qu = ie();
        Ta2.exports = Yu && Qu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Lt2 = E((im2, Ea2) => {
        var Zu2 = Ie(), ec = String, tc = TypeError;
        Ea2.exports = function(l) {
          if (Zu2(l))
            return l;
          throw tc(ec(l) + " is not an object");
        };
      });
      var et2 = E((ba2) => {
        var sc = ye(), rc = Ls2(), ic = va2(), Ot2 = Lt2(), Ca2 = Ds(), ac = TypeError, Bs2 = Object.defineProperty, nc = Object.getOwnPropertyDescriptor, Ms2 = "enumerable", _s = "configurable", Rs = "writable";
        ba2.f = sc ? ic ? function(h2, p2, d) {
          if (Ot2(h2), p2 = Ca2(p2), Ot2(d), typeof h2 == "function" && p2 === "prototype" && "value" in d && Rs in d && !d[Rs]) {
            var x2 = nc(h2, p2);
            x2 && x2[Rs] && (h2[p2] = d.value, d = { configurable: _s in d ? d[_s] : x2[_s], enumerable: Ms2 in d ? d[Ms2] : x2[Ms2], writable: false });
          }
          return Bs2(h2, p2, d);
        } : Bs2 : function(h2, p2, d) {
          if (Ot2(h2), p2 = Ca2(p2), Ot2(d), rc)
            try {
              return Bs2(h2, p2, d);
            } catch {
            }
          if ("get" in d || "set" in d)
            throw ac("Accessors not supported");
          return "value" in d && (h2[p2] = d.value), h2;
        };
      });
      var js2 = E((nm2, Sa2) => {
        var oc = ye(), lc = et2(), hc = fs();
        Sa2.exports = oc ? function(l, h2, p2) {
          return lc.f(l, h2, hc(1, p2));
        } : function(l, h2, p2) {
          return l[h2] = p2, l;
        };
      });
      var Na2 = E((om2, Ia2) => {
        var qs = ye(), uc = ve(), wa2 = Function.prototype, cc = qs && Object.getOwnPropertyDescriptor, Us = uc(wa2, "name"), pc = Us && (function() {
        }).name === "something", fc = Us && (!qs || qs && cc(wa2, "name").configurable);
        Ia2.exports = { EXISTS: Us, PROPER: pc, CONFIGURABLE: fc };
      });
      var Hs = E((lm2, ka2) => {
        var dc = ae(), mc = ee(), $s = Ft2(), yc = dc(Function.toString);
        mc($s.inspectSource) || ($s.inspectSource = function(l) {
          return yc(l);
        });
        ka2.exports = $s.inspectSource;
      });
      var La2 = E((hm2, Fa2) => {
        var xc = re2(), gc = ee(), Da = xc.WeakMap;
        Fa2.exports = gc(Da) && /native code/.test(String(Da));
      });
      var Ma2 = E((um2, Ba2) => {
        var Pc = Is(), Ac = ks(), Oa2 = Pc("keys");
        Ba2.exports = function(l) {
          return Oa2[l] || (Oa2[l] = Ac(l));
        };
      });
      var zs = E((cm2, _a3) => {
        _a3.exports = {};
      });
      var Ua2 = E((pm2, qa2) => {
        var Tc = La2(), ja2 = re2(), vc = Ie(), Ec = js2(), Vs2 = ve(), Ks = Ft2(), Cc = Ma2(), bc2 = zs(), Ra2 = "Object already initialized", Ws = ja2.TypeError, Sc = ja2.WeakMap, Bt, tt, Mt2, wc = function(l) {
          return Mt2(l) ? tt(l) : Bt(l, {});
        }, Ic = function(l) {
          return function(h2) {
            var p2;
            if (!vc(h2) || (p2 = tt(h2)).type !== l)
              throw Ws("Incompatible receiver, " + l + " required");
            return p2;
          };
        };
        Tc || Ks.state ? (oe = Ks.state || (Ks.state = new Sc()), oe.get = oe.get, oe.has = oe.has, oe.set = oe.set, Bt = function(l, h2) {
          if (oe.has(l))
            throw Ws(Ra2);
          return h2.facade = l, oe.set(l, h2), h2;
        }, tt = function(l) {
          return oe.get(l) || {};
        }, Mt2 = function(l) {
          return oe.has(l);
        }) : (ke = Cc("state"), bc2[ke] = true, Bt = function(l, h2) {
          if (Vs2(l, ke))
            throw Ws(Ra2);
          return h2.facade = l, Ec(l, ke, h2), h2;
        }, tt = function(l) {
          return Vs2(l, ke) ? l[ke] : {};
        }, Mt2 = function(l) {
          return Vs2(l, ke);
        });
        var oe, ke;
        qa2.exports = { set: Bt, get: tt, has: Mt2, enforce: wc, getterFor: Ic };
      });
      var Js2 = E((fm2, Ha2) => {
        var Nc = ie(), kc = ee(), _t2 = ve(), Gs = ye(), Dc = Na2().CONFIGURABLE, Fc = Hs(), $a2 = Ua2(), Lc = $a2.enforce, Oc = $a2.get, Rt2 = Object.defineProperty, Bc = Gs && !Nc(function() {
          return Rt2(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Mc = String(String).split("String"), _c = Ha2.exports = function(l, h2, p2) {
          String(h2).slice(0, 7) === "Symbol(" && (h2 = "[" + String(h2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), p2 && p2.getter && (h2 = "get " + h2), p2 && p2.setter && (h2 = "set " + h2), (!_t2(l, "name") || Dc && l.name !== h2) && (Gs ? Rt2(l, "name", { value: h2, configurable: true }) : l.name = h2), Bc && p2 && _t2(p2, "arity") && l.length !== p2.arity && Rt2(l, "length", { value: p2.arity });
          try {
            p2 && _t2(p2, "constructor") && p2.constructor ? Gs && Rt2(l, "prototype", { writable: false }) : l.prototype && (l.prototype = void 0);
          } catch {
          }
          var d = Lc(l);
          return _t2(d, "source") || (d.source = Mc.join(typeof h2 == "string" ? h2 : "")), l;
        };
        Function.prototype.toString = _c(function() {
          return kc(this) && Oc(this).source || Fc(this);
        }, "toString");
      });
      var Va2 = E((dm2, za2) => {
        var Rc = ee(), jc = et2(), qc = Js2(), Uc = Dt2();
        za2.exports = function(l, h2, p2, d) {
          d || (d = {});
          var x2 = d.enumerable, P = d.name !== void 0 ? d.name : h2;
          if (Rc(p2) && qc(p2, P, d), d.global)
            x2 ? l[h2] = p2 : Uc(h2, p2);
          else {
            try {
              d.unsafe ? l[h2] && (x2 = true) : delete l[h2];
            } catch {
            }
            x2 ? l[h2] = p2 : jc.f(l, h2, { value: p2, enumerable: false, configurable: !d.nonConfigurable, writable: !d.nonWritable });
          }
          return l;
        };
      });
      var Wa2 = E((mm2, Ka2) => {
        var $c = Math.ceil, Hc = Math.floor;
        Ka2.exports = Math.trunc || function(h2) {
          var p2 = +h2;
          return (p2 > 0 ? Hc : $c)(p2);
        };
      });
      var Xs = E((ym2, Ga2) => {
        var zc = Wa2();
        Ga2.exports = function(l) {
          var h2 = +l;
          return h2 !== h2 || h2 === 0 ? 0 : zc(h2);
        };
      });
      var Xa2 = E((xm2, Ja2) => {
        var Vc = Xs(), Kc = Math.max, Wc = Math.min;
        Ja2.exports = function(l, h2) {
          var p2 = Vc(l);
          return p2 < 0 ? Kc(p2 + h2, 0) : Wc(p2, h2);
        };
      });
      var Qa2 = E((gm2, Ya2) => {
        var Gc = Xs(), Jc = Math.min;
        Ya2.exports = function(l) {
          return l > 0 ? Jc(Gc(l), 9007199254740991) : 0;
        };
      });
      var jt2 = E((Pm2, Za2) => {
        var Xc = Qa2();
        Za2.exports = function(l) {
          return Xc(l.length);
        };
      });
      var sn2 = E((Am2, tn2) => {
        var Yc = It2(), Qc = Xa2(), Zc = jt2(), en = function(l) {
          return function(h2, p2, d) {
            var x2 = Yc(h2), P = Zc(x2), m2 = Qc(d, P), v;
            if (l && p2 != p2) {
              for (; P > m2; )
                if (v = x2[m2++], v != v)
                  return true;
            } else
              for (; P > m2; m2++)
                if ((l || m2 in x2) && x2[m2] === p2)
                  return l || m2 || 0;
            return !l && -1;
          };
        };
        tn2.exports = { includes: en(true), indexOf: en(false) };
      });
      var nn = E((Tm2, an) => {
        var ep = ae(), Ys2 = ve(), tp = It2(), sp = sn2().indexOf, rp = zs(), rn2 = ep([].push);
        an.exports = function(l, h2) {
          var p2 = tp(l), d = 0, x2 = [], P;
          for (P in p2)
            !Ys2(rp, P) && Ys2(p2, P) && rn2(x2, P);
          for (; h2.length > d; )
            Ys2(p2, P = h2[d++]) && (~sp(x2, P) || rn2(x2, P));
          return x2;
        };
      });
      var ln = E((vm2, on) => {
        on.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var un2 = E((hn) => {
        var ip2 = nn(), ap = ln(), np = ap.concat("length", "prototype");
        hn.f = Object.getOwnPropertyNames || function(h2) {
          return ip2(h2, np);
        };
      });
      var pn2 = E((cn) => {
        cn.f = Object.getOwnPropertySymbols;
      });
      var dn2 = E((bm2, fn) => {
        var op2 = Qe(), lp = ae(), hp = un2(), up = pn2(), cp = Lt2(), pp = lp([].concat);
        fn.exports = op2("Reflect", "ownKeys") || function(h2) {
          var p2 = hp.f(cp(h2)), d = up.f;
          return d ? pp(p2, d(h2)) : p2;
        };
      });
      var xn2 = E((Sm2, yn) => {
        var mn = ve(), fp = dn2(), dp = Os(), mp = et2();
        yn.exports = function(l, h2, p2) {
          for (var d = fp(h2), x2 = mp.f, P = dp.f, m2 = 0; m2 < d.length; m2++) {
            var v = d[m2];
            !mn(l, v) && !(p2 && mn(p2, v)) && x2(l, v, P(h2, v));
          }
        };
      });
      var Pn = E((wm2, gn2) => {
        var yp = ie(), xp = ee(), gp = /#|\.prototype\./, st = function(l, h2) {
          var p2 = Ap[Pp(l)];
          return p2 == vp ? true : p2 == Tp ? false : xp(h2) ? yp(h2) : !!h2;
        }, Pp = st.normalize = function(l) {
          return String(l).replace(gp, ".").toLowerCase();
        }, Ap = st.data = {}, Tp = st.NATIVE = "N", vp = st.POLYFILL = "P";
        gn2.exports = st;
      });
      var Zs2 = E((Im2, An) => {
        var Qs = re2(), Ep = Os().f, Cp = js2(), bp = Va2(), Sp = Dt2(), wp = xn2(), Ip = Pn();
        An.exports = function(l, h2) {
          var p2 = l.target, d = l.global, x2 = l.stat, P, m2, v, S, k, F;
          if (d ? m2 = Qs : x2 ? m2 = Qs[p2] || Sp(p2, {}) : m2 = (Qs[p2] || {}).prototype, m2)
            for (v in h2) {
              if (k = h2[v], l.dontCallGetSet ? (F = Ep(m2, v), S = F && F.value) : S = m2[v], P = Ip(d ? v : p2 + (x2 ? "." : "#") + v, l.forced), !P && S !== void 0) {
                if (typeof k == typeof S)
                  continue;
                wp(k, S);
              }
              (l.sham || S && S.sham) && Cp(k, "sham", true), bp(m2, v, k, l);
            }
        };
      });
      var Tn2 = E(() => {
        var Np = Zs2(), er2 = re2();
        Np({ global: true, forced: er2.globalThis !== er2 }, { globalThis: er2 });
      });
      var vn = E(() => {
        Tn2();
      });
      var bn2 = E((Lm2, Cn) => {
        var En2 = Js2(), kp = et2();
        Cn.exports = function(l, h2, p2) {
          return p2.get && En2(p2.get, h2, { getter: true }), p2.set && En2(p2.set, h2, { setter: true }), kp.f(l, h2, p2);
        };
      });
      var wn2 = E((Om2, Sn2) => {
        var Dp = Lt2();
        Sn2.exports = function() {
          var l = Dp(this), h2 = "";
          return l.hasIndices && (h2 += "d"), l.global && (h2 += "g"), l.ignoreCase && (h2 += "i"), l.multiline && (h2 += "m"), l.dotAll && (h2 += "s"), l.unicode && (h2 += "u"), l.unicodeSets && (h2 += "v"), l.sticky && (h2 += "y"), h2;
        };
      });
      var kn2 = E(() => {
        var Fp = re2(), Lp = ye(), Op = bn2(), Bp = wn2(), Mp = ie(), In2 = Fp.RegExp, Nn2 = In2.prototype, _p = Lp && Mp(function() {
          var l = true;
          try {
            In2(".", "d");
          } catch {
            l = false;
          }
          var h2 = {}, p2 = "", d = l ? "dgimsy" : "gimsy", x2 = function(S, k) {
            Object.defineProperty(h2, S, { get: function() {
              return p2 += k, true;
            } });
          }, P = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          l && (P.hasIndices = "d");
          for (var m2 in P)
            x2(m2, P[m2]);
          var v = Object.getOwnPropertyDescriptor(Nn2, "flags").get.call(h2);
          return v !== d || p2 !== d;
        });
        _p && Op(Nn2, "flags", { configurable: true, get: Bp });
      });
      var tr2 = E((_m2, Dn) => {
        var Rp = Ye();
        Dn.exports = Array.isArray || function(h2) {
          return Rp(h2) == "Array";
        };
      });
      var Ln2 = E((Rm2, Fn) => {
        var jp = TypeError, qp = 9007199254740991;
        Fn.exports = function(l) {
          if (l > qp)
            throw jp("Maximum allowed index exceeded");
          return l;
        };
      });
      var Bn = E((jm2, On2) => {
        var Up = Ye(), $p = ae();
        On2.exports = function(l) {
          if (Up(l) === "Function")
            return $p(l);
        };
      });
      var Rn2 = E((qm2, _n2) => {
        var Mn2 = Bn(), Hp = kt2(), zp = bt2(), Vp = Mn2(Mn2.bind);
        _n2.exports = function(l, h2) {
          return Hp(l), h2 === void 0 ? l : zp ? Vp(l, h2) : function() {
            return l.apply(h2, arguments);
          };
        };
      });
      var Un2 = E((Um2, qn2) => {
        var Kp = tr2(), Wp = jt2(), Gp = Ln2(), Jp = Rn2(), jn2 = function(l, h2, p2, d, x2, P, m2, v) {
          for (var S = x2, k = 0, F = m2 ? Jp(m2, v) : false, w, L; k < d; )
            k in p2 && (w = F ? F(p2[k], k, h2) : p2[k], P > 0 && Kp(w) ? (L = Wp(w), S = jn2(l, h2, w, L, S, P - 1) - 1) : (Gp(S + 1), l[S] = w), S++), k++;
          return S;
        };
        qn2.exports = jn2;
      });
      var zn2 = E(($m2, Hn2) => {
        var Xp = Ze(), Yp = Xp("toStringTag"), $n2 = {};
        $n2[Yp] = "z";
        Hn2.exports = String($n2) === "[object z]";
      });
      var Kn2 = E((Hm2, Vn2) => {
        var Qp = zn2(), Zp = ee(), qt2 = Ye(), ef = Ze(), tf = ef("toStringTag"), sf = Object, rf = qt2(/* @__PURE__ */ function() {
          return arguments;
        }()) == "Arguments", af = function(l, h2) {
          try {
            return l[h2];
          } catch {
          }
        };
        Vn2.exports = Qp ? qt2 : function(l) {
          var h2, p2, d;
          return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (p2 = af(h2 = sf(l), tf)) == "string" ? p2 : rf ? qt2(h2) : (d = qt2(h2)) == "Object" && Zp(h2.callee) ? "Arguments" : d;
        };
      });
      var Qn2 = E((zm2, Yn2) => {
        var nf = ae(), of = ie(), Wn2 = ee(), lf = Kn2(), hf = Qe(), uf = Hs(), Gn2 = function() {
        }, cf2 = [], Jn2 = hf("Reflect", "construct"), sr2 = /^\s*(?:class|function)\b/, pf2 = nf(sr2.exec), ff2 = !sr2.exec(Gn2), rt = function(h2) {
          if (!Wn2(h2))
            return false;
          try {
            return Jn2(Gn2, cf2, h2), true;
          } catch {
            return false;
          }
        }, Xn2 = function(h2) {
          if (!Wn2(h2))
            return false;
          switch (lf(h2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return ff2 || !!pf2(sr2, uf(h2));
          } catch {
            return true;
          }
        };
        Xn2.sham = true;
        Yn2.exports = !Jn2 || of(function() {
          var l;
          return rt(rt.call) || !rt(Object) || !rt(function() {
            l = true;
          }) || l;
        }) ? Xn2 : rt;
      });
      var so2 = E((Vm2, to2) => {
        var Zn2 = tr2(), df2 = Qn2(), mf2 = Ie(), yf = Ze(), xf = yf("species"), eo2 = Array;
        to2.exports = function(l) {
          var h2;
          return Zn2(l) && (h2 = l.constructor, df2(h2) && (h2 === eo2 || Zn2(h2.prototype)) ? h2 = void 0 : mf2(h2) && (h2 = h2[xf], h2 === null && (h2 = void 0))), h2 === void 0 ? eo2 : h2;
        };
      });
      var io2 = E((Km2, ro2) => {
        var gf = so2();
        ro2.exports = function(l, h2) {
          return new (gf(l))(h2 === 0 ? 0 : h2);
        };
      });
      var ao2 = E(() => {
        var Pf = Zs2(), Af = Un2(), Tf = kt2(), vf = Ns(), Ef = jt2(), Cf = io2();
        Pf({ target: "Array", proto: true }, { flatMap: function(h2) {
          var p2 = vf(this), d = Ef(p2), x2;
          return Tf(h2), x2 = Cf(p2, 0), x2.length = Af(x2, p2, p2, d, 0, 1, h2, arguments.length > 1 ? arguments[1] : void 0), x2;
        } });
      });
      var md2 = E((ty, Oo) => {
        vn();
        kn2();
        ao2();
        var nr = Object.defineProperty, bf = Object.getOwnPropertyDescriptor, or2 = Object.getOwnPropertyNames, Sf = Object.prototype.hasOwnProperty, co2 = (l, h2) => function() {
          return l && (h2 = (0, l[or2(l)[0]])(l = 0)), h2;
        }, $2 = (l, h2) => function() {
          return h2 || (0, l[or2(l)[0]])((h2 = { exports: {} }).exports, h2), h2.exports;
        }, wf = (l, h2) => {
          for (var p2 in h2)
            nr(l, p2, { get: h2[p2], enumerable: true });
        }, If = (l, h2, p2, d) => {
          if (h2 && typeof h2 == "object" || typeof h2 == "function")
            for (let x2 of or2(h2))
              !Sf.call(l, x2) && x2 !== p2 && nr(l, x2, { get: () => h2[x2], enumerable: !(d = bf(h2, x2)) || d.enumerable });
          return l;
        }, Nf = (l) => If(nr({}, "__esModule", { value: true }), l), U = co2({ "<define:process>"() {
        } }), kf = $2({ "src/utils/try-combinations.js"(l, h2) {
          U();
          function p2() {
            let d;
            for (var x2 = arguments.length, P = new Array(x2), m2 = 0; m2 < x2; m2++)
              P[m2] = arguments[m2];
            for (let [v, S] of P.entries())
              try {
                return { result: S() };
              } catch (k) {
                v === 0 && (d = k);
              }
            return { error: d };
          }
          h2.exports = p2;
        } }), po2 = $2({ "src/language-js/utils/get-shebang.js"(l, h2) {
          U();
          function p2(d) {
            if (!d.startsWith("#!"))
              return "";
            let x2 = d.indexOf(`
`);
            return x2 === -1 ? d : d.slice(0, x2);
          }
          h2.exports = p2;
        } }), Df2 = $2({ "src/utils/text/skip-inline-comment.js"(l, h2) {
          U();
          function p2(d, x2) {
            if (x2 === false)
              return false;
            if (d.charAt(x2) === "/" && d.charAt(x2 + 1) === "*") {
              for (let P = x2 + 2; P < d.length; ++P)
                if (d.charAt(P) === "*" && d.charAt(P + 1) === "/")
                  return P + 2;
            }
            return x2;
          }
          h2.exports = p2;
        } }), Ff = $2({ "src/utils/text/skip-newline.js"(l, h2) {
          U();
          function p2(d, x2, P) {
            let m2 = P && P.backwards;
            if (x2 === false)
              return false;
            let v = d.charAt(x2);
            if (m2) {
              if (d.charAt(x2 - 1) === "\r" && v === `
`)
                return x2 - 2;
              if (v === `
` || v === "\r" || v === "\u2028" || v === "\u2029")
                return x2 - 1;
            } else {
              if (v === "\r" && d.charAt(x2 + 1) === `
`)
                return x2 + 2;
              if (v === `
` || v === "\r" || v === "\u2028" || v === "\u2029")
                return x2 + 1;
            }
            return x2;
          }
          h2.exports = p2;
        } }), fo2 = $2({ "src/utils/text/skip.js"(l, h2) {
          U();
          function p2(v) {
            return (S, k, F) => {
              let w = F && F.backwards;
              if (k === false)
                return false;
              let { length: L } = S, A = k;
              for (; A >= 0 && A < L; ) {
                let _ = S.charAt(A);
                if (v instanceof RegExp) {
                  if (!v.test(_))
                    return A;
                } else if (!v.includes(_))
                  return A;
                w ? A-- : A++;
              }
              return A === -1 || A === L ? A : false;
            };
          }
          var d = p2(/\s/), x2 = p2(" 	"), P = p2(",; 	"), m2 = p2(/[^\n\r]/);
          h2.exports = { skipWhitespace: d, skipSpaces: x2, skipToLineEnd: P, skipEverythingButNewLine: m2 };
        } }), Lf = $2({ "src/utils/text/skip-trailing-comment.js"(l, h2) {
          U();
          var { skipEverythingButNewLine: p2 } = fo2();
          function d(x2, P) {
            return P === false ? false : x2.charAt(P) === "/" && x2.charAt(P + 1) === "/" ? p2(x2, P) : P;
          }
          h2.exports = d;
        } }), Of = $2({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(l, h2) {
          U();
          var p2 = Df2(), d = Ff(), x2 = Lf(), { skipSpaces: P } = fo2();
          function m2(v, S) {
            let k = null, F = S;
            for (; F !== k; )
              k = F, F = P(v, F), F = p2(v, F), F = x2(v, F), F = d(v, F);
            return F;
          }
          h2.exports = m2;
        } }), mo2 = {};
        wf(mo2, { EOL: () => ar2, arch: () => Bf, cpus: () => vo2, default: () => wo, endianness: () => yo2, freemem: () => Ao2, getNetworkInterfaces: () => So2, hostname: () => xo2, loadavg: () => go2, networkInterfaces: () => bo2, platform: () => Mf, release: () => Co2, tmpDir: () => rr2, tmpdir: () => ir, totalmem: () => To2, type: () => Eo2, uptime: () => Po });
        function yo2() {
          if (typeof Ut > "u") {
            var l = new ArrayBuffer(2), h2 = new Uint8Array(l), p2 = new Uint16Array(l);
            if (h2[0] = 1, h2[1] = 2, p2[0] === 258)
              Ut = "BE";
            else if (p2[0] === 513)
              Ut = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Ut;
        }
        function xo2() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function go2() {
          return [];
        }
        function Po() {
          return 0;
        }
        function Ao2() {
          return Number.MAX_VALUE;
        }
        function To2() {
          return Number.MAX_VALUE;
        }
        function vo2() {
          return [];
        }
        function Eo2() {
          return "Browser";
        }
        function Co2() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function bo2() {
        }
        function So2() {
        }
        function Bf() {
          return "javascript";
        }
        function Mf() {
          return "browser";
        }
        function rr2() {
          return "/tmp";
        }
        var Ut, ir, ar2, wo, _f = co2({ "node-modules-polyfills:os"() {
          U(), ir = rr2, ar2 = `
`, wo = { EOL: ar2, tmpdir: ir, tmpDir: rr2, networkInterfaces: bo2, getNetworkInterfaces: So2, release: Co2, type: Eo2, cpus: vo2, totalmem: To2, freemem: Ao2, uptime: Po, loadavg: go2, hostname: xo2, endianness: yo2 };
        } }), Rf = $2({ "node-modules-polyfills-commonjs:os"(l, h2) {
          U();
          var p2 = (_f(), Nf(mo2));
          if (p2 && p2.default) {
            h2.exports = p2.default;
            for (let d in p2)
              h2.exports[d] = p2[d];
          } else
            p2 && (h2.exports = p2);
        } }), jf = $2({ "node_modules/detect-newline/index.js"(l, h2) {
          U();
          var p2 = (d) => {
            if (typeof d != "string")
              throw new TypeError("Expected a string");
            let x2 = d.match(/(?:\r?\n)/g) || [];
            if (x2.length === 0)
              return;
            let P = x2.filter((v) => v === `\r
`).length, m2 = x2.length - P;
            return P > m2 ? `\r
` : `
`;
          };
          h2.exports = p2, h2.exports.graceful = (d) => typeof d == "string" && p2(d) || `
`;
        } }), qf = $2({ "node_modules/jest-docblock/build/index.js"(l) {
          U(), Object.defineProperty(l, "__esModule", { value: true }), l.extract = A, l.parse = G, l.parseWithComments = N, l.print = O, l.strip = _;
          function h2() {
            let R = Rf();
            return h2 = function() {
              return R;
            }, R;
          }
          function p2() {
            let R = d(jf());
            return p2 = function() {
              return R;
            }, R;
          }
          function d(R) {
            return R && R.__esModule ? R : { default: R };
          }
          var x2 = /\*\/$/, P = /^\/\*\*?/, m2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, v = /(^|\s+)\/\/([^\r\n]*)/g, S = /^(\r?\n)+/, k = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, F = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, w = /(\r?\n|^) *\* ?/g, L = [];
          function A(R) {
            let z = R.match(m2);
            return z ? z[0].trimLeft() : "";
          }
          function _(R) {
            let z = R.match(m2);
            return z && z[0] ? R.substring(z[0].length) : R;
          }
          function G(R) {
            return N(R).pragmas;
          }
          function N(R) {
            let z = (0, p2().default)(R) || h2().EOL;
            R = R.replace(P, "").replace(x2, "").replace(w, "$1");
            let Q = "";
            for (; Q !== R; )
              Q = R, R = R.replace(k, `${z}$1 $2${z}`);
            R = R.replace(S, "").trimRight();
            let b = /* @__PURE__ */ Object.create(null), B = R.replace(F, "").replace(S, "").trimRight(), Z;
            for (; Z = F.exec(R); ) {
              let q2 = Z[2].replace(v, "");
              typeof b[Z[1]] == "string" || Array.isArray(b[Z[1]]) ? b[Z[1]] = L.concat(b[Z[1]], q2) : b[Z[1]] = q2;
            }
            return { comments: B, pragmas: b };
          }
          function O(R) {
            let { comments: z = "", pragmas: Q = {} } = R, b = (0, p2().default)(z) || h2().EOL, B = "/**", Z = " *", q2 = " */", ue = Object.keys(Q), te2 = ue.map((se) => H(se, Q[se])).reduce((se, He) => se.concat(He), []).map((se) => `${Z} ${se}${b}`).join("");
            if (!z) {
              if (ue.length === 0)
                return "";
              if (ue.length === 1 && !Array.isArray(Q[ue[0]])) {
                let se = Q[ue[0]];
                return `${B} ${H(ue[0], se)[0]}${q2}`;
              }
            }
            let it = z.split(b).map((se) => `${Z} ${se}`).join(b) + b;
            return B + b + (z ? it : "") + (z && ue.length ? Z + b : "") + te2 + q2;
          }
          function H(R, z) {
            return L.concat(z).map((Q) => `@${R} ${Q}`.trim());
          }
        } }), Uf2 = $2({ "src/common/end-of-line.js"(l, h2) {
          U();
          function p2(m2) {
            let v = m2.indexOf("\r");
            return v >= 0 ? m2.charAt(v + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function d(m2) {
            switch (m2) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function x2(m2, v) {
            let S;
            switch (v) {
              case `
`:
                S = /\n/g;
                break;
              case "\r":
                S = /\r/g;
                break;
              case `\r
`:
                S = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(v)}.`);
            }
            let k = m2.match(S);
            return k ? k.length : 0;
          }
          function P(m2) {
            return m2.replace(/\r\n?/g, `
`);
          }
          h2.exports = { guessEndOfLine: p2, convertEndOfLineToChars: d, countEndOfLineChars: x2, normalizeEndOfLine: P };
        } }), $f = $2({ "src/language-js/pragma.js"(l, h2) {
          U();
          var { parseWithComments: p2, strip: d, extract: x2, print: P } = qf(), { normalizeEndOfLine: m2 } = Uf2(), v = po2();
          function S(w) {
            let L = v(w);
            L && (w = w.slice(L.length + 1));
            let A = x2(w), { pragmas: _, comments: G } = p2(A);
            return { shebang: L, text: w, pragmas: _, comments: G };
          }
          function k(w) {
            let L = Object.keys(S(w).pragmas);
            return L.includes("prettier") || L.includes("format");
          }
          function F(w) {
            let { shebang: L, text: A, pragmas: _, comments: G } = S(w), N = d(A), O = P({ pragmas: Object.assign({ format: "" }, _), comments: G.trimStart() });
            return (L ? `${L}
` : "") + m2(O) + (N.startsWith(`
`) ? `
` : `

`) + N;
          }
          h2.exports = { hasPragma: k, insertPragma: F };
        } }), Io = $2({ "src/utils/is-non-empty-array.js"(l, h2) {
          U();
          function p2(d) {
            return Array.isArray(d) && d.length > 0;
          }
          h2.exports = p2;
        } }), No = $2({ "src/language-js/loc.js"(l, h2) {
          U();
          var p2 = Io();
          function d(S) {
            var k, F;
            let w = S.range ? S.range[0] : S.start, L = (k = (F = S.declaration) === null || F === void 0 ? void 0 : F.decorators) !== null && k !== void 0 ? k : S.decorators;
            return p2(L) ? Math.min(d(L[0]), w) : w;
          }
          function x2(S) {
            return S.range ? S.range[1] : S.end;
          }
          function P(S, k) {
            let F = d(S);
            return Number.isInteger(F) && F === d(k);
          }
          function m2(S, k) {
            let F = x2(S);
            return Number.isInteger(F) && F === x2(k);
          }
          function v(S, k) {
            return P(S, k) && m2(S, k);
          }
          h2.exports = { locStart: d, locEnd: x2, hasSameLocStart: P, hasSameLoc: v };
        } }), ko = $2({ "src/language-js/parse/utils/create-parser.js"(l, h2) {
          U();
          var { hasPragma: p2 } = $f(), { locStart: d, locEnd: x2 } = No();
          function P(m2) {
            return m2 = typeof m2 == "function" ? { parse: m2 } : m2, Object.assign({ astFormat: "estree", hasPragma: p2, locStart: d, locEnd: x2 }, m2);
          }
          h2.exports = P;
        } }), lr2 = $2({ "src/common/parser-create-error.js"(l, h2) {
          U();
          function p2(d, x2) {
            let P = new SyntaxError(d + " (" + x2.start.line + ":" + x2.start.column + ")");
            return P.loc = x2, P;
          }
          h2.exports = p2;
        } }), Do2 = $2({ "src/language-js/parse/utils/create-babel-parse-error.js"(l, h2) {
          U();
          var p2 = lr2();
          function d(x2) {
            let { message: P, loc: m2 } = x2;
            return p2(P.replace(/ \(.*\)/, ""), { start: { line: m2 ? m2.line : 0, column: m2 ? m2.column + 1 : 0 } });
          }
          h2.exports = d;
        } }), Hf = $2({ "src/language-js/utils/is-ts-keyword-type.js"(l, h2) {
          U();
          function p2(d) {
            let { type: x2 } = d;
            return x2.startsWith("TS") && x2.endsWith("Keyword");
          }
          h2.exports = p2;
        } }), zf = $2({ "src/language-js/utils/is-block-comment.js"(l, h2) {
          U();
          var p2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d = (x2) => p2.has(x2 == null ? void 0 : x2.type);
          h2.exports = d;
        } }), Vf = $2({ "src/language-js/utils/is-type-cast-comment.js"(l, h2) {
          U();
          var p2 = zf();
          function d(x2) {
            return p2(x2) && x2.value[0] === "*" && /@(?:type|satisfies)\b/.test(x2.value);
          }
          h2.exports = d;
        } }), Kf2 = $2({ "src/utils/get-last.js"(l, h2) {
          U();
          var p2 = (d) => d[d.length - 1];
          h2.exports = p2;
        } }), Wf = $2({ "src/language-js/parse/postprocess/visit-node.js"(l, h2) {
          U();
          function p2(d, x2) {
            if (Array.isArray(d)) {
              for (let P = 0; P < d.length; P++)
                d[P] = p2(d[P], x2);
              return d;
            }
            if (d && typeof d == "object" && typeof d.type == "string") {
              let P = Object.keys(d);
              for (let m2 = 0; m2 < P.length; m2++)
                d[P[m2]] = p2(d[P[m2]], x2);
              return x2(d) || d;
            }
            return d;
          }
          h2.exports = p2;
        } }), Gf2 = $2({ "src/language-js/parse/postprocess/throw-syntax-error.js"(l, h2) {
          U();
          var p2 = lr2();
          function d(x2, P) {
            let { start: m2, end: v } = x2.loc;
            throw p2(P, { start: { line: m2.line, column: m2.column + 1 }, end: { line: v.line, column: v.column + 1 } });
          }
          h2.exports = d;
        } }), Jf2 = $2({ "src/language-js/parse/postprocess/index.js"(l, h2) {
          U();
          var { locStart: p2, locEnd: d } = No(), x2 = Hf(), P = Vf(), m2 = Kf2(), v = Wf(), S = Gf2();
          function k(A, _) {
            if (_.parser !== "typescript" && _.parser !== "flow" && _.parser !== "acorn" && _.parser !== "espree" && _.parser !== "meriyah") {
              let N = /* @__PURE__ */ new Set();
              A = v(A, (O) => {
                O.leadingComments && O.leadingComments.some(P) && N.add(p2(O));
              }), A = v(A, (O) => {
                if (O.type === "ParenthesizedExpression") {
                  let { expression: H } = O;
                  if (H.type === "TypeCastExpression")
                    return H.range = O.range, H;
                  let R = p2(O);
                  if (!N.has(R))
                    return H.extra = Object.assign(Object.assign({}, H.extra), {}, { parenthesized: true }), H;
                }
              });
            }
            return A = v(A, (N) => {
              switch (N.type) {
                case "ChainExpression":
                  return F(N.expression);
                case "LogicalExpression": {
                  if (w(N))
                    return L(N);
                  break;
                }
                case "VariableDeclaration": {
                  let O = m2(N.declarations);
                  O && O.init && G(N, O);
                  break;
                }
                case "TSParenthesizedType":
                  return x2(N.typeAnnotation) || N.typeAnnotation.type === "TSThisType" || (N.typeAnnotation.range = [p2(N), d(N)]), N.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof N.name == "string") {
                    let O = p2(N);
                    N.name = { type: "Identifier", name: N.name, range: [O, O + N.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (_.parser === "typescript") {
                    let O = N.properties.find((H) => H.type === "Property" && H.value.type === "TSEmptyBodyFunctionExpression");
                    O && S(O.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let O = m2(N.expressions);
                  N.range = [p2(N), Math.min(d(O), d(N))];
                  break;
                }
                case "TopicReference":
                  _.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: O } = N;
                  if (_.parser === "meriyah" && O && O.type === "Identifier") {
                    let H = _.originalText.slice(p2(O), d(O));
                    (H.startsWith('"') || H.startsWith("'")) && (N.exported = Object.assign(Object.assign({}, N.exported), {}, { type: "Literal", value: N.exported.name, raw: H }));
                  }
                  break;
                }
                case "PropertyDefinition":
                  if (_.parser === "meriyah" && N.static && !N.computed && !N.key) {
                    let O = "static", H = p2(N);
                    Object.assign(N, { static: false, key: { type: "Identifier", name: O, range: [H, H + O.length] } });
                  }
                  break;
              }
            }), A;
            function G(N, O) {
              _.originalText[d(O)] !== ";" && (N.range = [p2(N), d(O)]);
            }
          }
          function F(A) {
            switch (A.type) {
              case "CallExpression":
                A.type = "OptionalCallExpression", A.callee = F(A.callee);
                break;
              case "MemberExpression":
                A.type = "OptionalMemberExpression", A.object = F(A.object);
                break;
              case "TSNonNullExpression":
                A.expression = F(A.expression);
                break;
            }
            return A;
          }
          function w(A) {
            return A.type === "LogicalExpression" && A.right.type === "LogicalExpression" && A.operator === A.right.operator;
          }
          function L(A) {
            return w(A) ? L({ type: "LogicalExpression", operator: A.operator, left: L({ type: "LogicalExpression", operator: A.operator, left: A.left, right: A.right.left, range: [p2(A.left), d(A.right.left)] }), right: A.right.right, range: [p2(A), d(A)] }) : A;
          }
          h2.exports = k;
        } }), Fo2 = $2({ "node_modules/@babel/parser/lib/index.js"(l) {
          U(), Object.defineProperty(l, "__esModule", { value: true });
          var h2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
          function p2(t) {
            if (t && t.annexB != null && t.annexB !== false)
              throw new Error("The `annexB` option can only be set to `false`.");
            let r = {};
            for (let e of Object.keys(h2))
              r[e] = t && t[e] != null ? t[e] : h2[e];
            return r;
          }
          var d = class {
            constructor(t, r) {
              this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
            }
          }, x2 = { brace: new d("{"), j_oTag: new d("<tag"), j_cTag: new d("</tag"), j_expr: new d("<tag>...</tag>", true) };
          x2.template = new d("`", true);
          var P = true, m2 = true, v = true, S = true, k = true, F = true, w = class {
            constructor(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
            }
          }, L = /* @__PURE__ */ new Map();
          function A(t) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            r.keyword = t;
            let e = b(t, r);
            return L.set(t, e), e;
          }
          function _(t, r) {
            return b(t, { beforeExpr: P, binop: r });
          }
          var G = -1, N = [], O = [], H = [], R = [], z = [], Q = [];
          function b(t) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e, s2, i, a2;
            return ++G, O.push(t), H.push((e = r.binop) != null ? e : -1), R.push((s2 = r.beforeExpr) != null ? s2 : false), z.push((i = r.startsExpr) != null ? i : false), Q.push((a2 = r.prefix) != null ? a2 : false), N.push(new w(t, r)), G;
          }
          function B(t) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e, s2, i, a2;
            return ++G, L.set(t, G), O.push(t), H.push((e = r.binop) != null ? e : -1), R.push((s2 = r.beforeExpr) != null ? s2 : false), z.push((i = r.startsExpr) != null ? i : false), Q.push((a2 = r.prefix) != null ? a2 : false), N.push(new w("name", r)), G;
          }
          var Z = { bracketL: b("[", { beforeExpr: P, startsExpr: m2 }), bracketHashL: b("#[", { beforeExpr: P, startsExpr: m2 }), bracketBarL: b("[|", { beforeExpr: P, startsExpr: m2 }), bracketR: b("]"), bracketBarR: b("|]"), braceL: b("{", { beforeExpr: P, startsExpr: m2 }), braceBarL: b("{|", { beforeExpr: P, startsExpr: m2 }), braceHashL: b("#{", { beforeExpr: P, startsExpr: m2 }), braceR: b("}"), braceBarR: b("|}"), parenL: b("(", { beforeExpr: P, startsExpr: m2 }), parenR: b(")"), comma: b(",", { beforeExpr: P }), semi: b(";", { beforeExpr: P }), colon: b(":", { beforeExpr: P }), doubleColon: b("::", { beforeExpr: P }), dot: b("."), question: b("?", { beforeExpr: P }), questionDot: b("?."), arrow: b("=>", { beforeExpr: P }), template: b("template"), ellipsis: b("...", { beforeExpr: P }), backQuote: b("`", { startsExpr: m2 }), dollarBraceL: b("${", { beforeExpr: P, startsExpr: m2 }), templateTail: b("...`", { startsExpr: m2 }), templateNonTail: b("...${", { beforeExpr: P, startsExpr: m2 }), at: b("@"), hash: b("#", { startsExpr: m2 }), interpreterDirective: b("#!..."), eq: b("=", { beforeExpr: P, isAssign: S }), assign: b("_=", { beforeExpr: P, isAssign: S }), slashAssign: b("_=", { beforeExpr: P, isAssign: S }), xorAssign: b("_=", { beforeExpr: P, isAssign: S }), moduloAssign: b("_=", { beforeExpr: P, isAssign: S }), incDec: b("++/--", { prefix: k, postfix: F, startsExpr: m2 }), bang: b("!", { beforeExpr: P, prefix: k, startsExpr: m2 }), tilde: b("~", { beforeExpr: P, prefix: k, startsExpr: m2 }), doubleCaret: b("^^", { startsExpr: m2 }), doubleAt: b("@@", { startsExpr: m2 }), pipeline: _("|>", 0), nullishCoalescing: _("??", 1), logicalOR: _("||", 1), logicalAND: _("&&", 2), bitwiseOR: _("|", 3), bitwiseXOR: _("^", 4), bitwiseAND: _("&", 5), equality: _("==/!=/===/!==", 6), lt: _("</>/<=/>=", 7), gt: _("</>/<=/>=", 7), relational: _("</>/<=/>=", 7), bitShift: _("<</>>/>>>", 8), bitShiftL: _("<</>>/>>>", 8), bitShiftR: _("<</>>/>>>", 8), plusMin: b("+/-", { beforeExpr: P, binop: 9, prefix: k, startsExpr: m2 }), modulo: b("%", { binop: 10, startsExpr: m2 }), star: b("*", { binop: 10 }), slash: _("/", 10), exponent: b("**", { beforeExpr: P, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: P, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: P, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: P }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: P }), _else: A("else", { beforeExpr: P }), _finally: A("finally"), _function: A("function", { startsExpr: m2 }), _if: A("if"), _return: A("return", { beforeExpr: P }), _switch: A("switch"), _throw: A("throw", { beforeExpr: P, prefix: k, startsExpr: m2 }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: P, startsExpr: m2 }), _this: A("this", { startsExpr: m2 }), _super: A("super", { startsExpr: m2 }), _class: A("class", { startsExpr: m2 }), _extends: A("extends", { beforeExpr: P }), _export: A("export"), _import: A("import", { startsExpr: m2 }), _null: A("null", { startsExpr: m2 }), _true: A("true", { startsExpr: m2 }), _false: A("false", { startsExpr: m2 }), _typeof: A("typeof", { beforeExpr: P, prefix: k, startsExpr: m2 }), _void: A("void", { beforeExpr: P, prefix: k, startsExpr: m2 }), _delete: A("delete", { beforeExpr: P, prefix: k, startsExpr: m2 }), _do: A("do", { isLoop: v, beforeExpr: P }), _for: A("for", { isLoop: v }), _while: A("while", { isLoop: v }), _as: B("as", { startsExpr: m2 }), _assert: B("assert", { startsExpr: m2 }), _async: B("async", { startsExpr: m2 }), _await: B("await", { startsExpr: m2 }), _from: B("from", { startsExpr: m2 }), _get: B("get", { startsExpr: m2 }), _let: B("let", { startsExpr: m2 }), _meta: B("meta", { startsExpr: m2 }), _of: B("of", { startsExpr: m2 }), _sent: B("sent", { startsExpr: m2 }), _set: B("set", { startsExpr: m2 }), _static: B("static", { startsExpr: m2 }), _using: B("using", { startsExpr: m2 }), _yield: B("yield", { startsExpr: m2 }), _asserts: B("asserts", { startsExpr: m2 }), _checks: B("checks", { startsExpr: m2 }), _exports: B("exports", { startsExpr: m2 }), _global: B("global", { startsExpr: m2 }), _implements: B("implements", { startsExpr: m2 }), _intrinsic: B("intrinsic", { startsExpr: m2 }), _infer: B("infer", { startsExpr: m2 }), _is: B("is", { startsExpr: m2 }), _mixins: B("mixins", { startsExpr: m2 }), _proto: B("proto", { startsExpr: m2 }), _require: B("require", { startsExpr: m2 }), _satisfies: B("satisfies", { startsExpr: m2 }), _keyof: B("keyof", { startsExpr: m2 }), _readonly: B("readonly", { startsExpr: m2 }), _unique: B("unique", { startsExpr: m2 }), _abstract: B("abstract", { startsExpr: m2 }), _declare: B("declare", { startsExpr: m2 }), _enum: B("enum", { startsExpr: m2 }), _module: B("module", { startsExpr: m2 }), _namespace: B("namespace", { startsExpr: m2 }), _interface: B("interface", { startsExpr: m2 }), _type: B("type", { startsExpr: m2 }), _opaque: B("opaque", { startsExpr: m2 }), name: b("name", { startsExpr: m2 }), string: b("string", { startsExpr: m2 }), num: b("num", { startsExpr: m2 }), bigint: b("bigint", { startsExpr: m2 }), decimal: b("decimal", { startsExpr: m2 }), regexp: b("regexp", { startsExpr: m2 }), privateName: b("#name", { startsExpr: m2 }), eof: b("eof"), jsxName: b("jsxName"), jsxText: b("jsxText", { beforeExpr: true }), jsxTagStart: b("jsxTagStart", { startsExpr: true }), jsxTagEnd: b("jsxTagEnd"), placeholder: b("%%", { startsExpr: true }) };
          function q2(t) {
            return t >= 93 && t <= 130;
          }
          function ue(t) {
            return t <= 92;
          }
          function te2(t) {
            return t >= 58 && t <= 130;
          }
          function it(t) {
            return t >= 58 && t <= 134;
          }
          function se(t) {
            return R[t];
          }
          function He(t) {
            return z[t];
          }
          function Bo2(t) {
            return t >= 29 && t <= 33;
          }
          function hr2(t) {
            return t >= 127 && t <= 129;
          }
          function Mo(t) {
            return t >= 90 && t <= 92;
          }
          function $t2(t) {
            return t >= 58 && t <= 92;
          }
          function _o(t) {
            return t >= 39 && t <= 59;
          }
          function Ro(t) {
            return t === 34;
          }
          function jo(t) {
            return Q[t];
          }
          function qo(t) {
            return t >= 119 && t <= 121;
          }
          function Uo(t) {
            return t >= 122 && t <= 128;
          }
          function xe(t) {
            return O[t];
          }
          function at2(t) {
            return H[t];
          }
          function $o(t) {
            return t === 57;
          }
          function nt(t) {
            return t >= 24 && t <= 25;
          }
          function ce(t) {
            return N[t];
          }
          N[8].updateContext = (t) => {
            t.pop();
          }, N[5].updateContext = N[7].updateContext = N[23].updateContext = (t) => {
            t.push(x2.brace);
          }, N[22].updateContext = (t) => {
            t[t.length - 1] === x2.template ? t.pop() : t.push(x2.template);
          }, N[140].updateContext = (t) => {
            t.push(x2.j_expr, x2.j_oTag);
          };
          function ot2(t, r) {
            if (t == null)
              return {};
            var e = {}, s2 = Object.keys(t), i, a2;
            for (a2 = 0; a2 < s2.length; a2++)
              i = s2[a2], !(r.indexOf(i) >= 0) && (e[i] = t[i]);
            return e;
          }
          var ge = class {
            constructor(t, r, e) {
              this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = e;
            }
          }, lt2 = class {
            constructor(t, r) {
              this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
            }
          };
          function Y(t, r) {
            let { line: e, column: s2, index: i } = t;
            return new ge(e, s2 + r, i + r);
          }
          var Ht = { SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, Ho = function(t) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.length - 1;
            return { get() {
              return t.reduce((e, s2) => e[s2], this);
            }, set(e) {
              t.reduce((s2, i, a2) => a2 === r ? s2[i] = e : s2[i], this);
            } };
          }, zo = (t, r, e) => Object.keys(e).map((s2) => [s2, e[s2]]).filter((s2) => {
            let [, i] = s2;
            return !!i;
          }).map((s2) => {
            let [i, a2] = s2;
            return [i, typeof a2 == "function" ? { value: a2, enumerable: false } : typeof a2.reflect == "string" ? Object.assign({}, a2, Ho(a2.reflect.split("."))) : a2];
          }).reduce((s2, i) => {
            let [a2, n] = i;
            return Object.defineProperty(s2, a2, Object.assign({ configurable: true }, n));
          }, Object.assign(new t(), r)), Vo = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Ht.SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Ht.SourceTypeModuleError } }, ur = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, zt2 = (t) => {
            let { type: r, prefix: e } = t;
            return r === "UpdateExpression" ? ur.UpdateExpression[String(e)] : ur[r];
          }, Ko = { AccessorIsGenerator: (t) => {
            let { kind: r } = t;
            return `A ${r}ter cannot be a generator.`;
          }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitInUsingBinding: "'await' is not allowed to be used as a name in 'using' declarations.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (t) => {
            let { kind: r } = t;
            return `Missing initializer in ${r} declaration.`;
          }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (t) => {
            let { exportName: r } = t;
            return `\`${r}\` has already been exported. Exported identifiers must be unique.`;
          }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (t) => {
            let { localName: r, exportName: e } = t;
            return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r}' as '${e}' } from 'some-module'\`?`;
          }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (t) => {
            let { type: r } = t;
            return `'${r === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
          }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (t) => {
            let { type: r } = t;
            return `Unsyntactic ${r === "BreakStatement" ? "break" : "continue"}.`;
          }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: (t) => {
            let { importName: r } = t;
            return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r}" as foo }\`?`;
          }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (t) => {
            let { maxArgumentCount: r } = t;
            return `\`import()\` requires exactly ${r === 1 ? "one argument" : "one or two arguments"}.`;
          }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (t) => {
            let { radix: r } = t;
            return `Expected number in radix ${r}.`;
          }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (t) => {
            let { reservedWord: r } = t;
            return `Escape sequence in keyword ${r}.`;
          }, InvalidIdentifier: (t) => {
            let { identifierName: r } = t;
            return `Invalid identifier ${r}.`;
          }, InvalidLhs: (t) => {
            let { ancestor: r } = t;
            return `Invalid left-hand side in ${zt2(r)}.`;
          }, InvalidLhsBinding: (t) => {
            let { ancestor: r } = t;
            return `Binding invalid left-hand side in ${zt2(r)}.`;
          }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (t) => {
            let { unexpected: r } = t;
            return `Unexpected character '${r}'.`;
          }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (t) => {
            let { identifierName: r } = t;
            return `Private name #${r} is not defined.`;
          }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (t) => {
            let { labelName: r } = t;
            return `Label '${r}' is already declared.`;
          }, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (t) => {
            let { missingPlugin: r } = t;
            return `This experimental syntax requires enabling the parser plugin: ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
          }, MissingOneOfPlugins: (t) => {
            let { missingPlugin: r } = t;
            return `This experimental syntax requires enabling one of the following parser plugin(s): ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
          }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (t) => {
            let { key: r } = t;
            return `Duplicate key "${r}" is not allowed in module attributes.`;
          }, ModuleExportNameHasLoneSurrogate: (t) => {
            let { surrogateCharCode: r } = t;
            return `An export name cannot include a lone surrogate, found '\\u${r.toString(16)}'.`;
          }, ModuleExportUndefined: (t) => {
            let { localName: r } = t;
            return `Export '${r}' is not defined.`;
          }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (t) => {
            let { identifierName: r } = t;
            return `Private names are only allowed in property accesses (\`obj.#${r}\`) or in \`in\` expressions (\`#${r} in obj\`).`;
          }, PrivateNameRedeclaration: (t) => {
            let { identifierName: r } = t;
            return `Duplicate private name #${r}.`;
          }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (t) => {
            let { keyword: r } = t;
            return `Unexpected keyword '${r}'.`;
          }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (t) => {
            let { reservedWord: r } = t;
            return `Unexpected reserved word '${r}'.`;
          }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (t) => {
            let { expected: r, unexpected: e } = t;
            return `Unexpected token${e ? ` '${e}'.` : ""}${r ? `, expected "${r}"` : ""}`;
          }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (t) => {
            let { target: r, onlyValidPropertyName: e } = t;
            return `The only valid meta property for ${r} is ${r}.${e}.`;
          }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (t) => {
            let { identifierName: r } = t;
            return `Identifier '${r}' has already been declared.`;
          }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Wo = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (t) => {
            let { referenceName: r } = t;
            return `Assigning to '${r}' in strict mode.`;
          }, StrictEvalArgumentsBinding: (t) => {
            let { bindingName: r } = t;
            return `Binding '${r}' in strict mode.`;
          }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Go = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Jo = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (t) => {
            let { token: r } = t;
            return `Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r}" }.`;
          }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (t) => {
            let { type: r } = t;
            return `Hack-style pipe body cannot be an unparenthesized ${zt2({ type: r })}; please wrap it in parentheses.`;
          }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, Xo = ["toMessage"], Yo = ["message"];
          function Qo(t) {
            let { toMessage: r } = t, e = ot2(t, Xo);
            return function s2(i) {
              let { loc: a2, details: n } = i;
              return zo(SyntaxError, Object.assign({}, e, { loc: a2 }), { clone() {
                let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = o.loc || {};
                return s2({ loc: new ge("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
              }, details: { value: n, enumerable: false }, message: { get() {
                return `${r(this.details)} (${this.loc.line}:${this.loc.column})`;
              }, set(o) {
                Object.defineProperty(this, "message", { value: o });
              } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
            };
          }
          function pe(t, r) {
            if (Array.isArray(t))
              return (s2) => pe(s2, t[0]);
            let e = {};
            for (let s2 of Object.keys(t)) {
              let i = t[s2], a2 = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = a2, o = ot2(a2, Yo), u = typeof n == "string" ? () => n : n;
              e[s2] = Qo(Object.assign({ code: Ht.SyntaxError, reasonCode: s2, toMessage: u }, r ? { syntaxPlugin: r } : {}, o));
            }
            return e;
          }
          var f = Object.assign({}, pe(Vo), pe(Ko), pe(Wo), pe`pipelineOperator`(Jo)), { defineProperty: Zo } = Object, cr = (t, r) => Zo(t, r, { enumerable: false, value: t[r] });
          function ze(t) {
            return t.loc.start && cr(t.loc.start, "index"), t.loc.end && cr(t.loc.end, "index"), t;
          }
          var el = (t) => class extends t {
            parse() {
              let e = ze(super.parse());
              return this.options.tokens && (e.tokens = e.tokens.map(ze)), e;
            }
            parseRegExpLiteral(e) {
              let { pattern: s2, flags: i } = e, a2 = null;
              try {
                a2 = new RegExp(s2, i);
              } catch {
              }
              let n = this.estreeParseLiteral(a2);
              return n.regex = { pattern: s2, flags: i }, n;
            }
            parseBigIntLiteral(e) {
              let s2;
              try {
                s2 = BigInt(e);
              } catch {
                s2 = null;
              }
              let i = this.estreeParseLiteral(s2);
              return i.bigint = String(i.value || e), i;
            }
            parseDecimalLiteral(e) {
              let i = this.estreeParseLiteral(null);
              return i.decimal = String(i.value || e), i;
            }
            estreeParseLiteral(e) {
              return this.parseLiteral(e, "Literal");
            }
            parseStringLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNumericLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNullLiteral() {
              return this.estreeParseLiteral(null);
            }
            parseBooleanLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            directiveToStmt(e) {
              let s2 = e.value;
              delete e.value, s2.type = "Literal", s2.raw = s2.extra.raw, s2.value = s2.extra.expressionValue;
              let i = e;
              return i.type = "ExpressionStatement", i.expression = s2, i.directive = s2.extra.rawValue, delete s2.extra, i;
            }
            initFunction(e, s2) {
              super.initFunction(e, s2), e.expression = false;
            }
            checkDeclaration(e) {
              e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
            }
            getObjectOrClassMethodParams(e) {
              return e.value.params;
            }
            isValidDirective(e) {
              var s2;
              return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s2 = e.expression.extra) != null && s2.parenthesized);
            }
            parseBlockBody(e, s2, i, a2, n) {
              super.parseBlockBody(e, s2, i, a2, n);
              let o = e.directives.map((u) => this.directiveToStmt(u));
              e.body = o.concat(e.body), delete e.directives;
            }
            pushClassMethod(e, s2, i, a2, n, o) {
              this.parseMethod(s2, i, a2, n, o, "ClassMethod", true), s2.typeParameters && (s2.value.typeParameters = s2.typeParameters, delete s2.typeParameters), e.body.push(s2);
            }
            parsePrivateName() {
              let e = super.parsePrivateName();
              return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
            }
            convertPrivateNameToPrivateIdentifier(e) {
              let s2 = super.getPrivateNameSV(e);
              return e = e, delete e.id, e.name = s2, e.type = "PrivateIdentifier", e;
            }
            isPrivateName(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
            }
            getPrivateNameSV(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
            }
            parseLiteral(e, s2) {
              let i = super.parseLiteral(e, s2);
              return i.raw = i.extra.raw, delete i.extra, i;
            }
            parseFunctionBody(e, s2) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              super.parseFunctionBody(e, s2, i), e.expression = e.body.type !== "BlockStatement";
            }
            parseMethod(e, s2, i, a2, n, o) {
              let u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c2 = this.startNode();
              return c2.kind = e.kind, c2 = super.parseMethod(c2, s2, i, a2, n, o, u), c2.type = "FunctionExpression", delete c2.kind, e.value = c2, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
            }
            parseClassProperty() {
              let e = super.parseClassProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
            }
            parseClassPrivateProperty() {
              let e = super.parseClassPrivateProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
            }
            parseObjectMethod(e, s2, i, a2, n) {
              let o = super.parseObjectMethod(e, s2, i, a2, n);
              return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
            }
            parseObjectProperty(e, s2, i, a2) {
              let n = super.parseObjectProperty(e, s2, i, a2);
              return n && (n.kind = "init", n.type = "Property"), n;
            }
            isValidLVal(e, s2, i) {
              return e === "Property" ? "value" : super.isValidLVal(e, s2, i);
            }
            isAssignable(e, s2) {
              return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s2) : super.isAssignable(e, s2);
            }
            toAssignable(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e != null && this.isObjectProperty(e)) {
                let { key: i, value: a2 } = e;
                this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a2, s2);
              } else
                super.toAssignable(e, s2);
            }
            toAssignableObjectExpressionProp(e, s2, i) {
              e.kind === "get" || e.kind === "set" ? this.raise(f.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(f.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(e, s2, i);
            }
            finishCallExpression(e, s2) {
              let i = super.finishCallExpression(e, s2);
              if (i.callee.type === "Import") {
                if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAssertions")) {
                  var a2;
                  i.attributes = (a2 = i.arguments[1]) != null ? a2 : null;
                }
                delete i.arguments, delete i.callee;
              }
              return i;
            }
            toReferencedArguments(e) {
              e.type !== "ImportExpression" && super.toReferencedArguments(e);
            }
            parseExport(e, s2) {
              let i = this.state.lastTokStartLoc, a2 = super.parseExport(e, s2);
              switch (a2.type) {
                case "ExportAllDeclaration":
                  a2.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  a2.specifiers.length === 1 && a2.specifiers[0].type === "ExportNamespaceSpecifier" && (a2.type = "ExportAllDeclaration", a2.exported = a2.specifiers[0].exported, delete a2.specifiers);
                case "ExportDefaultDeclaration":
                  {
                    var n;
                    let { declaration: o } = a2;
                    (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === a2.start && this.resetStartLocation(a2, i);
                  }
                  break;
              }
              return a2;
            }
            parseSubscript(e, s2, i, a2) {
              let n = super.parseSubscript(e, s2, i, a2);
              if (a2.optionalChainMember) {
                if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a2.stop) {
                  let o = this.startNodeAtNode(n);
                  return o.expression = n, this.finishNode(o, "ChainExpression");
                }
              } else
                (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
              return n;
            }
            hasPropertyAsPrivateName(e) {
              return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
            }
            isObjectProperty(e) {
              return e.type === "Property" && e.kind === "init" && !e.method;
            }
            isObjectMethod(e) {
              return e.method || e.kind === "get" || e.kind === "set";
            }
            finishNodeAt(e, s2, i) {
              return ze(super.finishNodeAt(e, s2, i));
            }
            resetStartLocation(e, s2) {
              super.resetStartLocation(e, s2), ze(e);
            }
            resetEndLocation(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              super.resetEndLocation(e, s2), ze(e);
            }
          }, Vt2 = "ÂªÂµÂºÃ-ÃÃ-Ã¶Ã¸-ËË-ËË -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Í¿ÎÎ-ÎÎÎ-Î¡Î£-ÏµÏ·-ÒÒ-Ô¯Ô±-ÕÕÕ -Ö×-×ª×¯-×²Ø -ÙÙ®Ù¯Ù±-ÛÛÛ¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ-Ü¯Ý-Þ¥Þ±ß-ßªß´ßµßºà -à à à ¤à ¨à¡-à¡à¡ -à¡ªà¡°-à¢à¢-à¢à¢ -à£à¤-à¤¹à¤½à¥à¥-à¥¡à¥±-à¦à¦-à¦à¦à¦à¦-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§à§à§à§-à§¡à§°à§±à§¼à¨-à¨à¨à¨à¨-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©-à©à©à©²-à©´àª-àªàª-àªàª-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à«¹à¬-à¬à¬à¬à¬-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­à­à­-à­¡à­±à®à®-à®à®-à®à®-à®à®à®à®à®à®à®£à®¤à®¨-à®ªà®®-à®¹à¯à°-à°à°-à°à°-à°¨à°ª-à°¹à°½à±-à±à±à± à±¡à²à²-à²à²-à²à²-à²¨à²ª-à²³à²µ-à²¹à²½à³à³à³ à³¡à³±à³²à´-à´à´-à´à´-à´ºà´½àµàµ-àµàµ-àµ¡àµº-àµ¿à¶-à¶à¶-à¶±à¶³-à¶»à¶½à·-à·à¸-à¸°à¸²à¸³à¹-à¹àºàºàºàº-àºàº-àº£àº¥àº§-àº°àº²àº³àº½à»-à»à»à»-à»à¼à½-à½à½-à½¬à¾-à¾á-áªá¿á-áá-áá¡á¥á¦á®-á°áµ-ááá -áááá-áºá¼-áá-áá-ááá-áá -áá-áá-á°á²-áµá¸-á¾áá-áá-áá-áá-áá-áá-áá -áµá¸-á½á-á¬á¯-á¿á-áá -áªá®-á¸á-áá-á±á-áá -á¬á®-á°á-á³ááá  -á¡¸á¢-á¢¨á¢ªá¢°-á£µá¤-á¤á¥-á¥­á¥°-á¥´á¦-á¦«á¦°-á§á¨-á¨á¨ -á©áª§á¬-á¬³á­-á­á®-á® á®®á®¯á®º-á¯¥á°-á°£á±-á±á±-á±½á²-á²á²-á²ºá²½-á²¿á³©-á³¬á³®-á³³á³µá³¶á³ºá´-á¶¿á¸-á¼á¼-á¼á¼ -á½á½-á½á½-á½á½á½á½á½-á½½á¾-á¾´á¾¶-á¾¼á¾¾á¿-á¿á¿-á¿á¿-á¿á¿-á¿á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â-ââââ-âââ-ââ¤â¦â¨âª-â¹â¼-â¿â-âââ -ââ°-â³¤â³«-â³®â³²â³³â´-â´¥â´§â´­â´°-âµ§âµ¯â¶-â¶â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·-â·â·-â·â·-â·â·-â·ã-ãã¡-ã©ã±-ãµã¸-ã¼ã-ãã-ãã¡-ãºã¼-ã¿ã-ã¯ã±-ãã -ã¿ã°-ã¿ã-ä¶¿ä¸-êê-ê½ê-êê-êêªê«ê-ê®ê¿-êê -ê¯ê-êê¢-êê-êêêêê-êê²-ê ê -ê ê -ê ê -ê ¢ê¡-ê¡³ê¢-ê¢³ê£²-ê£·ê£»ê£½ê£¾ê¤-ê¤¥ê¤°-ê¥ê¥ -ê¥¼ê¦-ê¦²ê§ê§ -ê§¤ê§¦-ê§¯ê§º-ê§¾ê¨-ê¨¨ê©-ê©ê©-ê©ê© -ê©¶ê©ºê©¾-êª¯êª±êªµêª¶êª¹-êª½ê«ê«ê«-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬ê¬-ê¬ê¬-ê¬ê¬ -ê¬¦ê¬¨-ê¬®ê¬°-ê­ê­-ê­©ê­°-ê¯¢ê°-í£í°-íí-í»ï¤-ï©­ï©°-ï«ï¬-ï¬ï¬-ï¬ï¬ï¬-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­ï­ï­ï­ï­-ï®±ï¯-ï´½ïµ-ï¶ï¶-ï·ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½ï½¦-ï¾¾ï¿-ï¿ï¿-ï¿ï¿-ï¿ï¿-ï¿", pr2 = "ââÂ·Ì-Í¯ÎÒ-ÒÖ-Ö½Ö¿×××××Ø-ØÙ-Ù©Ù°Û-ÛÛ-Û¤Û§Û¨Ûª-Û­Û°-Û¹ÜÜ°-ÝÞ¦-Þ°ß-ßß«-ß³ß½à -à à -à £à ¥-à §à ©-à ­à¡-à¡à¢-à¢à£-à£¡à££-à¤à¤º-à¤¼à¤¾-à¥à¥-à¥à¥¢à¥£à¥¦-à¥¯à¦-à¦à¦¼à¦¾-à§à§à§à§-à§à§à§¢à§£à§¦-à§¯à§¾à¨-à¨à¨¼à¨¾-à©à©à©à©-à©à©à©¦-à©±à©µàª-àªàª¼àª¾-à«à«-à«à«-à«à«¢à«£à«¦-à«¯à«º-à«¿à¬-à¬à¬¼à¬¾-à­à­à­à­-à­à­-à­à­¢à­£à­¦-à­¯à®à®¾-à¯à¯-à¯à¯-à¯à¯à¯¦-à¯¯à°-à°à°¼à°¾-à±à±-à±à±-à±à±à±à±¢à±£à±¦-à±¯à²-à²à²¼à²¾-à³à³-à³à³-à³à³à³à³¢à³£à³¦-à³¯à³³à´-à´à´»à´¼à´¾-àµàµ-àµàµ-àµàµàµ¢àµ£àµ¦-àµ¯à¶-à¶à·à·-à·à·à·-à·à·¦-à·¯à·²à·³à¸±à¸´-à¸ºà¹-à¹à¹-à¹àº±àº´-àº¼à»-à»à»-à»à¼à¼à¼ -à¼©à¼µà¼·à¼¹à¼¾à¼¿à½±-à¾à¾à¾à¾-à¾à¾-à¾¼à¿á«-á¾á-áá-áá-á á¢-á¤á§-á­á±-á´á-áá-áá-áá©-á±á-áá²-á´ááá²á³á´-ááá -á©á -á á -á á¢©á¤ -á¤«á¤°-á¤»á¥-á¥á§-á§á¨-á¨á©-á©á© -á©¼á©¿-áªáª-áªáª°-áª½áª¿-á«á¬-á¬á¬´-á­á­-á­á­«-á­³á®-á®á®¡-á®­á®°-á®¹á¯¦-á¯³á°¤-á°·á±-á±á±-á±á³-á³á³-á³¨á³­á³´á³·-á³¹á·-á·¿â¿âââ-ââ¡â¥-â°â³¯-â³±âµ¿â· -â·¿ãª-ã¯ããê -ê©ê¯ê´-ê½êêê°ê±ê ê ê ê £-ê §ê ¬ê¢ê¢ê¢´-ê£ê£-ê£ê£ -ê£±ê£¿-ê¤ê¤¦-ê¤­ê¥-ê¥ê¦-ê¦ê¦³-ê§ê§-ê§ê§¥ê§°-ê§¹ê¨©-ê¨¶ê©ê©ê©ê©-ê©ê©»-ê©½êª°êª²-êª´êª·êª¸êª¾êª¿ê«ê««-ê«¯ê«µê«¶ê¯£-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ï¬ï¸-ï¸ï¸ -ï¸¯ï¸³ï¸´ï¹-ï¹ï¼-ï¼ï¼¿", tl = new RegExp("[" + Vt2 + "]"), sl = new RegExp("[" + Vt2 + pr2 + "]");
          Vt2 = pr2 = null;
          var fr2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], rl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
          function Kt2(t, r) {
            let e = 65536;
            for (let s2 = 0, i = r.length; s2 < i; s2 += 2) {
              if (e += r[s2], e > t)
                return false;
              if (e += r[s2 + 1], e >= t)
                return true;
            }
            return false;
          }
          function fe(t) {
            return t < 65 ? t === 36 : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && tl.test(String.fromCharCode(t)) : Kt2(t, fr2);
          }
          function De(t) {
            return t < 48 ? t === 36 : t < 58 ? true : t < 65 ? false : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && sl.test(String.fromCharCode(t)) : Kt2(t, fr2) || Kt2(t, rl);
          }
          var Wt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, il = new Set(Wt.keyword), al = new Set(Wt.strict), nl = new Set(Wt.strictBind);
          function dr2(t, r) {
            return r && t === "await" || t === "enum";
          }
          function mr2(t, r) {
            return dr2(t, r) || al.has(t);
          }
          function yr(t) {
            return nl.has(t);
          }
          function xr2(t, r) {
            return mr2(t, r) || yr(t);
          }
          function ol(t) {
            return il.has(t);
          }
          function ll(t, r, e) {
            return t === 64 && r === 64 && fe(e);
          }
          var hl = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
          function ul(t) {
            return hl.has(t);
          }
          var Fe = 0, Le = 1, de = 2, Gt2 = 4, gr2 = 8, ht2 = 16, Pr2 = 32, Ee = 64, ut2 = 128, Oe = 256, ct2 = Le | de | ut2 | Oe, le = 1, Ce = 2, Ar = 4, be = 8, pt2 = 16, Tr2 = 64, ft2 = 128, Jt2 = 256, Xt2 = 512, Yt2 = 1024, Qt2 = 2048, Ve = 4096, dt2 = 8192, vr = le | Ce | be | ft2 | dt2, Be = le | 0 | be | dt2, cl = le | 0 | be | 0, mt2 = le | 0 | Ar | 0, Er = le | 0 | pt2 | 0, pl = 0 | Ce | 0 | ft2, fl = 0 | Ce | 0 | 0, Cr = le | Ce | be | Jt2 | dt2, br2 = 0 | Yt2, Pe = 0 | Tr2, dl2 = le | 0 | 0 | Tr2, ml = Cr | Xt2, yl = 0 | Yt2, Sr = 0 | Ce | 0 | Ve, xl = Qt2, yt2 = 4, Zt2 = 2, es = 1, ts2 = Zt2 | es, gl = Zt2 | yt2, Pl = es | yt2, Al = Zt2, Tl = es, ss = 0, rs = class {
            constructor(t) {
              this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
            }
          }, is = class {
            constructor(t, r) {
              this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r;
            }
            get inTopLevel() {
              return (this.currentScope().flags & Le) > 0;
            }
            get inFunction() {
              return (this.currentVarScopeFlags() & de) > 0;
            }
            get allowSuper() {
              return (this.currentThisScopeFlags() & ht2) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScopeFlags() & Pr2) > 0;
            }
            get inClass() {
              return (this.currentThisScopeFlags() & Ee) > 0;
            }
            get inClassAndNotInNonArrowFunction() {
              let t = this.currentThisScopeFlags();
              return (t & Ee) > 0 && (t & de) === 0;
            }
            get inStaticBlock() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r } = this.scopeStack[t];
                if (r & ut2)
                  return true;
                if (r & (ct2 | Ee))
                  return false;
              }
            }
            get inNonArrowFunction() {
              return (this.currentThisScopeFlags() & de) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(t) {
              return new rs(t);
            }
            enter(t) {
              this.scopeStack.push(this.createScope(t));
            }
            exit() {
              return this.scopeStack.pop().flags;
            }
            treatFunctionsAsVarInScope(t) {
              return !!(t.flags & (de | ut2) || !this.parser.inModule && t.flags & Le);
            }
            declareName(t, r, e) {
              let s2 = this.currentScope();
              if (r & be || r & pt2)
                this.checkRedeclarationInScope(s2, t, r, e), r & pt2 ? s2.functions.add(t) : s2.lexical.add(t), r & be && this.maybeExportDefined(s2, t);
              else if (r & Ar)
                for (let i = this.scopeStack.length - 1; i >= 0 && (s2 = this.scopeStack[i], this.checkRedeclarationInScope(s2, t, r, e), s2.var.add(t), this.maybeExportDefined(s2, t), !(s2.flags & ct2)); --i)
                  ;
              this.parser.inModule && s2.flags & Le && this.undefinedExports.delete(t);
            }
            maybeExportDefined(t, r) {
              this.parser.inModule && t.flags & Le && this.undefinedExports.delete(r);
            }
            checkRedeclarationInScope(t, r, e, s2) {
              this.isRedeclaredInScope(t, r, e) && this.parser.raise(f.VarRedeclaration, { at: s2, identifierName: r });
            }
            isRedeclaredInScope(t, r, e) {
              return e & le ? e & be ? t.lexical.has(r) || t.functions.has(r) || t.var.has(r) : e & pt2 ? t.lexical.has(r) || !this.treatFunctionsAsVarInScope(t) && t.var.has(r) : t.lexical.has(r) && !(t.flags & gr2 && t.lexical.values().next().value === r) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(r) : false;
            }
            checkLocalExport(t) {
              let { name: r } = t, e = this.scopeStack[0];
              !e.lexical.has(r) && !e.var.has(r) && !e.functions.has(r) && this.undefinedExports.set(r, t.loc.start);
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r } = this.scopeStack[t];
                if (r & ct2)
                  return r;
              }
            }
            currentThisScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: r } = this.scopeStack[t];
                if (r & (ct2 | Ee) && !(r & Gt2))
                  return r;
              }
            }
          }, vl = class extends rs {
            constructor() {
              super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
            }
          }, El = class extends is {
            createScope(t) {
              return new vl(t);
            }
            declareName(t, r, e) {
              let s2 = this.currentScope();
              if (r & Qt2) {
                this.checkRedeclarationInScope(s2, t, r, e), this.maybeExportDefined(s2, t), s2.declareFunctions.add(t);
                return;
              }
              super.declareName(t, r, e);
            }
            isRedeclaredInScope(t, r, e) {
              return super.isRedeclaredInScope(t, r, e) ? true : e & Qt2 ? !t.declareFunctions.has(r) && (t.lexical.has(r) || t.functions.has(r)) : false;
            }
            checkLocalExport(t) {
              this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
            }
          }, Cl = class {
            constructor() {
              this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
            }
            hasPlugin(t) {
              if (typeof t == "string")
                return this.plugins.has(t);
              {
                let [r, e] = t;
                if (!this.hasPlugin(r))
                  return false;
                let s2 = this.plugins.get(r);
                for (let i of Object.keys(e))
                  if ((s2 == null ? void 0 : s2[i]) !== e[i])
                    return false;
                return true;
              }
            }
            getPluginOption(t, r) {
              var e;
              return (e = this.plugins.get(t)) == null ? void 0 : e[r];
            }
          };
          function wr2(t, r) {
            t.trailingComments === void 0 ? t.trailingComments = r : t.trailingComments.unshift(...r);
          }
          function bl(t, r) {
            t.leadingComments === void 0 ? t.leadingComments = r : t.leadingComments.unshift(...r);
          }
          function Ke2(t, r) {
            t.innerComments === void 0 ? t.innerComments = r : t.innerComments.unshift(...r);
          }
          function We(t, r, e) {
            let s2 = null, i = r.length;
            for (; s2 === null && i > 0; )
              s2 = r[--i];
            s2 === null || s2.start > e.start ? Ke2(t, e.comments) : wr2(s2, e.comments);
          }
          var Sl = class extends Cl {
            addComment(t) {
              this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
            }
            processComment(t) {
              let { commentStack: r } = this.state, e = r.length;
              if (e === 0)
                return;
              let s2 = e - 1, i = r[s2];
              i.start === t.end && (i.leadingNode = t, s2--);
              let { start: a2 } = t;
              for (; s2 >= 0; s2--) {
                let n = r[s2], o = n.end;
                if (o > a2)
                  n.containingNode = t, this.finalizeComment(n), r.splice(s2, 1);
                else {
                  o === a2 && (n.trailingNode = t);
                  break;
                }
              }
            }
            finalizeComment(t) {
              let { comments: r } = t;
              if (t.leadingNode !== null || t.trailingNode !== null)
                t.leadingNode !== null && wr2(t.leadingNode, r), t.trailingNode !== null && bl(t.trailingNode, r);
              else {
                let { containingNode: e, start: s2 } = t;
                if (this.input.charCodeAt(s2 - 1) === 44)
                  switch (e.type) {
                    case "ObjectExpression":
                    case "ObjectPattern":
                    case "RecordExpression":
                      We(e, e.properties, t);
                      break;
                    case "CallExpression":
                    case "OptionalCallExpression":
                      We(e, e.arguments, t);
                      break;
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ArrowFunctionExpression":
                    case "ObjectMethod":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                      We(e, e.params, t);
                      break;
                    case "ArrayExpression":
                    case "ArrayPattern":
                    case "TupleExpression":
                      We(e, e.elements, t);
                      break;
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                      We(e, e.specifiers, t);
                      break;
                    default:
                      Ke2(e, r);
                  }
                else
                  Ke2(e, r);
              }
            }
            finalizeRemainingComments() {
              let { commentStack: t } = this.state;
              for (let r = t.length - 1; r >= 0; r--)
                this.finalizeComment(t[r]);
              this.state.commentStack = [];
            }
            resetPreviousNodeTrailingComments(t) {
              let { commentStack: r } = this.state, { length: e } = r;
              if (e === 0)
                return;
              let s2 = r[e - 1];
              s2.leadingNode === t && (s2.leadingNode = null);
            }
            takeSurroundingComments(t, r, e) {
              let { commentStack: s2 } = this.state, i = s2.length;
              if (i === 0)
                return;
              let a2 = i - 1;
              for (; a2 >= 0; a2--) {
                let n = s2[a2], o = n.end;
                if (n.start === e)
                  n.leadingNode = t;
                else if (o === r)
                  n.trailingNode = t;
                else if (o < r)
                  break;
              }
            }
          }, as = /\r\n?|[\n\u2028\u2029]/, xt = new RegExp(as.source, "g");
          function Ge(t) {
            switch (t) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;
              default:
                return false;
            }
          }
          var ns = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, wl = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, Ir2 = new RegExp("(?=(" + wl.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
          function Il(t) {
            switch (t) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;
              default:
                return false;
            }
          }
          var Nr2 = class {
            constructor() {
              this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [x2.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
            }
            init(t) {
              let { strictMode: r, sourceType: e, startLine: s2, startColumn: i } = t;
              this.strict = r === false ? false : r === true ? true : e === "module", this.curLine = s2, this.lineStart = -i, this.startLoc = this.endLoc = new ge(s2, i, 0);
            }
            curPosition() {
              return new ge(this.curLine, this.pos - this.lineStart, this.pos);
            }
            clone(t) {
              let r = new Nr2(), e = Object.keys(this);
              for (let s2 = 0, i = e.length; s2 < i; s2++) {
                let a2 = e[s2], n = this[a2];
                !t && Array.isArray(n) && (n = n.slice()), r[a2] = n;
              }
              return r;
            }
          }, Nl = function(r) {
            return r >= 48 && r <= 57;
          }, kr2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, gt = { bin: (t) => t === 48 || t === 49, oct: (t) => t >= 48 && t <= 55, dec: (t) => t >= 48 && t <= 57, hex: (t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 };
          function Dr2(t, r, e, s2, i, a2) {
            let n = e, o = s2, u = i, c2 = "", y = null, g = e, { length: T } = r;
            for (; ; ) {
              if (e >= T) {
                a2.unterminated(n, o, u), c2 += r.slice(g, e);
                break;
              }
              let C = r.charCodeAt(e);
              if (kl(t, C, r, e)) {
                c2 += r.slice(g, e);
                break;
              }
              if (C === 92) {
                c2 += r.slice(g, e);
                let M = Dl(r, e, s2, i, t === "template", a2);
                M.ch === null && !y ? y = { pos: e, lineStart: s2, curLine: i } : c2 += M.ch, { pos: e, lineStart: s2, curLine: i } = M, g = e;
              } else
                C === 8232 || C === 8233 ? (++e, ++i, s2 = e) : C === 10 || C === 13 ? t === "template" ? (c2 += r.slice(g, e) + `
`, ++e, C === 13 && r.charCodeAt(e) === 10 && ++e, ++i, g = s2 = e) : a2.unterminated(n, o, u) : ++e;
            }
            return { pos: e, str: c2, firstInvalidLoc: y, lineStart: s2, curLine: i, containsInvalid: !!y };
          }
          function kl(t, r, e, s2) {
            return t === "template" ? r === 96 || r === 36 && e.charCodeAt(s2 + 1) === 123 : r === (t === "double" ? 34 : 39);
          }
          function Dl(t, r, e, s2, i, a2) {
            let n = !i;
            r++;
            let o = (c2) => ({ pos: r, ch: c2, lineStart: e, curLine: s2 }), u = t.charCodeAt(r++);
            switch (u) {
              case 110:
                return o(`
`);
              case 114:
                return o("\r");
              case 120: {
                let c2;
                return { code: c2, pos: r } = os(t, r, e, s2, 2, false, n, a2), o(c2 === null ? null : String.fromCharCode(c2));
              }
              case 117: {
                let c2;
                return { code: c2, pos: r } = Lr2(t, r, e, s2, n, a2), o(c2 === null ? null : String.fromCodePoint(c2));
              }
              case 116:
                return o("	");
              case 98:
                return o("\b");
              case 118:
                return o("\v");
              case 102:
                return o("\f");
              case 13:
                t.charCodeAt(r) === 10 && ++r;
              case 10:
                e = r, ++s2;
              case 8232:
              case 8233:
                return o("");
              case 56:
              case 57:
                if (i)
                  return o(null);
                a2.strictNumericEscape(r - 1, e, s2);
              default:
                if (u >= 48 && u <= 55) {
                  let c2 = r - 1, g = t.slice(c2, r + 2).match(/^[0-7]+/)[0], T = parseInt(g, 8);
                  T > 255 && (g = g.slice(0, -1), T = parseInt(g, 8)), r += g.length - 1;
                  let C = t.charCodeAt(r);
                  if (g !== "0" || C === 56 || C === 57) {
                    if (i)
                      return o(null);
                    a2.strictNumericEscape(c2, e, s2);
                  }
                  return o(String.fromCharCode(T));
                }
                return o(String.fromCharCode(u));
            }
          }
          function os(t, r, e, s2, i, a2, n, o) {
            let u = r, c2;
            return { n: c2, pos: r } = Fr2(t, r, e, s2, 16, i, a2, false, o, !n), c2 === null && (n ? o.invalidEscapeSequence(u, e, s2) : r = u - 1), { code: c2, pos: r };
          }
          function Fr2(t, r, e, s2, i, a2, n, o, u, c2) {
            let y = r, g = i === 16 ? kr2.hex : kr2.decBinOct, T = i === 16 ? gt.hex : i === 10 ? gt.dec : i === 8 ? gt.oct : gt.bin, C = false, M = 0;
            for (let j = 0, K = a2 == null ? 1 / 0 : a2; j < K; ++j) {
              let W = t.charCodeAt(r), V;
              if (W === 95 && o !== "bail") {
                let X = t.charCodeAt(r - 1), je = t.charCodeAt(r + 1);
                if (o) {
                  if (Number.isNaN(je) || !T(je) || g.has(X) || g.has(je)) {
                    if (c2)
                      return { n: null, pos: r };
                    u.unexpectedNumericSeparator(r, e, s2);
                  }
                } else {
                  if (c2)
                    return { n: null, pos: r };
                  u.numericSeparatorInEscapeSequence(r, e, s2);
                }
                ++r;
                continue;
              }
              if (W >= 97 ? V = W - 97 + 10 : W >= 65 ? V = W - 65 + 10 : Nl(W) ? V = W - 48 : V = 1 / 0, V >= i) {
                if (V <= 9 && c2)
                  return { n: null, pos: r };
                if (V <= 9 && u.invalidDigit(r, e, s2, i))
                  V = 0;
                else if (n)
                  V = 0, C = true;
                else
                  break;
              }
              ++r, M = M * i + V;
            }
            return r === y || a2 != null && r - y !== a2 || C ? { n: null, pos: r } : { n: M, pos: r };
          }
          function Lr2(t, r, e, s2, i, a2) {
            let n = t.charCodeAt(r), o;
            if (n === 123) {
              if (++r, { code: o, pos: r } = os(t, r, e, s2, t.indexOf("}", r) - r, true, i, a2), ++r, o !== null && o > 1114111)
                if (i)
                  a2.invalidCodePoint(r, e, s2);
                else
                  return { code: null, pos: r };
            } else
              ({ code: o, pos: r } = os(t, r, e, s2, 4, false, i, a2));
            return { code: o, pos: r };
          }
          var Fl = ["at"], Ll = ["at"];
          function Je(t, r, e) {
            return new ge(e, t - r, t);
          }
          var Ol = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Ae = class {
            constructor(t) {
              this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new lt2(t.startLoc, t.endLoc);
            }
          }, Bl = class extends Sl {
            constructor(t, r) {
              super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e, s2, i, a2) => this.options.errorRecovery ? (this.raise(f.InvalidDigit, { at: Je(e, s2, i), radix: a2 }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(f.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(f.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(f.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(f.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e, s2, i) => {
                this.recordStrictModeErrors(f.StrictNumericEscape, { at: Je(e, s2, i) });
              }, unterminated: (e, s2, i) => {
                throw this.raise(f.UnterminatedString, { at: Je(e - 1, s2, i) });
              } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(f.StrictNumericEscape), unterminated: (e, s2, i) => {
                throw this.raise(f.UnterminatedTemplate, { at: Je(e, s2, i) });
              } }), this.state = new Nr2(), this.state.init(t), this.input = r, this.length = r.length, this.isLookahead = false;
            }
            pushToken(t) {
              this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
            }
            next() {
              this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ae(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
            }
            eat(t) {
              return this.match(t) ? (this.next(), true) : false;
            }
            match(t) {
              return this.state.type === t;
            }
            createLookaheadState(t) {
              return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
            }
            lookahead() {
              let t = this.state;
              this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
              let r = this.state;
              return this.state = t, r;
            }
            nextTokenStart() {
              return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(t) {
              return ns.lastIndex = t, ns.test(this.input) ? ns.lastIndex : t;
            }
            lookaheadCharCode() {
              return this.input.charCodeAt(this.nextTokenStart());
            }
            codePointAtPos(t) {
              let r = this.input.charCodeAt(t);
              if ((r & 64512) === 55296 && ++t < this.input.length) {
                let e = this.input.charCodeAt(t);
                (e & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (e & 1023));
              }
              return r;
            }
            setStrict(t) {
              this.state.strict = t, t && (this.state.strictErrors.forEach((r) => {
                let [e, s2] = r;
                return this.raise(e, { at: s2 });
              }), this.state.strictErrors.clear());
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                this.finishToken(137);
                return;
              }
              this.getTokenFromCode(this.codePointAtPos(this.state.pos));
            }
            skipBlockComment(t) {
              let r;
              this.isLookahead || (r = this.state.curPosition());
              let e = this.state.pos, s2 = this.input.indexOf(t, e + 2);
              if (s2 === -1)
                throw this.raise(f.UnterminatedComment, { at: this.state.curPosition() });
              for (this.state.pos = s2 + t.length, xt.lastIndex = e + 2; xt.test(this.input) && xt.lastIndex <= s2; )
                ++this.state.curLine, this.state.lineStart = xt.lastIndex;
              if (this.isLookahead)
                return;
              let i = { type: "CommentBlock", value: this.input.slice(e + 2, s2), start: e, end: s2 + t.length, loc: new lt2(r, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(i), i;
            }
            skipLineComment(t) {
              let r = this.state.pos, e;
              this.isLookahead || (e = this.state.curPosition());
              let s2 = this.input.charCodeAt(this.state.pos += t);
              if (this.state.pos < this.length)
                for (; !Ge(s2) && ++this.state.pos < this.length; )
                  s2 = this.input.charCodeAt(this.state.pos);
              if (this.isLookahead)
                return;
              let i = this.state.pos, n = { type: "CommentLine", value: this.input.slice(r + t, i), start: r, end: i, loc: new lt2(e, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(n), n;
            }
            skipSpace() {
              let t = this.state.pos, r = [];
              e:
                for (; this.state.pos < this.length; ) {
                  let e = this.input.charCodeAt(this.state.pos);
                  switch (e) {
                    case 32:
                    case 160:
                    case 9:
                      ++this.state.pos;
                      break;
                    case 13:
                      this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                      ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                      break;
                    case 47:
                      switch (this.input.charCodeAt(this.state.pos + 1)) {
                        case 42: {
                          let s2 = this.skipBlockComment("*/");
                          s2 !== void 0 && (this.addComment(s2), this.options.attachComment && r.push(s2));
                          break;
                        }
                        case 47: {
                          let s2 = this.skipLineComment(2);
                          s2 !== void 0 && (this.addComment(s2), this.options.attachComment && r.push(s2));
                          break;
                        }
                        default:
                          break e;
                      }
                      break;
                    default:
                      if (Il(e))
                        ++this.state.pos;
                      else if (e === 45 && !this.inModule && this.options.annexB) {
                        let s2 = this.state.pos;
                        if (this.input.charCodeAt(s2 + 1) === 45 && this.input.charCodeAt(s2 + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                          let i = this.skipLineComment(3);
                          i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                        } else
                          break e;
                      } else if (e === 60 && !this.inModule && this.options.annexB) {
                        let s2 = this.state.pos;
                        if (this.input.charCodeAt(s2 + 1) === 33 && this.input.charCodeAt(s2 + 2) === 45 && this.input.charCodeAt(s2 + 3) === 45) {
                          let i = this.skipLineComment(4);
                          i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                        } else
                          break e;
                      } else
                        break e;
                  }
                }
              if (r.length > 0) {
                let e = this.state.pos, s2 = { start: t, end: e, comments: r, leadingNode: null, trailingNode: null, containingNode: null };
                this.state.commentStack.push(s2);
              }
            }
            finishToken(t, r) {
              this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
              let e = this.state.type;
              this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(e);
            }
            replaceToken(t) {
              this.state.type = t, this.updateContext();
            }
            readToken_numberSign() {
              if (this.state.pos === 0 && this.readToken_interpreter())
                return;
              let t = this.state.pos + 1, r = this.codePointAtPos(t);
              if (r >= 48 && r <= 57)
                throw this.raise(f.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
              if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                  throw this.raise(r === 123 ? f.RecordExpressionHashIncorrectStartSyntaxType : f.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
                this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
              } else
                fe(r) ? (++this.state.pos, this.finishToken(136, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
            }
            readToken_dot() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t >= 48 && t <= 57) {
                this.readNumber(true);
                return;
              }
              t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
            }
            readToken_slash() {
              this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
            }
            readToken_interpreter() {
              if (this.state.pos !== 0 || this.length < 2)
                return false;
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t !== 33)
                return false;
              let r = this.state.pos;
              for (this.state.pos += 1; !Ge(t) && ++this.state.pos < this.length; )
                t = this.input.charCodeAt(this.state.pos);
              let e = this.input.slice(r + 2, this.state.pos);
              return this.finishToken(28, e), true;
            }
            readToken_mult_modulo(t) {
              let r = t === 42 ? 55 : 54, e = 1, s2 = this.input.charCodeAt(this.state.pos + 1);
              t === 42 && s2 === 42 && (e++, s2 = this.input.charCodeAt(this.state.pos + 2), r = 57), s2 === 61 && !this.state.inType && (e++, r = t === 37 ? 33 : 30), this.finishOp(r, e);
            }
            readToken_pipe_amp(t) {
              let r = this.input.charCodeAt(this.state.pos + 1);
              if (r === t) {
                this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
                return;
              }
              if (t === 124) {
                if (r === 62) {
                  this.finishOp(39, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(f.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(9);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(f.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(4);
                  return;
                }
              }
              if (r === 61) {
                this.finishOp(30, 2);
                return;
              }
              this.finishOp(t === 124 ? 43 : 45, 1);
            }
            readToken_caret() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
            }
            readToken_atSign() {
              this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
            }
            readToken_plus_min(t) {
              let r = this.input.charCodeAt(this.state.pos + 1);
              if (r === t) {
                this.finishOp(34, 2);
                return;
              }
              r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
            }
            readToken_lt() {
              let { pos: t } = this.state, r = this.input.charCodeAt(t + 1);
              if (r === 60) {
                if (this.input.charCodeAt(t + 2) === 61) {
                  this.finishOp(30, 3);
                  return;
                }
                this.finishOp(51, 2);
                return;
              }
              if (r === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(47, 1);
            }
            readToken_gt() {
              let { pos: t } = this.state, r = this.input.charCodeAt(t + 1);
              if (r === 62) {
                let e = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(t + e) === 61) {
                  this.finishOp(30, e + 1);
                  return;
                }
                this.finishOp(52, e);
                return;
              }
              if (r === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(48, 1);
            }
            readToken_eq_excl(t) {
              let r = this.input.charCodeAt(this.state.pos + 1);
              if (r === 61) {
                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
              }
              if (t === 61 && r === 62) {
                this.state.pos += 2, this.finishToken(19);
                return;
              }
              this.finishOp(t === 61 ? 29 : 35, 1);
            }
            readToken_question() {
              let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
              t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
            }
            getTokenFromCode(t) {
              switch (t) {
                case 46:
                  this.readToken_dot();
                  return;
                case 40:
                  ++this.state.pos, this.finishToken(10);
                  return;
                case 41:
                  ++this.state.pos, this.finishToken(11);
                  return;
                case 59:
                  ++this.state.pos, this.finishToken(13);
                  return;
                case 44:
                  ++this.state.pos, this.finishToken(12);
                  return;
                case 91:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(f.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(2);
                  } else
                    ++this.state.pos, this.finishToken(0);
                  return;
                case 93:
                  ++this.state.pos, this.finishToken(3);
                  return;
                case 123:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(f.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(6);
                  } else
                    ++this.state.pos, this.finishToken(5);
                  return;
                case 125:
                  ++this.state.pos, this.finishToken(8);
                  return;
                case 58:
                  this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                  return;
                case 63:
                  this.readToken_question();
                  return;
                case 96:
                  this.readTemplateToken();
                  return;
                case 48: {
                  let r = this.input.charCodeAt(this.state.pos + 1);
                  if (r === 120 || r === 88) {
                    this.readRadixNumber(16);
                    return;
                  }
                  if (r === 111 || r === 79) {
                    this.readRadixNumber(8);
                    return;
                  }
                  if (r === 98 || r === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;
                case 34:
                case 39:
                  this.readString(t);
                  return;
                case 47:
                  this.readToken_slash();
                  return;
                case 37:
                case 42:
                  this.readToken_mult_modulo(t);
                  return;
                case 124:
                case 38:
                  this.readToken_pipe_amp(t);
                  return;
                case 94:
                  this.readToken_caret();
                  return;
                case 43:
                case 45:
                  this.readToken_plus_min(t);
                  return;
                case 60:
                  this.readToken_lt();
                  return;
                case 62:
                  this.readToken_gt();
                  return;
                case 61:
                case 33:
                  this.readToken_eq_excl(t);
                  return;
                case 126:
                  this.finishOp(36, 1);
                  return;
                case 64:
                  this.readToken_atSign();
                  return;
                case 35:
                  this.readToken_numberSign();
                  return;
                case 92:
                  this.readWord();
                  return;
                default:
                  if (fe(t)) {
                    this.readWord(t);
                    return;
                  }
              }
              throw this.raise(f.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t) });
            }
            finishOp(t, r) {
              let e = this.input.slice(this.state.pos, this.state.pos + r);
              this.state.pos += r, this.finishToken(t, e);
            }
            readRegexp() {
              let t = this.state.startLoc, r = this.state.start + 1, e, s2, { pos: i } = this.state;
              for (; ; ++i) {
                if (i >= this.length)
                  throw this.raise(f.UnterminatedRegExp, { at: Y(t, 1) });
                let u = this.input.charCodeAt(i);
                if (Ge(u))
                  throw this.raise(f.UnterminatedRegExp, { at: Y(t, 1) });
                if (e)
                  e = false;
                else {
                  if (u === 91)
                    s2 = true;
                  else if (u === 93 && s2)
                    s2 = false;
                  else if (u === 47 && !s2)
                    break;
                  e = u === 92;
                }
              }
              let a2 = this.input.slice(r, i);
              ++i;
              let n = "", o = () => Y(t, i + 2 - r);
              for (; i < this.length; ) {
                let u = this.codePointAtPos(i), c2 = String.fromCharCode(u);
                if (Ol.has(u))
                  u === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(f.IncompatibleRegExpUVFlags, { at: o() })) : u === 117 && n.includes("v") && this.raise(f.IncompatibleRegExpUVFlags, { at: o() }), n.includes(c2) && this.raise(f.DuplicateRegExpFlags, { at: o() });
                else if (De(u) || u === 92)
                  this.raise(f.MalformedRegExpFlags, { at: o() });
                else
                  break;
                ++i, n += c2;
              }
              this.state.pos = i, this.finishToken(135, { pattern: a2, flags: n });
            }
            readInt(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { n: i, pos: a2 } = Fr2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, e, s2, this.errorHandlers_readInt, false);
              return this.state.pos = a2, i;
            }
            readRadixNumber(t) {
              let r = this.state.curPosition(), e = false;
              this.state.pos += 2;
              let s2 = this.readInt(t);
              s2 == null && this.raise(f.InvalidDigit, { at: Y(r, 2), radix: t });
              let i = this.input.charCodeAt(this.state.pos);
              if (i === 110)
                ++this.state.pos, e = true;
              else if (i === 109)
                throw this.raise(f.InvalidDecimal, { at: r });
              if (fe(this.codePointAtPos(this.state.pos)))
                throw this.raise(f.NumberIdentifier, { at: this.state.curPosition() });
              if (e) {
                let a2 = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(133, a2);
                return;
              }
              this.finishToken(132, s2);
            }
            readNumber(t) {
              let r = this.state.pos, e = this.state.curPosition(), s2 = false, i = false, a2 = false, n = false, o = false;
              !t && this.readInt(10) === null && this.raise(f.InvalidNumber, { at: this.state.curPosition() });
              let u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
              if (u) {
                let T = this.input.slice(r, this.state.pos);
                if (this.recordStrictModeErrors(f.StrictOctalLiteral, { at: e }), !this.state.strict) {
                  let C = T.indexOf("_");
                  C > 0 && this.raise(f.ZeroDigitNumericSeparator, { at: Y(e, C) });
                }
                o = u && !/[89]/.test(T);
              }
              let c2 = this.input.charCodeAt(this.state.pos);
              if (c2 === 46 && !o && (++this.state.pos, this.readInt(10), s2 = true, c2 = this.input.charCodeAt(this.state.pos)), (c2 === 69 || c2 === 101) && !o && (c2 = this.input.charCodeAt(++this.state.pos), (c2 === 43 || c2 === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(f.InvalidOrMissingExponent, { at: e }), s2 = true, n = true, c2 = this.input.charCodeAt(this.state.pos)), c2 === 110 && ((s2 || u) && this.raise(f.InvalidBigIntLiteral, { at: e }), ++this.state.pos, i = true), c2 === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || u) && this.raise(f.InvalidDecimal, { at: e }), ++this.state.pos, a2 = true), fe(this.codePointAtPos(this.state.pos)))
                throw this.raise(f.NumberIdentifier, { at: this.state.curPosition() });
              let y = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
              if (i) {
                this.finishToken(133, y);
                return;
              }
              if (a2) {
                this.finishToken(134, y);
                return;
              }
              let g = o ? parseInt(y, 8) : parseFloat(y);
              this.finishToken(132, g);
            }
            readCodePoint(t) {
              let { code: r, pos: e } = Lr2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
              return this.state.pos = e, r;
            }
            readString(t) {
              let { str: r, pos: e, curLine: s2, lineStart: i } = Dr2(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
              this.state.pos = e + 1, this.state.lineStart = i, this.state.curLine = s2, this.finishToken(131, r);
            }
            readTemplateContinuation() {
              this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
            }
            readTemplateToken() {
              let t = this.input[this.state.pos], { str: r, firstInvalidLoc: e, pos: s2, curLine: i, lineStart: a2 } = Dr2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
              this.state.pos = s2 + 1, this.state.lineStart = a2, this.state.curLine = i, e && (this.state.firstInvalidTemplateEscapePos = new ge(e.curLine, e.pos - e.lineStart, e.pos)), this.input.codePointAt(s2) === 96 ? this.finishToken(24, e ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, e ? null : t + r + "${"));
            }
            recordStrictModeErrors(t, r) {
              let { at: e } = r, s2 = e.index;
              this.state.strict && !this.state.strictErrors.has(s2) ? this.raise(t, { at: e }) : this.state.strictErrors.set(s2, [t, e]);
            }
            readWord1(t) {
              this.state.containsEsc = false;
              let r = "", e = this.state.pos, s2 = this.state.pos;
              for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                let i = this.codePointAtPos(this.state.pos);
                if (De(i))
                  this.state.pos += i <= 65535 ? 1 : 2;
                else if (i === 92) {
                  this.state.containsEsc = true, r += this.input.slice(s2, this.state.pos);
                  let a2 = this.state.curPosition(), n = this.state.pos === e ? fe : De;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(f.MissingUnicodeEscape, { at: this.state.curPosition() }), s2 = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  let o = this.readCodePoint(true);
                  o !== null && (n(o) || this.raise(f.EscapedCharNotAnIdentifier, { at: a2 }), r += String.fromCodePoint(o)), s2 = this.state.pos;
                } else
                  break;
              }
              return r + this.input.slice(s2, this.state.pos);
            }
            readWord(t) {
              let r = this.readWord1(t), e = L.get(r);
              e !== void 0 ? this.finishToken(e, xe(e)) : this.finishToken(130, r);
            }
            checkKeywordEscapes() {
              let { type: t } = this.state;
              $t2(t) && this.state.containsEsc && this.raise(f.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: xe(t) });
            }
            raise(t, r) {
              let { at: e } = r, s2 = ot2(r, Fl), i = e instanceof ge ? e : e.loc.start, a2 = t({ loc: i, details: s2 });
              if (!this.options.errorRecovery)
                throw a2;
              return this.isLookahead || this.state.errors.push(a2), a2;
            }
            raiseOverwrite(t, r) {
              let { at: e } = r, s2 = ot2(r, Ll), i = e instanceof ge ? e : e.loc.start, a2 = i.index, n = this.state.errors;
              for (let o = n.length - 1; o >= 0; o--) {
                let u = n[o];
                if (u.loc.index === a2)
                  return n[o] = t({ loc: i, details: s2 });
                if (u.loc.index < a2)
                  break;
              }
              return this.raise(t, r);
            }
            updateContext(t) {
            }
            unexpected(t, r) {
              throw this.raise(f.UnexpectedToken, { expected: r ? xe(r) : null, at: t != null ? t : this.state.startLoc });
            }
            expectPlugin(t, r) {
              if (this.hasPlugin(t))
                return true;
              throw this.raise(f.MissingPlugin, { at: r != null ? r : this.state.startLoc, missingPlugin: [t] });
            }
            expectOnePlugin(t) {
              if (!t.some((r) => this.hasPlugin(r)))
                throw this.raise(f.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t });
            }
            errorBuilder(t) {
              return (r, e, s2) => {
                this.raise(t, { at: Je(r, e, s2) });
              };
            }
          }, Ml = class {
            constructor() {
              this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
            }
          }, _l = class {
            constructor(t) {
              this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
            }
            current() {
              return this.stack[this.stack.length - 1];
            }
            enter() {
              this.stack.push(new Ml());
            }
            exit() {
              let t = this.stack.pop(), r = this.current();
              for (let [e, s2] of Array.from(t.undefinedPrivateNames))
                r ? r.undefinedPrivateNames.has(e) || r.undefinedPrivateNames.set(e, s2) : this.parser.raise(f.InvalidPrivateFieldResolution, { at: s2, identifierName: e });
            }
            declarePrivateName(t, r, e) {
              let { privateNames: s2, loneAccessors: i, undefinedPrivateNames: a2 } = this.current(), n = s2.has(t);
              if (r & ts2) {
                let o = n && i.get(t);
                if (o) {
                  let u = o & yt2, c2 = r & yt2, y = o & ts2, g = r & ts2;
                  n = y === g || u !== c2, n || i.delete(t);
                } else
                  n || i.set(t, r);
              }
              n && this.parser.raise(f.PrivateNameRedeclaration, { at: e, identifierName: t }), s2.add(t), a2.delete(t);
            }
            usePrivateName(t, r) {
              let e;
              for (e of this.stack)
                if (e.privateNames.has(t))
                  return;
              e ? e.undefinedPrivateNames.set(t, r) : this.parser.raise(f.InvalidPrivateFieldResolution, { at: r, identifierName: t });
            }
          }, Rl = 0, Or2 = 1, ls = 2, Br2 = 3, Pt = class {
            constructor() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Rl;
              this.type = void 0, this.type = t;
            }
            canBeArrowParameterDeclaration() {
              return this.type === ls || this.type === Or2;
            }
            isCertainlyParameterDeclaration() {
              return this.type === Br2;
            }
          }, Mr = class extends Pt {
            constructor(t) {
              super(t), this.declarationErrors = /* @__PURE__ */ new Map();
            }
            recordDeclarationError(t, r) {
              let { at: e } = r, s2 = e.index;
              this.declarationErrors.set(s2, [t, e]);
            }
            clearDeclarationError(t) {
              this.declarationErrors.delete(t);
            }
            iterateErrors(t) {
              this.declarationErrors.forEach(t);
            }
          }, jl = class {
            constructor(t) {
              this.parser = void 0, this.stack = [new Pt()], this.parser = t;
            }
            enter(t) {
              this.stack.push(t);
            }
            exit() {
              this.stack.pop();
            }
            recordParameterInitializerError(t, r) {
              let { at: e } = r, s2 = { at: e.loc.start }, { stack: i } = this, a2 = i.length - 1, n = i[a2];
              for (; !n.isCertainlyParameterDeclaration(); ) {
                if (n.canBeArrowParameterDeclaration())
                  n.recordDeclarationError(t, s2);
                else
                  return;
                n = i[--a2];
              }
              this.parser.raise(t, s2);
            }
            recordArrowParameterBindingError(t, r) {
              let { at: e } = r, { stack: s2 } = this, i = s2[s2.length - 1], a2 = { at: e.loc.start };
              if (i.isCertainlyParameterDeclaration())
                this.parser.raise(t, a2);
              else if (i.canBeArrowParameterDeclaration())
                i.recordDeclarationError(t, a2);
              else
                return;
            }
            recordAsyncArrowParametersError(t) {
              let { at: r } = t, { stack: e } = this, s2 = e.length - 1, i = e[s2];
              for (; i.canBeArrowParameterDeclaration(); )
                i.type === ls && i.recordDeclarationError(f.AwaitBindingIdentifier, { at: r }), i = e[--s2];
            }
            validateAsPattern() {
              let { stack: t } = this, r = t[t.length - 1];
              r.canBeArrowParameterDeclaration() && r.iterateErrors((e) => {
                let [s2, i] = e;
                this.parser.raise(s2, { at: i });
                let a2 = t.length - 2, n = t[a2];
                for (; n.canBeArrowParameterDeclaration(); )
                  n.clearDeclarationError(i.index), n = t[--a2];
              });
            }
          };
          function ql() {
            return new Pt(Br2);
          }
          function Ul() {
            return new Mr(Or2);
          }
          function $l() {
            return new Mr(ls);
          }
          function _r2() {
            return new Pt();
          }
          var Me = 0, Rr = 1, At2 = 2, jr2 = 4, _e = 8, Hl = class {
            constructor() {
              this.stacks = [];
            }
            enter(t) {
              this.stacks.push(t);
            }
            exit() {
              this.stacks.pop();
            }
            currentFlags() {
              return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
              return (this.currentFlags() & At2) > 0;
            }
            get hasYield() {
              return (this.currentFlags() & Rr) > 0;
            }
            get hasReturn() {
              return (this.currentFlags() & jr2) > 0;
            }
            get hasIn() {
              return (this.currentFlags() & _e) > 0;
            }
          };
          function Tt2(t, r) {
            return (t ? At2 : 0) | (r ? Rr : 0);
          }
          var zl = class extends Bl {
            addExtra(t, r, e) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!t)
                return;
              let i = t.extra = t.extra || {};
              s2 ? i[r] = e : Object.defineProperty(i, r, { enumerable: s2, value: e });
            }
            isContextual(t) {
              return this.state.type === t && !this.state.containsEsc;
            }
            isUnparsedContextual(t, r) {
              let e = t + r.length;
              if (this.input.slice(t, e) === r) {
                let s2 = this.input.charCodeAt(e);
                return !(De(s2) || (s2 & 64512) === 55296);
              }
              return false;
            }
            isLookaheadContextual(t) {
              let r = this.nextTokenStart();
              return this.isUnparsedContextual(r, t);
            }
            eatContextual(t) {
              return this.isContextual(t) ? (this.next(), true) : false;
            }
            expectContextual(t, r) {
              if (!this.eatContextual(t)) {
                if (r != null)
                  throw this.raise(r, { at: this.state.startLoc });
                this.unexpected(null, t);
              }
            }
            canInsertSemicolon() {
              return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
            }
            hasPrecedingLineBreak() {
              return as.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
            }
            hasFollowingLineBreak() {
              return Ir2.lastIndex = this.state.end, Ir2.test(this.input);
            }
            isLineTerminator() {
              return this.eat(13) || this.canInsertSemicolon();
            }
            semicolon() {
              ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(f.MissingSemicolon, { at: this.state.lastTokEndLoc });
            }
            expect(t, r) {
              this.eat(t) || this.unexpected(r, t);
            }
            tryParse(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), e = { node: null };
              try {
                let s2 = t(function() {
                  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  throw e.node = i, e;
                });
                if (this.state.errors.length > r.errors.length) {
                  let i = this.state;
                  return this.state = r, this.state.tokensLength = i.tokensLength, { node: s2, error: i.errors[r.errors.length], thrown: false, aborted: false, failState: i };
                }
                return { node: s2, error: null, thrown: false, aborted: false, failState: null };
              } catch (s2) {
                let i = this.state;
                if (this.state = r, s2 instanceof SyntaxError)
                  return { node: null, error: s2, thrown: true, aborted: false, failState: i };
                if (s2 === e)
                  return { node: e.node, error: null, thrown: false, aborted: true, failState: i };
                throw s2;
              }
            }
            checkExpressionErrors(t, r) {
              if (!t)
                return false;
              let { shorthandAssignLoc: e, doubleProtoLoc: s2, privateKeyLoc: i, optionalParametersLoc: a2 } = t, n = !!e || !!s2 || !!a2 || !!i;
              if (!r)
                return n;
              e != null && this.raise(f.InvalidCoverInitializedName, { at: e }), s2 != null && this.raise(f.DuplicateProto, { at: s2 }), i != null && this.raise(f.UnexpectedPrivateField, { at: i }), a2 != null && this.unexpected(a2);
            }
            isLiteralPropertyName() {
              return it(this.state.type);
            }
            isPrivateName(t) {
              return t.type === "PrivateName";
            }
            getPrivateNameSV(t) {
              return t.id.name;
            }
            hasPropertyAsPrivateName(t) {
              return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
            }
            isObjectProperty(t) {
              return t.type === "ObjectProperty";
            }
            isObjectMethod(t) {
              return t.type === "ObjectMethod";
            }
            initializeScopes() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", r = this.state.labels;
              this.state.labels = [];
              let e = this.exportedIdentifiers;
              this.exportedIdentifiers = /* @__PURE__ */ new Set();
              let s2 = this.inModule;
              this.inModule = t;
              let i = this.scope, a2 = this.getScopeHandler();
              this.scope = new a2(this, t);
              let n = this.prodParam;
              this.prodParam = new Hl();
              let o = this.classScope;
              this.classScope = new _l(this);
              let u = this.expressionScope;
              return this.expressionScope = new jl(this), () => {
                this.state.labels = r, this.exportedIdentifiers = e, this.inModule = s2, this.scope = i, this.prodParam = n, this.classScope = o, this.expressionScope = u;
              };
            }
            enterInitialScopes() {
              let t = Me;
              this.inModule && (t |= At2), this.scope.enter(Le), this.prodParam.enter(t);
            }
            checkDestructuringPrivate(t) {
              let { privateKeyLoc: r } = t;
              r !== null && this.expectPlugin("destructuringPrivate", r);
            }
          }, vt2 = class {
            constructor() {
              this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
            }
          }, Et2 = class {
            constructor(t, r, e) {
              this.type = "", this.start = r, this.end = 0, this.loc = new lt2(e), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
            }
          }, hs = Et2.prototype;
          hs.__clone = function() {
            let t = new Et2(void 0, this.start, this.loc.start), r = Object.keys(this);
            for (let e = 0, s2 = r.length; e < s2; e++) {
              let i = r[e];
              i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
            }
            return t;
          };
          function Vl(t) {
            return me(t);
          }
          function me(t) {
            let { type: r, start: e, end: s2, loc: i, range: a2, extra: n, name: o } = t, u = Object.create(hs);
            return u.type = r, u.start = e, u.end = s2, u.loc = i, u.range = a2, u.extra = n, u.name = o, r === "Placeholder" && (u.expectedNode = t.expectedNode), u;
          }
          function Kl(t) {
            let { type: r, start: e, end: s2, loc: i, range: a2, extra: n } = t;
            if (r === "Placeholder")
              return Vl(t);
            let o = Object.create(hs);
            return o.type = r, o.start = e, o.end = s2, o.loc = i, o.range = a2, t.raw !== void 0 ? o.raw = t.raw : o.extra = n, o.value = t.value, o;
          }
          var Wl = class extends zl {
            startNode() {
              return new Et2(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(t) {
              return new Et2(this, t.index, t);
            }
            startNodeAtNode(t) {
              return this.startNodeAt(t.loc.start);
            }
            finishNode(t, r) {
              return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
            }
            finishNodeAt(t, r, e) {
              return t.type = r, t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index), this.options.attachComment && this.processComment(t), t;
            }
            resetStartLocation(t, r) {
              t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
            }
            resetEndLocation(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
            }
            resetStartLocationFromNode(t, r) {
              this.resetStartLocation(t, r.loc.start);
            }
          }, Gl = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), D = pe`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (t) => {
            let { reservedType: r } = t;
            return `Cannot overwrite reserved type ${r}.`;
          }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (t) => {
            let { memberName: r, enumName: e } = t;
            return `Boolean enum members need to be initialized. Use either \`${r} = true,\` or \`${r} = false,\` in enum \`${e}\`.`;
          }, EnumDuplicateMemberName: (t) => {
            let { memberName: r, enumName: e } = t;
            return `Enum member names need to be unique, but the name \`${r}\` has already been used before in enum \`${e}\`.`;
          }, EnumInconsistentMemberValues: (t) => {
            let { enumName: r } = t;
            return `Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
          }, EnumInvalidExplicitType: (t) => {
            let { invalidEnumType: r, enumName: e } = t;
            return `Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`;
          }, EnumInvalidExplicitTypeUnknownSupplied: (t) => {
            let { enumName: r } = t;
            return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`;
          }, EnumInvalidMemberInitializerPrimaryType: (t) => {
            let { enumName: r, memberName: e, explicitType: s2 } = t;
            return `Enum \`${r}\` has type \`${s2}\`, so the initializer of \`${e}\` needs to be a ${s2} literal.`;
          }, EnumInvalidMemberInitializerSymbolType: (t) => {
            let { enumName: r, memberName: e } = t;
            return `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r}\`.`;
          }, EnumInvalidMemberInitializerUnknownType: (t) => {
            let { enumName: r, memberName: e } = t;
            return `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r}\`.`;
          }, EnumInvalidMemberName: (t) => {
            let { enumName: r, memberName: e, suggestion: s2 } = t;
            return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s2}\`, in enum \`${r}\`.`;
          }, EnumNumberMemberNotInitialized: (t) => {
            let { enumName: r, memberName: e } = t;
            return `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r}\`.`;
          }, EnumStringMemberInconsistentlyInitailized: (t) => {
            let { enumName: r } = t;
            return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r}\`.`;
          }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (t) => {
            let { reservedType: r } = t;
            return `Unexpected reserved type ${r}.`;
          }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (t) => {
            let { unsupportedExportKind: r, suggestion: e } = t;
            return `\`declare export ${r}\` is not supported. Use \`${e}\` instead.`;
          }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
          function Jl(t) {
            return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "TypeAlias" && t.declaration.type !== "InterfaceDeclaration");
          }
          function us(t) {
            return t.importKind === "type" || t.importKind === "typeof";
          }
          function qr(t) {
            return te2(t) && t !== 97;
          }
          var Xl = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
          function Yl(t, r) {
            let e = [], s2 = [];
            for (let i = 0; i < t.length; i++)
              (r(t[i], i, t) ? e : s2).push(t[i]);
            return [e, s2];
          }
          var Ql = /\*?\s*@((?:no)?flow)\b/, Zl = (t) => class extends t {
            constructor() {
              super(...arguments), this.flowPragma = void 0;
            }
            getScopeHandler() {
              return El;
            }
            shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
            shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
            finishToken(e, s2) {
              e !== 131 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s2);
            }
            addComment(e) {
              if (this.flowPragma === void 0) {
                let s2 = Ql.exec(e.value);
                if (s2)
                  if (s2[1] === "flow")
                    this.flowPragma = "flow";
                  else if (s2[1] === "noflow")
                    this.flowPragma = "noflow";
                  else
                    throw new Error("Unexpected flow pragma");
              }
              super.addComment(e);
            }
            flowParseTypeInitialiser(e) {
              let s2 = this.state.inType;
              this.state.inType = true, this.expect(e || 14);
              let i = this.flowParseType();
              return this.state.inType = s2, i;
            }
            flowParsePredicate() {
              let e = this.startNode(), s2 = this.state.startLoc;
              return this.next(), this.expectContextual(108), this.state.lastTokStart > s2.index + 1 && this.raise(D.UnexpectedSpaceBetweenModuloChecks, { at: s2 }), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
            }
            flowParseTypeAndPredicateInitialiser() {
              let e = this.state.inType;
              this.state.inType = true, this.expect(14);
              let s2 = null, i = null;
              return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s2 = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s2, i];
            }
            flowParseDeclareClass(e) {
              return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
            }
            flowParseDeclareFunction(e) {
              this.next();
              let s2 = e.id = this.parseIdentifier(), i = this.startNode(), a2 = this.startNode();
              this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
              let n = this.flowParseFunctionTypeParams();
              return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), a2.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s2.typeAnnotation = this.finishNode(a2, "TypeAnnotation"), this.resetEndLocation(s2), this.semicolon(), this.scope.declareName(e.id.name, xl, e.id.loc.start), this.finishNode(e, "DeclareFunction");
            }
            flowParseDeclare(e, s2) {
              if (this.match(80))
                return this.flowParseDeclareClass(e);
              if (this.match(68))
                return this.flowParseDeclareFunction(e);
              if (this.match(74))
                return this.flowParseDeclareVariable(e);
              if (this.eatContextual(125))
                return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s2 && this.raise(D.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
              if (this.isContextual(128))
                return this.flowParseDeclareTypeAlias(e);
              if (this.isContextual(129))
                return this.flowParseDeclareOpaqueType(e);
              if (this.isContextual(127))
                return this.flowParseDeclareInterface(e);
              if (this.match(82))
                return this.flowParseDeclareExportDeclaration(e, s2);
              this.unexpected();
            }
            flowParseDeclareVariable(e) {
              return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, mt2, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
            }
            flowParseDeclareModule(e) {
              this.scope.enter(Fe), this.match(131) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
              let s2 = e.body = this.startNode(), i = s2.body = [];
              for (this.expect(5); !this.match(8); ) {
                let o = this.startNode();
                this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(D.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(o)) : (this.expectContextual(123, D.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
              }
              this.scope.exit(), this.expect(8), this.finishNode(s2, "BlockStatement");
              let a2 = null, n = false;
              return i.forEach((o) => {
                Jl(o) ? (a2 === "CommonJS" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a2 = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(D.DuplicateDeclareModuleExports, { at: o }), a2 === "ES" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a2 = "CommonJS", n = true);
              }), e.kind = a2 || "CommonJS", this.finishNode(e, "DeclareModule");
            }
            flowParseDeclareExportDeclaration(e, s2) {
              if (this.expect(82), this.eat(65))
                return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !s2) {
                let i = this.state.value;
                throw this.raise(D.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: i, suggestion: Xl[i] });
              }
              if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
                return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129))
                return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
              this.unexpected();
            }
            flowParseDeclareModuleExports(e) {
              return this.next(), this.expectContextual(109), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
            }
            flowParseDeclareTypeAlias(e) {
              this.next();
              let s2 = this.flowParseTypeAlias(e);
              return s2.type = "DeclareTypeAlias", s2;
            }
            flowParseDeclareOpaqueType(e) {
              this.next();
              let s2 = this.flowParseOpaqueType(e, true);
              return s2.type = "DeclareOpaqueType", s2;
            }
            flowParseDeclareInterface(e) {
              return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
            }
            flowParseInterfaceish(e, s2) {
              if (e.id = this.flowParseRestrictedIdentifier(!s2, true), this.scope.declareName(e.id.name, s2 ? Er : Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
                do
                  e.extends.push(this.flowParseInterfaceExtends());
                while (!s2 && this.eat(12));
              if (s2) {
                if (this.eatContextual(115))
                  do
                    e.mixins.push(this.flowParseInterfaceExtends());
                  while (this.eat(12));
                if (this.eatContextual(111))
                  do
                    e.implements.push(this.flowParseInterfaceExtends());
                  while (this.eat(12));
              }
              e.body = this.flowParseObjectType({ allowStatic: s2, allowExact: false, allowSpread: false, allowProto: s2, allowInexact: false });
            }
            flowParseInterfaceExtends() {
              let e = this.startNode();
              return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
            }
            flowParseInterface(e) {
              return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
            }
            checkNotUnderscore(e) {
              e === "_" && this.raise(D.UnexpectedReservedUnderscore, { at: this.state.startLoc });
            }
            checkReservedType(e, s2, i) {
              Gl.has(e) && this.raise(i ? D.AssignReservedType : D.UnexpectedReservedType, { at: s2, reservedType: e });
            }
            flowParseRestrictedIdentifier(e, s2) {
              return this.checkReservedType(this.state.value, this.state.startLoc, s2), this.parseIdentifier(e);
            }
            flowParseTypeAlias(e) {
              return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
            }
            flowParseOpaqueType(e, s2) {
              return this.expectContextual(128), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, Be, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s2 || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
            }
            flowParseTypeParameter() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s2 = this.state.startLoc, i = this.startNode(), a2 = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
              return i.name = n.name, i.variance = a2, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(D.MissingTypeParamDefault, { at: s2 }), this.finishNode(i, "TypeParameter");
            }
            flowParseTypeParameterDeclaration() {
              let e = this.state.inType, s2 = this.startNode();
              s2.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i = false;
              do {
                let a2 = this.flowParseTypeParameter(i);
                s2.params.push(a2), a2.default && (i = true), this.match(48) || this.expect(12);
              } while (!this.match(48));
              return this.expect(48), this.state.inType = e, this.finishNode(s2, "TypeParameterDeclaration");
            }
            flowParseTypeParameterInstantiation() {
              let e = this.startNode(), s2 = this.state.inType;
              e.params = [], this.state.inType = true, this.expect(47);
              let i = this.state.noAnonFunctionType;
              for (this.state.noAnonFunctionType = false; !this.match(48); )
                e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
              return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s2, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseTypeParameterInstantiationCallOrNew() {
              let e = this.startNode(), s2 = this.state.inType;
              for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
                e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
              return this.expect(48), this.state.inType = s2, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseInterfaceType() {
              let e = this.startNode();
              if (this.expectContextual(127), e.extends = [], this.eat(81))
                do
                  e.extends.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
            }
            flowParseObjectPropertyKey() {
              return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
            }
            flowParseObjectTypeIndexer(e, s2, i) {
              return e.static = s2, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
            }
            flowParseObjectTypeInternalSlot(e, s2) {
              return e.static = s2, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
            }
            flowParseObjectTypeMethodish(e) {
              for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
            }
            flowParseObjectTypeCallProperty(e, s2) {
              let i = this.startNode();
              return e.static = s2, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
            }
            flowParseObjectType(e) {
              let { allowStatic: s2, allowExact: i, allowSpread: a2, allowProto: n, allowInexact: o } = e, u = this.state.inType;
              this.state.inType = true;
              let c2 = this.startNode();
              c2.callProperties = [], c2.properties = [], c2.indexers = [], c2.internalSlots = [];
              let y, g, T = false;
              for (i && this.match(6) ? (this.expect(6), y = 9, g = true) : (this.expect(5), y = 8, g = false), c2.exact = g; !this.match(y); ) {
                let M = false, j = null, K = null, W = this.startNode();
                if (n && this.isContextual(116)) {
                  let X = this.lookahead();
                  X.type !== 14 && X.type !== 17 && (this.next(), j = this.state.startLoc, s2 = false);
                }
                if (s2 && this.isContextual(104)) {
                  let X = this.lookahead();
                  X.type !== 14 && X.type !== 17 && (this.next(), M = true);
                }
                let V = this.flowParseVariance();
                if (this.eat(0))
                  j != null && this.unexpected(j), this.eat(0) ? (V && this.unexpected(V.loc.start), c2.internalSlots.push(this.flowParseObjectTypeInternalSlot(W, M))) : c2.indexers.push(this.flowParseObjectTypeIndexer(W, M, V));
                else if (this.match(10) || this.match(47))
                  j != null && this.unexpected(j), V && this.unexpected(V.loc.start), c2.callProperties.push(this.flowParseObjectTypeCallProperty(W, M));
                else {
                  let X = "init";
                  if (this.isContextual(98) || this.isContextual(103)) {
                    let Nh = this.lookahead();
                    it(Nh.type) && (X = this.state.value, this.next());
                  }
                  let je = this.flowParseObjectTypeProperty(W, M, j, V, X, a2, o != null ? o : !g);
                  je === null ? (T = true, K = this.state.lastTokStartLoc) : c2.properties.push(je);
                }
                this.flowObjectTypeSemicolon(), K && !this.match(8) && !this.match(9) && this.raise(D.UnexpectedExplicitInexactInObject, { at: K });
              }
              this.expect(y), a2 && (c2.inexact = T);
              let C = this.finishNode(c2, "ObjectTypeAnnotation");
              return this.state.inType = u, C;
            }
            flowParseObjectTypeProperty(e, s2, i, a2, n, o, u) {
              if (this.eat(21))
                return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(D.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(D.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), a2 && this.raise(D.InexactVariance, { at: a2 }), null) : (o || this.raise(D.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), i != null && this.unexpected(i), a2 && this.raise(D.SpreadVariance, { at: a2 }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
              {
                e.key = this.flowParseObjectPropertyKey(), e.static = s2, e.proto = i != null, e.kind = n;
                let c2 = false;
                return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), a2 && this.unexpected(a2.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(D.ThisParamBannedInConstructor, { at: e.value.this })) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c2 = true), e.value = this.flowParseTypeInitialiser(), e.variance = a2), e.optional = c2, this.finishNode(e, "ObjectTypeProperty");
              }
            }
            flowCheckGetterSetterParams(e) {
              let s2 = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
              e.value.this && this.raise(e.kind === "get" ? D.GetterMayNotHaveThisParam : D.SetterMayNotHaveThisParam, { at: e.value.this }), i !== s2 && this.raise(e.kind === "get" ? f.BadGetterArity : f.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(f.BadSetterRestParameter, { at: e });
            }
            flowObjectTypeSemicolon() {
              !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
            }
            flowParseQualifiedTypeIdentifier(e, s2) {
              e != null || (e = this.state.startLoc);
              let a2 = s2 || this.flowParseRestrictedIdentifier(true);
              for (; this.eat(16); ) {
                let n = this.startNodeAt(e);
                n.qualification = a2, n.id = this.flowParseRestrictedIdentifier(true), a2 = this.finishNode(n, "QualifiedTypeIdentifier");
              }
              return a2;
            }
            flowParseGenericType(e, s2) {
              let i = this.startNodeAt(e);
              return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s2), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
            }
            flowParseTypeofType() {
              let e = this.startNode();
              return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
            }
            flowParseTupleType() {
              let e = this.startNode();
              for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
                this.expect(12);
              return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
            }
            flowParseFunctionTypeParam(e) {
              let s2 = null, i = false, a2 = null, n = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
              return o.type === 14 || o.type === 17 ? (u && !e && this.raise(D.ThisParamMustBeFirst, { at: n }), s2 = this.parseIdentifier(u), this.eat(17) && (i = true, u && this.raise(D.ThisParamMayNotBeOptional, { at: n })), a2 = this.flowParseTypeInitialiser()) : a2 = this.flowParseType(), n.name = s2, n.optional = i, n.typeAnnotation = a2, this.finishNode(n, "FunctionTypeParam");
            }
            reinterpretTypeAsFunctionTypeParam(e) {
              let s2 = this.startNodeAt(e.loc.start);
              return s2.name = null, s2.optional = false, s2.typeAnnotation = e, this.finishNode(s2, "FunctionTypeParam");
            }
            flowParseFunctionTypeParams() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s2 = null, i = null;
              for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (s2 = this.flowParseFunctionTypeParam(false)), { params: e, rest: s2, _this: i };
            }
            flowIdentToTypeAnnotation(e, s2, i) {
              switch (i.name) {
                case "any":
                  return this.finishNode(s2, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(s2, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(s2, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(s2, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(s2, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(s2, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(s2, "SymbolTypeAnnotation");
                default:
                  return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
              }
            }
            flowParsePrimaryType() {
              let e = this.state.startLoc, s2 = this.startNode(), i, a2, n = false, o = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case 5:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                case 6:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                case 0:
                  return this.state.noAnonFunctionType = false, a2 = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a2;
                case 47:
                  return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s2.params = i.params, s2.rest = i.rest, s2.this = i._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
                case 10:
                  if (this.next(), !this.match(11) && !this.match(21))
                    if (q2(this.state.type) || this.match(78)) {
                      let u = this.lookahead().type;
                      n = u !== 17 && u !== 14;
                    } else
                      n = true;
                  if (n) {
                    if (this.state.noAnonFunctionType = false, a2 = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                      return this.expect(11), a2;
                    this.eat(12);
                  }
                  return a2 ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a2)]) : i = this.flowParseFunctionTypeParams(), s2.params = i.params, s2.rest = i.rest, s2.this = i._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
                case 131:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                  return s2.value = this.match(85), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
                case 53:
                  if (this.state.value === "-") {
                    if (this.next(), this.match(132))
                      return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
                    if (this.match(133))
                      return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
                    throw this.raise(D.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                  }
                  this.unexpected();
                  return;
                case 132:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 133:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                  return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
                case 84:
                  return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
                case 78:
                  return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
                case 55:
                  return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
                case 87:
                  return this.flowParseTypeofType();
                default:
                  if ($t2(this.state.type)) {
                    let u = xe(this.state.type);
                    return this.next(), super.createIdentifier(s2, u);
                  } else if (q2(this.state.type))
                    return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s2, this.parseIdentifier());
              }
              this.unexpected();
            }
            flowParsePostfixType() {
              let e = this.state.startLoc, s2 = this.flowParsePrimaryType(), i = false;
              for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                let a2 = this.startNodeAt(e), n = this.eat(18);
                i = i || n, this.expect(0), !n && this.match(3) ? (a2.elementType = s2, this.next(), s2 = this.finishNode(a2, "ArrayTypeAnnotation")) : (a2.objectType = s2, a2.indexType = this.flowParseType(), this.expect(3), i ? (a2.optional = n, s2 = this.finishNode(a2, "OptionalIndexedAccessType")) : s2 = this.finishNode(a2, "IndexedAccessType"));
              }
              return s2;
            }
            flowParsePrefixType() {
              let e = this.startNode();
              return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
            }
            flowParseAnonFunctionWithoutParens() {
              let e = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(19)) {
                let s2 = this.startNodeAt(e.loc.start);
                return s2.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s2.rest = null, s2.this = null, s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
              }
              return e;
            }
            flowParseIntersectionType() {
              let e = this.startNode();
              this.eat(45);
              let s2 = this.flowParseAnonFunctionWithoutParens();
              for (e.types = [s2]; this.eat(45); )
                e.types.push(this.flowParseAnonFunctionWithoutParens());
              return e.types.length === 1 ? s2 : this.finishNode(e, "IntersectionTypeAnnotation");
            }
            flowParseUnionType() {
              let e = this.startNode();
              this.eat(43);
              let s2 = this.flowParseIntersectionType();
              for (e.types = [s2]; this.eat(43); )
                e.types.push(this.flowParseIntersectionType());
              return e.types.length === 1 ? s2 : this.finishNode(e, "UnionTypeAnnotation");
            }
            flowParseType() {
              let e = this.state.inType;
              this.state.inType = true;
              let s2 = this.flowParseUnionType();
              return this.state.inType = e, s2;
            }
            flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === 130 && this.state.value === "_") {
                let e = this.state.startLoc, s2 = this.parseIdentifier();
                return this.flowParseGenericType(e, s2);
              } else
                return this.flowParseType();
            }
            flowParseTypeAnnotation() {
              let e = this.startNode();
              return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
            }
            flowParseTypeAnnotatableIdentifier(e) {
              let s2 = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              return this.match(14) && (s2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s2)), s2;
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            flowParseVariance() {
              let e = null;
              return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
            }
            parseFunctionBody(e, s2) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (s2) {
                this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
                return;
              }
              super.parseFunctionBody(e, false, i);
            }
            parseFunctionBodyAndFinish(e, s2) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                let a2 = this.startNode();
                [a2.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = a2.typeAnnotation ? this.finishNode(a2, "TypeAnnotation") : null;
              }
              return super.parseFunctionBodyAndFinish(e, s2, i);
            }
            parseStatementLike(e) {
              if (this.state.strict && this.isContextual(127)) {
                let i = this.lookahead();
                if (te2(i.type)) {
                  let a2 = this.startNode();
                  return this.next(), this.flowParseInterface(a2);
                }
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                let i = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(i);
              }
              let s2 = super.parseStatementLike(e);
              return this.flowPragma === void 0 && !this.isValidDirective(s2) && (this.flowPragma = null), s2;
            }
            parseExpressionStatement(e, s2, i) {
              if (s2.type === "Identifier") {
                if (s2.name === "declare") {
                  if (this.match(80) || q2(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                    return this.flowParseDeclare(e);
                } else if (q2(this.state.type)) {
                  if (s2.name === "interface")
                    return this.flowParseInterface(e);
                  if (s2.name === "type")
                    return this.flowParseTypeAlias(e);
                  if (s2.name === "opaque")
                    return this.flowParseOpaqueType(e, false);
                }
              }
              return super.parseExpressionStatement(e, s2, i);
            }
            shouldParseExportDeclaration() {
              let { type: e } = this.state;
              return hr2(e) || this.shouldParseEnums() && e === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
            }
            isExportDefaultSpecifier() {
              let { type: e } = this.state;
              return hr2(e) || this.shouldParseEnums() && e === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
            }
            parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual(124)) {
                let e = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(e);
              }
              return super.parseExportDefaultExpression();
            }
            parseConditional(e, s2, i) {
              if (!this.match(17))
                return e;
              if (this.state.maybeInArrowParameters) {
                let T = this.lookaheadCharCode();
                if (T === 44 || T === 61 || T === 58 || T === 41)
                  return this.setOptionalParametersError(i), e;
              }
              this.expect(17);
              let a2 = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s2), { consequent: u, failed: c2 } = this.tryParseConditionalConsequent(), [y, g] = this.getArrowLikeExpressions(u);
              if (c2 || g.length > 0) {
                let T = [...n];
                if (g.length > 0) {
                  this.state = a2, this.state.noArrowAt = T;
                  for (let C = 0; C < g.length; C++)
                    T.push(g[C].start);
                  ({ consequent: u, failed: c2 } = this.tryParseConditionalConsequent()), [y, g] = this.getArrowLikeExpressions(u);
                }
                c2 && y.length > 1 && this.raise(D.AmbiguousConditionalArrow, { at: a2.startLoc }), c2 && y.length === 1 && (this.state = a2, T.push(y[0].start), this.state.noArrowAt = T, { consequent: u, failed: c2 } = this.tryParseConditionalConsequent());
              }
              return this.getArrowLikeExpressions(u, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
            }
            tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              let e = this.parseMaybeAssignAllowIn(), s2 = !this.match(14);
              return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s2 };
            }
            getArrowLikeExpressions(e, s2) {
              let i = [e], a2 = [];
              for (; i.length !== 0; ) {
                let n = i.pop();
                n.type === "ArrowFunctionExpression" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : a2.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
              }
              return s2 ? (a2.forEach((n) => this.finishArrowValidation(n)), [a2, []]) : Yl(a2, (n) => n.params.every((o) => this.isAssignable(o, true)));
            }
            finishArrowValidation(e) {
              var s2;
              this.toAssignableList(e.params, (s2 = e.extra) == null ? void 0 : s2.trailingCommaLoc, false), this.scope.enter(de | Gt2), super.checkParams(e, false, true), this.scope.exit();
            }
            forwardNoArrowParamsConversionAt(e, s2) {
              let i;
              return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s2(), this.state.noArrowParamsConversionAt.pop()) : i = s2(), i;
            }
            parseParenItem(e, s2) {
              if (e = super.parseParenItem(e, s2), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s2);
                return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
              }
              return e;
            }
            assertModuleNodeAllowed(e) {
              e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
            }
            parseExport(e, s2) {
              let i = super.parseExport(e, s2);
              return (i.type === "ExportNamedDeclaration" || i.type === "ExportAllDeclaration") && (i.exportKind = i.exportKind || "value"), i;
            }
            parseExportDeclaration(e) {
              if (this.isContextual(128)) {
                e.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s2);
              } else if (this.isContextual(129)) {
                e.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.flowParseOpaqueType(s2, false);
              } else if (this.isContextual(127)) {
                e.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.flowParseInterface(s2);
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                e.exportKind = "value";
                let s2 = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(s2);
              } else
                return super.parseExportDeclaration(e);
            }
            eatExportStar(e) {
              return super.eatExportStar(e) ? true : this.isContextual(128) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
            }
            maybeParseExportNamespaceSpecifier(e) {
              let { startLoc: s2 } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
              return i && e.exportKind === "type" && this.unexpected(s2), i;
            }
            parseClassId(e, s2, i) {
              super.parseClassId(e, s2, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
            }
            parseClassMember(e, s2, i) {
              let { startLoc: a2 } = this.state;
              if (this.isContextual(123)) {
                if (super.parseClassMemberFromModifier(e, s2))
                  return;
                s2.declare = true;
              }
              super.parseClassMember(e, s2, i), s2.declare && (s2.type !== "ClassProperty" && s2.type !== "ClassPrivateProperty" && s2.type !== "PropertyDefinition" ? this.raise(D.DeclareClassElement, { at: a2 }) : s2.value && this.raise(D.DeclareClassFieldInitializer, { at: s2.value }));
            }
            isIterator(e) {
              return e === "iterator" || e === "asyncIterator";
            }
            readIterator() {
              let e = super.readWord1(), s2 = "@@" + e;
              (!this.isIterator(e) || !this.state.inType) && this.raise(f.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s2 }), this.finishToken(130, s2);
            }
            getTokenFromCode(e) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              e === 123 && s2 === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : ll(e, s2, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
            }
            isAssignable(e, s2) {
              return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s2) : super.isAssignable(e, s2);
            }
            toAssignable(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              !s2 && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s2);
            }
            toAssignableList(e, s2, i) {
              for (let a2 = 0; a2 < e.length; a2++) {
                let n = e[a2];
                (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[a2] = this.typeCastToParameter(n));
              }
              super.toAssignableList(e, s2, i);
            }
            toReferencedList(e, s2) {
              for (let a2 = 0; a2 < e.length; a2++) {
                var i;
                let n = e[a2];
                n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s2) && this.raise(D.TypeCastInPattern, { at: n.typeAnnotation });
              }
              return e;
            }
            parseArrayLike(e, s2, i, a2) {
              let n = super.parseArrayLike(e, s2, i, a2);
              return s2 && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
            }
            isValidLVal(e, s2, i) {
              return e === "TypeCastExpression" || super.isValidLVal(e, s2, i);
            }
            parseClassProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(14) || super.isClassProperty();
            }
            isNonstaticConstructor(e) {
              return !this.match(14) && super.isNonstaticConstructor(e);
            }
            pushClassMethod(e, s2, i, a2, n, o) {
              if (s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s2, i, a2, n, o), s2.params && n) {
                let u = s2.params;
                u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s2 });
              } else if (s2.type === "MethodDefinition" && n && s2.value.params) {
                let u = s2.value.params;
                u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s2 });
              }
            }
            pushClassPrivateMethod(e, s2, i, a2) {
              s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s2, i, a2);
            }
            parseClassSuper(e) {
              if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
                this.next();
                let s2 = e.implements = [];
                do {
                  let i = this.startNode();
                  i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s2.push(this.finishNode(i, "ClassImplements"));
                } while (this.eat(12));
              }
            }
            checkGetterSetterParams(e) {
              super.checkGetterSetterParams(e);
              let s2 = this.getObjectOrClassMethodParams(e);
              if (s2.length > 0) {
                let i = s2[0];
                this.isThisParam(i) && e.kind === "get" ? this.raise(D.GetterMayNotHaveThisParam, { at: i }) : this.isThisParam(i) && this.raise(D.SetterMayNotHaveThisParam, { at: i });
              }
            }
            parsePropertyNamePrefixOperator(e) {
              e.variance = this.flowParseVariance();
            }
            parseObjPropValue(e, s2, i, a2, n, o, u) {
              e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
              let c2;
              this.match(47) && !o && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
              let y = super.parseObjPropValue(e, s2, i, a2, n, o, u);
              return c2 && ((y.value || y).typeParameters = c2), y;
            }
            parseAssignableListItemTypes(e) {
              return this.eat(17) && (e.type !== "Identifier" && this.raise(D.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(D.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(D.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(D.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
            }
            parseMaybeDefault(e, s2) {
              let i = super.parseMaybeDefault(e, s2);
              return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(D.TypeBeforeInitializer, { at: i.typeAnnotation }), i;
            }
            shouldParseDefaultImport(e) {
              return us(e) ? qr(this.state.type) : super.shouldParseDefaultImport(e);
            }
            checkImportReflection(e) {
              super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(D.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
            }
            parseImportSpecifierLocal(e, s2, i) {
              s2.local = us(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s2, i));
            }
            maybeParseDefaultImportSpecifier(e) {
              e.importKind = "value";
              let s2 = null;
              if (this.match(87) ? s2 = "typeof" : this.isContextual(128) && (s2 = "type"), s2) {
                let i = this.lookahead(), { type: a2 } = i;
                s2 === "type" && a2 === 55 && this.unexpected(null, i.type), (qr(a2) || a2 === 5 || a2 === 55) && (this.next(), e.importKind = s2);
              }
              return super.maybeParseDefaultImportSpecifier(e);
            }
            parseImportSpecifier(e, s2, i, a2, n) {
              let o = e.imported, u = null;
              o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
              let c2 = false;
              if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                let g = this.parseIdentifier(true);
                u !== null && !te2(this.state.type) ? (e.imported = g, e.importKind = u, e.local = me(g)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
              } else {
                if (u !== null && te2(this.state.type))
                  e.imported = this.parseIdentifier(true), e.importKind = u;
                else {
                  if (s2)
                    throw this.raise(f.ImportBindingIsString, { at: e, importName: o.value });
                  e.imported = o, e.importKind = null;
                }
                this.eatContextual(93) ? e.local = this.parseIdentifier() : (c2 = true, e.local = me(e.imported));
              }
              let y = us(e);
              return i && y && this.raise(D.ImportTypeShorthandOnlyInPureImport, { at: e }), (i || y) && this.checkReservedType(e.local.name, e.local.loc.start, true), c2 && !i && !y && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseFunctionParams(e, s2) {
              let i = e.kind;
              i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s2);
            }
            parseVarId(e, s2) {
              super.parseVarId(e, s2), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s2) {
              if (this.match(14)) {
                let i = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
              }
              return super.parseAsyncArrowFromCallExpression(e, s2);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            parseMaybeAssign(e, s2) {
              var i;
              let a2 = null, n;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (a2 = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s2), a2), !n.error)
                  return n.node;
                let { context: c2 } = this.state, y = c2[c2.length - 1];
                (y === x2.j_oTag || y === x2.j_expr) && c2.pop();
              }
              if ((i = n) != null && i.error || this.match(47)) {
                var o, u;
                a2 = a2 || this.state.clone();
                let c2, y = this.tryParse((T) => {
                  var C;
                  c2 = this.flowParseTypeParameterDeclaration();
                  let M = this.forwardNoArrowParamsConversionAt(c2, () => {
                    let K = super.parseMaybeAssign(e, s2);
                    return this.resetStartLocationFromNode(K, c2), K;
                  });
                  (C = M.extra) != null && C.parenthesized && T();
                  let j = this.maybeUnwrapTypeCastExpression(M);
                  return j.type !== "ArrowFunctionExpression" && T(), j.typeParameters = c2, this.resetStartLocationFromNode(j, c2), M;
                }, a2), g = null;
                if (y.node && this.maybeUnwrapTypeCastExpression(y.node).type === "ArrowFunctionExpression") {
                  if (!y.error && !y.aborted)
                    return y.node.async && this.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: c2 }), y.node;
                  g = y.node;
                }
                if ((o = n) != null && o.node)
                  return this.state = n.failState, n.node;
                if (g)
                  return this.state = y.failState, g;
                throw (u = n) != null && u.thrown ? n.error : y.thrown ? y.error : this.raise(D.UnexpectedTokenAfterTypeParameter, { at: c2 });
              }
              return super.parseMaybeAssign(e, s2);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s2 = this.tryParse(() => {
                  let i = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  let a2 = this.startNode();
                  return [a2.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), a2;
                });
                if (s2.thrown)
                  return null;
                s2.error && (this.state = s2.failState), e.returnType = s2.node.typeAnnotation ? this.finishNode(s2.node, "TypeAnnotation") : null;
              }
              return super.parseArrow(e);
            }
            shouldParseArrow(e) {
              return this.match(14) || super.shouldParseArrow(e);
            }
            setArrowFunctionParameters(e, s2) {
              this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s2 : super.setArrowFunctionParameters(e, s2);
            }
            checkParams(e, s2, i) {
              let a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
                for (let n = 0; n < e.params.length; n++)
                  this.isThisParam(e.params[n]) && n > 0 && this.raise(D.ThisParamMustBeFirst, { at: e.params[n] });
                super.checkParams(e, s2, i, a2);
              }
            }
            parseParenAndDistinguishExpression(e) {
              return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
            parseSubscripts(e, s2, i) {
              if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s2.index) !== -1) {
                this.next();
                let a2 = this.startNodeAt(s2);
                a2.callee = e, a2.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(a2, "CallExpression");
              } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
                let a2 = this.state.clone(), n = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s2) || u(), a2);
                if (!n.error && !n.aborted)
                  return n.node;
                let o = this.tryParse(() => super.parseSubscripts(e, s2, i), a2);
                if (o.node && !o.error)
                  return o.node;
                if (n.node)
                  return this.state = n.failState, n.node;
                if (o.node)
                  return this.state = o.failState, o.node;
                throw n.error || o.error;
              }
              return super.parseSubscripts(e, s2, i);
            }
            parseSubscript(e, s2, i, a2) {
              if (this.match(18) && this.isLookaheadToken_lt()) {
                if (a2.optionalChainMember = true, i)
                  return a2.stop = true, e;
                this.next();
                let n = this.startNodeAt(s2);
                return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
              } else if (!i && this.shouldParseTypes() && this.match(47)) {
                let n = this.startNodeAt(s2);
                n.callee = e;
                let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), a2.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a2.optionalChainMember)));
                if (o.node)
                  return o.error && (this.state = o.failState), o.node;
              }
              return super.parseSubscript(e, s2, i, a2);
            }
            parseNewCallee(e) {
              super.parseNewCallee(e);
              let s2 = null;
              this.shouldParseTypes() && this.match(47) && (s2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s2;
            }
            parseAsyncArrowWithTypeParameters(e) {
              let s2 = this.startNodeAt(e);
              if (this.parseFunctionParams(s2, false), !!this.parseArrow(s2))
                return super.parseArrowExpression(s2, void 0, true);
            }
            readToken_mult_modulo(e) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              if (e === 42 && s2 === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
                return;
              }
              super.readToken_mult_modulo(e);
            }
            readToken_pipe_amp(e) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              if (e === 124 && s2 === 125) {
                this.finishOp(9, 2);
                return;
              }
              super.readToken_pipe_amp(e);
            }
            parseTopLevel(e, s2) {
              let i = super.parseTopLevel(e, s2);
              return this.state.hasFlowComment && this.raise(D.UnterminatedFlowComment, { at: this.state.curPosition() }), i;
            }
            skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment)
                  throw this.raise(D.NestedFlowComment, { at: this.state.startLoc });
                this.hasFlowCommentCompletion();
                let e = this.skipFlowComment();
                e && (this.state.pos += e, this.state.hasFlowComment = true);
                return;
              }
              return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            }
            skipFlowComment() {
              let { pos: e } = this.state, s2 = 2;
              for (; [32, 9].includes(this.input.charCodeAt(e + s2)); )
                s2++;
              let i = this.input.charCodeAt(s2 + e), a2 = this.input.charCodeAt(s2 + e + 1);
              return i === 58 && a2 === 58 ? s2 + 2 : this.input.slice(s2 + e, s2 + e + 12) === "flow-include" ? s2 + 12 : i === 58 && a2 !== 58 ? s2 : false;
            }
            hasFlowCommentCompletion() {
              if (this.input.indexOf("*/", this.state.pos) === -1)
                throw this.raise(f.UnterminatedComment, { at: this.state.curPosition() });
            }
            flowEnumErrorBooleanMemberNotInitialized(e, s2) {
              let { enumName: i, memberName: a2 } = s2;
              this.raise(D.EnumBooleanMemberNotInitialized, { at: e, memberName: a2, enumName: i });
            }
            flowEnumErrorInvalidMemberInitializer(e, s2) {
              return this.raise(s2.explicitType ? s2.explicitType === "symbol" ? D.EnumInvalidMemberInitializerSymbolType : D.EnumInvalidMemberInitializerPrimaryType : D.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s2));
            }
            flowEnumErrorNumberMemberNotInitialized(e, s2) {
              let { enumName: i, memberName: a2 } = s2;
              this.raise(D.EnumNumberMemberNotInitialized, { at: e, enumName: i, memberName: a2 });
            }
            flowEnumErrorStringMemberInconsistentlyInitailized(e, s2) {
              let { enumName: i } = s2;
              this.raise(D.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: i });
            }
            flowEnumMemberInit() {
              let e = this.state.startLoc, s2 = () => this.match(12) || this.match(8);
              switch (this.state.type) {
                case 132: {
                  let i = this.parseNumericLiteral(this.state.value);
                  return s2() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                case 131: {
                  let i = this.parseStringLiteral(this.state.value);
                  return s2() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                case 85:
                case 86: {
                  let i = this.parseBooleanLiteral(this.match(85));
                  return s2() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
                }
                default:
                  return { type: "invalid", loc: e };
              }
            }
            flowEnumMemberRaw() {
              let e = this.state.startLoc, s2 = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
              return { id: s2, init: i };
            }
            flowEnumCheckExplicitTypeMismatch(e, s2, i) {
              let { explicitType: a2 } = s2;
              a2 !== null && a2 !== i && this.flowEnumErrorInvalidMemberInitializer(e, s2);
            }
            flowEnumMembers(e) {
              let { enumName: s2, explicitType: i } = e, a2 = /* @__PURE__ */ new Set(), n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, o = false;
              for (; !this.match(8); ) {
                if (this.eat(21)) {
                  o = true;
                  break;
                }
                let u = this.startNode(), { id: c2, init: y } = this.flowEnumMemberRaw(), g = c2.name;
                if (g === "")
                  continue;
                /^[a-z]/.test(g) && this.raise(D.EnumInvalidMemberName, { at: c2, memberName: g, suggestion: g[0].toUpperCase() + g.slice(1), enumName: s2 }), a2.has(g) && this.raise(D.EnumDuplicateMemberName, { at: c2, memberName: g, enumName: s2 }), a2.add(g);
                let T = { enumName: s2, explicitType: i, memberName: g };
                switch (u.id = c2, y.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "boolean"), u.init = y.value, n.booleanMembers.push(this.finishNode(u, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "number"), u.init = y.value, n.numberMembers.push(this.finishNode(u, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(y.loc, T, "string"), u.init = y.value, n.stringMembers.push(this.finishNode(u, "EnumStringMember"));
                    break;
                  }
                  case "invalid":
                    throw this.flowEnumErrorInvalidMemberInitializer(y.loc, T);
                  case "none":
                    switch (i) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(y.loc, T);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(y.loc, T);
                        break;
                      default:
                        n.defaultedMembers.push(this.finishNode(u, "EnumDefaultedMember"));
                    }
                }
                this.match(8) || this.expect(12);
              }
              return { members: n, hasUnknownMembers: o };
            }
            flowEnumStringMembers(e, s2, i) {
              let { enumName: a2 } = i;
              if (e.length === 0)
                return s2;
              if (s2.length === 0)
                return e;
              if (s2.length > e.length) {
                for (let n of e)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a2 });
                return s2;
              } else {
                for (let n of s2)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a2 });
                return e;
              }
            }
            flowEnumParseExplicitType(e) {
              let { enumName: s2 } = e;
              if (!this.eatContextual(101))
                return null;
              if (!q2(this.state.type))
                throw this.raise(D.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s2 });
              let { value: i } = this.state;
              return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(D.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s2, invalidEnumType: i }), i;
            }
            flowEnumBody(e, s2) {
              let i = s2.name, a2 = s2.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
              this.expect(5);
              let { members: o, hasUnknownMembers: u } = this.flowEnumMembers({ enumName: i, explicitType: n });
              switch (e.hasUnknownMembers = u, n) {
                case "boolean":
                  return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                case "number":
                  return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                case "string":
                  return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                case "symbol":
                  return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
                default: {
                  let c2 = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                  e.explicitType = false;
                  let y = o.booleanMembers.length, g = o.numberMembers.length, T = o.stringMembers.length, C = o.defaultedMembers.length;
                  if (!y && !g && !T && !C)
                    return c2();
                  if (!y && !g)
                    return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                  if (!g && !T && y >= C) {
                    for (let M of o.defaultedMembers)
                      this.flowEnumErrorBooleanMemberNotInitialized(M.loc.start, { enumName: i, memberName: M.id.name });
                    return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                  } else if (!y && !T && g >= C) {
                    for (let M of o.defaultedMembers)
                      this.flowEnumErrorNumberMemberNotInitialized(M.loc.start, { enumName: i, memberName: M.id.name });
                    return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                  } else
                    return this.raise(D.EnumInconsistentMemberValues, { at: a2, enumName: i }), c2();
                }
              }
            }
            flowParseEnumDeclaration(e) {
              let s2 = this.parseIdentifier();
              return e.id = s2, e.body = this.flowEnumBody(this.startNode(), s2), this.finishNode(e, "EnumDeclaration");
            }
            isLookaheadToken_lt() {
              let e = this.nextTokenStart();
              if (this.input.charCodeAt(e) === 60) {
                let s2 = this.input.charCodeAt(e + 1);
                return s2 !== 60 && s2 !== 61;
              }
              return false;
            }
            maybeUnwrapTypeCastExpression(e) {
              return e.type === "TypeCastExpression" ? e.expression : e;
            }
          }, eh = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "Â ", iexcl: "Â¡", cent: "Â¢", pound: "Â£", curren: "Â¤", yen: "Â¥", brvbar: "Â¦", sect: "Â§", uml: "Â¨", copy: "Â©", ordf: "Âª", laquo: "Â«", not: "Â¬", shy: "Â­", reg: "Â®", macr: "Â¯", deg: "Â°", plusmn: "Â±", sup2: "Â²", sup3: "Â³", acute: "Â´", micro: "Âµ", para: "Â¶", middot: "Â·", cedil: "Â¸", sup1: "Â¹", ordm: "Âº", raquo: "Â»", frac14: "Â¼", frac12: "Â½", frac34: "Â¾", iquest: "Â¿", Agrave: "Ã", Aacute: "Ã", Acirc: "Ã", Atilde: "Ã", Auml: "Ã", Aring: "Ã", AElig: "Ã", Ccedil: "Ã", Egrave: "Ã", Eacute: "Ã", Ecirc: "Ã", Euml: "Ã", Igrave: "Ã", Iacute: "Ã", Icirc: "Ã", Iuml: "Ã", ETH: "Ã", Ntilde: "Ã", Ograve: "Ã", Oacute: "Ã", Ocirc: "Ã", Otilde: "Ã", Ouml: "Ã", times: "Ã", Oslash: "Ã", Ugrave: "Ã", Uacute: "Ã", Ucirc: "Ã", Uuml: "Ã", Yacute: "Ã", THORN: "Ã", szlig: "Ã", agrave: "Ã ", aacute: "Ã¡", acirc: "Ã¢", atilde: "Ã£", auml: "Ã¤", aring: "Ã¥", aelig: "Ã¦", ccedil: "Ã§", egrave: "Ã¨", eacute: "Ã©", ecirc: "Ãª", euml: "Ã«", igrave: "Ã¬", iacute: "Ã­", icirc: "Ã®", iuml: "Ã¯", eth: "Ã°", ntilde: "Ã±", ograve: "Ã²", oacute: "Ã³", ocirc: "Ã´", otilde: "Ãµ", ouml: "Ã¶", divide: "Ã·", oslash: "Ã¸", ugrave: "Ã¹", uacute: "Ãº", ucirc: "Ã»", uuml: "Ã¼", yacute: "Ã½", thorn: "Ã¾", yuml: "Ã¿", OElig: "Å", oelig: "Å", Scaron: "Å ", scaron: "Å¡", Yuml: "Å¸", fnof: "Æ", circ: "Ë", tilde: "Ë", Alpha: "Î", Beta: "Î", Gamma: "Î", Delta: "Î", Epsilon: "Î", Zeta: "Î", Eta: "Î", Theta: "Î", Iota: "Î", Kappa: "Î", Lambda: "Î", Mu: "Î", Nu: "Î", Xi: "Î", Omicron: "Î", Pi: "Î ", Rho: "Î¡", Sigma: "Î£", Tau: "Î¤", Upsilon: "Î¥", Phi: "Î¦", Chi: "Î§", Psi: "Î¨", Omega: "Î©", alpha: "Î±", beta: "Î²", gamma: "Î³", delta: "Î´", epsilon: "Îµ", zeta: "Î¶", eta: "Î·", theta: "Î¸", iota: "Î¹", kappa: "Îº", lambda: "Î»", mu: "Î¼", nu: "Î½", xi: "Î¾", omicron: "Î¿", pi: "Ï", rho: "Ï", sigmaf: "Ï", sigma: "Ï", tau: "Ï", upsilon: "Ï", phi: "Ï", chi: "Ï", psi: "Ï", omega: "Ï", thetasym: "Ï", upsih: "Ï", piv: "Ï", ensp: "â", emsp: "â", thinsp: "â", zwnj: "â", zwj: "â", lrm: "â", rlm: "â", ndash: "â", mdash: "â", lsquo: "â", rsquo: "â", sbquo: "â", ldquo: "â", rdquo: "â", bdquo: "â", dagger: "â ", Dagger: "â¡", bull: "â¢", hellip: "â¦", permil: "â°", prime: "â²", Prime: "â³", lsaquo: "â¹", rsaquo: "âº", oline: "â¾", frasl: "â", euro: "â¬", image: "â", weierp: "â", real: "â", trade: "â¢", alefsym: "âµ", larr: "â", uarr: "â", rarr: "â", darr: "â", harr: "â", crarr: "âµ", lArr: "â", uArr: "â", rArr: "â", dArr: "â", hArr: "â", forall: "â", part: "â", exist: "â", empty: "â", nabla: "â", isin: "â", notin: "â", ni: "â", prod: "â", sum: "â", minus: "â", lowast: "â", radic: "â", prop: "â", infin: "â", ang: "â ", and: "â§", or: "â¨", cap: "â©", cup: "âª", int: "â«", there4: "â´", sim: "â¼", cong: "â", asymp: "â", ne: "â ", equiv: "â¡", le: "â¤", ge: "â¥", sub: "â", sup: "â", nsub: "â", sube: "â", supe: "â", oplus: "â", otimes: "â", perp: "â¥", sdot: "â", lceil: "â", rceil: "â", lfloor: "â", rfloor: "â", lang: "â©", rang: "âª", loz: "â", spades: "â ", clubs: "â£", hearts: "â¥", diams: "â¦" }, Se = pe`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (t) => {
            let { openingTagName: r } = t;
            return `Expected corresponding JSX closing tag for <${r}>.`;
          }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (t) => {
            let { unexpected: r, HTMLEntity: e } = t;
            return `Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{'${r}'}\`?`;
          }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
          function Te2(t) {
            return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : false;
          }
          function Re(t) {
            if (t.type === "JSXIdentifier")
              return t.name;
            if (t.type === "JSXNamespacedName")
              return t.namespace.name + ":" + t.name.name;
            if (t.type === "JSXMemberExpression")
              return Re(t.object) + "." + Re(t.property);
            throw new Error("Node had unexpected type: " + t.type);
          }
          var th = (t) => class extends t {
            jsxReadToken() {
              let e = "", s2 = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(Se.UnterminatedJsxContent, { at: this.state.startLoc });
                let i = this.input.charCodeAt(this.state.pos);
                switch (i) {
                  case 60:
                  case 123:
                    if (this.state.pos === this.state.start) {
                      i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(i);
                      return;
                    }
                    e += this.input.slice(s2, this.state.pos), this.finishToken(139, e);
                    return;
                  case 38:
                    e += this.input.slice(s2, this.state.pos), e += this.jsxReadEntity(), s2 = this.state.pos;
                    break;
                  case 62:
                  case 125:
                  default:
                    Ge(i) ? (e += this.input.slice(s2, this.state.pos), e += this.jsxReadNewLine(true), s2 = this.state.pos) : ++this.state.pos;
                }
              }
            }
            jsxReadNewLine(e) {
              let s2 = this.input.charCodeAt(this.state.pos), i;
              return ++this.state.pos, s2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s2), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
            }
            jsxReadString(e) {
              let s2 = "", i = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(f.UnterminatedString, { at: this.state.startLoc });
                let a2 = this.input.charCodeAt(this.state.pos);
                if (a2 === e)
                  break;
                a2 === 38 ? (s2 += this.input.slice(i, this.state.pos), s2 += this.jsxReadEntity(), i = this.state.pos) : Ge(a2) ? (s2 += this.input.slice(i, this.state.pos), s2 += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
              }
              s2 += this.input.slice(i, this.state.pos++), this.finishToken(131, s2);
            }
            jsxReadEntity() {
              let e = ++this.state.pos;
              if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let s2 = 10;
                this.codePointAtPos(this.state.pos) === 120 && (s2 = 16, ++this.state.pos);
                let i = this.readInt(s2, void 0, false, "bail");
                if (i !== null && this.codePointAtPos(this.state.pos) === 59)
                  return ++this.state.pos, String.fromCodePoint(i);
              } else {
                let s2 = 0, i = false;
                for (; s2++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
                  ++this.state.pos;
                if (i) {
                  let a2 = this.input.slice(e, this.state.pos), n = eh[a2];
                  if (++this.state.pos, n)
                    return n;
                }
              }
              return this.state.pos = e, "&";
            }
            jsxReadWord() {
              let e, s2 = this.state.pos;
              do
                e = this.input.charCodeAt(++this.state.pos);
              while (De(e) || e === 45);
              this.finishToken(138, this.input.slice(s2, this.state.pos));
            }
            jsxParseIdentifier() {
              let e = this.startNode();
              return this.match(138) ? e.name = this.state.value : $t2(this.state.type) ? e.name = xe(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
            }
            jsxParseNamespacedName() {
              let e = this.state.startLoc, s2 = this.jsxParseIdentifier();
              if (!this.eat(14))
                return s2;
              let i = this.startNodeAt(e);
              return i.namespace = s2, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
            }
            jsxParseElementName() {
              let e = this.state.startLoc, s2 = this.jsxParseNamespacedName();
              if (s2.type === "JSXNamespacedName")
                return s2;
              for (; this.eat(16); ) {
                let i = this.startNodeAt(e);
                i.object = s2, i.property = this.jsxParseIdentifier(), s2 = this.finishNode(i, "JSXMemberExpression");
              }
              return s2;
            }
            jsxParseAttributeValue() {
              let e;
              switch (this.state.type) {
                case 5:
                  return e = this.startNode(), this.setContext(x2.brace), this.next(), e = this.jsxParseExpressionContainer(e, x2.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Se.AttributeIsEmpty, { at: e }), e;
                case 140:
                case 131:
                  return this.parseExprAtom();
                default:
                  throw this.raise(Se.UnsupportedJsxValue, { at: this.state.startLoc });
              }
            }
            jsxParseEmptyExpression() {
              let e = this.startNodeAt(this.state.lastTokEndLoc);
              return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
            }
            jsxParseSpreadChild(e) {
              return this.next(), e.expression = this.parseExpression(), this.setContext(x2.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
            }
            jsxParseExpressionContainer(e, s2) {
              if (this.match(8))
                e.expression = this.jsxParseEmptyExpression();
              else {
                let i = this.parseExpression();
                e.expression = i;
              }
              return this.setContext(s2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
            }
            jsxParseAttribute() {
              let e = this.startNode();
              return this.match(5) ? (this.setContext(x2.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(x2.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
            }
            jsxParseOpeningElementAt(e) {
              let s2 = this.startNodeAt(e);
              return this.eat(141) ? this.finishNode(s2, "JSXOpeningFragment") : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
            }
            jsxParseOpeningElementAfterName(e) {
              let s2 = [];
              for (; !this.match(56) && !this.match(141); )
                s2.push(this.jsxParseAttribute());
              return e.attributes = s2, e.selfClosing = this.eat(56), this.expect(141), this.finishNode(e, "JSXOpeningElement");
            }
            jsxParseClosingElementAt(e) {
              let s2 = this.startNodeAt(e);
              return this.eat(141) ? this.finishNode(s2, "JSXClosingFragment") : (s2.name = this.jsxParseElementName(), this.expect(141), this.finishNode(s2, "JSXClosingElement"));
            }
            jsxParseElementAt(e) {
              let s2 = this.startNodeAt(e), i = [], a2 = this.jsxParseOpeningElementAt(e), n = null;
              if (!a2.selfClosing) {
                e:
                  for (; ; )
                    switch (this.state.type) {
                      case 140:
                        if (e = this.state.startLoc, this.next(), this.eat(56)) {
                          n = this.jsxParseClosingElementAt(e);
                          break e;
                        }
                        i.push(this.jsxParseElementAt(e));
                        break;
                      case 139:
                        i.push(this.parseExprAtom());
                        break;
                      case 5: {
                        let o = this.startNode();
                        this.setContext(x2.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, x2.j_expr));
                        break;
                      }
                      default:
                        this.unexpected();
                    }
                Te2(a2) && !Te2(n) && n !== null ? this.raise(Se.MissingClosingTagFragment, { at: n }) : !Te2(a2) && Te2(n) ? this.raise(Se.MissingClosingTagElement, { at: n, openingTagName: Re(a2.name) }) : !Te2(a2) && !Te2(n) && Re(n.name) !== Re(a2.name) && this.raise(Se.MissingClosingTagElement, { at: n, openingTagName: Re(a2.name) });
              }
              if (Te2(a2) ? (s2.openingFragment = a2, s2.closingFragment = n) : (s2.openingElement = a2, s2.closingElement = n), s2.children = i, this.match(47))
                throw this.raise(Se.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
              return Te2(a2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
            }
            jsxParseElement() {
              let e = this.state.startLoc;
              return this.next(), this.jsxParseElementAt(e);
            }
            setContext(e) {
              let { context: s2 } = this.state;
              s2[s2.length - 1] = e;
            }
            parseExprAtom(e) {
              return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e);
            }
            skipSpace() {
              this.curContext().preserveSpace || super.skipSpace();
            }
            getTokenFromCode(e) {
              let s2 = this.curContext();
              if (s2 === x2.j_expr) {
                this.jsxReadToken();
                return;
              }
              if (s2 === x2.j_oTag || s2 === x2.j_cTag) {
                if (fe(e)) {
                  this.jsxReadWord();
                  return;
                }
                if (e === 62) {
                  ++this.state.pos, this.finishToken(141);
                  return;
                }
                if ((e === 34 || e === 39) && s2 === x2.j_oTag) {
                  this.jsxReadString(e);
                  return;
                }
              }
              if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos, this.finishToken(140);
                return;
              }
              super.getTokenFromCode(e);
            }
            updateContext(e) {
              let { context: s2, type: i } = this.state;
              if (i === 56 && e === 140)
                s2.splice(-2, 2, x2.j_cTag), this.state.canStartJSXElement = false;
              else if (i === 140)
                s2.push(x2.j_oTag);
              else if (i === 141) {
                let a2 = s2[s2.length - 1];
                a2 === x2.j_oTag && e === 56 || a2 === x2.j_cTag ? (s2.pop(), this.state.canStartJSXElement = s2[s2.length - 1] === x2.j_expr) : (this.setContext(x2.j_expr), this.state.canStartJSXElement = true);
              } else
                this.state.canStartJSXElement = se(i);
            }
          }, sh = class extends rs {
            constructor() {
              super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
            }
          }, rh = class extends is {
            constructor() {
              super(...arguments), this.importsStack = [];
            }
            createScope(t) {
              return this.importsStack.push(/* @__PURE__ */ new Set()), new sh(t);
            }
            enter(t) {
              t == Oe && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
            }
            exit() {
              let t = super.exit();
              return t == Oe && this.importsStack.pop(), t;
            }
            hasImport(t, r) {
              let e = this.importsStack.length;
              if (this.importsStack[e - 1].has(t))
                return true;
              if (!r && e > 1) {
                for (let s2 = 0; s2 < e - 1; s2++)
                  if (this.importsStack[s2].has(t))
                    return true;
              }
              return false;
            }
            declareName(t, r, e) {
              if (r & Ve) {
                this.hasImport(t, true) && this.parser.raise(f.VarRedeclaration, { at: e, identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
                return;
              }
              let s2 = this.currentScope();
              if (r & Yt2) {
                this.maybeExportDefined(s2, t), s2.exportOnlyBindings.add(t);
                return;
              }
              super.declareName(t, r, e), r & Ce && (r & le || (this.checkRedeclarationInScope(s2, t, r, e), this.maybeExportDefined(s2, t)), s2.types.add(t)), r & Jt2 && s2.enums.add(t), r & Xt2 && s2.constEnums.add(t), r & ft2 && s2.classes.add(t);
            }
            isRedeclaredInScope(t, r, e) {
              if (t.enums.has(r)) {
                if (e & Jt2) {
                  let s2 = !!(e & Xt2), i = t.constEnums.has(r);
                  return s2 !== i;
                }
                return true;
              }
              return e & ft2 && t.classes.has(r) ? t.lexical.has(r) ? !!(e & le) : false : e & Ce && t.types.has(r) ? true : super.isRedeclaredInScope(t, r, e);
            }
            checkLocalExport(t) {
              let { name: r } = t;
              if (this.hasImport(r))
                return;
              let e = this.scopeStack.length;
              for (let s2 = e - 1; s2 >= 0; s2--) {
                let i = this.scopeStack[s2];
                if (i.types.has(r) || i.exportOnlyBindings.has(r))
                  return;
              }
              super.checkLocalExport(t);
            }
          }, ih = (t, r) => Object.hasOwnProperty.call(t, r) && t[r], Ur = (t) => t.type === "ParenthesizedExpression" ? Ur(t.expression) : t, ah = class extends Wl {
            toAssignable(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var e, s2;
              let i;
              switch ((t.type === "ParenthesizedExpression" || (e = t.extra) != null && e.parenthesized) && (i = Ur(t), r ? i.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(f.InvalidParenthesizedAssignment, { at: t }) : i.type !== "MemberExpression" && this.raise(f.InvalidParenthesizedAssignment, { at: t }) : this.raise(f.InvalidParenthesizedAssignment, { at: t })), t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  break;
                case "ObjectExpression":
                  t.type = "ObjectPattern";
                  for (let n = 0, o = t.properties.length, u = o - 1; n < o; n++) {
                    var a2;
                    let c2 = t.properties[n], y = n === u;
                    this.toAssignableObjectExpressionProp(c2, y, r), y && c2.type === "RestElement" && (a2 = t.extra) != null && a2.trailingCommaLoc && this.raise(f.RestTrailingComma, { at: t.extra.trailingCommaLoc });
                  }
                  break;
                case "ObjectProperty": {
                  let { key: n, value: o } = t;
                  this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, r);
                  break;
                }
                case "SpreadElement":
                  throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                case "ArrayExpression":
                  t.type = "ArrayPattern", this.toAssignableList(t.elements, (s2 = t.extra) == null ? void 0 : s2.trailingCommaLoc, r);
                  break;
                case "AssignmentExpression":
                  t.operator !== "=" && this.raise(f.MissingEqInAssignment, { at: t.left.loc.end }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(i, r);
                  break;
              }
            }
            toAssignableObjectExpressionProp(t, r, e) {
              if (t.type === "ObjectMethod")
                this.raise(t.kind === "get" || t.kind === "set" ? f.PatternHasAccessor : f.PatternHasMethod, { at: t.key });
              else if (t.type === "SpreadElement") {
                t.type = "RestElement";
                let s2 = t.argument;
                this.checkToRestConversion(s2, false), this.toAssignable(s2, e), r || this.raise(f.RestTrailingComma, { at: t });
              } else
                this.toAssignable(t, e);
            }
            toAssignableList(t, r, e) {
              let s2 = t.length - 1;
              for (let i = 0; i <= s2; i++) {
                let a2 = t[i];
                if (a2) {
                  if (a2.type === "SpreadElement") {
                    a2.type = "RestElement";
                    let n = a2.argument;
                    this.checkToRestConversion(n, true), this.toAssignable(n, e);
                  } else
                    this.toAssignable(a2, e);
                  a2.type === "RestElement" && (i < s2 ? this.raise(f.RestTrailingComma, { at: a2 }) : r && this.raise(f.RestTrailingComma, { at: r }));
                }
              }
            }
            isAssignable(t, r) {
              switch (t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  return true;
                case "ObjectExpression": {
                  let e = t.properties.length - 1;
                  return t.properties.every((s2, i) => s2.type !== "ObjectMethod" && (i === e || s2.type !== "SpreadElement") && this.isAssignable(s2));
                }
                case "ObjectProperty":
                  return this.isAssignable(t.value);
                case "SpreadElement":
                  return this.isAssignable(t.argument);
                case "ArrayExpression":
                  return t.elements.every((e) => e === null || this.isAssignable(e));
                case "AssignmentExpression":
                  return t.operator === "=";
                case "ParenthesizedExpression":
                  return this.isAssignable(t.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return !r;
                default:
                  return false;
              }
            }
            toReferencedList(t, r) {
              return t;
            }
            toReferencedListDeep(t, r) {
              this.toReferencedList(t, r);
              for (let e of t)
                (e == null ? void 0 : e.type) === "ArrayExpression" && this.toReferencedListDeep(e.elements);
            }
            parseSpread(t) {
              let r = this.startNode();
              return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
            }
            parseRestBinding() {
              let t = this.startNode();
              return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 0: {
                  let t = this.startNode();
                  return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
                }
                case 5:
                  return this.parseObjectLike(8, true);
              }
              return this.parseIdentifier();
            }
            parseBindingList(t, r, e) {
              let s2 = e & 1, i = [], a2 = true;
              for (; !this.eat(t); )
                if (a2 ? a2 = false : this.expect(12), s2 && this.match(12))
                  i.push(null);
                else {
                  if (this.eat(t))
                    break;
                  if (this.match(21)) {
                    if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding(), e)), !this.checkCommaAfterRest(r)) {
                      this.expect(t);
                      break;
                    }
                  } else {
                    let n = [];
                    for (this.match(26) && this.hasPlugin("decorators") && this.raise(f.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                      n.push(this.parseDecorator());
                    i.push(this.parseAssignableListItem(e, n));
                  }
                }
              return i;
            }
            parseBindingRestProperty(t) {
              return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
            }
            parseBindingProperty() {
              let t = this.startNode(), { type: r, startLoc: e } = this.state;
              return r === 21 ? this.parseBindingRestProperty(t) : (r === 136 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = false, this.parseObjPropValue(t, e, false, false, true, false));
            }
            parseAssignableListItem(t, r) {
              let e = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(e, t);
              let s2 = this.parseMaybeDefault(e.loc.start, e);
              return r.length && (e.decorators = r), s2;
            }
            parseAssignableListItemTypes(t, r) {
              return t;
            }
            parseMaybeDefault(t, r) {
              var s2;
              if (t != null || (t = this.state.startLoc), r = (s2 = r) != null ? s2 : this.parseBindingAtom(), !this.eat(29))
                return r;
              let i = this.startNodeAt(t);
              return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
            }
            isValidLVal(t, r, e) {
              return ih({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
            }
            checkLVal(t, r) {
              let { in: e, binding: s2 = Pe, checkClashes: i = false, strictModeChanged: a2 = false, hasParenthesizedAncestor: n = false } = r;
              var o;
              let u = t.type;
              if (this.isObjectMethod(t))
                return;
              if (u === "MemberExpression") {
                s2 !== Pe && this.raise(f.InvalidPropertyBindingPattern, { at: t });
                return;
              }
              if (u === "Identifier") {
                this.checkIdentifier(t, s2, a2);
                let { name: C } = t;
                i && (i.has(C) ? this.raise(f.ParamDupe, { at: t }) : i.add(C));
                return;
              }
              let c2 = this.isValidLVal(u, !(n || (o = t.extra) != null && o.parenthesized) && e.type === "AssignmentExpression", s2);
              if (c2 === true)
                return;
              if (c2 === false) {
                let C = s2 === Pe ? f.InvalidLhs : f.InvalidLhsBinding;
                this.raise(C, { at: t, ancestor: e });
                return;
              }
              let [y, g] = Array.isArray(c2) ? c2 : [c2, u === "ParenthesizedExpression"], T = u === "ArrayPattern" || u === "ObjectPattern" || u === "ParenthesizedExpression" ? { type: u } : e;
              for (let C of [].concat(t[y]))
                C && this.checkLVal(C, { in: T, binding: s2, checkClashes: i, strictModeChanged: a2, hasParenthesizedAncestor: g });
            }
            checkIdentifier(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.state.strict && (e ? xr2(t.name, this.inModule) : yr(t.name)) && (r === Pe ? this.raise(f.StrictEvalArguments, { at: t, referenceName: t.name }) : this.raise(f.StrictEvalArgumentsBinding, { at: t, bindingName: t.name })), r & dt2 && t.name === "let" && this.raise(f.LetInLexicalBinding, { at: t }), r & Pe || this.declareNameFromIdentifier(t, r);
            }
            declareNameFromIdentifier(t, r) {
              this.scope.declareName(t.name, r, t.loc.start);
            }
            checkToRestConversion(t, r) {
              switch (t.type) {
                case "ParenthesizedExpression":
                  this.checkToRestConversion(t.expression, r);
                  break;
                case "Identifier":
                case "MemberExpression":
                  break;
                case "ArrayExpression":
                case "ObjectExpression":
                  if (r)
                    break;
                default:
                  this.raise(f.InvalidRestAssignmentPattern, { at: t });
              }
            }
            checkCommaAfterRest(t) {
              return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? f.RestTrailingComma : f.ElementAfterRest, { at: this.state.startLoc }), true) : false;
            }
          }, nh = (t, r) => Object.hasOwnProperty.call(t, r) && t[r];
          function oh(t) {
            if (t == null)
              throw new Error(`Unexpected ${t} value.`);
            return t;
          }
          function $r(t) {
            if (!t)
              throw new Error("Assert fail");
          }
          var I = pe`typescript`({ AbstractMethodHasImplementation: (t) => {
            let { methodName: r } = t;
            return `Method '${r}' cannot have an implementation because it is marked abstract.`;
          }, AbstractPropertyHasInitializer: (t) => {
            let { propertyName: r } = t;
            return `Property '${r}' cannot have an initializer because it is marked abstract.`;
          }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (t) => {
            let { kind: r } = t;
            return `'declare' is not allowed in ${r}ters.`;
          }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (t) => {
            return "Accessibility modifier already seen.";
          }, DuplicateModifier: (t) => {
            let { modifier: r } = t;
            return `Duplicate modifier: '${r}'.`;
          }, EmptyHeritageClauseType: (t) => {
            let { token: r } = t;
            return `'${r}' list cannot be empty.`;
          }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (t) => {
            let { modifiers: r } = t;
            return `'${r[0]}' modifier cannot be used with '${r[1]}' modifier.`;
          }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (t) => {
            let { modifier: r } = t;
            return `Index signatures cannot have an accessibility modifier ('${r}').`;
          }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (t) => {
            let { modifier: r } = t;
            return `'${r}' modifier cannot appear on a type member.`;
          }, InvalidModifierOnTypeParameter: (t) => {
            let { modifier: r } = t;
            return `'${r}' modifier cannot appear on a type parameter.`;
          }, InvalidModifierOnTypeParameterPositions: (t) => {
            let { modifier: r } = t;
            return `'${r}' modifier can only appear on a type parameter of a class, interface or type alias.`;
          }, InvalidModifiersOrder: (t) => {
            let { orderedModifiers: r } = t;
            return `'${r[0]}' modifier must precede '${r[1]}' modifier.`;
          }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (t) => {
            let { modifier: r } = t;
            return `Private elements cannot have an accessibility modifier ('${r}').`;
          }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (t) => {
            let { typeParameterName: r } = t;
            return `Single type parameter ${r} should have a trailing comma. Example usage: <${r},>.`;
          }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (t) => {
            let { type: r } = t;
            return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`;
          } });
          function lh(t) {
            switch (t) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }
          function Hr(t) {
            return t === "private" || t === "public" || t === "protected";
          }
          function hh(t) {
            return t === "in" || t === "out";
          }
          var uh = (t) => class extends t {
            constructor() {
              super(...arguments), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: I.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: I.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: I.InvalidModifierOnTypeParameter });
            }
            getScopeHandler() {
              return rh;
            }
            tsIsIdentifier() {
              return q2(this.state.type);
            }
            tsTokenCanFollowModifier() {
              return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
            tsNextTokenCanFollowModifier() {
              return this.next(), this.tsTokenCanFollowModifier();
            }
            tsParseModifier(e, s2) {
              if (!q2(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
                return;
              let i = this.state.value;
              if (e.indexOf(i) !== -1) {
                if (s2 && this.tsIsStartOfStaticBlocks())
                  return;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                  return i;
              }
            }
            tsParseModifiers(e, s2) {
              let { allowedModifiers: i, disallowedModifiers: a2, stopOnStartOfClassStaticBlock: n, errorTemplate: o = I.InvalidModifierOnTypeMember } = e, u = (y, g, T, C) => {
                g === T && s2[C] && this.raise(I.InvalidModifiersOrder, { at: y, orderedModifiers: [T, C] });
              }, c2 = (y, g, T, C) => {
                (s2[T] && g === C || s2[C] && g === T) && this.raise(I.IncompatibleModifiers, { at: y, modifiers: [T, C] });
              };
              for (; ; ) {
                let { startLoc: y } = this.state, g = this.tsParseModifier(i.concat(a2 != null ? a2 : []), n);
                if (!g)
                  break;
                Hr(g) ? s2.accessibility ? this.raise(I.DuplicateAccessibilityModifier, { at: y, modifier: g }) : (u(y, g, g, "override"), u(y, g, g, "static"), u(y, g, g, "readonly"), s2.accessibility = g) : hh(g) ? (s2[g] && this.raise(I.DuplicateModifier, { at: y, modifier: g }), s2[g] = true, u(y, g, "in", "out")) : (Object.hasOwnProperty.call(s2, g) ? this.raise(I.DuplicateModifier, { at: y, modifier: g }) : (u(y, g, "static", "readonly"), u(y, g, "static", "override"), u(y, g, "override", "readonly"), u(y, g, "abstract", "override"), c2(y, g, "declare", "override"), c2(y, g, "static", "abstract")), s2[g] = true), a2 != null && a2.includes(g) && this.raise(o, { at: y, modifier: g });
              }
            }
            tsIsListTerminator(e) {
              switch (e) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(8);
                case "HeritageClauseElement":
                  return this.match(5);
                case "TupleElementTypes":
                  return this.match(3);
                case "TypeParametersOrArguments":
                  return this.match(48);
              }
            }
            tsParseList(e, s2) {
              let i = [];
              for (; !this.tsIsListTerminator(e); )
                i.push(s2());
              return i;
            }
            tsParseDelimitedList(e, s2, i) {
              return oh(this.tsParseDelimitedListWorker(e, s2, true, i));
            }
            tsParseDelimitedListWorker(e, s2, i, a2) {
              let n = [], o = -1;
              for (; !this.tsIsListTerminator(e); ) {
                o = -1;
                let u = s2();
                if (u == null)
                  return;
                if (n.push(u), this.eat(12)) {
                  o = this.state.lastTokStart;
                  continue;
                }
                if (this.tsIsListTerminator(e))
                  break;
                i && this.expect(12);
                return;
              }
              return a2 && (a2.value = o), n;
            }
            tsParseBracketedList(e, s2, i, a2, n) {
              a2 || (i ? this.expect(0) : this.expect(47));
              let o = this.tsParseDelimitedList(e, s2, n);
              return i ? this.expect(3) : this.expect(48), o;
            }
            tsParseImportType() {
              let e = this.startNode();
              return this.expect(83), this.expect(10), this.match(131) || this.raise(I.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
            }
            tsParseEntityName() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = this.parseIdentifier(e);
              for (; this.eat(16); ) {
                let i = this.startNodeAtNode(s2);
                i.left = s2, i.right = this.parseIdentifier(e), s2 = this.finishNode(i, "TSQualifiedName");
              }
              return s2;
            }
            tsParseTypeReference() {
              let e = this.startNode();
              return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
            }
            tsParseThisTypePredicate(e) {
              this.next();
              let s2 = this.startNodeAtNode(e);
              return s2.parameterName = e, s2.typeAnnotation = this.tsParseTypeAnnotation(false), s2.asserts = false, this.finishNode(s2, "TSTypePredicate");
            }
            tsParseThisTypeNode() {
              let e = this.startNode();
              return this.next(), this.finishNode(e, "TSThisType");
            }
            tsParseTypeQuery() {
              let e = this.startNode();
              return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
            }
            tsParseTypeParameter(e) {
              let s2 = this.startNode();
              return e(s2), s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsEatThenParseType(81), s2.default = this.tsEatThenParseType(29), this.finishNode(s2, "TSTypeParameter");
            }
            tsTryParseTypeParameters(e) {
              if (this.match(47))
                return this.tsParseTypeParameters(e);
            }
            tsParseTypeParameters(e) {
              let s2 = this.startNode();
              this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i = { value: -1 };
              return s2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s2.params.length === 0 && this.raise(I.EmptyTypeParameters, { at: s2 }), i.value !== -1 && this.addExtra(s2, "trailingComma", i.value), this.finishNode(s2, "TSTypeParameterDeclaration");
            }
            tsFillSignature(e, s2) {
              let i = e === 19, a2 = "parameters", n = "typeAnnotation";
              s2.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s2[a2] = this.tsParseBindingListForSignature(), i ? s2[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s2[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
            }
            tsParseBindingListForSignature() {
              return super.parseBindingList(11, 41, 2).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(I.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
            }
            tsParseTypeMemberSemicolon() {
              !this.eat(12) && !this.isLineTerminator() && this.expect(13);
            }
            tsParseSignatureMember(e, s2) {
              return this.tsFillSignature(14, s2), this.tsParseTypeMemberSemicolon(), this.finishNode(s2, e);
            }
            tsIsUnambiguouslyIndexSignature() {
              return this.next(), q2(this.state.type) ? (this.next(), this.match(14)) : false;
            }
            tsTryParseIndexSignature(e) {
              if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
                return;
              this.expect(0);
              let s2 = this.parseIdentifier();
              s2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s2), this.expect(3), e.parameters = [s2];
              let i = this.tsTryParseTypeAnnotation();
              return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
            }
            tsParsePropertyOrMethodSignature(e, s2) {
              this.eat(17) && (e.optional = true);
              let i = e;
              if (this.match(10) || this.match(47)) {
                s2 && this.raise(I.ReadonlyForMethodSignature, { at: e });
                let a2 = i;
                a2.kind && this.match(47) && this.raise(I.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, a2), this.tsParseTypeMemberSemicolon();
                let n = "parameters", o = "typeAnnotation";
                if (a2.kind === "get")
                  a2[n].length > 0 && (this.raise(f.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(a2[n][0]) && this.raise(I.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
                else if (a2.kind === "set") {
                  if (a2[n].length !== 1)
                    this.raise(f.BadSetterArity, { at: this.state.curPosition() });
                  else {
                    let u = a2[n][0];
                    this.isThisParam(u) && this.raise(I.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), u.type === "Identifier" && u.optional && this.raise(I.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), u.type === "RestElement" && this.raise(I.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                  }
                  a2[o] && this.raise(I.SetAccesorCannotHaveReturnType, { at: a2[o] });
                } else
                  a2.kind = "method";
                return this.finishNode(a2, "TSMethodSignature");
              } else {
                let a2 = i;
                s2 && (a2.readonly = true);
                let n = this.tsTryParseTypeAnnotation();
                return n && (a2.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(a2, "TSPropertySignature");
              }
            }
            tsParseTypeMember() {
              let e = this.startNode();
              if (this.match(10) || this.match(47))
                return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
              if (this.match(77)) {
                let i = this.startNode();
                return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
              }
              this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
              let s2 = this.tsTryParseIndexSignature(e);
              return s2 || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
            }
            tsParseTypeLiteral() {
              let e = this.startNode();
              return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
            }
            tsParseObjectTypeMembers() {
              this.expect(5);
              let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              return this.expect(8), e;
            }
            tsIsStartOfMappedType() {
              return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
            }
            tsParseMappedTypeParameter() {
              let e = this.startNode();
              return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
            }
            tsParseMappedType() {
              let e = this.startNode();
              return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
            }
            tsParseTupleType() {
              let e = this.startNode();
              e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              let s2 = false, i = null;
              return e.elementTypes.forEach((a2) => {
                let { type: o } = a2;
                s2 && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && a2.optional) && this.raise(I.OptionalTypeBeforeRequired, { at: a2 }), s2 || (s2 = o === "TSNamedTupleMember" && a2.optional || o === "TSOptionalType");
                let u = o;
                o === "TSRestType" && (a2 = a2.typeAnnotation, u = a2.type);
                let c2 = u === "TSNamedTupleMember";
                i != null || (i = c2), i !== c2 && this.raise(I.MixedLabeledAndUnlabeledElements, { at: a2 });
              }), this.finishNode(e, "TSTupleType");
            }
            tsParseTupleElementType() {
              let { startLoc: e } = this.state, s2 = this.eat(21), i, a2, n, o, c2 = te2(this.state.type) ? this.lookaheadCharCode() : null;
              if (c2 === 58)
                i = true, n = false, a2 = this.parseIdentifier(true), this.expect(14), o = this.tsParseType();
              else if (c2 === 63) {
                n = true;
                let y = this.state.startLoc, g = this.state.value, T = this.tsParseNonArrayType();
                this.lookaheadCharCode() === 58 ? (i = true, a2 = this.createIdentifier(this.startNodeAt(y), g), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = false, o = T, this.expect(17));
              } else
                o = this.tsParseType(), n = this.eat(17), i = this.eat(14);
              if (i) {
                let y;
                a2 ? (y = this.startNodeAtNode(a2), y.optional = n, y.label = a2, y.elementType = o, this.eat(17) && (y.optional = true, this.raise(I.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (y = this.startNodeAtNode(o), y.optional = n, this.raise(I.InvalidTupleMemberLabel, { at: o }), y.label = o, y.elementType = this.tsParseType()), o = this.finishNode(y, "TSNamedTupleMember");
              } else if (n) {
                let y = this.startNodeAtNode(o);
                y.typeAnnotation = o, o = this.finishNode(y, "TSOptionalType");
              }
              if (s2) {
                let y = this.startNodeAt(e);
                y.typeAnnotation = o, o = this.finishNode(y, "TSRestType");
              }
              return o;
            }
            tsParseParenthesizedType() {
              let e = this.startNode();
              return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
            }
            tsParseFunctionOrConstructorType(e, s2) {
              let i = this.startNode();
              return e === "TSConstructorType" && (i.abstract = !!s2, s2 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
            }
            tsParseLiteralTypeNode() {
              let e = this.startNode();
              return e.literal = (() => {
                switch (this.state.type) {
                  case 132:
                  case 133:
                  case 131:
                  case 85:
                  case 86:
                    return super.parseExprAtom();
                  default:
                    this.unexpected();
                }
              })(), this.finishNode(e, "TSLiteralType");
            }
            tsParseTemplateLiteralType() {
              let e = this.startNode();
              return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
            }
            parseTemplateSubstitution() {
              return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
            }
            tsParseThisTypeOrThisTypePredicate() {
              let e = this.tsParseThisTypeNode();
              return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
            }
            tsParseNonArrayType() {
              switch (this.state.type) {
                case 131:
                case 132:
                case 133:
                case 85:
                case 86:
                  return this.tsParseLiteralTypeNode();
                case 53:
                  if (this.state.value === "-") {
                    let e = this.startNode(), s2 = this.lookahead();
                    return s2.type !== 132 && s2.type !== 133 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                  }
                  break;
                case 78:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                  return this.tsParseTypeQuery();
                case 83:
                  return this.tsParseImportType();
                case 5:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                  return this.tsParseTupleType();
                case 10:
                  return this.tsParseParenthesizedType();
                case 25:
                case 24:
                  return this.tsParseTemplateLiteralType();
                default: {
                  let { type: e } = this.state;
                  if (q2(e) || e === 88 || e === 84) {
                    let s2 = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : lh(this.state.value);
                    if (s2 !== void 0 && this.lookaheadCharCode() !== 46) {
                      let i = this.startNode();
                      return this.next(), this.finishNode(i, s2);
                    }
                    return this.tsParseTypeReference();
                  }
                }
              }
              this.unexpected();
            }
            tsParseArrayTypeOrHigher() {
              let e = this.tsParseNonArrayType();
              for (; !this.hasPrecedingLineBreak() && this.eat(0); )
                if (this.match(3)) {
                  let s2 = this.startNodeAtNode(e);
                  s2.elementType = e, this.expect(3), e = this.finishNode(s2, "TSArrayType");
                } else {
                  let s2 = this.startNodeAtNode(e);
                  s2.objectType = e, s2.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s2, "TSIndexedAccessType");
                }
              return e;
            }
            tsParseTypeOperator() {
              let e = this.startNode(), s2 = this.state.value;
              return this.next(), e.operator = s2, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
            }
            tsCheckTypeAnnotationForReadOnly(e) {
              switch (e.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(I.UnexpectedReadonly, { at: e });
              }
            }
            tsParseInferType() {
              let e = this.startNode();
              this.expectContextual(113);
              let s2 = this.startNode();
              return s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s2, "TSTypeParameter"), this.finishNode(e, "TSInferType");
            }
            tsParseConstraintForInferType() {
              if (this.eat(81)) {
                let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                  return e;
              }
            }
            tsParseTypeOperatorOrHigher() {
              return qo(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
            }
            tsParseUnionOrIntersectionType(e, s2, i) {
              let a2 = this.startNode(), n = this.eat(i), o = [];
              do
                o.push(s2());
              while (this.eat(i));
              return o.length === 1 && !n ? o[0] : (a2.types = o, this.finishNode(a2, e));
            }
            tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
            }
            tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
            }
            tsIsStartOfFunctionType() {
              return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
            tsSkipParameterStart() {
              if (q2(this.state.type) || this.match(78))
                return this.next(), true;
              if (this.match(5)) {
                let { errors: e } = this.state, s2 = e.length;
                try {
                  return this.parseObjectLike(8, true), e.length === s2;
                } catch {
                  return false;
                }
              }
              if (this.match(0)) {
                this.next();
                let { errors: e } = this.state, s2 = e.length;
                try {
                  return super.parseBindingList(3, 93, 1), e.length === s2;
                } catch {
                  return false;
                }
              }
              return false;
            }
            tsIsUnambiguouslyStartOfFunctionType() {
              return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
            }
            tsParseTypeOrTypePredicateAnnotation(e) {
              return this.tsInType(() => {
                let s2 = this.startNode();
                this.expect(e);
                let i = this.startNode(), a2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (a2 && this.match(78)) {
                  let u = this.tsParseThisTypeOrThisTypePredicate();
                  return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = true, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, i), u.asserts = true), s2.typeAnnotation = u, this.finishNode(s2, "TSTypeAnnotation");
                }
                let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!n)
                  return a2 ? (i.parameterName = this.parseIdentifier(), i.asserts = a2, i.typeAnnotation = null, s2.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s2);
                let o = this.tsParseTypeAnnotation(false);
                return i.parameterName = n, i.typeAnnotation = o, i.asserts = a2, s2.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation");
              });
            }
            tsTryParseTypeOrTypePredicateAnnotation() {
              return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
            }
            tsTryParseTypeAnnotation() {
              return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
            }
            tsTryParseType() {
              return this.tsEatThenParseType(14);
            }
            tsParseTypePredicatePrefix() {
              let e = this.parseIdentifier();
              if (this.isContextual(114) && !this.hasPrecedingLineBreak())
                return this.next(), e;
            }
            tsParseTypePredicateAsserts() {
              if (this.state.type !== 107)
                return false;
              let e = this.state.containsEsc;
              return this.next(), !q2(this.state.type) && !this.match(78) ? false : (e && this.raise(f.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
            }
            tsParseTypeAnnotation() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
              return this.tsInType(() => {
                e && this.expect(14), s2.typeAnnotation = this.tsParseType();
              }), this.finishNode(s2, "TSTypeAnnotation");
            }
            tsParseType() {
              $r(this.state.inType);
              let e = this.tsParseNonConditionalType();
              if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
                return e;
              let s2 = this.startNodeAtNode(e);
              return s2.checkType = e, s2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s2, "TSConditionalType");
            }
            isAbstractConstructorSignature() {
              return this.isContextual(122) && this.lookahead().type === 77;
            }
            tsParseNonConditionalType() {
              return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
            }
            tsParseTypeAssertion() {
              this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(I.ReservedTypeAssertion, { at: this.state.startLoc });
              let e = this.startNode();
              return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
            }
            tsParseHeritageClause(e) {
              let s2 = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
                let a2 = this.startNode();
                return a2.expression = this.tsParseEntityName(), this.match(47) && (a2.typeParameters = this.tsParseTypeArguments()), this.finishNode(a2, "TSExpressionWithTypeArguments");
              });
              return i.length || this.raise(I.EmptyHeritageClauseType, { at: s2, token: e }), i;
            }
            tsParseInterfaceDeclaration(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.hasFollowingLineBreak())
                return null;
              this.expectContextual(127), s2.declare && (e.declare = true), q2(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, pl)) : (e.id = null, this.raise(I.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
              let i = this.startNode();
              return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
            }
            tsParseTypeAliasDeclaration(e) {
              return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, fl), e.typeAnnotation = this.tsInType(() => {
                if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
                  let s2 = this.startNode();
                  return this.next(), this.finishNode(s2, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
              }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
            }
            tsInNoContext(e) {
              let s2 = this.state.context;
              this.state.context = [s2[0]];
              try {
                return e();
              } finally {
                this.state.context = s2;
              }
            }
            tsInType(e) {
              let s2 = this.state.inType;
              this.state.inType = true;
              try {
                return e();
              } finally {
                this.state.inType = s2;
              }
            }
            tsInDisallowConditionalTypesContext(e) {
              let s2 = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = true;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s2;
              }
            }
            tsInAllowConditionalTypesContext(e) {
              let s2 = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = false;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s2;
              }
            }
            tsEatThenParseType(e) {
              return this.match(e) ? this.tsNextThenParseType() : void 0;
            }
            tsExpectThenParseType(e) {
              return this.tsDoThenParseType(() => this.expect(e));
            }
            tsNextThenParseType() {
              return this.tsDoThenParseType(() => this.next());
            }
            tsDoThenParseType(e) {
              return this.tsInType(() => (e(), this.tsParseType()));
            }
            tsParseEnumMember() {
              let e = this.startNode();
              return e.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
            }
            tsParseEnumDeclaration(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return s2.const && (e.const = true), s2.declare && (e.declare = true), this.expectContextual(124), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? ml : Cr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
            }
            tsParseModuleBlock() {
              let e = this.startNode();
              return this.scope.enter(Fe), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
            }
            tsParseModuleOrNamespaceDeclaration(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e.id = this.parseIdentifier(), s2 || this.checkIdentifier(e.id, yl), this.eat(16)) {
                let i = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
              } else
                this.scope.enter(Oe), this.prodParam.enter(Me), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
              return this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseAmbientExternalModuleDeclaration(e) {
              return this.isContextual(110) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(131) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(Oe), this.prodParam.enter(Me), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseImportEqualsDeclaration(e, s2) {
              e.isExport = s2 || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Ve), this.expect(29);
              let i = this.tsParseModuleReference();
              return e.importKind === "type" && i.type !== "TSExternalModuleReference" && this.raise(I.ImportAliasHasImportType, { at: i }), e.moduleReference = i, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
            }
            tsIsExternalModuleReference() {
              return this.isContextual(117) && this.lookaheadCharCode() === 40;
            }
            tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
            tsParseExternalModuleReference() {
              let e = this.startNode();
              return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
            }
            tsLookAhead(e) {
              let s2 = this.state.clone(), i = e();
              return this.state = s2, i;
            }
            tsTryParseAndCatch(e) {
              let s2 = this.tryParse((i) => e() || i());
              if (!(s2.aborted || !s2.node))
                return s2.error && (this.state = s2.failState), s2.node;
            }
            tsTryParse(e) {
              let s2 = this.state.clone(), i = e();
              if (i !== void 0 && i !== false)
                return i;
              this.state = s2;
            }
            tsTryParseDeclare(e) {
              if (this.isLineTerminator())
                return;
              let s2 = this.state.type, i;
              return this.isContextual(99) && (s2 = 74, i = "let"), this.tsInAmbientContext(() => {
                if (s2 === 68)
                  return e.declare = true, super.parseFunctionStatement(e, false, false);
                if (s2 === 80)
                  return e.declare = true, this.parseClass(e, true, false);
                if (s2 === 124)
                  return this.tsParseEnumDeclaration(e, { declare: true });
                if (s2 === 110)
                  return this.tsParseAmbientExternalModuleDeclaration(e);
                if (s2 === 75 || s2 === 74)
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                if (s2 === 127) {
                  let a2 = this.tsParseInterfaceDeclaration(e, { declare: true });
                  if (a2)
                    return a2;
                }
                if (q2(s2))
                  return this.tsParseDeclaration(e, this.state.value, true, null);
              });
            }
            tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
            }
            tsParseExpressionStatement(e, s2, i) {
              switch (s2.name) {
                case "declare": {
                  let a2 = this.tsTryParseDeclare(e);
                  if (a2)
                    return a2.declare = true, a2;
                  break;
                }
                case "global":
                  if (this.match(5)) {
                    this.scope.enter(Oe), this.prodParam.enter(Me);
                    let a2 = e;
                    return a2.global = true, a2.id = s2, a2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a2, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(e, s2.name, false, i);
              }
            }
            tsParseDeclaration(e, s2, i, a2) {
              switch (s2) {
                case "abstract":
                  if (this.tsCheckLineTerminator(i) && (this.match(80) || q2(this.state.type)))
                    return this.tsParseAbstractDeclaration(e, a2);
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(i)) {
                    if (this.match(131))
                      return this.tsParseAmbientExternalModuleDeclaration(e);
                    if (q2(this.state.type))
                      return this.tsParseModuleOrNamespaceDeclaration(e);
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(i) && q2(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(e);
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(i) && q2(this.state.type))
                    return this.tsParseTypeAliasDeclaration(e);
                  break;
              }
            }
            tsCheckLineTerminator(e) {
              return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
            }
            tsTryParseGenericAsyncArrowFunction(e) {
              if (!this.match(47))
                return;
              let s2 = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              let i = this.tsTryParseAndCatch(() => {
                let a2 = this.startNodeAt(e);
                return a2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a2), a2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a2;
              });
              if (this.state.maybeInArrowParameters = s2, !!i)
                return super.parseArrowExpression(i, null, true);
            }
            tsParseTypeArgumentsInExpression() {
              if (this.reScan_lt() === 47)
                return this.tsParseTypeArguments();
            }
            tsParseTypeArguments() {
              let e = this.startNode();
              return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(I.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
            }
            tsIsDeclarationStart() {
              return Uo(this.state.type);
            }
            isExportDefaultSpecifier() {
              return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
            }
            parseAssignableListItem(e, s2) {
              let i = this.state.startLoc, a2 = {};
              this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, a2);
              let n = a2.accessibility, o = a2.override, u = a2.readonly;
              !(e & 4) && (n || u || o) && this.raise(I.UnexpectedParameterModifier, { at: i });
              let c2 = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(c2, e);
              let y = this.parseMaybeDefault(c2.loc.start, c2);
              if (n || u || o) {
                let g = this.startNodeAt(i);
                return s2.length && (g.decorators = s2), n && (g.accessibility = n), u && (g.readonly = u), o && (g.override = o), y.type !== "Identifier" && y.type !== "AssignmentPattern" && this.raise(I.UnsupportedParameterPropertyKind, { at: g }), g.parameter = y, this.finishNode(g, "TSParameterProperty");
              }
              return s2.length && (c2.decorators = s2), y;
            }
            isSimpleParameter(e) {
              return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
            }
            tsDisallowOptionalPattern(e) {
              for (let s2 of e.params)
                s2.type !== "Identifier" && s2.optional && !this.state.isAmbientContext && this.raise(I.PatternIsOptional, { at: s2 });
            }
            setArrowFunctionParameters(e, s2, i) {
              super.setArrowFunctionParameters(e, s2, i), this.tsDisallowOptionalPattern(e);
            }
            parseFunctionBodyAndFinish(e, s2) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
              let a2 = s2 === "FunctionDeclaration" ? "TSDeclareFunction" : s2 === "ClassMethod" || s2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
              return a2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, a2) : a2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(I.DeclareFunctionHasImplementation, { at: e }), e.declare) ? super.parseFunctionBodyAndFinish(e, a2, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s2, i));
            }
            registerFunctionStatementId(e) {
              !e.body && e.id ? this.checkIdentifier(e.id, br2) : super.registerFunctionStatementId(e);
            }
            tsCheckForInvalidTypeCasts(e) {
              e.forEach((s2) => {
                (s2 == null ? void 0 : s2.type) === "TSTypeCastExpression" && this.raise(I.UnexpectedTypeAnnotation, { at: s2.typeAnnotation });
              });
            }
            toReferencedList(e, s2) {
              return this.tsCheckForInvalidTypeCasts(e), e;
            }
            parseArrayLike(e, s2, i, a2) {
              let n = super.parseArrayLike(e, s2, i, a2);
              return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
            }
            parseSubscript(e, s2, i, a2) {
              if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false, this.next();
                let o = this.startNodeAt(s2);
                return o.expression = e, this.finishNode(o, "TSNonNullExpression");
              }
              let n = false;
              if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (i)
                  return a2.stop = true, e;
                a2.optionalChainMember = n = true, this.next();
              }
              if (this.match(47) || this.match(51)) {
                let o, u = this.tsTryParseAndCatch(() => {
                  if (!i && this.atPossibleAsyncArrow(e)) {
                    let T = this.tsTryParseGenericAsyncArrowFunction(s2);
                    if (T)
                      return T;
                  }
                  let c2 = this.tsParseTypeArgumentsInExpression();
                  if (!c2)
                    return;
                  if (n && !this.match(10)) {
                    o = this.state.curPosition();
                    return;
                  }
                  if (nt(this.state.type)) {
                    let T = super.parseTaggedTemplateExpression(e, s2, a2);
                    return T.typeParameters = c2, T;
                  }
                  if (!i && this.eat(10)) {
                    let T = this.startNodeAt(s2);
                    return T.callee = e, T.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(T.arguments), T.typeParameters = c2, a2.optionalChainMember && (T.optional = n), this.finishCallExpression(T, a2.optionalChainMember);
                  }
                  let y = this.state.type;
                  if (y === 48 || y === 52 || y !== 10 && He(y) && !this.hasPrecedingLineBreak())
                    return;
                  let g = this.startNodeAt(s2);
                  return g.expression = e, g.typeParameters = c2, this.finishNode(g, "TSInstantiationExpression");
                });
                if (o && this.unexpected(o, 10), u)
                  return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(I.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), u;
              }
              return super.parseSubscript(e, s2, i, a2);
            }
            parseNewCallee(e) {
              var s2;
              super.parseNewCallee(e);
              let { callee: i } = e;
              i.type === "TSInstantiationExpression" && !((s2 = i.extra) != null && s2.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
            }
            parseExprOp(e, s2, i) {
              let a2;
              if (at2(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a2 = this.isContextual(118)))) {
                let n = this.startNodeAt(s2);
                return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a2 && this.raise(f.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, a2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s2, i);
              }
              return super.parseExprOp(e, s2, i);
            }
            checkReservedWord(e, s2, i, a2) {
              this.state.isAmbientContext || super.checkReservedWord(e, s2, i, a2);
            }
            checkImportReflection(e) {
              super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(I.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
            }
            checkDuplicateExports() {
            }
            parseImport(e) {
              if (e.importKind = "value", q2(this.state.type) || this.match(55) || this.match(5)) {
                let i = this.lookahead();
                if (this.isContextual(128) && i.type !== 12 && i.type !== 97 && i.type !== 29 && (e.importKind = "type", this.next(), i = this.lookahead()), q2(this.state.type) && i.type === 29)
                  return this.tsParseImportEqualsDeclaration(e);
              }
              let s2 = super.parseImport(e);
              return s2.importKind === "type" && s2.specifiers.length > 1 && s2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(I.TypeImportCannotSpecifyDefaultAndNamed, { at: s2 }), s2;
            }
            parseExport(e, s2) {
              if (this.match(83))
                return this.next(), this.isContextual(128) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
              if (this.eat(29)) {
                let i = e;
                return i.expression = super.parseExpression(), this.semicolon(), this.finishNode(i, "TSExportAssignment");
              } else if (this.eatContextual(93)) {
                let i = e;
                return this.expectContextual(126), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
              } else {
                if (e.exportKind = "value", this.isContextual(128)) {
                  let i = this.lookaheadCharCode();
                  (i === 123 || i === 42) && (this.next(), e.exportKind = "type");
                }
                return super.parseExport(e, s2);
              }
            }
            isAbstractClass() {
              return this.isContextual(122) && this.lookahead().type === 80;
            }
            parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                let e = this.startNode();
                return this.next(), e.abstract = true, this.parseClass(e, true, true);
              }
              if (this.match(127)) {
                let e = this.tsParseInterfaceDeclaration(this.startNode());
                if (e)
                  return e;
              }
              return super.parseExportDefaultExpression();
            }
            parseVarStatement(e, s2) {
              let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: a2 } = this.state, n = super.parseVarStatement(e, s2, i || a2);
              if (!a2)
                return n;
              for (let { id: o, init: u } of n.declarations)
                u && (s2 !== "const" || o.typeAnnotation ? this.raise(I.InitializerNotAllowedInAmbientContext, { at: u }) : ph(u, this.hasPlugin("estree")) || this.raise(I.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: u }));
              return n;
            }
            parseStatementContent(e, s2) {
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                let i = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
              }
              if (this.isContextual(124))
                return this.tsParseEnumDeclaration(this.startNode());
              if (this.isContextual(127)) {
                let i = this.tsParseInterfaceDeclaration(this.startNode());
                if (i)
                  return i;
              }
              return super.parseStatementContent(e, s2);
            }
            parseAccessModifier() {
              return this.tsParseModifier(["public", "protected", "private"]);
            }
            tsHasSomeModifiers(e, s2) {
              return s2.some((i) => Hr(i) ? e.accessibility === i : !!e[i]);
            }
            tsIsStartOfStaticBlocks() {
              return this.isContextual(104) && this.lookaheadCharCode() === 123;
            }
            parseClassMember(e, s2, i) {
              let a2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
              this.tsParseModifiers({ allowedModifiers: a2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: I.InvalidModifierOnTypeParameterPositions }, s2);
              let n = () => {
                this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s2, a2) && this.raise(I.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e, s2)) : this.parseClassMemberWithIsStatic(e, s2, i, !!s2.static);
              };
              s2.declare ? this.tsInAmbientContext(n) : n();
            }
            parseClassMemberWithIsStatic(e, s2, i, a2) {
              let n = this.tsTryParseIndexSignature(s2);
              if (n) {
                e.body.push(n), s2.abstract && this.raise(I.IndexSignatureHasAbstract, { at: s2 }), s2.accessibility && this.raise(I.IndexSignatureHasAccessibility, { at: s2, modifier: s2.accessibility }), s2.declare && this.raise(I.IndexSignatureHasDeclare, { at: s2 }), s2.override && this.raise(I.IndexSignatureHasOverride, { at: s2 });
                return;
              }
              !this.state.inAbstractClass && s2.abstract && this.raise(I.NonAbstractClassHasAbstractMethod, { at: s2 }), s2.override && (i.hadSuperClass || this.raise(I.OverrideNotInSubClass, { at: s2 })), super.parseClassMemberWithIsStatic(e, s2, i, a2);
            }
            parsePostMemberNameModifiers(e) {
              this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(I.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(I.ClassMethodHasDeclare, { at: e });
            }
            parseExpressionStatement(e, s2, i) {
              return (s2.type === "Identifier" ? this.tsParseExpressionStatement(e, s2, i) : void 0) || super.parseExpressionStatement(e, s2, i);
            }
            shouldParseExportDeclaration() {
              return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
            }
            parseConditional(e, s2, i) {
              if (!this.state.maybeInArrowParameters || !this.match(17))
                return super.parseConditional(e, s2, i);
              let a2 = this.tryParse(() => super.parseConditional(e, s2));
              return a2.node ? (a2.error && (this.state = a2.failState), a2.node) : (a2.error && super.setOptionalParametersError(i, a2.error), e);
            }
            parseParenItem(e, s2) {
              if (e = super.parseParenItem(e, s2), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s2);
                return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
              }
              return e;
            }
            parseExportDeclaration(e) {
              if (!this.state.isAmbientContext && this.isContextual(123))
                return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
              let s2 = this.state.startLoc, i = this.eatContextual(123);
              if (i && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
                throw this.raise(I.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
              let n = q2(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
              return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s2), n.declare = true), n) : null;
            }
            parseClassId(e, s2, i, a2) {
              if ((!s2 || i) && this.isContextual(111))
                return;
              super.parseClassId(e, s2, i, e.declare ? br2 : vr);
              let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
              n && (e.typeParameters = n);
            }
            parseClassPropertyAnnotation(e) {
              e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
              let s2 = this.tsTryParseTypeAnnotation();
              s2 && (e.typeAnnotation = s2);
            }
            parseClassProperty(e) {
              if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(I.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
                let { key: s2 } = e;
                this.raise(I.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s2.type === "Identifier" && !e.computed ? s2.name : `[${this.input.slice(s2.start, s2.end)}]` });
              }
              return super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return e.abstract && this.raise(I.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(I.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
            }
            parseClassAccessorProperty(e) {
              return this.parseClassPropertyAnnotation(e), e.optional && this.raise(I.AccessorCannotBeOptional, { at: e }), super.parseClassAccessorProperty(e);
            }
            pushClassMethod(e, s2, i, a2, n, o) {
              let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              u && n && this.raise(I.ConstructorHasTypeParameters, { at: u });
              let { declare: c2 = false, kind: y } = s2;
              c2 && (y === "get" || y === "set") && this.raise(I.DeclareAccessor, { at: s2, kind: y }), u && (s2.typeParameters = u), super.pushClassMethod(e, s2, i, a2, n, o);
            }
            pushClassPrivateMethod(e, s2, i, a2) {
              let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              n && (s2.typeParameters = n), super.pushClassPrivateMethod(e, s2, i, a2);
            }
            declareClassPrivateMethodInScope(e, s2) {
              e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s2));
            }
            parseClassSuper(e) {
              super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e.implements = this.tsParseHeritageClause("implements"));
            }
            parseObjPropValue(e, s2, i, a2, n, o, u) {
              let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              return c2 && (e.typeParameters = c2), super.parseObjPropValue(e, s2, i, a2, n, o, u);
            }
            parseFunctionParams(e, s2) {
              let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
              i && (e.typeParameters = i), super.parseFunctionParams(e, s2);
            }
            parseVarId(e, s2) {
              super.parseVarId(e, s2), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
              let i = this.tsTryParseTypeAnnotation();
              i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s2) {
              return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s2);
            }
            parseMaybeAssign(e, s2) {
              var i, a2, n, o, u, c2, y;
              let g, T, C;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (g = this.state.clone(), T = this.tryParse(() => super.parseMaybeAssign(e, s2), g), !T.error)
                  return T.node;
                let { context: K } = this.state, W = K[K.length - 1];
                (W === x2.j_oTag || W === x2.j_expr) && K.pop();
              }
              if (!((i = T) != null && i.error) && !this.match(47))
                return super.parseMaybeAssign(e, s2);
              (!g || g === this.state) && (g = this.state.clone());
              let M, j = this.tryParse((K) => {
                var W, V;
                M = this.tsParseTypeParameters(this.tsParseConstModifier);
                let X = super.parseMaybeAssign(e, s2);
                return (X.type !== "ArrowFunctionExpression" || (W = X.extra) != null && W.parenthesized) && K(), ((V = M) == null ? void 0 : V.params.length) !== 0 && this.resetStartLocationFromNode(X, M), X.typeParameters = M, X;
              }, g);
              if (!j.error && !j.aborted)
                return M && this.reportReservedArrowTypeParam(M), j.node;
              if (!T && ($r(!this.hasPlugin("jsx")), C = this.tryParse(() => super.parseMaybeAssign(e, s2), g), !C.error))
                return C.node;
              if ((a2 = T) != null && a2.node)
                return this.state = T.failState, T.node;
              if (j.node)
                return this.state = j.failState, M && this.reportReservedArrowTypeParam(M), j.node;
              if ((n = C) != null && n.node)
                return this.state = C.failState, C.node;
              throw (o = T) != null && o.thrown ? T.error : j.thrown ? j.error : (u = C) != null && u.thrown ? C.error : ((c2 = T) == null ? void 0 : c2.error) || j.error || ((y = C) == null ? void 0 : y.error);
            }
            reportReservedArrowTypeParam(e) {
              var s2;
              e.params.length === 1 && !e.params[0].constraint && !((s2 = e.extra) != null && s2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(I.ReservedArrowTypeParam, { at: e });
            }
            parseMaybeUnary(e, s2) {
              return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s2);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s2 = this.tryParse((i) => {
                  let a2 = this.tsParseTypeOrTypePredicateAnnotation(14);
                  return (this.canInsertSemicolon() || !this.match(19)) && i(), a2;
                });
                if (s2.aborted)
                  return;
                s2.thrown || (s2.error && (this.state = s2.failState), e.returnType = s2.node);
              }
              return super.parseArrow(e);
            }
            parseAssignableListItemTypes(e, s2) {
              if (!(s2 & 2))
                return e;
              this.eat(17) && (e.optional = true);
              let i = this.tsTryParseTypeAnnotation();
              return i && (e.typeAnnotation = i), this.resetEndLocation(e), e;
            }
            isAssignable(e, s2) {
              switch (e.type) {
                case "TSTypeCastExpression":
                  return this.isAssignable(e.expression, s2);
                case "TSParameterProperty":
                  return true;
                default:
                  return super.isAssignable(e, s2);
              }
            }
            toAssignable(e) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              switch (e.type) {
                case "ParenthesizedExpression":
                  this.toAssignableParenthesizedExpression(e, s2);
                  break;
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  s2 ? this.expressionScope.recordArrowParameterBindingError(I.UnexpectedTypeCastInParameter, { at: e }) : this.raise(I.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s2);
                  break;
                case "AssignmentExpression":
                  !s2 && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
                default:
                  super.toAssignable(e, s2);
              }
            }
            toAssignableParenthesizedExpression(e, s2) {
              switch (e.expression.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  this.toAssignable(e.expression, s2);
                  break;
                default:
                  super.toAssignable(e, s2);
              }
            }
            checkToRestConversion(e, s2) {
              switch (e.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                  this.checkToRestConversion(e.expression, false);
                  break;
                default:
                  super.checkToRestConversion(e, s2);
              }
            }
            isValidLVal(e, s2, i) {
              return nh({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (i !== Pe || !s2) && ["expression", true], TSSatisfiesExpression: (i !== Pe || !s2) && ["expression", true], TSTypeAssertion: (i !== Pe || !s2) && ["expression", true] }, e) || super.isValidLVal(e, s2, i);
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseMaybeDecoratorArguments(e) {
              if (this.match(47) || this.match(51)) {
                let s2 = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                  let i = super.parseMaybeDecoratorArguments(e);
                  return i.typeParameters = s2, i;
                }
                this.unexpected(null, 10);
              }
              return super.parseMaybeDecoratorArguments(e);
            }
            checkCommaAfterRest(e) {
              return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(35) || this.match(14) || super.isClassProperty();
            }
            parseMaybeDefault(e, s2) {
              let i = super.parseMaybeDefault(e, s2);
              return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(I.TypeAnnotationAfterAssign, { at: i.typeAnnotation }), i;
            }
            getTokenFromCode(e) {
              if (this.state.inType) {
                if (e === 62) {
                  this.finishOp(48, 1);
                  return;
                }
                if (e === 60) {
                  this.finishOp(47, 1);
                  return;
                }
              }
              super.getTokenFromCode(e);
            }
            reScan_lt_gt() {
              let { type: e } = this.state;
              e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
            }
            reScan_lt() {
              let { type: e } = this.state;
              return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
            }
            toAssignableList(e, s2, i) {
              for (let a2 = 0; a2 < e.length; a2++) {
                let n = e[a2];
                (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[a2] = this.typeCastToParameter(n));
              }
              super.toAssignableList(e, s2, i);
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            shouldParseArrow(e) {
              return this.match(14) ? e.every((s2) => this.isAssignable(s2, true)) : super.shouldParseArrow(e);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            canHaveLeadingDecorator() {
              return super.canHaveLeadingDecorator() || this.isAbstractClass();
            }
            jsxParseOpeningElementAfterName(e) {
              if (this.match(47) || this.match(51)) {
                let s2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                s2 && (e.typeParameters = s2);
              }
              return super.jsxParseOpeningElementAfterName(e);
            }
            getGetterSetterExpectedParamCount(e) {
              let s2 = super.getGetterSetterExpectedParamCount(e), a2 = this.getObjectOrClassMethodParams(e)[0];
              return a2 && this.isThisParam(a2) ? s2 + 1 : s2;
            }
            parseCatchClauseParam() {
              let e = super.parseCatchClauseParam(), s2 = this.tsTryParseTypeAnnotation();
              return s2 && (e.typeAnnotation = s2, this.resetEndLocation(e)), e;
            }
            tsInAmbientContext(e) {
              let s2 = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return e();
              } finally {
                this.state.isAmbientContext = s2;
              }
            }
            parseClass(e, s2, i) {
              let a2 = this.state.inAbstractClass;
              this.state.inAbstractClass = !!e.abstract;
              try {
                return super.parseClass(e, s2, i);
              } finally {
                this.state.inAbstractClass = a2;
              }
            }
            tsParseAbstractDeclaration(e, s2) {
              if (this.match(80))
                return e.abstract = true, this.maybeTakeDecorators(s2, this.parseClass(e, true, false));
              if (this.isContextual(127)) {
                if (!this.hasFollowingLineBreak())
                  return e.abstract = true, this.raise(I.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
              } else
                this.unexpected(null, 80);
            }
            parseMethod(e, s2, i, a2, n, o, u) {
              let c2 = super.parseMethod(e, s2, i, a2, n, o, u);
              if (c2.abstract && (this.hasPlugin("estree") ? !!c2.value.body : !!c2.body)) {
                let { key: g } = c2;
                this.raise(I.AbstractMethodHasImplementation, { at: c2, methodName: g.type === "Identifier" && !c2.computed ? g.name : `[${this.input.slice(g.start, g.end)}]` });
              }
              return c2;
            }
            tsParseTypeParameterName() {
              return this.parseIdentifier().name;
            }
            shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
            parse() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
            }
            getExpression() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
            }
            parseExportSpecifier(e, s2, i, a2) {
              return !s2 && a2 ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s2, i, a2));
            }
            parseImportSpecifier(e, s2, i, a2, n) {
              return !s2 && a2 ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s2, i, a2, i ? Sr : Ve));
            }
            parseTypeOnlyImportExportSpecifier(e, s2, i) {
              let a2 = s2 ? "imported" : "local", n = s2 ? "local" : "exported", o = e[a2], u, c2 = false, y = true, g = o.loc.start;
              if (this.isContextual(93)) {
                let C = this.parseIdentifier();
                if (this.isContextual(93)) {
                  let M = this.parseIdentifier();
                  te2(this.state.type) ? (c2 = true, o = C, u = s2 ? this.parseIdentifier() : this.parseModuleExportName(), y = false) : (u = M, y = false);
                } else
                  te2(this.state.type) ? (y = false, u = s2 ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o = C);
              } else
                te2(this.state.type) && (c2 = true, s2 ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
              c2 && i && this.raise(s2 ? I.TypeModifierIsUsedInTypeImports : I.TypeModifierIsUsedInTypeExports, { at: g }), e[a2] = o, e[n] = u;
              let T = s2 ? "importKind" : "exportKind";
              e[T] = c2 ? "type" : "value", y && this.eatContextual(93) && (e[n] = s2 ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = me(e[a2])), s2 && this.checkIdentifier(e[n], c2 ? Sr : Ve);
            }
          };
          function ch(t) {
            if (t.type !== "MemberExpression")
              return false;
            let { computed: r, property: e } = t;
            return r && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : Vr(t.object);
          }
          function ph(t, r) {
            var e;
            let { type: s2 } = t;
            if ((e = t.extra) != null && e.parenthesized)
              return false;
            if (r) {
              if (s2 === "Literal") {
                let { value: i } = t;
                if (typeof i == "string" || typeof i == "boolean")
                  return true;
              }
            } else if (s2 === "StringLiteral" || s2 === "BooleanLiteral")
              return true;
            return !!(zr(t, r) || fh(t, r) || s2 === "TemplateLiteral" && t.expressions.length === 0 || ch(t));
          }
          function zr(t, r) {
            return r ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLiteral";
          }
          function fh(t, r) {
            if (t.type === "UnaryExpression") {
              let { operator: e, argument: s2 } = t;
              if (e === "-" && zr(s2, r))
                return true;
            }
            return false;
          }
          function Vr(t) {
            return t.type === "Identifier" ? true : t.type !== "MemberExpression" || t.computed ? false : Vr(t.object);
          }
          var Kr2 = pe`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), dh = (t) => class extends t {
            parsePlaceholder(e) {
              if (this.match(142)) {
                let s2 = this.startNode();
                return this.next(), this.assertNoSpace(), s2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(s2, e);
              }
            }
            finishPlaceholder(e, s2) {
              let i = !!(e.expectedNode && e.type === "Placeholder");
              return e.expectedNode = s2, i ? e : this.finishNode(e, "Placeholder");
            }
            getTokenFromCode(e) {
              e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(e);
            }
            parseExprAtom(e) {
              return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
            }
            parseIdentifier(e) {
              return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
            }
            checkReservedWord(e, s2, i, a2) {
              e !== void 0 && super.checkReservedWord(e, s2, i, a2);
            }
            parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
            }
            isValidLVal(e, s2, i) {
              return e === "Placeholder" || super.isValidLVal(e, s2, i);
            }
            toAssignable(e, s2) {
              e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s2);
            }
            chStartsBindingIdentifier(e, s2) {
              return !!(super.chStartsBindingIdentifier(e, s2) || this.lookahead().type === 142);
            }
            verifyBreakContinue(e, s2) {
              e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s2);
            }
            parseExpressionStatement(e, s2) {
              if (s2.type !== "Placeholder" || s2.extra && s2.extra.parenthesized)
                return super.parseExpressionStatement(e, s2);
              if (this.match(14)) {
                let i = e;
                return i.label = this.finishPlaceholder(s2, "Identifier"), this.next(), i.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(i, "LabeledStatement");
              }
              return this.semicolon(), e.name = s2.name, this.finishPlaceholder(e, "Statement");
            }
            parseBlock(e, s2, i) {
              return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s2, i);
            }
            parseFunctionId(e) {
              return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
            }
            parseClass(e, s2, i) {
              let a2 = s2 ? "ClassDeclaration" : "ClassExpression";
              this.next();
              let n = this.state.strict, o = this.parsePlaceholder("Identifier");
              if (o)
                if (this.match(81) || this.match(142) || this.match(5))
                  e.id = o;
                else {
                  if (i || !s2)
                    return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, a2);
                  throw this.raise(Kr2.ClassNameIsRequired, { at: this.state.startLoc });
                }
              else
                this.parseClassId(e, s2, i);
              return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, a2);
            }
            parseExport(e, s2) {
              let i = this.parsePlaceholder("Identifier");
              if (!i)
                return super.parseExport(e, s2);
              if (!this.isContextual(97) && !this.match(12))
                return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
              this.expectPlugin("exportDefaultFrom");
              let a2 = this.startNode();
              return a2.exported = i, e.specifiers = [this.finishNode(a2, "ExportDefaultSpecifier")], super.parseExport(e, s2);
            }
            isExportDefaultSpecifier() {
              if (this.match(65)) {
                let e = this.nextTokenStart();
                if (this.isUnparsedContextual(e, "from") && this.input.startsWith(xe(142), this.nextTokenStartSince(e + 4)))
                  return true;
              }
              return super.isExportDefaultSpecifier();
            }
            maybeParseExportDefaultSpecifier(e) {
              return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(e);
            }
            checkExport(e) {
              let { specifiers: s2 } = e;
              s2 != null && s2.length && (e.specifiers = s2.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s2;
            }
            parseImport(e) {
              let s2 = this.parsePlaceholder("Identifier");
              if (!s2)
                return super.parseImport(e);
              if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
                return e.source = this.finishPlaceholder(s2, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
              let i = this.startNodeAtNode(s2);
              return i.local = s2, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
            }
            parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
            }
            assertNoSpace() {
              this.state.start > this.state.lastTokEndLoc.index && this.raise(Kr2.UnexpectedSpace, { at: this.state.lastTokEndLoc });
            }
          }, mh = (t) => class extends t {
            parseV8Intrinsic() {
              if (this.match(54)) {
                let e = this.state.startLoc, s2 = this.startNode();
                if (this.next(), q2(this.state.type)) {
                  let i = this.parseIdentifierName(), a2 = this.createIdentifier(s2, i);
                  if (a2.type = "V8IntrinsicIdentifier", this.match(10))
                    return a2;
                }
                this.unexpected(e);
              }
            }
            parseExprAtom(e) {
              return this.parseV8Intrinsic() || super.parseExprAtom(e);
            }
          };
          function J(t, r) {
            let [e, s2] = typeof r == "string" ? [r, {}] : r, i = Object.keys(s2), a2 = i.length === 0;
            return t.some((n) => {
              if (typeof n == "string")
                return a2 && n === e;
              {
                let [o, u] = n;
                if (o !== e)
                  return false;
                for (let c2 of i)
                  if (u[c2] !== s2[c2])
                    return false;
                return true;
              }
            });
          }
          function we(t, r, e) {
            let s2 = t.find((i) => Array.isArray(i) ? i[0] === r : i === r);
            return s2 && Array.isArray(s2) && s2.length > 1 ? s2[1][e] : null;
          }
          var Wr2 = ["minimal", "fsharp", "hack", "smart"], Gr2 = ["^^", "@@", "^", "%", "#"], Jr2 = ["hash", "bar"];
          function yh(t) {
            if (J(t, "decorators")) {
              if (J(t, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              let r = we(t, "decorators", "decoratorsBeforeExport");
              if (r != null && typeof r != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              let e = we(t, "decorators", "allowCallParenthesized");
              if (e != null && typeof e != "boolean")
                throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (J(t, "flow") && J(t, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (J(t, "placeholders") && J(t, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (J(t, "pipelineOperator")) {
              let r = we(t, "pipelineOperator", "proposal");
              if (!Wr2.includes(r)) {
                let s2 = Wr2.map((i) => `"${i}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s2}.`);
              }
              let e = J(t, ["recordAndTuple", { syntaxType: "hash" }]);
              if (r === "hack") {
                if (J(t, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (J(t, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                let s2 = we(t, "pipelineOperator", "topicToken");
                if (!Gr2.includes(s2)) {
                  let i = Gr2.map((a2) => `"${a2}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
                }
                if (s2 === "#" && e)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (r === "smart" && e)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (J(t, "moduleAttributes")) {
              if (J(t, "importAssertions"))
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (we(t, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (J(t, "recordAndTuple") && we(t, "recordAndTuple", "syntaxType") != null && !Jr2.includes(we(t, "recordAndTuple", "syntaxType")))
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Jr2.map((r) => `'${r}'`).join(", "));
            if (J(t, "asyncDoExpressions") && !J(t, "doExpressions")) {
              let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw r.missingPlugins = "doExpressions", r;
            }
          }
          var Xr2 = { estree: el, jsx: th, flow: Zl, typescript: uh, v8intrinsic: mh, placeholders: dh }, xh = Object.keys(Xr2), gh = class extends ah {
            checkProto(t, r, e, s2) {
              if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
                return;
              let i = t.key;
              if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
                if (r) {
                  this.raise(f.RecordNoProto, { at: i });
                  return;
                }
                e.used && (s2 ? s2.doubleProtoLoc === null && (s2.doubleProtoLoc = i.loc.start) : this.raise(f.DuplicateProto, { at: i })), e.used = true;
              }
            }
            shouldExitDescending(t, r) {
              return t.type === "ArrowFunctionExpression" && t.start === r;
            }
            getExpression() {
              this.enterInitialScopes(), this.nextToken();
              let t = this.parseExpression();
              return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
            }
            parseExpression(t, r) {
              return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
            }
            parseExpressionBase(t) {
              let r = this.state.startLoc, e = this.parseMaybeAssign(t);
              if (this.match(12)) {
                let s2 = this.startNodeAt(r);
                for (s2.expressions = [e]; this.eat(12); )
                  s2.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(s2.expressions), this.finishNode(s2, "SequenceExpression");
              }
              return e;
            }
            parseMaybeAssignDisallowIn(t, r) {
              return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
            }
            parseMaybeAssignAllowIn(t, r) {
              return this.allowInAnd(() => this.parseMaybeAssign(t, r));
            }
            setOptionalParametersError(t, r) {
              var e;
              t.optionalParametersLoc = (e = r == null ? void 0 : r.loc) != null ? e : this.state.startLoc;
            }
            parseMaybeAssign(t, r) {
              let e = this.state.startLoc;
              if (this.isContextual(106) && this.prodParam.hasYield) {
                let n = this.parseYield();
                return r && (n = r.call(this, n, e)), n;
              }
              let s2;
              t ? s2 = false : (t = new vt2(), s2 = true);
              let { type: i } = this.state;
              (i === 10 || q2(i)) && (this.state.potentialArrowAt = this.state.start);
              let a2 = this.parseMaybeConditional(t);
              if (r && (a2 = r.call(this, a2, e)), Bo2(this.state.type)) {
                let n = this.startNodeAt(e), o = this.state.value;
                if (n.operator = o, this.match(29)) {
                  this.toAssignable(a2, true), n.left = a2;
                  let u = e.index;
                  t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
                } else
                  n.left = a2;
                return this.next(), n.right = this.parseMaybeAssign(), this.checkLVal(a2, { in: this.finishNode(n, "AssignmentExpression") }), n;
              } else
                s2 && this.checkExpressionErrors(t, true);
              return a2;
            }
            parseMaybeConditional(t) {
              let r = this.state.startLoc, e = this.state.potentialArrowAt, s2 = this.parseExprOps(t);
              return this.shouldExitDescending(s2, e) ? s2 : this.parseConditional(s2, r, t);
            }
            parseConditional(t, r, e) {
              if (this.eat(17)) {
                let s2 = this.startNodeAt(r);
                return s2.test = t, s2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s2.alternate = this.parseMaybeAssign(), this.finishNode(s2, "ConditionalExpression");
              }
              return t;
            }
            parseMaybeUnaryOrPrivate(t) {
              return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t);
            }
            parseExprOps(t) {
              let r = this.state.startLoc, e = this.state.potentialArrowAt, s2 = this.parseMaybeUnaryOrPrivate(t);
              return this.shouldExitDescending(s2, e) ? s2 : this.parseExprOp(s2, r, -1);
            }
            parseExprOp(t, r, e) {
              if (this.isPrivateName(t)) {
                let i = this.getPrivateNameSV(t);
                (e >= at2(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(f.PrivateInExpectedIn, { at: t, identifierName: i }), this.classScope.usePrivateName(i, t.loc.start);
              }
              let s2 = this.state.type;
              if (_o(s2) && (this.prodParam.hasIn || !this.match(58))) {
                let i = at2(s2);
                if (i > e) {
                  if (s2 === 39) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                      return t;
                    this.checkPipelineAtInfixOperator(t, r);
                  }
                  let a2 = this.startNodeAt(r);
                  a2.left = t, a2.operator = this.state.value;
                  let n = s2 === 41 || s2 === 42, o = s2 === 40;
                  if (o && (i = at2(42)), this.next(), s2 === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                    throw this.raise(f.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                  a2.right = this.parseExprOpRightExpr(s2, i);
                  let u = this.finishNode(a2, n || o ? "LogicalExpression" : "BinaryExpression"), c2 = this.state.type;
                  if (o && (c2 === 41 || c2 === 42) || n && c2 === 40)
                    throw this.raise(f.MixingCoalesceWithLogical, { at: this.state.startLoc });
                  return this.parseExprOp(u, r, e);
                }
              }
              return t;
            }
            parseExprOpRightExpr(t, r) {
              let e = this.state.startLoc;
              switch (t) {
                case 39:
                  switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "hack":
                      return this.withTopicBindingContext(() => this.parseHackPipeBody());
                    case "smart":
                      return this.withTopicBindingContext(() => {
                        if (this.prodParam.hasYield && this.isContextual(106))
                          throw this.raise(f.PipeBodyIsTighter, { at: this.state.startLoc });
                        return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), e);
                      });
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
                  }
                default:
                  return this.parseExprOpBaseRightExpr(t, r);
              }
            }
            parseExprOpBaseRightExpr(t, r) {
              let e = this.state.startLoc;
              return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, $o(t) ? r - 1 : r);
            }
            parseHackPipeBody() {
              var t;
              let { startLoc: r } = this.state, e = this.parseMaybeAssign();
              return Go.has(e.type) && !((t = e.extra) != null && t.parenthesized) && this.raise(f.PipeUnparenthesizedBody, { at: r, type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(f.PipeTopicUnused, { at: r }), e;
            }
            checkExponentialAfterUnary(t) {
              this.match(57) && this.raise(f.UnexpectedTokenUnaryExponentiation, { at: t.argument });
            }
            parseMaybeUnary(t, r) {
              let e = this.state.startLoc, s2 = this.isContextual(96);
              if (s2 && this.isAwaitAllowed()) {
                this.next();
                let o = this.parseAwait(e);
                return r || this.checkExponentialAfterUnary(o), o;
              }
              let i = this.match(34), a2 = this.startNode();
              if (jo(this.state.type)) {
                a2.operator = this.state.value, a2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
                let o = this.match(89);
                if (this.next(), a2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && o) {
                  let u = a2.argument;
                  u.type === "Identifier" ? this.raise(f.StrictDelete, { at: a2 }) : this.hasPropertyAsPrivateName(u) && this.raise(f.DeletePrivateField, { at: a2 });
                }
                if (!i)
                  return r || this.checkExponentialAfterUnary(a2), this.finishNode(a2, "UnaryExpression");
              }
              let n = this.parseUpdate(a2, i, t);
              if (s2) {
                let { type: o } = this.state;
                if ((this.hasPlugin("v8intrinsic") ? He(o) : He(o) && !this.match(54)) && !this.isAmbiguousAwait())
                  return this.raiseOverwrite(f.AwaitNotInAsyncContext, { at: e }), this.parseAwait(e);
              }
              return n;
            }
            parseUpdate(t, r, e) {
              if (r) {
                let a2 = t;
                return this.checkLVal(a2.argument, { in: this.finishNode(a2, "UpdateExpression") }), t;
              }
              let s2 = this.state.startLoc, i = this.parseExprSubscripts(e);
              if (this.checkExpressionErrors(e, false))
                return i;
              for (; Ro(this.state.type) && !this.canInsertSemicolon(); ) {
                let a2 = this.startNodeAt(s2);
                a2.operator = this.state.value, a2.prefix = false, a2.argument = i, this.next(), this.checkLVal(i, { in: i = this.finishNode(a2, "UpdateExpression") });
              }
              return i;
            }
            parseExprSubscripts(t) {
              let r = this.state.startLoc, e = this.state.potentialArrowAt, s2 = this.parseExprAtom(t);
              return this.shouldExitDescending(s2, e) ? s2 : this.parseSubscripts(s2, r);
            }
            parseSubscripts(t, r, e) {
              let s2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
              do
                t = this.parseSubscript(t, r, e, s2), s2.maybeAsyncArrow = false;
              while (!s2.stop);
              return t;
            }
            parseSubscript(t, r, e, s2) {
              let { type: i } = this.state;
              if (!e && i === 15)
                return this.parseBind(t, r, e, s2);
              if (nt(i))
                return this.parseTaggedTemplateExpression(t, r, s2);
              let a2 = false;
              if (i === 18) {
                if (e && (this.raise(f.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40))
                  return s2.stop = true, t;
                s2.optionalChainMember = a2 = true, this.next();
              }
              if (!e && this.match(10))
                return this.parseCoverCallAndAsyncArrowHead(t, r, s2, a2);
              {
                let n = this.eat(0);
                return n || a2 || this.eat(16) ? this.parseMember(t, r, s2, n, a2) : (s2.stop = true, t);
              }
            }
            parseMember(t, r, e, s2, i) {
              let a2 = this.startNodeAt(r);
              return a2.object = t, a2.computed = s2, s2 ? (a2.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t.type === "Super" && this.raise(f.SuperPrivateField, { at: r }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a2.property = this.parsePrivateName()) : a2.property = this.parseIdentifier(true), e.optionalChainMember ? (a2.optional = i, this.finishNode(a2, "OptionalMemberExpression")) : this.finishNode(a2, "MemberExpression");
            }
            parseBind(t, r, e, s2) {
              let i = this.startNodeAt(r);
              return i.object = t, this.next(), i.callee = this.parseNoCallExpr(), s2.stop = true, this.parseSubscripts(this.finishNode(i, "BindExpression"), r, e);
            }
            parseCoverCallAndAsyncArrowHead(t, r, e, s2) {
              let i = this.state.maybeInArrowParameters, a2 = null;
              this.state.maybeInArrowParameters = true, this.next();
              let n = this.startNodeAt(r);
              n.callee = t;
              let { maybeAsyncArrow: o, optionalChainMember: u } = e;
              o && (this.expressionScope.enter($l()), a2 = new vt2()), u && (n.optional = s2), s2 ? n.arguments = this.parseCallExpressionArguments(11) : n.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", n, a2);
              let c2 = this.finishCallExpression(n, u);
              return o && this.shouldParseAsyncArrow() && !s2 ? (e.stop = true, this.checkDestructuringPrivate(a2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c2)) : (o && (this.checkExpressionErrors(a2, true), this.expressionScope.exit()), this.toReferencedArguments(c2)), this.state.maybeInArrowParameters = i, c2;
            }
            toReferencedArguments(t, r) {
              this.toReferencedListDeep(t.arguments, r);
            }
            parseTaggedTemplateExpression(t, r, e) {
              let s2 = this.startNodeAt(r);
              return s2.tag = t, s2.quasi = this.parseTemplate(true), e.optionalChainMember && this.raise(f.OptionalChainingNoTemplate, { at: r }), this.finishNode(s2, "TaggedTemplateExpression");
            }
            atPossibleAsyncArrow(t) {
              return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
            }
            finishCallExpression(t, r) {
              if (t.callee.type === "Import")
                if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t.arguments.length === 0 || t.arguments.length > 2)
                  this.raise(f.ImportCallArity, { at: t, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
                else
                  for (let e of t.arguments)
                    e.type === "SpreadElement" && this.raise(f.ImportCallSpreadArgument, { at: e });
              return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
            }
            parseCallExpressionArguments(t, r, e, s2, i) {
              let a2 = [], n = true, o = this.state.inFSharpPipelineDirectBody;
              for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
                if (n)
                  n = false;
                else if (this.expect(12), this.match(t)) {
                  r && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(f.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), s2 && this.addTrailingCommaExtraToNode(s2), this.next();
                  break;
                }
                a2.push(this.parseExprListItem(false, i, e));
              }
              return this.state.inFSharpPipelineDirectBody = o, a2;
            }
            shouldParseAsyncArrow() {
              return this.match(19) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(t, r) {
              var e;
              return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, true, (e = r.extra) == null ? void 0 : e.trailingCommaLoc), r.innerComments && Ke2(t, r.innerComments), r.callee.trailingComments && Ke2(t, r.callee.trailingComments), t;
            }
            parseNoCallExpr() {
              let t = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), t, true);
            }
            parseExprAtom(t) {
              let r, e = null, { type: s2 } = this.state;
              switch (s2) {
                case 79:
                  return this.parseSuper();
                case 83:
                  return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : (this.match(10) || this.raise(f.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(r, "Import"));
                case 78:
                  return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
                case 90:
                  return this.parseDo(this.startNode(), false);
                case 56:
                case 31:
                  return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                case 132:
                  return this.parseNumericLiteral(this.state.value);
                case 133:
                  return this.parseBigIntLiteral(this.state.value);
                case 134:
                  return this.parseDecimalLiteral(this.state.value);
                case 131:
                  return this.parseStringLiteral(this.state.value);
                case 84:
                  return this.parseNullLiteral();
                case 85:
                  return this.parseBooleanLiteral(true);
                case 86:
                  return this.parseBooleanLiteral(false);
                case 10: {
                  let i = this.state.potentialArrowAt === this.state.start;
                  return this.parseParenAndDistinguishExpression(i);
                }
                case 2:
                case 1:
                  return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                case 0:
                  return this.parseArrayLike(3, true, false, t);
                case 6:
                case 7:
                  return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                case 5:
                  return this.parseObjectLike(8, false, false, t);
                case 68:
                  return this.parseFunctionOrFunctionSent();
                case 26:
                  e = this.parseDecorators();
                case 80:
                  return this.parseClass(this.maybeTakeDecorators(e, this.startNode()), false);
                case 77:
                  return this.parseNewOrNewTarget();
                case 25:
                case 24:
                  return this.parseTemplate(false);
                case 15: {
                  r = this.startNode(), this.next(), r.object = null;
                  let i = r.callee = this.parseNoCallExpr();
                  if (i.type === "MemberExpression")
                    return this.finishNode(r, "BindExpression");
                  throw this.raise(f.UnsupportedBind, { at: i });
                }
                case 136:
                  return this.raise(f.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
                case 33:
                  return this.parseTopicReferenceThenEqualsSign(54, "%");
                case 32:
                  return this.parseTopicReferenceThenEqualsSign(44, "^");
                case 37:
                case 38:
                  return this.parseTopicReference("hack");
                case 44:
                case 54:
                case 27: {
                  let i = this.getPluginOption("pipelineOperator", "proposal");
                  if (i)
                    return this.parseTopicReference(i);
                  this.unexpected();
                  break;
                }
                case 47: {
                  let i = this.input.codePointAt(this.nextTokenStart());
                  fe(i) || i === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                  break;
                }
                default:
                  if (q2(s2)) {
                    if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                      return this.parseModuleExpression();
                    let i = this.state.potentialArrowAt === this.state.start, a2 = this.state.containsEsc, n = this.parseIdentifier();
                    if (!a2 && n.name === "async" && !this.canInsertSemicolon()) {
                      let { type: o } = this.state;
                      if (o === 68)
                        return this.resetPreviousNodeTrailingComments(n), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n));
                      if (q2(o))
                        return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n)) : n;
                      if (o === 90)
                        return this.resetPreviousNodeTrailingComments(n), this.parseDo(this.startNodeAtNode(n), true);
                    }
                    return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [n], false)) : n;
                  } else
                    this.unexpected();
              }
            }
            parseTopicReferenceThenEqualsSign(t, r) {
              let e = this.getPluginOption("pipelineOperator", "proposal");
              if (e)
                return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Y(this.state.endLoc, -1), this.parseTopicReference(e);
              this.unexpected();
            }
            parseTopicReference(t) {
              let r = this.startNode(), e = this.state.startLoc, s2 = this.state.type;
              return this.next(), this.finishTopicReference(r, e, t, s2);
            }
            finishTopicReference(t, r, e, s2) {
              if (this.testTopicReferenceConfiguration(e, r, s2)) {
                let i = e === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                return this.topicReferenceIsAllowedInCurrentContext() || this.raise(e === "smart" ? f.PrimaryTopicNotAllowed : f.PipeTopicUnbound, { at: r }), this.registerTopicReference(), this.finishNode(t, i);
              } else
                throw this.raise(f.PipeTopicUnconfiguredToken, { at: r, token: xe(s2) });
            }
            testTopicReferenceConfiguration(t, r, e) {
              switch (t) {
                case "hack":
                  return this.hasPlugin(["pipelineOperator", { topicToken: xe(e) }]);
                case "smart":
                  return e === 27;
                default:
                  throw this.raise(f.PipeTopicRequiresHackPipes, { at: r });
              }
            }
            parseAsyncArrowUnaryFunction(t) {
              this.prodParam.enter(Tt2(true, this.prodParam.hasYield));
              let r = [this.parseIdentifier()];
              return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(f.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t, r, true);
            }
            parseDo(t, r) {
              this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
              let e = this.state.labels;
              return this.state.labels = [], r ? (this.prodParam.enter(At2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = e, this.finishNode(t, "DoExpression");
            }
            parseSuper() {
              let t = this.startNode();
              return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(f.SuperNotAllowed, { at: t }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(f.UnexpectedSuper, { at: t }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(f.UnsupportedSuper, { at: t }), this.finishNode(t, "Super");
            }
            parsePrivateName() {
              let t = this.startNode(), r = this.startNodeAt(Y(this.state.startLoc, 1)), e = this.state.value;
              return this.next(), t.id = this.createIdentifier(r, e), this.finishNode(t, "PrivateName");
            }
            parseFunctionOrFunctionSent() {
              let t = this.startNode();
              if (this.next(), this.prodParam.hasYield && this.match(16)) {
                let r = this.createIdentifier(this.startNodeAtNode(t), "function");
                return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
              }
              return this.parseFunction(t);
            }
            parseMetaProperty(t, r, e) {
              t.meta = r;
              let s2 = this.state.containsEsc;
              return t.property = this.parseIdentifier(true), (t.property.name !== e || s2) && this.raise(f.UnsupportedMetaProperty, { at: t.property, target: r.name, onlyValidPropertyName: e }), this.finishNode(t, "MetaProperty");
            }
            parseImportMetaProperty(t) {
              let r = this.createIdentifier(this.startNodeAtNode(t), "import");
              return this.next(), this.isContextual(100) && (this.inModule || this.raise(f.ImportMetaOutsideModule, { at: r }), this.sawUnambiguousESM = true), this.parseMetaProperty(t, r, "meta");
            }
            parseLiteralAtNode(t, r, e) {
              return this.addExtra(e, "rawValue", t), this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.value = t, this.next(), this.finishNode(e, r);
            }
            parseLiteral(t, r) {
              let e = this.startNode();
              return this.parseLiteralAtNode(t, r, e);
            }
            parseStringLiteral(t) {
              return this.parseLiteral(t, "StringLiteral");
            }
            parseNumericLiteral(t) {
              return this.parseLiteral(t, "NumericLiteral");
            }
            parseBigIntLiteral(t) {
              return this.parseLiteral(t, "BigIntLiteral");
            }
            parseDecimalLiteral(t) {
              return this.parseLiteral(t, "DecimalLiteral");
            }
            parseRegExpLiteral(t) {
              let r = this.parseLiteral(t.value, "RegExpLiteral");
              return r.pattern = t.pattern, r.flags = t.flags, r;
            }
            parseBooleanLiteral(t) {
              let r = this.startNode();
              return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
            }
            parseNullLiteral() {
              let t = this.startNode();
              return this.next(), this.finishNode(t, "NullLiteral");
            }
            parseParenAndDistinguishExpression(t) {
              let r = this.state.startLoc, e;
              this.next(), this.expressionScope.enter(Ul());
              let s2 = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
              this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
              let a2 = this.state.startLoc, n = [], o = new vt2(), u = true, c2, y;
              for (; !this.match(11); ) {
                if (u)
                  u = false;
                else if (this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc), this.match(11)) {
                  y = this.state.startLoc;
                  break;
                }
                if (this.match(21)) {
                  let C = this.state.startLoc;
                  if (c2 = this.state.startLoc, n.push(this.parseParenItem(this.parseRestBinding(), C)), !this.checkCommaAfterRest(41))
                    break;
                } else
                  n.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
              }
              let g = this.state.lastTokEndLoc;
              this.expect(11), this.state.maybeInArrowParameters = s2, this.state.inFSharpPipelineDirectBody = i;
              let T = this.startNodeAt(r);
              return t && this.shouldParseArrow(n) && (T = this.parseArrow(T)) ? (this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(T, n, false), T) : (this.expressionScope.exit(), n.length || this.unexpected(this.state.lastTokStartLoc), y && this.unexpected(y), c2 && this.unexpected(c2), this.checkExpressionErrors(o, true), this.toReferencedListDeep(n, true), n.length > 1 ? (e = this.startNodeAt(a2), e.expressions = n, this.finishNode(e, "SequenceExpression"), this.resetEndLocation(e, g)) : e = n[0], this.wrapParenthesis(r, e));
            }
            wrapParenthesis(t, r) {
              if (!this.options.createParenthesizedExpressions)
                return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
              let e = this.startNodeAt(t);
              return e.expression = r, this.finishNode(e, "ParenthesizedExpression");
            }
            shouldParseArrow(t) {
              return !this.canInsertSemicolon();
            }
            parseArrow(t) {
              if (this.eat(19))
                return t;
            }
            parseParenItem(t, r) {
              return t;
            }
            parseNewOrNewTarget() {
              let t = this.startNode();
              if (this.next(), this.match(16)) {
                let r = this.createIdentifier(this.startNodeAtNode(t), "new");
                this.next();
                let e = this.parseMetaProperty(t, r, "target");
                return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(f.UnexpectedNewTarget, { at: e }), e;
              }
              return this.parseNew(t);
            }
            parseNew(t) {
              if (this.parseNewCallee(t), this.eat(10)) {
                let r = this.parseExprList(11);
                this.toReferencedList(r), t.arguments = r;
              } else
                t.arguments = [];
              return this.finishNode(t, "NewExpression");
            }
            parseNewCallee(t) {
              t.callee = this.parseNoCallExpr(), t.callee.type === "Import" && this.raise(f.ImportCallNotNewExpression, { at: t.callee });
            }
            parseTemplateElement(t) {
              let { start: r, startLoc: e, end: s2, value: i } = this.state, a2 = r + 1, n = this.startNodeAt(Y(e, 1));
              i === null && (t || this.raise(f.InvalidEscapeSequenceTemplate, { at: Y(this.state.firstInvalidTemplateEscapePos, 1) }));
              let o = this.match(24), u = o ? -1 : -2, c2 = s2 + u;
              n.value = { raw: this.input.slice(a2, c2).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, u) }, n.tail = o, this.next();
              let y = this.finishNode(n, "TemplateElement");
              return this.resetEndLocation(y, Y(this.state.lastTokEndLoc, u)), y;
            }
            parseTemplate(t) {
              let r = this.startNode();
              r.expressions = [];
              let e = this.parseTemplateElement(t);
              for (r.quasis = [e]; !e.tail; )
                r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(e = this.parseTemplateElement(t));
              return this.finishNode(r, "TemplateLiteral");
            }
            parseTemplateSubstitution() {
              return this.parseExpression();
            }
            parseObjectLike(t, r, e, s2) {
              e && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a2 = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
              for (o.properties = [], this.next(); !this.match(t); ) {
                if (n)
                  n = false;
                else if (this.expect(12), this.match(t)) {
                  this.addTrailingCommaExtraToNode(o);
                  break;
                }
                let c2;
                r ? c2 = this.parseBindingProperty() : (c2 = this.parsePropertyDefinition(s2), this.checkProto(c2, e, a2, s2)), e && !this.isObjectProperty(c2) && c2.type !== "SpreadElement" && this.raise(f.InvalidRecordProperty, { at: c2 }), c2.shorthand && this.addExtra(c2, "shorthand", true), o.properties.push(c2);
              }
              this.next(), this.state.inFSharpPipelineDirectBody = i;
              let u = "ObjectExpression";
              return r ? u = "ObjectPattern" : e && (u = "RecordExpression"), this.finishNode(o, u);
            }
            addTrailingCommaExtraToNode(t) {
              this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
            }
            maybeAsyncOrAccessorProp(t) {
              return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
            }
            parsePropertyDefinition(t) {
              let r = [];
              if (this.match(26))
                for (this.hasPlugin("decorators") && this.raise(f.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                  r.push(this.parseDecorator());
              let e = this.startNode(), s2 = false, i = false, a2;
              if (this.match(21))
                return r.length && this.unexpected(), this.parseSpread();
              r.length && (e.decorators = r, r = []), e.method = false, t && (a2 = this.state.startLoc);
              let n = this.eat(55);
              this.parsePropertyNamePrefixOperator(e);
              let o = this.state.containsEsc, u = this.parsePropertyName(e, t);
              if (!n && !o && this.maybeAsyncOrAccessorProp(e)) {
                let c2 = u.name;
                c2 === "async" && !this.hasPrecedingLineBreak() && (s2 = true, this.resetPreviousNodeTrailingComments(u), n = this.eat(55), this.parsePropertyName(e)), (c2 === "get" || c2 === "set") && (i = true, this.resetPreviousNodeTrailingComments(u), e.kind = c2, this.match(55) && (n = true, this.raise(f.AccessorIsGenerator, { at: this.state.curPosition(), kind: c2 }), this.next()), this.parsePropertyName(e));
              }
              return this.parseObjPropValue(e, a2, n, s2, false, i, t);
            }
            getGetterSetterExpectedParamCount(t) {
              return t.kind === "get" ? 0 : 1;
            }
            getObjectOrClassMethodParams(t) {
              return t.params;
            }
            checkGetterSetterParams(t) {
              var r;
              let e = this.getGetterSetterExpectedParamCount(t), s2 = this.getObjectOrClassMethodParams(t);
              s2.length !== e && this.raise(t.kind === "get" ? f.BadGetterArity : f.BadSetterArity, { at: t }), t.kind === "set" && ((r = s2[s2.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(f.BadSetterRestParameter, { at: t });
            }
            parseObjectMethod(t, r, e, s2, i) {
              if (i) {
                let a2 = this.parseMethod(t, r, false, false, false, "ObjectMethod");
                return this.checkGetterSetterParams(a2), a2;
              }
              if (e || r || this.match(10))
                return s2 && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, r, e, false, false, "ObjectMethod");
            }
            parseObjectProperty(t, r, e, s2) {
              if (t.shorthand = false, this.eat(14))
                return t.value = e ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s2), this.finishNode(t, "ObjectProperty");
              if (!t.computed && t.key.type === "Identifier") {
                if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), e)
                  t.value = this.parseMaybeDefault(r, me(t.key));
                else if (this.match(29)) {
                  let i = this.state.startLoc;
                  s2 != null ? s2.shorthandAssignLoc === null && (s2.shorthandAssignLoc = i) : this.raise(f.InvalidCoverInitializedName, { at: i }), t.value = this.parseMaybeDefault(r, me(t.key));
                } else
                  t.value = me(t.key);
                return t.shorthand = true, this.finishNode(t, "ObjectProperty");
              }
            }
            parseObjPropValue(t, r, e, s2, i, a2, n) {
              let o = this.parseObjectMethod(t, e, s2, i, a2) || this.parseObjectProperty(t, r, i, n);
              return o || this.unexpected(), o;
            }
            parsePropertyName(t, r) {
              if (this.eat(0))
                t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
              else {
                let { type: e, value: s2 } = this.state, i;
                if (te2(e))
                  i = this.parseIdentifier(true);
                else
                  switch (e) {
                    case 132:
                      i = this.parseNumericLiteral(s2);
                      break;
                    case 131:
                      i = this.parseStringLiteral(s2);
                      break;
                    case 133:
                      i = this.parseBigIntLiteral(s2);
                      break;
                    case 134:
                      i = this.parseDecimalLiteral(s2);
                      break;
                    case 136: {
                      let a2 = this.state.startLoc;
                      r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a2) : this.raise(f.UnexpectedPrivateField, { at: a2 }), i = this.parsePrivateName();
                      break;
                    }
                    default:
                      this.unexpected();
                  }
                t.key = i, e !== 136 && (t.computed = false);
              }
              return t.key;
            }
            initFunction(t, r) {
              t.id = null, t.generator = false, t.async = r;
            }
            parseMethod(t, r, e, s2, i, a2) {
              let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              this.initFunction(t, e), t.generator = r, this.scope.enter(de | ht2 | (n ? Ee : 0) | (i ? Pr2 : 0)), this.prodParam.enter(Tt2(e, t.generator)), this.parseFunctionParams(t, s2);
              let o = this.parseFunctionBodyAndFinish(t, a2, true);
              return this.prodParam.exit(), this.scope.exit(), o;
            }
            parseArrayLike(t, r, e, s2) {
              e && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a2 = this.startNode();
              return this.next(), a2.elements = this.parseExprList(t, !e, s2, a2), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a2, e ? "TupleExpression" : "ArrayExpression");
            }
            parseArrowExpression(t, r, e, s2) {
              this.scope.enter(de | Gt2);
              let i = Tt2(e, false);
              !this.match(5) && this.prodParam.hasIn && (i |= _e), this.prodParam.enter(i), this.initFunction(t, e);
              let a2 = this.state.maybeInArrowParameters;
              return r && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, r, s2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(t, "ArrowFunctionExpression");
            }
            setArrowFunctionParameters(t, r, e) {
              this.toAssignableList(r, e, false), t.params = r;
            }
            parseFunctionBodyAndFinish(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.parseFunctionBody(t, false, e), this.finishNode(t, r);
            }
            parseFunctionBody(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = r && !this.match(5);
              if (this.expressionScope.enter(_r2()), s2)
                t.body = this.parseMaybeAssign(), this.checkParams(t, false, r, false);
              else {
                let i = this.state.strict, a2 = this.state.labels;
                this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | jr2), t.body = this.parseBlock(true, false, (n) => {
                  let o = !this.isSimpleParamList(t.params);
                  n && o && this.raise(f.IllegalLanguageModeDirective, { at: (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t });
                  let u = !i && this.state.strict;
                  this.checkParams(t, !this.state.strict && !r && !e && !o, r, u), this.state.strict && t.id && this.checkIdentifier(t.id, dl2, u);
                }), this.prodParam.exit(), this.state.labels = a2;
              }
              this.expressionScope.exit();
            }
            isSimpleParameter(t) {
              return t.type === "Identifier";
            }
            isSimpleParamList(t) {
              for (let r = 0, e = t.length; r < e; r++)
                if (!this.isSimpleParameter(t[r]))
                  return false;
              return true;
            }
            checkParams(t, r, e) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = !r && /* @__PURE__ */ new Set(), a2 = { type: "FormalParameters" };
              for (let n of t.params)
                this.checkLVal(n, { in: a2, binding: mt2, checkClashes: i, strictModeChanged: s2 });
            }
            parseExprList(t, r, e, s2) {
              let i = [], a2 = true;
              for (; !this.eat(t); ) {
                if (a2)
                  a2 = false;
                else if (this.expect(12), this.match(t)) {
                  s2 && this.addTrailingCommaExtraToNode(s2), this.next();
                  break;
                }
                i.push(this.parseExprListItem(r, e));
              }
              return i;
            }
            parseExprListItem(t, r, e) {
              let s2;
              if (this.match(12))
                t || this.raise(f.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), s2 = null;
              else if (this.match(21)) {
                let i = this.state.startLoc;
                s2 = this.parseParenItem(this.parseSpread(r), i);
              } else if (this.match(17)) {
                this.expectPlugin("partialApplication"), e || this.raise(f.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
                let i = this.startNode();
                this.next(), s2 = this.finishNode(i, "ArgumentPlaceholder");
              } else
                s2 = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
              return s2;
            }
            parseIdentifier(t) {
              let r = this.startNode(), e = this.parseIdentifierName(t);
              return this.createIdentifier(r, e);
            }
            createIdentifier(t, r) {
              return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
            }
            parseIdentifierName(t) {
              let r, { startLoc: e, type: s2 } = this.state;
              te2(s2) ? r = this.state.value : this.unexpected();
              let i = ue(s2);
              return t ? i && this.replaceToken(130) : this.checkReservedWord(r, e, i, false), this.next(), r;
            }
            checkReservedWord(t, r, e, s2) {
              if (t.length > 10 || !ul(t))
                return;
              if (e && ol(t)) {
                this.raise(f.UnexpectedKeyword, { at: r, keyword: t });
                return;
              }
              if ((this.state.strict ? s2 ? xr2 : mr2 : dr2)(t, this.inModule)) {
                this.raise(f.UnexpectedReservedWord, { at: r, reservedWord: t });
                return;
              } else if (t === "yield") {
                if (this.prodParam.hasYield) {
                  this.raise(f.YieldBindingIdentifier, { at: r });
                  return;
                }
              } else if (t === "await") {
                if (this.prodParam.hasAwait) {
                  this.raise(f.AwaitBindingIdentifier, { at: r });
                  return;
                }
                if (this.scope.inStaticBlock) {
                  this.raise(f.AwaitBindingIdentifierInStaticBlock, { at: r });
                  return;
                }
                this.expressionScope.recordAsyncArrowParametersError({ at: r });
              } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(f.ArgumentsInClass, { at: r });
                return;
              }
            }
            isAwaitAllowed() {
              return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
            }
            parseAwait(t) {
              let r = this.startNodeAt(t);
              return this.expressionScope.recordParameterInitializerError(f.AwaitExpressionFormalParameter, { at: r }), this.eat(55) && this.raise(f.ObsoleteAwaitStar, { at: r }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
            }
            isAmbiguousAwait() {
              if (this.hasPrecedingLineBreak())
                return true;
              let { type: t } = this.state;
              return t === 53 || t === 10 || t === 0 || nt(t) || t === 101 && !this.state.containsEsc || t === 135 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
            }
            parseYield() {
              let t = this.startNode();
              this.expressionScope.recordParameterInitializerError(f.YieldInParameter, { at: t }), this.next();
              let r = false, e = null;
              if (!this.hasPrecedingLineBreak())
                switch (r = this.eat(55), this.state.type) {
                  case 13:
                  case 137:
                  case 8:
                  case 11:
                  case 3:
                  case 9:
                  case 14:
                  case 12:
                    if (!r)
                      break;
                  default:
                    e = this.parseMaybeAssign();
                }
              return t.delegate = r, t.argument = e, this.finishNode(t, "YieldExpression");
            }
            checkPipelineAtInfixOperator(t, r) {
              this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(f.PipelineHeadSequenceExpression, { at: r });
            }
            parseSmartPipelineBodyInStyle(t, r) {
              if (this.isSimpleReference(t)) {
                let e = this.startNodeAt(r);
                return e.callee = t, this.finishNode(e, "PipelineBareFunction");
              } else {
                let e = this.startNodeAt(r);
                return this.checkSmartPipeTopicBodyEarlyErrors(r), e.expression = t, this.finishNode(e, "PipelineTopicExpression");
              }
            }
            isSimpleReference(t) {
              switch (t.type) {
                case "MemberExpression":
                  return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            checkSmartPipeTopicBodyEarlyErrors(t) {
              if (this.match(19))
                throw this.raise(f.PipelineBodyNoArrow, { at: this.state.startLoc });
              this.topicReferenceWasUsedInCurrentContext() || this.raise(f.PipelineTopicUnused, { at: t });
            }
            withTopicBindingContext(t) {
              let r = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
              try {
                return t();
              } finally {
                this.state.topicContext = r;
              }
            }
            withSmartMixTopicForbiddingContext(t) {
              if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
                let r = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                try {
                  return t();
                } finally {
                  this.state.topicContext = r;
                }
              } else
                return t();
            }
            withSoloAwaitPermittingContext(t) {
              let r = this.state.soloAwait;
              this.state.soloAwait = true;
              try {
                return t();
              } finally {
                this.state.soloAwait = r;
              }
            }
            allowInAnd(t) {
              let r = this.prodParam.currentFlags();
              if (_e & ~r) {
                this.prodParam.enter(r | _e);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            disallowInAnd(t) {
              let r = this.prodParam.currentFlags();
              if (_e & r) {
                this.prodParam.enter(r & ~_e);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            topicReferenceIsAllowedInCurrentContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentContext() {
              return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
            }
            parseFSharpPipelineBody(t) {
              let r = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              let e = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = true;
              let s2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
              return this.state.inFSharpPipelineDirectBody = e, s2;
            }
            parseModuleExpression() {
              this.expectPlugin("moduleBlocks");
              let t = this.startNode();
              this.next(), this.match(5) || this.unexpected(null, 5);
              let r = this.startNodeAt(this.state.endLoc);
              this.next();
              let e = this.initializeScopes(true);
              this.enterInitialScopes();
              try {
                t.body = this.parseProgram(r, 8, "module");
              } finally {
                e();
              }
              return this.finishNode(t, "ModuleExpression");
            }
            parsePropertyNamePrefixOperator(t) {
            }
          }, cs2 = { kind: "loop" }, Ph = { kind: "switch" }, Ah = /[\uD800-\uDFFF]/u, ps = /in(?:stanceof)?/y;
          function Th(t, r) {
            for (let e = 0; e < t.length; e++) {
              let s2 = t[e], { type: i } = s2;
              if (typeof i == "number") {
                {
                  if (i === 136) {
                    let { loc: a2, start: n, value: o, end: u } = s2, c2 = n + 1, y = Y(a2.start, 1);
                    t.splice(e, 1, new Ae({ type: ce(27), value: "#", start: n, end: c2, startLoc: a2.start, endLoc: y }), new Ae({ type: ce(130), value: o, start: c2, end: u, startLoc: y, endLoc: a2.end })), e++;
                    continue;
                  }
                  if (nt(i)) {
                    let { loc: a2, start: n, value: o, end: u } = s2, c2 = n + 1, y = Y(a2.start, 1), g;
                    r.charCodeAt(n) === 96 ? g = new Ae({ type: ce(22), value: "`", start: n, end: c2, startLoc: a2.start, endLoc: y }) : g = new Ae({ type: ce(8), value: "}", start: n, end: c2, startLoc: a2.start, endLoc: y });
                    let T, C, M, j;
                    i === 24 ? (C = u - 1, M = Y(a2.end, -1), T = o === null ? null : o.slice(1, -1), j = new Ae({ type: ce(22), value: "`", start: C, end: u, startLoc: M, endLoc: a2.end })) : (C = u - 2, M = Y(a2.end, -2), T = o === null ? null : o.slice(1, -2), j = new Ae({ type: ce(23), value: "${", start: C, end: u, startLoc: M, endLoc: a2.end })), t.splice(e, 1, g, new Ae({ type: ce(20), value: T, start: c2, end: C, startLoc: y, endLoc: M }), j), e += 2;
                    continue;
                  }
                }
                s2.type = ce(i);
              }
            }
            return t;
          }
          var vh = class extends gh {
            parseTopLevel(t, r) {
              return t.program = this.parseProgram(r), t.comments = this.state.comments, this.options.tokens && (t.tokens = Th(this.tokens, this.input)), this.finishNode(t, "File");
            }
            parseProgram(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 137, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
              if (t.sourceType = e, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                for (let [i, a2] of Array.from(this.scope.undefinedExports))
                  this.raise(f.ModuleExportUndefined, { at: a2, localName: i });
              let s2;
              return r === 137 ? s2 = this.finishNode(t, "Program") : s2 = this.finishNodeAt(t, "Program", Y(this.state.startLoc, -1)), s2;
            }
            stmtToDirective(t) {
              let r = t;
              r.type = "Directive", r.value = r.expression, delete r.expression;
              let e = r.value, s2 = e.value, i = this.input.slice(e.start, e.end), a2 = e.value = i.slice(1, -1);
              return this.addExtra(e, "raw", i), this.addExtra(e, "rawValue", a2), this.addExtra(e, "expressionValue", s2), e.type = "DirectiveLiteral", r;
            }
            parseInterpreterDirective() {
              if (!this.match(28))
                return null;
              let t = this.startNode();
              return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
            }
            isLet() {
              return this.isContextual(99) ? this.hasFollowingBindingAtom() : false;
            }
            chStartsBindingIdentifier(t, r) {
              if (fe(t)) {
                if (ps.lastIndex = r, ps.test(this.input)) {
                  let e = this.codePointAtPos(ps.lastIndex);
                  if (!De(e) && e !== 92)
                    return false;
                }
                return true;
              } else
                return t === 92;
            }
            chStartsBindingPattern(t) {
              return t === 91 || t === 123;
            }
            hasFollowingBindingAtom() {
              let t = this.nextTokenStart(), r = this.codePointAtPos(t);
              return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
            }
            hasFollowingBindingIdentifier() {
              let t = this.nextTokenStart(), r = this.codePointAtPos(t);
              return this.chStartsBindingIdentifier(r, t);
            }
            startsUsingForOf() {
              let t = this.lookahead();
              return t.type === 101 && !t.containsEsc ? false : (this.expectPlugin("explicitResourceManagement"), true);
            }
            parseModuleItem() {
              return this.parseStatementLike(15);
            }
            parseStatementListItem() {
              return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
            }
            parseStatementOrSloppyAnnexBFunctionDeclaration() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r = 0;
              return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
            }
            parseStatement() {
              return this.parseStatementLike(0);
            }
            parseStatementLike(t) {
              let r = null;
              return this.match(26) && (r = this.parseDecorators(true)), this.parseStatementContent(t, r);
            }
            parseStatementContent(t, r) {
              let e = this.state.type, s2 = this.startNode(), i = !!(t & 2), a2 = !!(t & 4), n = t & 1;
              switch (e) {
                case 60:
                  return this.parseBreakContinueStatement(s2, true);
                case 63:
                  return this.parseBreakContinueStatement(s2, false);
                case 64:
                  return this.parseDebuggerStatement(s2);
                case 90:
                  return this.parseDoWhileStatement(s2);
                case 91:
                  return this.parseForStatement(s2);
                case 68:
                  if (this.lookaheadCharCode() === 46)
                    break;
                  return a2 || this.raise(this.state.strict ? f.StrictFunction : this.options.annexB ? f.SloppyFunctionAnnexB : f.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(s2, false, !i && a2);
                case 80:
                  return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s2), true);
                case 69:
                  return this.parseIfStatement(s2);
                case 70:
                  return this.parseReturnStatement(s2);
                case 71:
                  return this.parseSwitchStatement(s2);
                case 72:
                  return this.parseThrowStatement(s2);
                case 73:
                  return this.parseTryStatement(s2);
                case 105:
                  if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier())
                    break;
                  return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(f.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i || this.raise(f.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(s2, "using");
                case 99: {
                  if (this.state.containsEsc)
                    break;
                  let c2 = this.nextTokenStart(), y = this.codePointAtPos(c2);
                  if (y !== 91 && (!i && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(y, c2) && y !== 123))
                    break;
                }
                case 75:
                  i || this.raise(f.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
                case 74: {
                  let c2 = this.state.value;
                  return this.parseVarStatement(s2, c2);
                }
                case 92:
                  return this.parseWhileStatement(s2);
                case 76:
                  return this.parseWithStatement(s2);
                case 5:
                  return this.parseBlock();
                case 13:
                  return this.parseEmptyStatement(s2);
                case 83: {
                  let c2 = this.lookaheadCharCode();
                  if (c2 === 40 || c2 === 46)
                    break;
                }
                case 82: {
                  !this.options.allowImportExportEverywhere && !n && this.raise(f.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
                  let c2;
                  return e === 83 ? (c2 = this.parseImport(s2), c2.type === "ImportDeclaration" && (!c2.importKind || c2.importKind === "value") && (this.sawUnambiguousESM = true)) : (c2 = this.parseExport(s2, r), (c2.type === "ExportNamedDeclaration" && (!c2.exportKind || c2.exportKind === "value") || c2.type === "ExportAllDeclaration" && (!c2.exportKind || c2.exportKind === "value") || c2.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(c2), c2;
                }
                default:
                  if (this.isAsyncFunction())
                    return i || this.raise(f.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(s2, true, !i && a2);
              }
              let o = this.state.value, u = this.parseExpression();
              return q2(e) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s2, o, u, t) : this.parseExpressionStatement(s2, u, r);
            }
            assertModuleNodeAllowed(t) {
              !this.options.allowImportExportEverywhere && !this.inModule && this.raise(f.ImportOutsideModule, { at: t });
            }
            decoratorsEnabledBeforeExport() {
              return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
            }
            maybeTakeDecorators(t, r, e) {
              return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(f.DecoratorsBeforeAfterExport, { at: r.decorators[0] }), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), e && this.resetStartLocationFromNode(e, r)), r;
            }
            canHaveLeadingDecorator() {
              return this.match(80);
            }
            parseDecorators(t) {
              let r = [];
              do
                r.push(this.parseDecorator());
              while (this.match(26));
              if (this.match(82))
                t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(f.DecoratorExportClass, { at: this.state.startLoc });
              else if (!this.canHaveLeadingDecorator())
                throw this.raise(f.UnexpectedLeadingDecorator, { at: this.state.startLoc });
              return r;
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators", "decorators-legacy"]);
              let t = this.startNode();
              if (this.next(), this.hasPlugin("decorators")) {
                let r = this.state.startLoc, e;
                if (this.match(10)) {
                  let s2 = this.state.startLoc;
                  this.next(), e = this.parseExpression(), this.expect(11), e = this.wrapParenthesis(s2, e);
                  let i = this.state.startLoc;
                  t.expression = this.parseMaybeDecoratorArguments(e), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== e && this.raise(f.DecoratorArgumentsOutsideParentheses, { at: i });
                } else {
                  for (e = this.parseIdentifier(false); this.eat(16); ) {
                    let s2 = this.startNodeAt(r);
                    s2.object = e, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s2.property = this.parsePrivateName()) : s2.property = this.parseIdentifier(true), s2.computed = false, e = this.finishNode(s2, "MemberExpression");
                  }
                  t.expression = this.parseMaybeDecoratorArguments(e);
                }
              } else
                t.expression = this.parseExprSubscripts();
              return this.finishNode(t, "Decorator");
            }
            parseMaybeDecoratorArguments(t) {
              if (this.eat(10)) {
                let r = this.startNodeAtNode(t);
                return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
              }
              return t;
            }
            parseBreakContinueStatement(t, r) {
              return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
            }
            verifyBreakContinue(t, r) {
              let e;
              for (e = 0; e < this.state.labels.length; ++e) {
                let s2 = this.state.labels[e];
                if ((t.label == null || s2.name === t.label.name) && (s2.kind != null && (r || s2.kind === "loop") || t.label && r))
                  break;
              }
              if (e === this.state.labels.length) {
                let s2 = r ? "BreakStatement" : "ContinueStatement";
                this.raise(f.IllegalBreakContinue, { at: t, type: s2 });
              }
            }
            parseDebuggerStatement(t) {
              return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
            }
            parseHeaderExpression() {
              this.expect(10);
              let t = this.parseExpression();
              return this.expect(11), t;
            }
            parseDoWhileStatement(t) {
              return this.next(), this.state.labels.push(cs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
            }
            parseForStatement(t) {
              this.next(), this.state.labels.push(cs2);
              let r = null;
              if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(Fe), this.expect(10), this.match(13))
                return r !== null && this.unexpected(r), this.parseFor(t, null);
              let e = this.isContextual(99), s2 = this.isContextual(105) && !this.hasFollowingLineBreak(), i = e && this.hasFollowingBindingAtom() || s2 && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
              if (this.match(74) || this.match(75) || i) {
                let c2 = this.startNode(), y = this.state.value;
                this.next(), this.parseVar(c2, true, y);
                let g = this.finishNode(c2, "VariableDeclaration"), T = this.match(58);
                return T && s2 && this.raise(f.ForInUsing, { at: g }), (T || this.isContextual(101)) && g.declarations.length === 1 ? this.parseForIn(t, g, r) : (r !== null && this.unexpected(r), this.parseFor(t, g));
              }
              let a2 = this.isContextual(95), n = new vt2(), o = this.parseExpression(true, n), u = this.isContextual(101);
              if (u && (e && this.raise(f.ForOfLet, { at: o }), r === null && a2 && o.type === "Identifier" && this.raise(f.ForOfAsync, { at: o })), u || this.match(58)) {
                this.checkDestructuringPrivate(n), this.toAssignable(o, true);
                let c2 = u ? "ForOfStatement" : "ForInStatement";
                return this.checkLVal(o, { in: { type: c2 } }), this.parseForIn(t, o, r);
              } else
                this.checkExpressionErrors(n, true);
              return r !== null && this.unexpected(r), this.parseFor(t, o);
            }
            parseFunctionStatement(t, r, e) {
              return this.next(), this.parseFunction(t, 1 | (e ? 2 : 0) | (r ? 8 : 0));
            }
            parseIfStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
            }
            parseReturnStatement(t) {
              return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(f.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
            }
            parseSwitchStatement(t) {
              this.next(), t.discriminant = this.parseHeaderExpression();
              let r = t.cases = [];
              this.expect(5), this.state.labels.push(Ph), this.scope.enter(Fe);
              let e;
              for (let s2; !this.match(8); )
                if (this.match(61) || this.match(65)) {
                  let i = this.match(61);
                  e && this.finishNode(e, "SwitchCase"), r.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (s2 && this.raise(f.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), s2 = true, e.test = null), this.expect(14);
                } else
                  e ? e.consequent.push(this.parseStatementListItem()) : this.unexpected();
              return this.scope.exit(), e && this.finishNode(e, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
            }
            parseThrowStatement(t) {
              return this.next(), this.hasPrecedingLineBreak() && this.raise(f.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
            }
            parseCatchClauseParam() {
              let t = this.parseBindingAtom();
              return this.scope.enter(this.options.annexB && t.type === "Identifier" ? gr2 : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: cl }), t;
            }
            parseTryStatement(t) {
              if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
                let r = this.startNode();
                this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(Fe)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
              }
              return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(f.NoCatchOrFinally, { at: t }), this.finishNode(t, "TryStatement");
            }
            parseVarStatement(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.next(), this.parseVar(t, false, r, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
            }
            parseWhileStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(cs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
            }
            parseWithStatement(t) {
              return this.state.strict && this.raise(f.StrictWith, { at: this.state.startLoc }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
            }
            parseEmptyStatement(t) {
              return this.next(), this.finishNode(t, "EmptyStatement");
            }
            parseLabeledStatement(t, r, e, s2) {
              for (let a2 of this.state.labels)
                a2.name === r && this.raise(f.LabelRedeclaration, { at: e, labelName: r });
              let i = Mo(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
              for (let a2 = this.state.labels.length - 1; a2 >= 0; a2--) {
                let n = this.state.labels[a2];
                if (n.statementStart === t.start)
                  n.statementStart = this.state.start, n.kind = i;
                else
                  break;
              }
              return this.state.labels.push({ name: r, kind: i, statementStart: this.state.start }), t.body = s2 & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = e, this.finishNode(t, "LabeledStatement");
            }
            parseExpressionStatement(t, r, e) {
              return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
            }
            parseBlock() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, e = arguments.length > 2 ? arguments[2] : void 0, s2 = this.startNode();
              return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(Fe), this.parseBlockBody(s2, t, false, 8, e), r && this.scope.exit(), this.finishNode(s2, "BlockStatement");
            }
            isValidDirective(t) {
              return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
            }
            parseBlockBody(t, r, e, s2, i) {
              let a2 = t.body = [], n = t.directives = [];
              this.parseBlockOrModuleBlockBody(a2, r ? n : void 0, e, s2, i);
            }
            parseBlockOrModuleBlockBody(t, r, e, s2, i) {
              let a2 = this.state.strict, n = false, o = false;
              for (; !this.match(s2); ) {
                let u = e ? this.parseModuleItem() : this.parseStatementListItem();
                if (r && !o) {
                  if (this.isValidDirective(u)) {
                    let c2 = this.stmtToDirective(u);
                    r.push(c2), !n && c2.value.value === "use strict" && (n = true, this.setStrict(true));
                    continue;
                  }
                  o = true, this.state.strictErrors.clear();
                }
                t.push(u);
              }
              i && i.call(this, n), a2 || this.setStrict(false), this.next();
            }
            parseFor(t, r) {
              return t.init = r, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
            }
            parseForIn(t, r, e) {
              let s2 = this.match(58);
              return this.next(), s2 ? e !== null && this.unexpected(e) : t.await = e !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s2 || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(f.ForInOfLoopInitializer, { at: r, type: s2 ? "ForInStatement" : "ForOfStatement" }), r.type === "AssignmentPattern" && this.raise(f.InvalidLhs, { at: r, ancestor: { type: "ForStatement" } }), t.left = r, t.right = s2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s2 ? "ForInStatement" : "ForOfStatement");
            }
            parseVar(t, r, e) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = t.declarations = [];
              for (t.kind = e; ; ) {
                let a2 = this.startNode();
                if (this.parseVarId(a2, e), a2.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a2.init === null && !s2 && (a2.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(101))) ? this.raise(f.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : e === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(f.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i.push(this.finishNode(a2, "VariableDeclarator")), !this.eat(12))
                  break;
              }
              return t;
            }
            parseVarId(t, r) {
              r === "using" && !this.inModule && this.match(96) && this.raise(f.AwaitInUsingBinding, { at: this.state.startLoc });
              let e = this.parseBindingAtom();
              this.checkLVal(e, { in: { type: "VariableDeclarator" }, binding: r === "var" ? mt2 : Be }), t.id = e;
            }
            parseAsyncFunctionExpression(t) {
              return this.parseFunction(t, 8);
            }
            parseFunction(t) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = r & 2, s2 = !!(r & 1), i = s2 && !(r & 4), a2 = !!(r & 8);
              this.initFunction(t, a2), this.match(55) && (e && this.raise(f.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), t.generator = true), s2 && (t.id = this.parseFunctionId(i));
              let n = this.state.maybeInArrowParameters;
              return this.state.maybeInArrowParameters = false, this.scope.enter(de), this.prodParam.enter(Tt2(a2, t.generator)), s2 || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(t, s2 ? "FunctionDeclaration" : "FunctionExpression");
              }), this.prodParam.exit(), this.scope.exit(), s2 && !e && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = n, t;
            }
            parseFunctionId(t) {
              return t || q2(this.state.type) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(t, r) {
              this.expect(10), this.expressionScope.enter(ql()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
            }
            registerFunctionStatementId(t) {
              t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? mt2 : Be : Er, t.id.loc.start);
            }
            parseClass(t, r, e) {
              this.next();
              let s2 = this.state.strict;
              return this.state.strict = true, this.parseClassId(t, r, e), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s2), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
            }
            isClassProperty() {
              return this.match(29) || this.match(13) || this.match(8);
            }
            isClassMethod() {
              return this.match(10);
            }
            isNonstaticConstructor(t) {
              return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
            }
            parseClassBody(t, r) {
              this.classScope.enter();
              let e = { hadConstructor: false, hadSuperClass: t }, s2 = [], i = this.startNode();
              if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                for (; !this.match(8); ) {
                  if (this.eat(13)) {
                    if (s2.length > 0)
                      throw this.raise(f.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                    continue;
                  }
                  if (this.match(26)) {
                    s2.push(this.parseDecorator());
                    continue;
                  }
                  let a2 = this.startNode();
                  s2.length && (a2.decorators = s2, this.resetStartLocationFromNode(a2, s2[0]), s2 = []), this.parseClassMember(i, a2, e), a2.kind === "constructor" && a2.decorators && a2.decorators.length > 0 && this.raise(f.DecoratorConstructor, { at: a2 });
                }
              }), this.state.strict = r, this.next(), s2.length)
                throw this.raise(f.TrailingDecorator, { at: this.state.startLoc });
              return this.classScope.exit(), this.finishNode(i, "ClassBody");
            }
            parseClassMemberFromModifier(t, r) {
              let e = this.parseIdentifier(true);
              if (this.isClassMethod()) {
                let s2 = r;
                return s2.kind = "method", s2.computed = false, s2.key = e, s2.static = false, this.pushClassMethod(t, s2, false, false, false, false), true;
              } else if (this.isClassProperty()) {
                let s2 = r;
                return s2.computed = false, s2.key = e, s2.static = false, t.body.push(this.parseClassProperty(s2)), true;
              }
              return this.resetPreviousNodeTrailingComments(e), false;
            }
            parseClassMember(t, r, e) {
              let s2 = this.isContextual(104);
              if (s2) {
                if (this.parseClassMemberFromModifier(t, r))
                  return;
                if (this.eat(5)) {
                  this.parseClassStaticBlock(t, r);
                  return;
                }
              }
              this.parseClassMemberWithIsStatic(t, r, e, s2);
            }
            parseClassMemberWithIsStatic(t, r, e, s2) {
              let i = r, a2 = r, n = r, o = r, u = r, c2 = i, y = i;
              if (r.static = s2, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
                c2.kind = "method";
                let j = this.match(136);
                if (this.parseClassElementName(c2), j) {
                  this.pushClassPrivateMethod(t, a2, true, false);
                  return;
                }
                this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsGenerator, { at: i.key }), this.pushClassMethod(t, i, true, false, false, false);
                return;
              }
              let g = q2(this.state.type) && !this.state.containsEsc, T = this.match(136), C = this.parseClassElementName(r), M = this.state.startLoc;
              if (this.parsePostMemberNameModifiers(y), this.isClassMethod()) {
                if (c2.kind = "method", T) {
                  this.pushClassPrivateMethod(t, a2, false, false);
                  return;
                }
                let j = this.isNonstaticConstructor(i), K = false;
                j && (i.kind = "constructor", e.hadConstructor && !this.hasPlugin("typescript") && this.raise(f.DuplicateConstructor, { at: C }), j && this.hasPlugin("typescript") && r.override && this.raise(f.OverrideOnConstructor, { at: C }), e.hadConstructor = true, K = e.hadSuperClass), this.pushClassMethod(t, i, false, false, j, K);
              } else if (this.isClassProperty())
                T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);
              else if (g && C.name === "async" && !this.isLineTerminator()) {
                this.resetPreviousNodeTrailingComments(C);
                let j = this.eat(55);
                y.optional && this.unexpected(M), c2.kind = "method";
                let K = this.match(136);
                this.parseClassElementName(c2), this.parsePostMemberNameModifiers(y), K ? this.pushClassPrivateMethod(t, a2, j, true) : (this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsAsync, { at: i.key }), this.pushClassMethod(t, i, j, true, false, false));
              } else if (g && (C.name === "get" || C.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                this.resetPreviousNodeTrailingComments(C), c2.kind = C.name;
                let j = this.match(136);
                this.parseClassElementName(i), j ? this.pushClassPrivateMethod(t, a2, false, false) : (this.isNonstaticConstructor(i) && this.raise(f.ConstructorIsAccessor, { at: i.key }), this.pushClassMethod(t, i, false, false, false, false)), this.checkGetterSetterParams(i);
              } else if (g && C.name === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(C);
                let j = this.match(136);
                this.parseClassElementName(n), this.pushClassAccessorProperty(t, u, j);
              } else
                this.isLineTerminator() ? T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected();
            }
            parseClassElementName(t) {
              let { type: r, value: e } = this.state;
              if ((r === 130 || r === 131) && t.static && e === "prototype" && this.raise(f.StaticPrototype, { at: this.state.startLoc }), r === 136) {
                e === "constructor" && this.raise(f.ConstructorClassPrivateField, { at: this.state.startLoc });
                let s2 = this.parsePrivateName();
                return t.key = s2, s2;
              }
              return this.parsePropertyName(t);
            }
            parseClassStaticBlock(t, r) {
              var e;
              this.scope.enter(Ee | ut2 | ht2);
              let s2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(Me);
              let i = r.body = [];
              this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s2, t.body.push(this.finishNode(r, "StaticBlock")), (e = r.decorators) != null && e.length && this.raise(f.DecoratorStaticBlock, { at: r });
            }
            pushClassProperty(t, r) {
              !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(f.ConstructorClassField, { at: r.key }), t.body.push(this.parseClassProperty(r));
            }
            pushClassPrivateProperty(t, r) {
              let e = this.parseClassPrivateProperty(r);
              t.body.push(e), this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), ss, e.key.loc.start);
            }
            pushClassAccessorProperty(t, r, e) {
              if (!e && !r.computed) {
                let i = r.key;
                (i.name === "constructor" || i.value === "constructor") && this.raise(f.ConstructorClassField, { at: i });
              }
              let s2 = this.parseClassAccessorProperty(r);
              t.body.push(s2), e && this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), ss, s2.key.loc.start);
            }
            pushClassMethod(t, r, e, s2, i, a2) {
              t.body.push(this.parseMethod(r, e, s2, i, a2, "ClassMethod", true));
            }
            pushClassPrivateMethod(t, r, e, s2) {
              let i = this.parseMethod(r, e, s2, false, false, "ClassPrivateMethod", true);
              t.body.push(i);
              let a2 = i.kind === "get" ? i.static ? gl : Al : i.kind === "set" ? i.static ? Pl : Tl : ss;
              this.declareClassPrivateMethodInScope(i, a2);
            }
            declareClassPrivateMethodInScope(t, r) {
              this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
            }
            parsePostMemberNameModifiers(t) {
            }
            parseClassPrivateProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
            }
            parseClassProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
            }
            parseClassAccessorProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
            }
            parseInitializer(t) {
              this.scope.enter(Ee | ht2), this.expressionScope.enter(_r2()), this.prodParam.enter(Me), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
            }
            parseClassId(t, r, e) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : vr;
              if (q2(this.state.type))
                t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s2);
              else if (e || !r)
                t.id = null;
              else
                throw this.raise(f.MissingClassName, { at: this.state.startLoc });
            }
            parseClassSuper(t) {
              t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
            }
            parseExport(t, r) {
              let e = this.maybeParseExportDefaultSpecifier(t), s2 = !e || this.eat(12), i = s2 && this.eatExportStar(t), a2 = i && this.maybeParseExportNamespaceSpecifier(t), n = s2 && (!a2 || this.eat(12)), o = e || i;
              if (i && !a2) {
                if (e && this.unexpected(), r)
                  throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
              }
              let u = this.maybeParseExportNamedSpecifiers(t);
              e && s2 && !i && !u && this.unexpected(null, 5), a2 && n && this.unexpected(null, 97);
              let c2;
              if (o || u) {
                if (c2 = false, r)
                  throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                this.parseExportFrom(t, o);
              } else
                c2 = this.maybeParseExportDeclaration(t);
              if (o || u || c2) {
                var y;
                let g = t;
                if (this.checkExport(g, true, false, !!g.source), ((y = g.declaration) == null ? void 0 : y.type) === "ClassDeclaration")
                  this.maybeTakeDecorators(r, g.declaration, g);
                else if (r)
                  throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.finishNode(g, "ExportNamedDeclaration");
              }
              if (this.eat(65)) {
                let g = t, T = this.parseExportDefaultExpression();
                if (g.declaration = T, T.type === "ClassDeclaration")
                  this.maybeTakeDecorators(r, T, g);
                else if (r)
                  throw this.raise(f.UnsupportedDecoratorExport, { at: t });
                return this.checkExport(g, true, true), this.finishNode(g, "ExportDefaultDeclaration");
              }
              this.unexpected(null, 5);
            }
            eatExportStar(t) {
              return this.eat(55);
            }
            maybeParseExportDefaultSpecifier(t) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                let r = this.startNode();
                return r.exported = this.parseIdentifier(true), t.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(t) {
              if (this.isContextual(93)) {
                t.specifiers || (t.specifiers = []);
                let r = this.startNodeAt(this.state.lastTokStartLoc);
                return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), true;
              }
              return false;
            }
            maybeParseExportNamedSpecifiers(t) {
              if (this.match(5)) {
                t.specifiers || (t.specifiers = []);
                let r = t.exportKind === "type";
                return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), true;
              }
              return false;
            }
            maybeParseExportDeclaration(t) {
              return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
            }
            isAsyncFunction() {
              if (!this.isContextual(95))
                return false;
              let t = this.nextTokenStart();
              return !as.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function");
            }
            parseExportDefaultExpression() {
              let t = this.startNode();
              if (this.match(68))
                return this.next(), this.parseFunction(t, 5);
              if (this.isAsyncFunction())
                return this.next(), this.next(), this.parseFunction(t, 13);
              if (this.match(80))
                return this.parseClass(t, true, true);
              if (this.match(26))
                return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(f.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
              if (this.match(75) || this.match(74) || this.isLet())
                throw this.raise(f.UnsupportedDefaultExport, { at: this.state.startLoc });
              let r = this.parseMaybeAssignAllowIn();
              return this.semicolon(), r;
            }
            parseExportDeclaration(t) {
              return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
            }
            isExportDefaultSpecifier() {
              let { type: t } = this.state;
              if (q2(t)) {
                if (t === 95 && !this.state.containsEsc || t === 99)
                  return false;
                if ((t === 128 || t === 127) && !this.state.containsEsc) {
                  let { type: s2 } = this.lookahead();
                  if (q2(s2) && s2 !== 97 || s2 === 5)
                    return this.expectOnePlugin(["flow", "typescript"]), false;
                }
              } else if (!this.match(65))
                return false;
              let r = this.nextTokenStart(), e = this.isUnparsedContextual(r, "from");
              if (this.input.charCodeAt(r) === 44 || q2(this.state.type) && e)
                return true;
              if (this.match(65) && e) {
                let s2 = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
                return s2 === 34 || s2 === 39;
              }
              return false;
            }
            parseExportFrom(t, r) {
              if (this.eatContextual(97)) {
                t.source = this.parseImportSource(), this.checkExport(t);
                let e = this.maybeParseImportAssertions();
                e && (t.assertions = e, this.checkJSONModuleImport(t));
              } else
                r && this.unexpected();
              this.semicolon();
            }
            shouldParseExportDeclaration() {
              let { type: t } = this.state;
              return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(f.DecoratorBeforeExport, { at: this.state.startLoc }), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
            }
            checkExport(t, r, e, s2) {
              if (r) {
                if (e) {
                  if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                    var i;
                    let a2 = t.declaration;
                    a2.type === "Identifier" && a2.name === "from" && a2.end - a2.start === 4 && !((i = a2.extra) != null && i.parenthesized) && this.raise(f.ExportDefaultFromAsIdentifier, { at: a2 });
                  }
                } else if (t.specifiers && t.specifiers.length)
                  for (let a2 of t.specifiers) {
                    let { exported: n } = a2, o = n.type === "Identifier" ? n.name : n.value;
                    if (this.checkDuplicateExports(a2, o), !s2 && a2.local) {
                      let { local: u } = a2;
                      u.type !== "Identifier" ? this.raise(f.ExportBindingIsString, { at: a2, localName: u.value, exportName: o }) : (this.checkReservedWord(u.name, u.loc.start, true, false), this.scope.checkLocalExport(u));
                    }
                  }
                else if (t.declaration) {
                  if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
                    let a2 = t.declaration.id;
                    if (!a2)
                      throw new Error("Assertion failure");
                    this.checkDuplicateExports(t, a2.name);
                  } else if (t.declaration.type === "VariableDeclaration")
                    for (let a2 of t.declaration.declarations)
                      this.checkDeclaration(a2.id);
                }
              }
            }
            checkDeclaration(t) {
              if (t.type === "Identifier")
                this.checkDuplicateExports(t, t.name);
              else if (t.type === "ObjectPattern")
                for (let r of t.properties)
                  this.checkDeclaration(r);
              else if (t.type === "ArrayPattern")
                for (let r of t.elements)
                  r && this.checkDeclaration(r);
              else
                t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
            }
            checkDuplicateExports(t, r) {
              this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(f.DuplicateDefaultExport, { at: t }) : this.raise(f.DuplicateExport, { at: t, exportName: r })), this.exportedIdentifiers.add(r);
            }
            parseExportSpecifiers(t) {
              let r = [], e = true;
              for (this.expect(5); !this.eat(8); ) {
                if (e)
                  e = false;
                else if (this.expect(12), this.eat(8))
                  break;
                let s2 = this.isContextual(128), i = this.match(131), a2 = this.startNode();
                a2.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a2, i, t, s2));
              }
              return r;
            }
            parseExportSpecifier(t, r, e, s2) {
              return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = Kl(t.local) : t.exported || (t.exported = me(t.local)), this.finishNode(t, "ExportSpecifier");
            }
            parseModuleExportName() {
              if (this.match(131)) {
                let t = this.parseStringLiteral(this.state.value), r = t.value.match(Ah);
                return r && this.raise(f.ModuleExportNameHasLoneSurrogate, { at: t, surrogateCharCode: r[0].charCodeAt(0) }), t;
              }
              return this.parseIdentifier(true);
            }
            isJSONModuleImport(t) {
              return t.assertions != null ? t.assertions.some((r) => {
                let { key: e, value: s2 } = r;
                return s2.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type");
              }) : false;
            }
            checkImportReflection(t) {
              if (t.module) {
                var r;
                (t.specifiers.length !== 1 || t.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(f.ImportReflectionNotBinding, { at: t.specifiers[0].loc.start }), ((r = t.assertions) == null ? void 0 : r.length) > 0 && this.raise(f.ImportReflectionHasAssertion, { at: t.specifiers[0].loc.start });
              }
            }
            checkJSONModuleImport(t) {
              if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
                let { specifiers: r } = t;
                if (r != null) {
                  let e = r.find((s2) => {
                    let i;
                    if (s2.type === "ExportSpecifier" ? i = s2.local : s2.type === "ImportSpecifier" && (i = s2.imported), i !== void 0)
                      return i.type === "Identifier" ? i.name !== "default" : i.value !== "default";
                  });
                  e !== void 0 && this.raise(f.ImportJSONBindingNotDefault, { at: e.loc.start });
                }
              }
            }
            parseMaybeImportReflection(t) {
              let r = false;
              if (this.isContextual(125)) {
                let e = this.lookahead(), s2 = e.type;
                q2(s2) ? (s2 !== 97 || this.input.charCodeAt(this.nextTokenStartSince(e.end)) === 102) && (r = true) : s2 !== 12 && (r = true);
              }
              r ? (this.expectPlugin("importReflection"), this.next(), t.module = true) : this.hasPlugin("importReflection") && (t.module = false);
            }
            parseImport(t) {
              if (t.specifiers = [], !this.match(131)) {
                this.parseMaybeImportReflection(t);
                let s2 = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12), i = s2 && this.maybeParseStarImportSpecifier(t);
                s2 && !i && this.parseNamedImportSpecifiers(t), this.expectContextual(97);
              }
              t.source = this.parseImportSource();
              let r = this.maybeParseImportAssertions();
              if (r)
                t.assertions = r;
              else {
                let e = this.maybeParseModuleAttributes();
                e && (t.attributes = e);
              }
              return this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
            }
            parseImportSource() {
              return this.match(131) || this.unexpected(), this.parseExprAtom();
            }
            shouldParseDefaultImport(t) {
              return q2(this.state.type);
            }
            parseImportSpecifierLocal(t, r, e) {
              r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, e));
            }
            finishImportSpecifier(t, r) {
              let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Be;
              return this.checkLVal(t.local, { in: { type: r }, binding: e }), this.finishNode(t, r);
            }
            parseAssertEntries() {
              let t = [], r = /* @__PURE__ */ new Set();
              do {
                if (this.match(8))
                  break;
                let e = this.startNode(), s2 = this.state.value;
                if (r.has(s2) && this.raise(f.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: s2 }), r.add(s2), this.match(131) ? e.key = this.parseStringLiteral(s2) : e.key = this.parseIdentifier(true), this.expect(14), !this.match(131))
                  throw this.raise(f.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(e, "ImportAttribute"));
              } while (this.eat(12));
              return t;
            }
            maybeParseModuleAttributes() {
              if (this.match(76) && !this.hasPrecedingLineBreak())
                this.expectPlugin("moduleAttributes"), this.next();
              else
                return this.hasPlugin("moduleAttributes") ? [] : null;
              let t = [], r = /* @__PURE__ */ new Set();
              do {
                let e = this.startNode();
                if (e.key = this.parseIdentifier(true), e.key.name !== "type" && this.raise(f.ModuleAttributeDifferentFromType, { at: e.key }), r.has(e.key.name) && this.raise(f.ModuleAttributesWithDuplicateKeys, { at: e.key, key: e.key.name }), r.add(e.key.name), this.expect(14), !this.match(131))
                  throw this.raise(f.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e.value = this.parseStringLiteral(this.state.value), this.finishNode(e, "ImportAttribute"), t.push(e);
              } while (this.eat(12));
              return t;
            }
            maybeParseImportAssertions() {
              if (this.isContextual(94) && !this.hasPrecedingLineBreak())
                this.expectPlugin("importAssertions"), this.next();
              else
                return this.hasPlugin("importAssertions") ? [] : null;
              this.eat(5);
              let t = this.parseAssertEntries();
              return this.eat(8), t;
            }
            maybeParseDefaultImportSpecifier(t) {
              return this.shouldParseDefaultImport(t) ? (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true) : false;
            }
            maybeParseStarImportSpecifier(t) {
              if (this.match(55)) {
                let r = this.startNode();
                return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), true;
              }
              return false;
            }
            parseNamedImportSpecifiers(t) {
              let r = true;
              for (this.expect(5); !this.eat(8); ) {
                if (r)
                  r = false;
                else {
                  if (this.eat(14))
                    throw this.raise(f.DestructureNamedImport, { at: this.state.startLoc });
                  if (this.expect(12), this.eat(8))
                    break;
                }
                let e = this.startNode(), s2 = this.match(131), i = this.isContextual(128);
                e.imported = this.parseModuleExportName();
                let a2 = this.parseImportSpecifier(e, s2, t.importKind === "type" || t.importKind === "typeof", i, void 0);
                t.specifiers.push(a2);
              }
            }
            parseImportSpecifier(t, r, e, s2, i) {
              if (this.eatContextual(93))
                t.local = this.parseIdentifier();
              else {
                let { imported: a2 } = t;
                if (r)
                  throw this.raise(f.ImportBindingIsString, { at: t, importName: a2.value });
                this.checkReservedWord(a2.name, t.loc.start, true, true), t.local || (t.local = me(a2));
              }
              return this.finishImportSpecifier(t, "ImportSpecifier", i);
            }
            isThisParam(t) {
              return t.type === "Identifier" && t.name === "this";
            }
          }, Yr2 = class extends vh {
            constructor(t, r) {
              t = p2(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = Eh(this.options.plugins), this.filename = t.sourceFilename;
            }
            getScopeHandler() {
              return is;
            }
            parse() {
              this.enterInitialScopes();
              let t = this.startNode(), r = this.startNode();
              return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t;
            }
          };
          function Eh(t) {
            let r = /* @__PURE__ */ new Map();
            for (let e of t) {
              let [s2, i] = Array.isArray(e) ? e : [e, {}];
              r.has(s2) || r.set(s2, i || {});
            }
            return r;
          }
          function Ch(t, r) {
            var e;
            if (((e = r) == null ? void 0 : e.sourceType) === "unambiguous") {
              r = Object.assign({}, r);
              try {
                r.sourceType = "module";
                let s2 = Xe(r, t), i = s2.parse();
                if (s2.sawUnambiguousESM)
                  return i;
                if (s2.ambiguousScriptDifferentAst)
                  try {
                    return r.sourceType = "script", Xe(r, t).parse();
                  } catch {
                  }
                else
                  i.program.sourceType = "script";
                return i;
              } catch (s2) {
                try {
                  return r.sourceType = "script", Xe(r, t).parse();
                } catch {
                }
                throw s2;
              }
            } else
              return Xe(r, t).parse();
          }
          function bh(t, r) {
            let e = Xe(r, t);
            return e.options.strictMode && (e.state.strict = true), e.getExpression();
          }
          function Sh(t) {
            let r = {};
            for (let e of Object.keys(t))
              r[e] = ce(t[e]);
            return r;
          }
          var wh = Sh(Z);
          function Xe(t, r) {
            let e = Yr2;
            return t != null && t.plugins && (yh(t.plugins), e = Ih(t.plugins)), new e(t, r);
          }
          var Qr = {};
          function Ih(t) {
            let r = xh.filter((i) => J(t, i)), e = r.join("/"), s2 = Qr[e];
            if (!s2) {
              s2 = Yr2;
              for (let i of r)
                s2 = Xr2[i](s2);
              Qr[e] = s2;
            }
            return s2;
          }
          l.parse = Ch, l.parseExpression = bh, l.tokTypes = wh;
        } }), Xf = $2({ "src/language-js/parse/json.js"(l, h2) {
          U();
          var p2 = Io(), d = lr2(), x2 = ko(), P = Do2();
          function m2() {
            let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: L = true } = w;
            return function(_) {
              let { parseExpression: G } = Fo2(), N;
              try {
                N = G(_, { tokens: true, ranges: true });
              } catch (O) {
                throw P(O);
              }
              if (!L && p2(N.comments))
                throw v(N.comments[0], "Comment");
              return S(N), N;
            };
          }
          function v(w, L) {
            let [A, _] = [w.loc.start, w.loc.end].map((G) => {
              let { line: N, column: O } = G;
              return { line: N, column: O + 1 };
            });
            return d(`${L} is not allowed in JSON.`, { start: A, end: _ });
          }
          function S(w) {
            switch (w.type) {
              case "ArrayExpression":
                for (let L of w.elements)
                  L !== null && S(L);
                return;
              case "ObjectExpression":
                for (let L of w.properties)
                  S(L);
                return;
              case "ObjectProperty":
                if (w.computed)
                  throw v(w.key, "Computed key");
                if (w.shorthand)
                  throw v(w.key, "Shorthand property");
                w.key.type !== "Identifier" && S(w.key), S(w.value);
                return;
              case "UnaryExpression": {
                let { operator: L, argument: A } = w;
                if (L !== "+" && L !== "-")
                  throw v(w, `Operator '${w.operator}'`);
                if (A.type === "NumericLiteral" || A.type === "Identifier" && (A.name === "Infinity" || A.name === "NaN"))
                  return;
                throw v(A, `Operator '${L}' before '${A.type}'`);
              }
              case "Identifier":
                if (w.name !== "Infinity" && w.name !== "NaN" && w.name !== "undefined")
                  throw v(w, `Identifier '${w.name}'`);
                return;
              case "TemplateLiteral":
                if (p2(w.expressions))
                  throw v(w.expressions[0], "'TemplateLiteral' with expression");
                for (let L of w.quasis)
                  S(L);
                return;
              case "NullLiteral":
              case "BooleanLiteral":
              case "NumericLiteral":
              case "StringLiteral":
              case "TemplateElement":
                return;
              default:
                throw v(w, `'${w.type}'`);
            }
          }
          var k = m2(), F = { json: x2({ parse: k, hasPragma() {
            return true;
          } }), json5: x2(k), "json-stringify": x2({ parse: m2({ allowComments: false }), astFormat: "estree-json" }) };
          h2.exports = F;
        } });
        U();
        var Yf2 = kf(), Qf2 = po2(), Zf2 = Of(), Ue2 = ko(), ed2 = Do2(), td2 = Jf2(), sd2 = Xf(), rd2 = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, id2 = ["recordAndTuple", { syntaxType: "hash" }], no2 = "v8intrinsic", oo2 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], he = function(l) {
          let h2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rd2;
          return Object.assign(Object.assign({}, h2), {}, { plugins: [...h2.plugins, ...l] });
        }, ad2 = /@(?:no)?flow\b/;
        function nd2(l, h2) {
          if (h2.filepath && h2.filepath.endsWith(".js.flow"))
            return true;
          let p2 = Qf2(l);
          p2 && (l = l.slice(p2.length));
          let d = Zf2(l, 0);
          return d !== false && (l = l.slice(0, d)), ad2.test(l);
        }
        function od2(l, h2, p2) {
          let d = Fo2()[l], x2 = d(h2, p2), P = x2.errors.find((m2) => !fd2.has(m2.reasonCode));
          if (P)
            throw P;
          return x2;
        }
        function $e(l) {
          for (var h2 = arguments.length, p2 = new Array(h2 > 1 ? h2 - 1 : 0), d = 1; d < h2; d++)
            p2[d - 1] = arguments[d];
          return function(x2, P) {
            let m2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((m2.parser === "babel" || m2.parser === "__babel_estree") && nd2(x2, m2))
              return m2.parser = "babel-flow", Lo(x2, P, m2);
            let v = p2;
            m2.__babelSourceType === "script" && (v = v.map((w) => Object.assign(Object.assign({}, w), {}, { sourceType: "script" }))), /#[[{]/.test(x2) && (v = v.map((w) => he([id2], w)));
            let S = /%[A-Z]/.test(x2);
            x2.includes("|>") ? v = (S ? [...oo2, no2] : oo2).flatMap((L) => v.map((A) => he([L], A))) : S && (v = v.map((w) => he([no2], w)));
            let { result: k, error: F } = Yf2(...v.map((w) => () => od2(l, x2, w)));
            if (!k)
              throw ed2(F);
            return m2.originalText = x2, td2(k, m2);
          };
        }
        var ld2 = $e("parse", he(["jsx", "flow"])), Lo = $e("parse", he(["jsx", ["flow", { all: true, enums: true }]])), hd2 = $e("parse", he(["jsx", "typescript"]), he(["typescript"])), ud2 = $e("parse", he(["jsx", "flow", "estree"])), cd2 = $e("parseExpression", he(["jsx"])), pd2 = $e("parseExpression", he(["typescript"])), fd2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), lo2 = Ue2(ld2), ho2 = Ue2(hd2), uo2 = Ue2(cd2), dd2 = Ue2(pd2);
        Oo.exports = { parsers: Object.assign(Object.assign({ babel: lo2, "babel-flow": Ue2(Lo), "babel-ts": ho2 }, sd2), {}, { __js_expression: uo2, __vue_expression: uo2, __vue_ts_expression: dd2, __vue_event_binding: lo2, __vue_ts_event_binding: ho2, __babel_estree: Ue2(ud2) }) };
      });
      return md2();
    });
  })(parserBabel);
  var parserBabelExports = parserBabel.exports;
  var prettierPluginBabel = /* @__PURE__ */ getDefaultExportFromCjs(parserBabelExports);
  function hasParbreak(nodes) {
    return nodes.some(
      (node2) => match.parbreak(node2) || match.macro(node2, "par")
    );
  }
  function hasBreakingNode(nodes, options2) {
    if (hasParbreak(nodes)) {
      return true;
    }
    const {
      macrosThatBreakPars = [
        "part",
        "chapter",
        "section",
        "subsection",
        "subsubsection",
        "vspace",
        "smallskip",
        "medskip",
        "bigskip",
        "hfill"
      ],
      environmentsThatDontBreakPars = []
    } = {};
    const macroMatcher = match.createMacroMatcher(macrosThatBreakPars);
    const envMatcher = match.createEnvironmentMatcher(
      environmentsThatDontBreakPars
    );
    return nodes.some(
      (node2) => macroMatcher(node2) || match.anyEnvironment(node2) && !envMatcher(node2)
    );
  }
  const REPLACEMENTS$1 = {
    color: colorToTextcolorMacro
  };
  const isReplaceable$1 = match.createMacroMatcher(REPLACEMENTS$1);
  function groupStartsWithMacroAndHasNoParbreak$1(group2) {
    if (!match.group(group2)) {
      return false;
    }
    let firstNode = firstSignificantNode(group2.content);
    return isReplaceable$1(firstNode) && !hasParbreak(group2.content);
  }
  `## Lint Rule

Prefer using fond color commands with arguments (e.g. \`\\textcolor{red}{foo bar}\`) over in-stream color commands
(e.g. \`{\\color{red} foo bar}\`) if the style does not apply for multiple paragraphs.
This rule is useful when parsing LaTeX into other tree structures (e.g., when converting from LaTeX to HTML). 


This rule flags any usage of \`${Object.keys(REPLACEMENTS$1).map((r) => printRaw(m(r))).join("` `")}\`
`;
  const unifiedLatexLintArgumentColorCommands = lintRule(
    { origin: "unified-latex-lint:argument-color-commands" },
    (tree, file, options2) => {
      const lintedNodes = /* @__PURE__ */ new Set();
      visit$3(
        tree,
        (group2, info) => {
          const nodes = group2.content;
          for (const node2 of nodes) {
            if (isReplaceable$1(node2) && !lintedNodes.has(node2)) {
              lintedNodes.add(node2);
              const macroName = node2.content;
              file.message(
                `Replace "${printRaw(group2)}" with "${printRaw(
                  REPLACEMENTS$1[macroName](s$1("..."), node2)
                )}"`,
                node2
              );
              break;
            }
          }
          if (options2 == null ? void 0 : options2.fix) {
            let fixed = replaceStreamingCommand(
              group2,
              isReplaceable$1,
              (content2, command) => {
                return REPLACEMENTS$1[command.content](
                  content2,
                  command
                );
              }
            );
            if (!info.containingArray || info.index == null) {
              return;
            }
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (match.whitespaceLike(prevToken) && match.whitespaceLike(fixed[0])) {
              trimStart(fixed);
            }
            if (match.whitespaceLike(nextToken) && match.whitespaceLike(fixed[fixed.length - 1])) {
              trimEnd(fixed);
            }
            replaceNodeDuringVisit(fixed, info);
          }
        },
        { test: groupStartsWithMacroAndHasNoParbreak$1 }
      );
      visit$3(
        tree,
        (nodes) => {
          if (hasParbreak(nodes)) {
            return;
          }
          let hasReplaceableContent = false;
          for (const node2 of nodes) {
            if (isReplaceable$1(node2) && !lintedNodes.has(node2)) {
              lintedNodes.add(node2);
              hasReplaceableContent = true;
              const macroName = node2.content;
              file.message(
                `Replace "${printRaw(nodes)}" with "${printRaw(
                  REPLACEMENTS$1[macroName](s$1("..."), node2)
                )}"`,
                node2
              );
            }
          }
          if (hasReplaceableContent && (options2 == null ? void 0 : options2.fix)) {
            replaceStreamingCommand(
              nodes,
              isReplaceable$1,
              (content2, command) => {
                return REPLACEMENTS$1[command.content](
                  content2,
                  command
                );
              }
            );
          }
        },
        { includeArrays: true, test: Array.isArray }
      );
    }
  );
  function singleArgMacroFactory(macroName) {
    return (content2) => {
      if (!Array.isArray(content2)) {
        content2 = [content2];
      }
      return {
        type: "macro",
        content: macroName,
        args: [
          {
            type: "argument",
            openMark: "{",
            closeMark: "}",
            content: content2
          }
        ],
        _renderInfo: { inParMode: true }
      };
    };
  }
  const REPLACEMENTS = {
    bfseries: singleArgMacroFactory("textbf"),
    itshape: singleArgMacroFactory("textit"),
    rmfamily: singleArgMacroFactory("textrm"),
    scshape: singleArgMacroFactory("textsc"),
    sffamily: singleArgMacroFactory("textsf"),
    slshape: singleArgMacroFactory("textsl"),
    ttfamily: singleArgMacroFactory("texttt"),
    em: singleArgMacroFactory("emph")
  };
  const isReplaceable = match.createMacroMatcher(REPLACEMENTS);
  function groupStartsWithMacroAndHasNoParbreak(group2) {
    if (!match.group(group2)) {
      return false;
    }
    let firstNode = firstSignificantNode(group2.content);
    return isReplaceable(firstNode) && !hasBreakingNode(group2.content);
  }
  `## Lint Rule

Prefer using text shaping commands with arguments (e.g. \`\\textbf{foo bar}\`) over in-stream text shaping commands
(e.g. \`{\\bfseries foo bar}\`) if the style does not apply for multiple paragraphs.
This rule is useful when parsing LaTeX into other tree structures (e.g., when converting from LaTeX to HTML). 


This rule flags any usage of \`${Object.keys(REPLACEMENTS).map((r) => printRaw(m(r))).join("` `")}\`
`;
  const unifiedLatexLintArgumentFontShapingCommands = lintRule(
    { origin: "unified-latex-lint:argument-font-shaping-commands" },
    (tree, file, options2) => {
      const lintedNodes = /* @__PURE__ */ new Set();
      visit$3(
        tree,
        (group2, info) => {
          const nodes = group2.content;
          for (const node2 of nodes) {
            if (isReplaceable(node2) && !lintedNodes.has(node2)) {
              lintedNodes.add(node2);
              const macroName = node2.content;
              file.message(
                `Replace "${printRaw(group2)}" with "${printRaw(
                  REPLACEMENTS[macroName](s$1("..."))
                )}"`,
                node2
              );
              break;
            }
          }
          if (options2 == null ? void 0 : options2.fix) {
            let fixed = replaceStreamingCommand(
              group2,
              isReplaceable,
              (content2, command) => {
                return REPLACEMENTS[command.content](content2);
              }
            );
            if (!info.containingArray || info.index == null) {
              return;
            }
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (match.whitespaceLike(prevToken) && match.whitespaceLike(fixed[0])) {
              trimStart(fixed);
            }
            if (match.whitespaceLike(nextToken) && match.whitespaceLike(fixed[fixed.length - 1])) {
              trimEnd(fixed);
            }
            replaceNodeDuringVisit(fixed, info);
          }
        },
        { test: groupStartsWithMacroAndHasNoParbreak }
      );
      visit$3(
        tree,
        (nodes) => {
          if (hasBreakingNode(nodes)) {
            return;
          }
          let hasReplaceableContent = false;
          for (const node2 of nodes) {
            if (isReplaceable(node2) && !lintedNodes.has(node2)) {
              lintedNodes.add(node2);
              hasReplaceableContent = true;
              const macroName = node2.content;
              file.message(
                `Replace "${printRaw(nodes)}" with "${printRaw(
                  REPLACEMENTS[macroName](s$1("..."))
                )}"`,
                node2
              );
            }
          }
          if (hasReplaceableContent && (options2 == null ? void 0 : options2.fix)) {
            replaceStreamingCommand(
              nodes,
              isReplaceable,
              (content2, command) => {
                return REPLACEMENTS[command.content](content2);
              }
            );
          }
        },
        { includeArrays: true, test: Array.isArray }
      );
    }
  );
  const unifiedLatexLintConsistentInlineMath = lintRule(
    { origin: "unified-latex-lint:consistent-inline-math" },
    (tree, file, options2) => {
      const inlineMath = {
        tex: [],
        latex: []
      };
      visit$3(
        tree,
        (node2) => {
          if (node2.type !== "inlinemath" || node2.position == null) {
            return;
          }
          if (file.value && file.value.slice(
            node2.position.start.offset,
            node2.position.start.offset + 1
          ) === "$") {
            inlineMath.tex.push(node2);
          } else {
            inlineMath.latex.push(node2);
          }
        },
        { test: match.math }
      );
      if (options2 == null ? void 0 : options2.preferredStyle) {
        if (options2.preferredStyle === "tex") {
          for (const node2 of inlineMath.latex) {
            file.message(
              `Prefer TeX-style $...$ inline math to LaTeX-style \\(...\\)`,
              node2
            );
          }
        }
        if (options2.preferredStyle === "latex") {
          for (const node2 of inlineMath.latex) {
            file.message(
              `Prefer LaTeX-style \\(...\\) inline math to LaTeX-style $...$`,
              node2
            );
          }
        }
      } else {
        const numTex = inlineMath.tex.length;
        const numLatex = inlineMath.latex.length;
        if (numTex > 0 && numLatex > 0) {
          if (numLatex > numTex) {
            for (const node2 of inlineMath.tex) {
              file.message(
                `Inconsistent inline-math style. This document uses LaTeX-style \\(...\\) inline math more than TeX-style $...$ inline math`,
                node2
              );
            }
          } else {
            for (const node2 of inlineMath.latex) {
              file.message(
                `Inconsistent inline-math style. This document uses TeX-style $...$ inline math more than LaTeX-style \\(...\\) inline math`,
                node2
              );
            }
          }
        }
      }
    }
  );
  const isDefMacro = match.createMacroMatcher(["def"]);
  const unifiedLatexLintNoDef = lintRule(
    { origin: "unified-latex-lint:no-def" },
    (tree, file) => {
      visit$3(
        tree,
        (node2) => {
          file.message(
            `Do not use \`\\def\\macro{val}\` to define a macro. Use \`\\newcommand{\\macro}{val}\` or \`\\NewDocumentCommand{\\macro}{}{val}\` from the \`xparse\` package.`,
            node2
          );
        },
        { test: isDefMacro }
      );
    }
  );
  const OPERATOR_NAMES = [
    "Pr",
    "arccos",
    "arcctg",
    "arcsin",
    "arctan",
    "arctg",
    "arg",
    "argmax",
    "argmin",
    "ch",
    "cos",
    "cosec",
    "cosh",
    "cot",
    "cotg",
    "coth",
    "csc",
    "ctg",
    "cth",
    "deg",
    "det",
    "dim",
    "exp",
    "gcd",
    "hom",
    "inf",
    "injlim",
    "ker",
    "lg",
    "lim",
    "liminf",
    "limsup",
    "ln",
    "log",
    "max",
    "min",
    "plim",
    "projlim",
    "sec",
    "sh",
    "sin",
    "sinh",
    "sup",
    "tan",
    "tanh",
    "tg",
    "th",
    "varinjlim",
    "varliminf",
    "varlimsup",
    "varprojlim"
  ];
  const prefixTree = Trie(OPERATOR_NAMES);
  function matchesAtPos(nodes, index2) {
    const prevNode = nodes[index2 - 1];
    if (match.string(prevNode) && prevNode.content.match(/^[a-zA-Z]/)) {
      return null;
    }
    const matched = prefixMatch(nodes, prefixTree, {
      startIndex: index2,
      // In math mode, all string nodes should be single characters. If they're
      // not, we have mangled them via some other process and the shouldn't be treated
      // normally
      assumeOneCharStrings: true
    });
    if (!matched) {
      return null;
    }
    const nextNode = nodes[matched.endNodeIndex + 1];
    if (match.string(nextNode) && nextNode.content.match(/^[a-zA-Z]/)) {
      return null;
    }
    return matched;
  }
  const unifiedLatexLintNoPlaintextOperators = lintRule(
    { origin: "unified-latex-lint:no-plaintext-operators" },
    (tree, file, options2) => {
      visit$3(
        tree,
        (nodes, info) => {
          if (!info.context.inMathMode) {
            return;
          }
          for (let i = 0; i < nodes.length; i++) {
            const matched = matchesAtPos(nodes, i);
            if (matched) {
              file.message(
                `Use "\\${matched.match}" instead of the string "${matched.match}" to specify an operator name in math mode`,
                {
                  start: pointStart$1(nodes[i]),
                  end: pointEnd$1(nodes[matched.endNodeIndex])
                }
              );
              if (options2 == null ? void 0 : options2.fix) {
                nodes.splice(i, matched.endNodeIndex - i + 1, {
                  type: "macro",
                  content: matched.match
                });
                i++;
              }
            }
          }
        },
        { test: Array.isArray, includeArrays: true }
      );
    }
  );
  const unifiedLatexLintNoTexDisplayMath = lintRule(
    { origin: "unified-latex-lint:no-tex-display-math" },
    (tree, file, options2) => {
      visit$3(
        tree,
        (node2) => {
          if (node2.type !== "displaymath" || node2.position == null) {
            return;
          }
          if (file.value && file.value.slice(
            node2.position.start.offset,
            node2.position.start.offset + 2
          ) === "$$") {
            file.message(
              `Avoid using $$...$$ for display math; prefer \\[...\\]`,
              node2
            );
          }
        },
        { test: match.math }
      );
    }
  );
  function stripComments(nodes) {
    return nodes.filter((node2) => node2.type !== "comment");
  }
  function trimWithReturn(nodes) {
    trim(nodes);
    return nodes;
  }
  function splitOnComma(nodes) {
    const ret = [];
    let curr = [];
    for (const node2 of stripComments(nodes)) {
      if (node2.type === "string" && node2.content === ",") {
        ret.push(curr);
        curr = [];
      } else {
        curr.push(node2);
      }
    }
    if (curr.length > 0) {
      ret.push(curr);
    }
    return ret.map(trimWithReturn);
  }
  function nodesToString(nodes) {
    var _a3, _b;
    if (nodes.length === 0) {
      return { type: "string", content: "" };
    }
    if (nodes.length === 1 && nodes[0].type === "string") {
      return nodes[0];
    }
    const start = (_a3 = nodes[0].position) == null ? void 0 : _a3.start;
    const end2 = (_b = nodes[nodes.length - 1].position) == null ? void 0 : _b.end;
    const ret = { type: "string", content: printRaw(nodes) };
    if (start && end2) {
      Object.assign(ret, { position: { start, end: end2 } });
    }
    return ret;
  }
  function processCommaSeparatedList(nodes) {
    return splitOnComma(nodes).map(nodesToString);
  }
  const isUseOrRequirePackageMacro = match.createMacroMatcher([
    "usepackage",
    "RequirePackage"
  ]);
  function listPackages(tree) {
    const ret = [];
    visit$3(
      tree,
      (node2) => {
        if (node2.content === "usepackage") {
          const packages = processCommaSeparatedList(
            node2.args ? node2.args[1].content : []
          );
          ret.push(...packages);
        }
        if (node2.content === "RequirePackage") {
          const packages = processCommaSeparatedList(
            node2.args ? node2.args[1].content : []
          );
          ret.push(...packages);
        }
      },
      { test: isUseOrRequirePackageMacro }
    );
    return ret;
  }
  const OBSOLETE = {
    a4: "Use `geometry` or `typearea` instead",
    a4wide: "Use `geometry` or `typearea` instead",
    anysize: "Use `geometry` or `typearea` instead",
    backrefx: "Use `backref` instead",
    bitfield: "Use `bytefield` instead",
    caption2: "Use `caption` instead",
    csvtools: "Use `datatool` instead",
    dinat: "Use `natdin` instead",
    doublespace: "Use `setspace` instead",
    dropping: "Use `lettrine` instead",
    eledmac: "Use `reledmac` instead",
    eps: "Use `graphicx` instead",
    epsfig: "Use `graphicx` instead",
    euler: "Use `eulervm` instead",
    eurotex: "Use `inputenx` instead",
    fancyheadings: "Use `fancyhdr` instead",
    filecontents: "Not needed; package now included in the LaTeX kernel",
    floatfig: "Use `floatflt` instead",
    german: "Use `babel` instead",
    glossary: "Use `glossaries` instead",
    graphics: "Use `graphicxs` instead",
    here: "Use `float` instead",
    hyper: "Use `hyperref` instead",
    ifthen: "Use `etoolbox` instead",
    isolatin: "Use `inputenc` instead",
    isolatin1: "Use `inputenc` instead",
    mathpple: "Use `mathpazo` instead",
    mathptm: "Use `mathptmx` instead",
    ngerman: "Use `babel` instead",
    nthm: "Use `ntheorem` instead",
    palatino: "Use `mathpazo` instead",
    picinpar: "Use `floatflt`, `picins`, or `wrapfig` instead",
    prosper: "Use `powerdot` or `beamer` instead",
    "HA-prosper": "Use `powerdot` or `beamer` instead",
    ps4pdf: "Use `pst-pdf` instead",
    raggedr: "Use `ragged2e` instead",
    scrlettr: "Use `scrlttr2` instead",
    scrpage: "Use `scrpage2` instead",
    seminar: "Use `powerdot` or `beamer` instead",
    subfigure: "Use `subfig` or `subcaption` instead",
    t1enc: "Use `\\usepackage[T1]{fontenc}` instead",
    times: "Use `mathptmx` instead",
    ucs: "Use `inputenc` or `inputencx` with utf8 option instead",
    umlaute: "Use `inputenc` instead",
    umlaut: "Use `\\usepackage[latin1]{inputenc}` instead",
    utopia: "Use `fourier` instead",
    vmargin: "Use `geometry` or `typearea` instead"
  };
  `## Lint Rule

Avoid including obsolete packages. Use modern replacements. 

The following packages are considered obsolete:
${Object.entries(OBSOLETE).map(([name2, suggestion]) => `  * \`${name2}\`: ${suggestion}`).join("\n")}

### See

CTAN l2tabuen Section 1.1
https://tex.stackexchange.com/questions/3910/how-to-keep-up-with-packages-and-know-which-ones-are-obsolete
`;
  const unifiedLatexLintObsoletePackages = lintRule({ origin: "unified-latex-lint:obsolete-packages" }, (tree, file, options2) => {
    for (const packageStr of listPackages(tree)) {
      const packageName = packageStr.content;
      if (packageName in OBSOLETE) {
        file.message(
          `Inclusion of obsolete package \`${packageName}\`. Suggestion: ${OBSOLETE[packageName]}.`,
          packageStr
        );
      }
    }
  });
  function parseTexGlue(source) {
    try {
      return GluePegParser.parse(source);
    } catch {
    }
    return null;
  }
  function printGlue(glue) {
    const ret = [
      { type: "string", content: `${glue.fixed.value}${glue.fixed.unit}` }
    ];
    if (glue.stretchable) {
      ret.push({ type: "whitespace" });
      ret.push({ type: "string", content: "plus" });
      ret.push({ type: "whitespace" });
      ret.push({
        type: "string",
        content: `${glue.stretchable.value}${glue.stretchable.unit}`
      });
    }
    if (glue.shrinkable) {
      ret.push({ type: "whitespace" });
      ret.push({ type: "string", content: "minus" });
      ret.push({ type: "whitespace" });
      ret.push({
        type: "string",
        content: `${glue.shrinkable.value}${glue.shrinkable.unit}`
      });
    }
    return ret;
  }
  function findGlue(nodes, startIndex) {
    let searchString = "";
    const sourceIndices = [];
    for (let i = startIndex; i < nodes.length; i++) {
      const node2 = nodes[i];
      if (match.whitespace(node2) || match.comment(node2)) {
        continue;
      }
      if (!match.anyString(node2)) {
        break;
      }
      searchString += node2.content;
      node2.content.split("").forEach(() => sourceIndices.push(i));
    }
    const glue = parseTexGlue(searchString);
    if (!glue) {
      return null;
    }
    const printedGlue = printGlue(glue);
    const glueLen = glue.position.end.offset;
    const firstInstanceOfNodeIndex = sourceIndices.indexOf(
      sourceIndices[glueLen]
    );
    return {
      printedGlue,
      endIndex: sourceIndices[glueLen - 1],
      partialSliceLen: glueLen - firstInstanceOfNodeIndex
    };
  }
  function extractFormattedGlue(nodes, startIndex) {
    const glue = findGlue(nodes, startIndex);
    if (!glue) {
      return null;
    }
    let trailingStrings = [];
    const retNodes = glue.printedGlue;
    const lastString = nodes[glue.endIndex];
    if (lastString.type !== "string") {
      throw new Error(`Expect string node, but found "${lastString.type}"`);
    }
    if (lastString.content.length > glue.partialSliceLen) {
      trailingStrings.push({
        type: "string",
        content: lastString.content.slice(glue.partialSliceLen)
      });
    }
    return {
      glue: retNodes,
      span: { start: startIndex, end: glue.endIndex },
      trailingStrings
    };
  }
  const LENGTH_MACROS = [
    "abovecaptionskip",
    "arraycolsep",
    "arrayrulewidth",
    "belowcaptionskip",
    "captionindent",
    "columnsep",
    "columnseprule",
    "doublerulsep",
    "fboxrule",
    "fboxsep",
    "itemsep",
    "itemindent",
    "labelsep",
    "labelwidth",
    "leftmargin",
    "leftmargini",
    "leftmarginii",
    "leftmarginiii",
    "leftmarginiv",
    "leftmarginv",
    "leftmarginvi",
    "lineskip",
    "linewidth",
    "listparindent",
    "marginparsep",
    "marginparwidth",
    "@mpfootins",
    "normallineskip",
    "overfullrule",
    "paperwidth",
    "paperheight",
    "parsep",
    "partopsep",
    "parskip",
    "parindent",
    "parfillskip",
    "tabbingsep",
    "tabcolsep"
  ];
  const isLengthMacro = match.createMacroMatcher(LENGTH_MACROS);
  const unifiedLatexLintPreferSetlength = lintRule({ origin: "unified-latex-lint:prefer-setlength" }, (tree, file, options2) => {
    visit$3(
      tree,
      (node2, info) => {
        if (info.index == null) {
          return;
        }
        const containingArray = info.containingArray;
        if (!containingArray) {
          return;
        }
        const equalsIndex = scan(containingArray, "=", {
          startIndex: info.index + 1,
          onlySkipWhitespaceAndComments: true
        });
        if (equalsIndex == null) {
          return;
        }
        file.message(
          `TeX-style assignment to length \`${printRaw(
            node2
          )}\`; prefer LaTeX \`\\setlength{${printRaw(node2)}}{...}\``,
          node2
        );
        if (options2 == null ? void 0 : options2.fix) {
          const glue = extractFormattedGlue(
            containingArray,
            equalsIndex + 1
          );
          if (!glue) {
            console.warn(
              "Expected to find glue following `=` but couldn't"
            );
            return;
          }
          const numReplacements = glue.span.end - info.index + 1;
          containingArray.splice(
            info.index,
            numReplacements,
            ...[
              m("setlength", [arg(node2), arg(glue.glue)]),
              ...glue.trailingStrings
            ]
          );
          return info.index + 1;
        }
      },
      { test: isLengthMacro }
    );
  });
  const lints = {
    unifiedLatexLintArgumentColorCommands,
    unifiedLatexLintArgumentFontShapingCommands,
    unifiedLatexLintConsistentInlineMath,
    unifiedLatexLintNoDef,
    unifiedLatexLintNoPlaintextOperators,
    unifiedLatexLintNoTexDisplayMath,
    unifiedLatexLintNoTexFontShapingCommands,
    unifiedLatexLintObsoletePackages,
    unifiedLatexLintPreferSetlength
  };
  const minpath = { basename, dirname, extname, join, sep: "/" };
  function basename(path2, extname2) {
    if (extname2 !== void 0 && typeof extname2 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath$1(path2);
    let start = 0;
    let end2 = -1;
    let index2 = path2.length;
    let seenNonSlash;
    if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
      while (index2--) {
        if (path2.codePointAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else if (end2 < 0) {
          seenNonSlash = true;
          end2 = index2 + 1;
        }
      }
      return end2 < 0 ? "" : path2.slice(start, end2);
    }
    if (extname2 === path2) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname2.length - 1;
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extnameIndex > -1) {
          if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end2 = index2;
            }
          } else {
            extnameIndex = -1;
            end2 = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end2) {
      end2 = firstNonSlashEnd;
    } else if (end2 < 0) {
      end2 = path2.length;
    }
    return path2.slice(start, end2);
  }
  function dirname(path2) {
    assertPath$1(path2);
    if (path2.length === 0) {
      return ".";
    }
    let end2 = -1;
    let index2 = path2.length;
    let unmatchedSlash;
    while (--index2) {
      if (path2.codePointAt(index2) === 47) {
        if (unmatchedSlash) {
          end2 = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
  }
  function extname(path2) {
    assertPath$1(path2);
    let index2 = path2.length;
    let end2 = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code2 = path2.codePointAt(index2);
      if (code2 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end2 < 0) {
        unmatchedSlash = true;
        end2 = index2 + 1;
      }
      if (code2 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end2);
  }
  function join(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath$1(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize(joined);
  }
  function normalize(path2) {
    assertPath$1(path2);
    const absolute = path2.codePointAt(0) === 47;
    let value2 = normalizeString(path2, !absolute);
    if (value2.length === 0 && !absolute) {
      value2 = ".";
    }
    if (value2.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
      value2 += "/";
    }
    return absolute ? "/" + value2 : value2;
  }
  function normalizeString(path2, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code2;
    let lastSlashIndex;
    while (++index2 <= path2.length) {
      if (index2 < path2.length) {
        code2 = path2.codePointAt(index2);
      } else if (code2 === 47) {
        break;
      } else {
        code2 = 47;
      }
      if (code2 === 47) {
        if (lastSlash === index2 - 1 || dots === 1)
          ;
        else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path2.slice(lastSlash + 1, index2);
          } else {
            result = path2.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code2 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath$1(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path2)
      );
    }
  }
  const minproc = { cwd };
  function cwd() {
    return "/";
  }
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }
  function urlToPath(path2) {
    if (typeof path2 === "string") {
      path2 = new URL(path2);
    } else if (!isUrl(path2)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path2.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path2);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
        const third = pathname.codePointAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  const order = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  class VFile {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array` â `{value: options}`
     * *   `URL` â `{path: options}`
     * *   `VFile` â shallow copies its data over to the new file
     * *   `object` â all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value2) {
      let options2;
      if (!value2) {
        options2 = {};
      } else if (isUrl(value2)) {
        options2 = { path: value2 };
      } else if (typeof value2 === "string" || isUint8Array(value2)) {
        options2 = { value: value2 };
      } else {
        options2 = value2;
      }
      this.cwd = "cwd" in options2 ? "" : minproc.cwd();
      this.data = {};
      this.history = [];
      this.messages = [];
      this.value;
      this.map;
      this.result;
      this.stored;
      let index2 = -1;
      while (++index2 < order.length) {
        const field2 = order[index2];
        if (field2 in options2 && options2[field2] !== void 0 && options2[field2] !== null) {
          this[field2] = field2 === "history" ? [...options2[field2]] : options2[field2];
        }
      }
      let field;
      for (field in options2) {
        if (!order.includes(field)) {
          this[field] = options2[field];
        }
      }
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(basename2) {
      assertNonEmpty(basename2, "basename");
      assertPart(basename2, "basename");
      this.path = minpath.join(this.dirname || "", basename2);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if thereâs no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(dirname2) {
      assertPath(this.basename, "dirname");
      this.path = minpath.join(dirname2 || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if thereâs no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(extname2) {
      assertPart(extname2, "extname");
      assertPath(this.dirname, "extname");
      if (extname2) {
        if (extname2.codePointAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(path2) {
      if (isUrl(path2)) {
        path2 = urlToPath(path2);
      }
      assertNonEmpty(path2, "path");
      if (this.path !== path2) {
        this.history.push(path2);
      }
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > ðª¦ **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = true;
      throw message;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > ðª¦ **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = void 0;
      return message;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > ðª¦ **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = new VFileMessage(
        // @ts-expect-error: the overloads are fine.
        causeOrReason,
        optionsOrParentOrPlace,
        origin
      );
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when itâs a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      if (this.value === void 0) {
        return "";
      }
      if (typeof this.value === "string") {
        return this.value;
      }
      const decoder = new TextDecoder(encoding || void 0);
      return decoder.decode(this.value);
    }
  }
  function assertPart(part, name2) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name2) {
    if (!part) {
      throw new Error("`" + name2 + "` cannot be empty");
    }
  }
  function assertPath(path2, name2) {
    if (!path2) {
      throw new Error("Setting `" + name2 + "` requires `path` to be set too");
    }
  }
  function isUint8Array(value2) {
    return Boolean(
      value2 && typeof value2 === "object" && "byteLength" in value2 && "byteOffset" in value2
    );
  }
  function ensureRoot(ast2) {
    if (Array.isArray(ast2)) {
      return { type: "root", content: ast2 };
    } else if (ast2.type === "root") {
      return ast2;
    } else {
      return { type: "root", content: [ast2] };
    }
  }
  const fixAllLints = (tree) => {
    let root2 = ensureRoot(tree);
    let processor = unified();
    for (const lint of Object.values(lints)) {
      processor = processor.use(lint, { fix: true });
    }
    const ret = processor.runSync(root2);
    if (Array.isArray(tree)) {
      return ret.content;
    }
    if (tree.type === "root") {
      return ret;
    }
    return ret.content[0];
  };
  const getLints = (tree, source) => {
    tree = ensureRoot(tree);
    let file = new VFile(source);
    let processor = unified();
    for (const lint of Object.values(lints)) {
      processor = processor.use(lint);
    }
    processor.runSync(tree, file);
    return file.messages.map((m2) => Object.assign({}, m2));
  };
  const ptxExtraEnvironmentReplacements = {
    solution: (node2) => {
      return htmlLike({
        tag: "solution",
        content: node2.content
      });
    },
    answer: (node2) => {
      return htmlLike({
        tag: "answer",
        content: node2.content
      });
    },
    hint: (node2) => {
      return htmlLike({
        tag: "hint",
        content: node2.content
      });
    },
    center: (node2) => {
      return htmlLike({
        tag: "blockquote",
        content: htmlLike({
          tag: "p",
          content: node2.content
        })
      });
    },
    table: (node2) => {
      return htmlLike({
        tag: "table",
        content: node2.content
      });
    },
    figure: (node2) => {
      return htmlLike({
        tag: "figure",
        content: node2.content
      });
    }
  };
  const myMacroReplacements = {
    includegraphics: (node2) => {
      const args = getArgsContent(node2);
      console.log("includegraphics args", args);
      const path2 = printRaw(
        args[args.length - 1] || []
      ).replace(/\.pdf$/, ".png");
      return htmlLike({
        tag: "img",
        attributes: { src: path2 }
      });
    },
    title: (node2) => {
      const args = getArgsContent(node2);
      const titleText = args[args.length - 1] || [];
      console.log("title args", args);
      return htmlLike({
        tag: "title",
        content: titleText
      });
    },
    date: (node2) => {
      const args = getArgsContent(node2);
      const dateText = args[args.length - 1] || [];
      console.log("date args", args);
      return htmlLike({
        tag: "date",
        content: dateText
      });
    },
    today: (node2) => {
      return htmlLike({
        tag: "today"
      });
    },
    caption: (node2) => {
      const args = getArgsContent(node2);
      const captionText = args[args.length - 1] || [];
      console.log("caption args", args);
      return htmlLike({
        tag: "caption",
        content: captionText
      });
    }
  };
  function printPrettier(source = "", options2 = {}) {
    return Ty.format(source, {
      printWidth: 80,
      useTabs: true,
      ...options2,
      parser: "latex-parser",
      plugins: [prettierPluginLatex]
    });
  }
  const prettierPluginLatexWithLint = {
    ...prettierPluginLatex,
    printers: {
      "latex-ast": {
        ...((_a2 = prettierPluginLatex.printers) == null ? void 0 : _a2["latex-ast"]) || {},
        preprocess: (ast2, options2) => {
          const ret = fixAllLints(ast2);
          return ret;
        }
      }
    }
  };
  function printPrettierWithLints(source = "", options2 = {}) {
    return Ty.format(source, {
      printWidth: 80,
      useTabs: true,
      useCache: false,
      ...options2,
      parser: "latex-parser",
      plugins: [prettierPluginLatexWithLint]
    });
  }
  const exposed = {
    format(texInput, options2 = {}) {
      let output;
      output = options2.fixLints ? printPrettierWithLints(texInput, options2) : printPrettier(texInput, options2);
      return output;
    },
    formatWithLints(texInput, options2 = {}) {
      const output = printPrettierWithLints(texInput, options2);
      return output;
    },
    formatAsHtml(texInput, options2 = {}) {
      let output = parse$3(texInput);
      return convertToHtml(output);
    },
    formatAsMarkdown(texInput, options2 = {}) {
      let ast2 = unified().use(unifiedLatexFromString).use(unifiedLatexToMdast).parse(texInput);
      let mdast = unified().use(unifiedLatexToMdast).runSync(ast2);
      let output = toMarkdown(mdast);
      return output;
    },
    formatAsPretext(texInput, options2 = {}) {
      return pretextConvert(texInput);
    },
    parse(texInput, options2 = {}) {
      const output = parse$3(texInput);
      return output;
    },
    getLints(texInput) {
      const parsed = exposed.parse(texInput);
      return getLints(parsed, texInput);
    },
    // There are extra parsers made for parsing the AST.
    // This function will first parse to an AST and then
    // run the additional parser.
    parseWithAstParser(texInput, options2 = {
      parser: "parseAlignEnvironment",
      parserSource: null
    }) {
      const { parserSource } = options2;
      let ast2 = null;
      try {
        ast2 = parse$3(texInput);
      } catch (e) {
        e.message = "Failed to parse LaTeX source " + e.message;
        throw e;
      }
      if (ast2.type === "root") {
        ast2 = ast2.content;
      }
      let parser2 = null;
      try {
        parser2 = peg$1.generate(parserSource);
      } catch (e) {
        e.message = "Failed to create Pegjs parser " + e.message;
        throw e;
      }
      if (!parser2) {
        throw new Error("Received null create Pegjs parser");
      }
      const output = parser2.parse(decorateArrayForPegjs(ast2), {});
      return output;
    },
    parseToDoc(texInput, options2 = {}) {
      const doc = Ty.__debug.printToDoc(texInput, {
        ...options2,
        parser: "latex-parser",
        plugins: [prettierPluginLatex]
      });
      const output = Ty.__debug.formatDoc(doc, {
        parser: "babel",
        plugins: [prettierPluginBabel]
      });
      return output;
    }
  };
  function pretextConvert(texInput) {
    const convert2 = (value2) => processLatexViaUnified().use(unifiedLatexToPretext, {
      producePretextFragment: true,
      macroReplacements: myMacroReplacements,
      environmentReplacements: ptxExtraEnvironmentReplacements
    }).use(xmlCompilePlugin).processSync({ value: value2 });
    return convert2(texInput).value;
  }
  expose(exposed);
})();
//# sourceMappingURL=parsing-worker-Cy0Ed-l0.js.map
